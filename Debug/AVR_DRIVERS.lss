
AVR_DRIVERS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006b46  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000152  00800060  00006b46  00006bda  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006a9  008001b2  008001b2  00006d2c  2**0
                  ALLOC
  3 .stab         0000cdc8  00000000  00000000  00006d2c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00007a3f  00000000  00000000  00013af4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001c0  00000000  00000000  0001b533  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000214  00000000  00000000  0001b6f3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002612  00000000  00000000  0001b907  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000014ce  00000000  00000000  0001df19  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000130b  00000000  00000000  0001f3e7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001e0  00000000  00000000  000206f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000307  00000000  00000000  000208d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000a1a  00000000  00000000  00020bdb  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  000215f5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 b8 0f 	jmp	0x1f70	; 0x1f70 <__vector_1>
       8:	0c 94 e1 0f 	jmp	0x1fc2	; 0x1fc2 <__vector_2>
       c:	0c 94 0a 10 	jmp	0x2014	; 0x2014 <__vector_3>
      10:	0c 94 d4 0a 	jmp	0x15a8	; 0x15a8 <__vector_4>
      14:	0c 94 9f 0a 	jmp	0x153e	; 0x153e <__vector_5>
      18:	0c 94 9e 0e 	jmp	0x1d3c	; 0x1d3c <__vector_6>
      1c:	0c 94 93 19 	jmp	0x3326	; 0x3326 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 17 0c 	jmp	0x182e	; 0x182e <__vector_10>
      2c:	0c 94 de 0b 	jmp	0x17bc	; 0x17bc <__vector_11>
      30:	0c 94 8d 0c 	jmp	0x191a	; 0x191a <__vector_12>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e6 e4       	ldi	r30, 0x46	; 70
      68:	fb e6       	ldi	r31, 0x6B	; 107
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 3b       	cpi	r26, 0xB2	; 178
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	18 e0       	ldi	r17, 0x08	; 8
      78:	a2 eb       	ldi	r26, 0xB2	; 178
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ab 35       	cpi	r26, 0x5B	; 91
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 d3 17 	call	0x2fa6	; 0x2fa6 <main>
      8a:	0c 94 a1 35 	jmp	0x6b42	; 0x6b42 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 b3 04 	call	0x966	; 0x966 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 b3 04 	call	0x966	; 0x966 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 88 31 	jmp	0x6310	; 0x6310 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a8 e6       	ldi	r26, 0x68	; 104
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 a4 31 	jmp	0x6348	; 0x6348 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 94 31 	jmp	0x6328	; 0x6328 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 b0 31 	jmp	0x6360	; 0x6360 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 94 31 	jmp	0x6328	; 0x6328 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 b0 31 	jmp	0x6360	; 0x6360 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 88 31 	jmp	0x6310	; 0x6310 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	88 e6       	ldi	r24, 0x68	; 104
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 a4 31 	jmp	0x6348	; 0x6348 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 90 31 	jmp	0x6320	; 0x6320 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	68 e6       	ldi	r22, 0x68	; 104
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 ac 31 	jmp	0x6358	; 0x6358 <__epilogue_restores__+0x10>

0000078a <__eqsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 94 31 	jmp	0x6328	; 0x6328 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__eqsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__eqsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 1c 07 	call	0xe38	; 0xe38 <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__eqsf2+0x58>
     7e0:	81 e0       	ldi	r24, 0x01	; 1
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 b0 31 	jmp	0x6360	; 0x6360 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 94 31 	jmp	0x6328	; 0x6328 <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 1c 07 	call	0xe38	; 0xe38 <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 b0 31 	jmp	0x6360	; 0x6360 <__epilogue_restores__+0x18>

0000084a <__lesf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 94 31 	jmp	0x6328	; 0x6328 <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 1c 07 	call	0xe38	; 0xe38 <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 b0 31 	jmp	0x6360	; 0x6360 <__epilogue_restores__+0x18>

000008aa <__floatsisf>:
     8aa:	a8 e0       	ldi	r26, 0x08	; 8
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 91 31 	jmp	0x6322	; 0x6322 <__prologue_saves__+0x12>
     8b6:	9b 01       	movw	r18, r22
     8b8:	ac 01       	movw	r20, r24
     8ba:	83 e0       	ldi	r24, 0x03	; 3
     8bc:	89 83       	std	Y+1, r24	; 0x01
     8be:	da 01       	movw	r26, r20
     8c0:	c9 01       	movw	r24, r18
     8c2:	88 27       	eor	r24, r24
     8c4:	b7 fd       	sbrc	r27, 7
     8c6:	83 95       	inc	r24
     8c8:	99 27       	eor	r25, r25
     8ca:	aa 27       	eor	r26, r26
     8cc:	bb 27       	eor	r27, r27
     8ce:	b8 2e       	mov	r11, r24
     8d0:	21 15       	cp	r18, r1
     8d2:	31 05       	cpc	r19, r1
     8d4:	41 05       	cpc	r20, r1
     8d6:	51 05       	cpc	r21, r1
     8d8:	19 f4       	brne	.+6      	; 0x8e0 <__floatsisf+0x36>
     8da:	82 e0       	ldi	r24, 0x02	; 2
     8dc:	89 83       	std	Y+1, r24	; 0x01
     8de:	3a c0       	rjmp	.+116    	; 0x954 <__floatsisf+0xaa>
     8e0:	88 23       	and	r24, r24
     8e2:	a9 f0       	breq	.+42     	; 0x90e <__floatsisf+0x64>
     8e4:	20 30       	cpi	r18, 0x00	; 0
     8e6:	80 e0       	ldi	r24, 0x00	; 0
     8e8:	38 07       	cpc	r19, r24
     8ea:	80 e0       	ldi	r24, 0x00	; 0
     8ec:	48 07       	cpc	r20, r24
     8ee:	80 e8       	ldi	r24, 0x80	; 128
     8f0:	58 07       	cpc	r21, r24
     8f2:	29 f4       	brne	.+10     	; 0x8fe <__floatsisf+0x54>
     8f4:	60 e0       	ldi	r22, 0x00	; 0
     8f6:	70 e0       	ldi	r23, 0x00	; 0
     8f8:	80 e0       	ldi	r24, 0x00	; 0
     8fa:	9f ec       	ldi	r25, 0xCF	; 207
     8fc:	30 c0       	rjmp	.+96     	; 0x95e <__floatsisf+0xb4>
     8fe:	ee 24       	eor	r14, r14
     900:	ff 24       	eor	r15, r15
     902:	87 01       	movw	r16, r14
     904:	e2 1a       	sub	r14, r18
     906:	f3 0a       	sbc	r15, r19
     908:	04 0b       	sbc	r16, r20
     90a:	15 0b       	sbc	r17, r21
     90c:	02 c0       	rjmp	.+4      	; 0x912 <__floatsisf+0x68>
     90e:	79 01       	movw	r14, r18
     910:	8a 01       	movw	r16, r20
     912:	8e e1       	ldi	r24, 0x1E	; 30
     914:	c8 2e       	mov	r12, r24
     916:	d1 2c       	mov	r13, r1
     918:	dc 82       	std	Y+4, r13	; 0x04
     91a:	cb 82       	std	Y+3, r12	; 0x03
     91c:	ed 82       	std	Y+5, r14	; 0x05
     91e:	fe 82       	std	Y+6, r15	; 0x06
     920:	0f 83       	std	Y+7, r16	; 0x07
     922:	18 87       	std	Y+8, r17	; 0x08
     924:	c8 01       	movw	r24, r16
     926:	b7 01       	movw	r22, r14
     928:	0e 94 80 05 	call	0xb00	; 0xb00 <__clzsi2>
     92c:	01 97       	sbiw	r24, 0x01	; 1
     92e:	18 16       	cp	r1, r24
     930:	19 06       	cpc	r1, r25
     932:	84 f4       	brge	.+32     	; 0x954 <__floatsisf+0xaa>
     934:	08 2e       	mov	r0, r24
     936:	04 c0       	rjmp	.+8      	; 0x940 <__floatsisf+0x96>
     938:	ee 0c       	add	r14, r14
     93a:	ff 1c       	adc	r15, r15
     93c:	00 1f       	adc	r16, r16
     93e:	11 1f       	adc	r17, r17
     940:	0a 94       	dec	r0
     942:	d2 f7       	brpl	.-12     	; 0x938 <__floatsisf+0x8e>
     944:	ed 82       	std	Y+5, r14	; 0x05
     946:	fe 82       	std	Y+6, r15	; 0x06
     948:	0f 83       	std	Y+7, r16	; 0x07
     94a:	18 87       	std	Y+8, r17	; 0x08
     94c:	c8 1a       	sub	r12, r24
     94e:	d9 0a       	sbc	r13, r25
     950:	dc 82       	std	Y+4, r13	; 0x04
     952:	cb 82       	std	Y+3, r12	; 0x03
     954:	ba 82       	std	Y+2, r11	; 0x02
     956:	ce 01       	movw	r24, r28
     958:	01 96       	adiw	r24, 0x01	; 1
     95a:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     95e:	28 96       	adiw	r28, 0x08	; 8
     960:	e9 e0       	ldi	r30, 0x09	; 9
     962:	0c 94 ad 31 	jmp	0x635a	; 0x635a <__epilogue_restores__+0x12>

00000966 <__fixsfsi>:
     966:	ac e0       	ldi	r26, 0x0C	; 12
     968:	b0 e0       	ldi	r27, 0x00	; 0
     96a:	e9 eb       	ldi	r30, 0xB9	; 185
     96c:	f4 e0       	ldi	r31, 0x04	; 4
     96e:	0c 94 98 31 	jmp	0x6330	; 0x6330 <__prologue_saves__+0x20>
     972:	69 83       	std	Y+1, r22	; 0x01
     974:	7a 83       	std	Y+2, r23	; 0x02
     976:	8b 83       	std	Y+3, r24	; 0x03
     978:	9c 83       	std	Y+4, r25	; 0x04
     97a:	ce 01       	movw	r24, r28
     97c:	01 96       	adiw	r24, 0x01	; 1
     97e:	be 01       	movw	r22, r28
     980:	6b 5f       	subi	r22, 0xFB	; 251
     982:	7f 4f       	sbci	r23, 0xFF	; 255
     984:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     988:	8d 81       	ldd	r24, Y+5	; 0x05
     98a:	82 30       	cpi	r24, 0x02	; 2
     98c:	61 f1       	breq	.+88     	; 0x9e6 <__fixsfsi+0x80>
     98e:	82 30       	cpi	r24, 0x02	; 2
     990:	50 f1       	brcs	.+84     	; 0x9e6 <__fixsfsi+0x80>
     992:	84 30       	cpi	r24, 0x04	; 4
     994:	21 f4       	brne	.+8      	; 0x99e <__fixsfsi+0x38>
     996:	8e 81       	ldd	r24, Y+6	; 0x06
     998:	88 23       	and	r24, r24
     99a:	51 f1       	breq	.+84     	; 0x9f0 <__fixsfsi+0x8a>
     99c:	2e c0       	rjmp	.+92     	; 0x9fa <__fixsfsi+0x94>
     99e:	2f 81       	ldd	r18, Y+7	; 0x07
     9a0:	38 85       	ldd	r19, Y+8	; 0x08
     9a2:	37 fd       	sbrc	r19, 7
     9a4:	20 c0       	rjmp	.+64     	; 0x9e6 <__fixsfsi+0x80>
     9a6:	6e 81       	ldd	r22, Y+6	; 0x06
     9a8:	2f 31       	cpi	r18, 0x1F	; 31
     9aa:	31 05       	cpc	r19, r1
     9ac:	1c f0       	brlt	.+6      	; 0x9b4 <__fixsfsi+0x4e>
     9ae:	66 23       	and	r22, r22
     9b0:	f9 f0       	breq	.+62     	; 0x9f0 <__fixsfsi+0x8a>
     9b2:	23 c0       	rjmp	.+70     	; 0x9fa <__fixsfsi+0x94>
     9b4:	8e e1       	ldi	r24, 0x1E	; 30
     9b6:	90 e0       	ldi	r25, 0x00	; 0
     9b8:	82 1b       	sub	r24, r18
     9ba:	93 0b       	sbc	r25, r19
     9bc:	29 85       	ldd	r18, Y+9	; 0x09
     9be:	3a 85       	ldd	r19, Y+10	; 0x0a
     9c0:	4b 85       	ldd	r20, Y+11	; 0x0b
     9c2:	5c 85       	ldd	r21, Y+12	; 0x0c
     9c4:	04 c0       	rjmp	.+8      	; 0x9ce <__fixsfsi+0x68>
     9c6:	56 95       	lsr	r21
     9c8:	47 95       	ror	r20
     9ca:	37 95       	ror	r19
     9cc:	27 95       	ror	r18
     9ce:	8a 95       	dec	r24
     9d0:	d2 f7       	brpl	.-12     	; 0x9c6 <__fixsfsi+0x60>
     9d2:	66 23       	and	r22, r22
     9d4:	b1 f0       	breq	.+44     	; 0xa02 <__fixsfsi+0x9c>
     9d6:	50 95       	com	r21
     9d8:	40 95       	com	r20
     9da:	30 95       	com	r19
     9dc:	21 95       	neg	r18
     9de:	3f 4f       	sbci	r19, 0xFF	; 255
     9e0:	4f 4f       	sbci	r20, 0xFF	; 255
     9e2:	5f 4f       	sbci	r21, 0xFF	; 255
     9e4:	0e c0       	rjmp	.+28     	; 0xa02 <__fixsfsi+0x9c>
     9e6:	20 e0       	ldi	r18, 0x00	; 0
     9e8:	30 e0       	ldi	r19, 0x00	; 0
     9ea:	40 e0       	ldi	r20, 0x00	; 0
     9ec:	50 e0       	ldi	r21, 0x00	; 0
     9ee:	09 c0       	rjmp	.+18     	; 0xa02 <__fixsfsi+0x9c>
     9f0:	2f ef       	ldi	r18, 0xFF	; 255
     9f2:	3f ef       	ldi	r19, 0xFF	; 255
     9f4:	4f ef       	ldi	r20, 0xFF	; 255
     9f6:	5f e7       	ldi	r21, 0x7F	; 127
     9f8:	04 c0       	rjmp	.+8      	; 0xa02 <__fixsfsi+0x9c>
     9fa:	20 e0       	ldi	r18, 0x00	; 0
     9fc:	30 e0       	ldi	r19, 0x00	; 0
     9fe:	40 e0       	ldi	r20, 0x00	; 0
     a00:	50 e8       	ldi	r21, 0x80	; 128
     a02:	b9 01       	movw	r22, r18
     a04:	ca 01       	movw	r24, r20
     a06:	2c 96       	adiw	r28, 0x0c	; 12
     a08:	e2 e0       	ldi	r30, 0x02	; 2
     a0a:	0c 94 b4 31 	jmp	0x6368	; 0x6368 <__epilogue_restores__+0x20>

00000a0e <__floatunsisf>:
     a0e:	a8 e0       	ldi	r26, 0x08	; 8
     a10:	b0 e0       	ldi	r27, 0x00	; 0
     a12:	ed e0       	ldi	r30, 0x0D	; 13
     a14:	f5 e0       	ldi	r31, 0x05	; 5
     a16:	0c 94 90 31 	jmp	0x6320	; 0x6320 <__prologue_saves__+0x10>
     a1a:	7b 01       	movw	r14, r22
     a1c:	8c 01       	movw	r16, r24
     a1e:	61 15       	cp	r22, r1
     a20:	71 05       	cpc	r23, r1
     a22:	81 05       	cpc	r24, r1
     a24:	91 05       	cpc	r25, r1
     a26:	19 f4       	brne	.+6      	; 0xa2e <__floatunsisf+0x20>
     a28:	82 e0       	ldi	r24, 0x02	; 2
     a2a:	89 83       	std	Y+1, r24	; 0x01
     a2c:	60 c0       	rjmp	.+192    	; 0xaee <__floatunsisf+0xe0>
     a2e:	83 e0       	ldi	r24, 0x03	; 3
     a30:	89 83       	std	Y+1, r24	; 0x01
     a32:	8e e1       	ldi	r24, 0x1E	; 30
     a34:	c8 2e       	mov	r12, r24
     a36:	d1 2c       	mov	r13, r1
     a38:	dc 82       	std	Y+4, r13	; 0x04
     a3a:	cb 82       	std	Y+3, r12	; 0x03
     a3c:	ed 82       	std	Y+5, r14	; 0x05
     a3e:	fe 82       	std	Y+6, r15	; 0x06
     a40:	0f 83       	std	Y+7, r16	; 0x07
     a42:	18 87       	std	Y+8, r17	; 0x08
     a44:	c8 01       	movw	r24, r16
     a46:	b7 01       	movw	r22, r14
     a48:	0e 94 80 05 	call	0xb00	; 0xb00 <__clzsi2>
     a4c:	fc 01       	movw	r30, r24
     a4e:	31 97       	sbiw	r30, 0x01	; 1
     a50:	f7 ff       	sbrs	r31, 7
     a52:	3b c0       	rjmp	.+118    	; 0xaca <__floatunsisf+0xbc>
     a54:	22 27       	eor	r18, r18
     a56:	33 27       	eor	r19, r19
     a58:	2e 1b       	sub	r18, r30
     a5a:	3f 0b       	sbc	r19, r31
     a5c:	57 01       	movw	r10, r14
     a5e:	68 01       	movw	r12, r16
     a60:	02 2e       	mov	r0, r18
     a62:	04 c0       	rjmp	.+8      	; 0xa6c <__floatunsisf+0x5e>
     a64:	d6 94       	lsr	r13
     a66:	c7 94       	ror	r12
     a68:	b7 94       	ror	r11
     a6a:	a7 94       	ror	r10
     a6c:	0a 94       	dec	r0
     a6e:	d2 f7       	brpl	.-12     	; 0xa64 <__floatunsisf+0x56>
     a70:	40 e0       	ldi	r20, 0x00	; 0
     a72:	50 e0       	ldi	r21, 0x00	; 0
     a74:	60 e0       	ldi	r22, 0x00	; 0
     a76:	70 e0       	ldi	r23, 0x00	; 0
     a78:	81 e0       	ldi	r24, 0x01	; 1
     a7a:	90 e0       	ldi	r25, 0x00	; 0
     a7c:	a0 e0       	ldi	r26, 0x00	; 0
     a7e:	b0 e0       	ldi	r27, 0x00	; 0
     a80:	04 c0       	rjmp	.+8      	; 0xa8a <__floatunsisf+0x7c>
     a82:	88 0f       	add	r24, r24
     a84:	99 1f       	adc	r25, r25
     a86:	aa 1f       	adc	r26, r26
     a88:	bb 1f       	adc	r27, r27
     a8a:	2a 95       	dec	r18
     a8c:	d2 f7       	brpl	.-12     	; 0xa82 <__floatunsisf+0x74>
     a8e:	01 97       	sbiw	r24, 0x01	; 1
     a90:	a1 09       	sbc	r26, r1
     a92:	b1 09       	sbc	r27, r1
     a94:	8e 21       	and	r24, r14
     a96:	9f 21       	and	r25, r15
     a98:	a0 23       	and	r26, r16
     a9a:	b1 23       	and	r27, r17
     a9c:	00 97       	sbiw	r24, 0x00	; 0
     a9e:	a1 05       	cpc	r26, r1
     aa0:	b1 05       	cpc	r27, r1
     aa2:	21 f0       	breq	.+8      	; 0xaac <__floatunsisf+0x9e>
     aa4:	41 e0       	ldi	r20, 0x01	; 1
     aa6:	50 e0       	ldi	r21, 0x00	; 0
     aa8:	60 e0       	ldi	r22, 0x00	; 0
     aaa:	70 e0       	ldi	r23, 0x00	; 0
     aac:	4a 29       	or	r20, r10
     aae:	5b 29       	or	r21, r11
     ab0:	6c 29       	or	r22, r12
     ab2:	7d 29       	or	r23, r13
     ab4:	4d 83       	std	Y+5, r20	; 0x05
     ab6:	5e 83       	std	Y+6, r21	; 0x06
     ab8:	6f 83       	std	Y+7, r22	; 0x07
     aba:	78 87       	std	Y+8, r23	; 0x08
     abc:	8e e1       	ldi	r24, 0x1E	; 30
     abe:	90 e0       	ldi	r25, 0x00	; 0
     ac0:	8e 1b       	sub	r24, r30
     ac2:	9f 0b       	sbc	r25, r31
     ac4:	9c 83       	std	Y+4, r25	; 0x04
     ac6:	8b 83       	std	Y+3, r24	; 0x03
     ac8:	12 c0       	rjmp	.+36     	; 0xaee <__floatunsisf+0xe0>
     aca:	30 97       	sbiw	r30, 0x00	; 0
     acc:	81 f0       	breq	.+32     	; 0xaee <__floatunsisf+0xe0>
     ace:	0e 2e       	mov	r0, r30
     ad0:	04 c0       	rjmp	.+8      	; 0xada <__floatunsisf+0xcc>
     ad2:	ee 0c       	add	r14, r14
     ad4:	ff 1c       	adc	r15, r15
     ad6:	00 1f       	adc	r16, r16
     ad8:	11 1f       	adc	r17, r17
     ada:	0a 94       	dec	r0
     adc:	d2 f7       	brpl	.-12     	; 0xad2 <__floatunsisf+0xc4>
     ade:	ed 82       	std	Y+5, r14	; 0x05
     ae0:	fe 82       	std	Y+6, r15	; 0x06
     ae2:	0f 83       	std	Y+7, r16	; 0x07
     ae4:	18 87       	std	Y+8, r17	; 0x08
     ae6:	ce 1a       	sub	r12, r30
     ae8:	df 0a       	sbc	r13, r31
     aea:	dc 82       	std	Y+4, r13	; 0x04
     aec:	cb 82       	std	Y+3, r12	; 0x03
     aee:	1a 82       	std	Y+2, r1	; 0x02
     af0:	ce 01       	movw	r24, r28
     af2:	01 96       	adiw	r24, 0x01	; 1
     af4:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     af8:	28 96       	adiw	r28, 0x08	; 8
     afa:	ea e0       	ldi	r30, 0x0A	; 10
     afc:	0c 94 ac 31 	jmp	0x6358	; 0x6358 <__epilogue_restores__+0x10>

00000b00 <__clzsi2>:
     b00:	ef 92       	push	r14
     b02:	ff 92       	push	r15
     b04:	0f 93       	push	r16
     b06:	1f 93       	push	r17
     b08:	7b 01       	movw	r14, r22
     b0a:	8c 01       	movw	r16, r24
     b0c:	80 e0       	ldi	r24, 0x00	; 0
     b0e:	e8 16       	cp	r14, r24
     b10:	80 e0       	ldi	r24, 0x00	; 0
     b12:	f8 06       	cpc	r15, r24
     b14:	81 e0       	ldi	r24, 0x01	; 1
     b16:	08 07       	cpc	r16, r24
     b18:	80 e0       	ldi	r24, 0x00	; 0
     b1a:	18 07       	cpc	r17, r24
     b1c:	88 f4       	brcc	.+34     	; 0xb40 <__clzsi2+0x40>
     b1e:	8f ef       	ldi	r24, 0xFF	; 255
     b20:	e8 16       	cp	r14, r24
     b22:	f1 04       	cpc	r15, r1
     b24:	01 05       	cpc	r16, r1
     b26:	11 05       	cpc	r17, r1
     b28:	31 f0       	breq	.+12     	; 0xb36 <__clzsi2+0x36>
     b2a:	28 f0       	brcs	.+10     	; 0xb36 <__clzsi2+0x36>
     b2c:	88 e0       	ldi	r24, 0x08	; 8
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	a0 e0       	ldi	r26, 0x00	; 0
     b32:	b0 e0       	ldi	r27, 0x00	; 0
     b34:	17 c0       	rjmp	.+46     	; 0xb64 <__clzsi2+0x64>
     b36:	80 e0       	ldi	r24, 0x00	; 0
     b38:	90 e0       	ldi	r25, 0x00	; 0
     b3a:	a0 e0       	ldi	r26, 0x00	; 0
     b3c:	b0 e0       	ldi	r27, 0x00	; 0
     b3e:	12 c0       	rjmp	.+36     	; 0xb64 <__clzsi2+0x64>
     b40:	80 e0       	ldi	r24, 0x00	; 0
     b42:	e8 16       	cp	r14, r24
     b44:	80 e0       	ldi	r24, 0x00	; 0
     b46:	f8 06       	cpc	r15, r24
     b48:	80 e0       	ldi	r24, 0x00	; 0
     b4a:	08 07       	cpc	r16, r24
     b4c:	81 e0       	ldi	r24, 0x01	; 1
     b4e:	18 07       	cpc	r17, r24
     b50:	28 f0       	brcs	.+10     	; 0xb5c <__clzsi2+0x5c>
     b52:	88 e1       	ldi	r24, 0x18	; 24
     b54:	90 e0       	ldi	r25, 0x00	; 0
     b56:	a0 e0       	ldi	r26, 0x00	; 0
     b58:	b0 e0       	ldi	r27, 0x00	; 0
     b5a:	04 c0       	rjmp	.+8      	; 0xb64 <__clzsi2+0x64>
     b5c:	80 e1       	ldi	r24, 0x10	; 16
     b5e:	90 e0       	ldi	r25, 0x00	; 0
     b60:	a0 e0       	ldi	r26, 0x00	; 0
     b62:	b0 e0       	ldi	r27, 0x00	; 0
     b64:	20 e2       	ldi	r18, 0x20	; 32
     b66:	30 e0       	ldi	r19, 0x00	; 0
     b68:	40 e0       	ldi	r20, 0x00	; 0
     b6a:	50 e0       	ldi	r21, 0x00	; 0
     b6c:	28 1b       	sub	r18, r24
     b6e:	39 0b       	sbc	r19, r25
     b70:	4a 0b       	sbc	r20, r26
     b72:	5b 0b       	sbc	r21, r27
     b74:	04 c0       	rjmp	.+8      	; 0xb7e <__clzsi2+0x7e>
     b76:	16 95       	lsr	r17
     b78:	07 95       	ror	r16
     b7a:	f7 94       	ror	r15
     b7c:	e7 94       	ror	r14
     b7e:	8a 95       	dec	r24
     b80:	d2 f7       	brpl	.-12     	; 0xb76 <__clzsi2+0x76>
     b82:	f7 01       	movw	r30, r14
     b84:	e0 59       	subi	r30, 0x90	; 144
     b86:	ff 4f       	sbci	r31, 0xFF	; 255
     b88:	80 81       	ld	r24, Z
     b8a:	28 1b       	sub	r18, r24
     b8c:	31 09       	sbc	r19, r1
     b8e:	41 09       	sbc	r20, r1
     b90:	51 09       	sbc	r21, r1
     b92:	c9 01       	movw	r24, r18
     b94:	1f 91       	pop	r17
     b96:	0f 91       	pop	r16
     b98:	ff 90       	pop	r15
     b9a:	ef 90       	pop	r14
     b9c:	08 95       	ret

00000b9e <__pack_f>:
     b9e:	df 92       	push	r13
     ba0:	ef 92       	push	r14
     ba2:	ff 92       	push	r15
     ba4:	0f 93       	push	r16
     ba6:	1f 93       	push	r17
     ba8:	fc 01       	movw	r30, r24
     baa:	e4 80       	ldd	r14, Z+4	; 0x04
     bac:	f5 80       	ldd	r15, Z+5	; 0x05
     bae:	06 81       	ldd	r16, Z+6	; 0x06
     bb0:	17 81       	ldd	r17, Z+7	; 0x07
     bb2:	d1 80       	ldd	r13, Z+1	; 0x01
     bb4:	80 81       	ld	r24, Z
     bb6:	82 30       	cpi	r24, 0x02	; 2
     bb8:	48 f4       	brcc	.+18     	; 0xbcc <__pack_f+0x2e>
     bba:	80 e0       	ldi	r24, 0x00	; 0
     bbc:	90 e0       	ldi	r25, 0x00	; 0
     bbe:	a0 e1       	ldi	r26, 0x10	; 16
     bc0:	b0 e0       	ldi	r27, 0x00	; 0
     bc2:	e8 2a       	or	r14, r24
     bc4:	f9 2a       	or	r15, r25
     bc6:	0a 2b       	or	r16, r26
     bc8:	1b 2b       	or	r17, r27
     bca:	a5 c0       	rjmp	.+330    	; 0xd16 <__pack_f+0x178>
     bcc:	84 30       	cpi	r24, 0x04	; 4
     bce:	09 f4       	brne	.+2      	; 0xbd2 <__pack_f+0x34>
     bd0:	9f c0       	rjmp	.+318    	; 0xd10 <__pack_f+0x172>
     bd2:	82 30       	cpi	r24, 0x02	; 2
     bd4:	21 f4       	brne	.+8      	; 0xbde <__pack_f+0x40>
     bd6:	ee 24       	eor	r14, r14
     bd8:	ff 24       	eor	r15, r15
     bda:	87 01       	movw	r16, r14
     bdc:	05 c0       	rjmp	.+10     	; 0xbe8 <__pack_f+0x4a>
     bde:	e1 14       	cp	r14, r1
     be0:	f1 04       	cpc	r15, r1
     be2:	01 05       	cpc	r16, r1
     be4:	11 05       	cpc	r17, r1
     be6:	19 f4       	brne	.+6      	; 0xbee <__pack_f+0x50>
     be8:	e0 e0       	ldi	r30, 0x00	; 0
     bea:	f0 e0       	ldi	r31, 0x00	; 0
     bec:	96 c0       	rjmp	.+300    	; 0xd1a <__pack_f+0x17c>
     bee:	62 81       	ldd	r22, Z+2	; 0x02
     bf0:	73 81       	ldd	r23, Z+3	; 0x03
     bf2:	9f ef       	ldi	r25, 0xFF	; 255
     bf4:	62 38       	cpi	r22, 0x82	; 130
     bf6:	79 07       	cpc	r23, r25
     bf8:	0c f0       	brlt	.+2      	; 0xbfc <__pack_f+0x5e>
     bfa:	5b c0       	rjmp	.+182    	; 0xcb2 <__pack_f+0x114>
     bfc:	22 e8       	ldi	r18, 0x82	; 130
     bfe:	3f ef       	ldi	r19, 0xFF	; 255
     c00:	26 1b       	sub	r18, r22
     c02:	37 0b       	sbc	r19, r23
     c04:	2a 31       	cpi	r18, 0x1A	; 26
     c06:	31 05       	cpc	r19, r1
     c08:	2c f0       	brlt	.+10     	; 0xc14 <__pack_f+0x76>
     c0a:	20 e0       	ldi	r18, 0x00	; 0
     c0c:	30 e0       	ldi	r19, 0x00	; 0
     c0e:	40 e0       	ldi	r20, 0x00	; 0
     c10:	50 e0       	ldi	r21, 0x00	; 0
     c12:	2a c0       	rjmp	.+84     	; 0xc68 <__pack_f+0xca>
     c14:	b8 01       	movw	r22, r16
     c16:	a7 01       	movw	r20, r14
     c18:	02 2e       	mov	r0, r18
     c1a:	04 c0       	rjmp	.+8      	; 0xc24 <__pack_f+0x86>
     c1c:	76 95       	lsr	r23
     c1e:	67 95       	ror	r22
     c20:	57 95       	ror	r21
     c22:	47 95       	ror	r20
     c24:	0a 94       	dec	r0
     c26:	d2 f7       	brpl	.-12     	; 0xc1c <__pack_f+0x7e>
     c28:	81 e0       	ldi	r24, 0x01	; 1
     c2a:	90 e0       	ldi	r25, 0x00	; 0
     c2c:	a0 e0       	ldi	r26, 0x00	; 0
     c2e:	b0 e0       	ldi	r27, 0x00	; 0
     c30:	04 c0       	rjmp	.+8      	; 0xc3a <__pack_f+0x9c>
     c32:	88 0f       	add	r24, r24
     c34:	99 1f       	adc	r25, r25
     c36:	aa 1f       	adc	r26, r26
     c38:	bb 1f       	adc	r27, r27
     c3a:	2a 95       	dec	r18
     c3c:	d2 f7       	brpl	.-12     	; 0xc32 <__pack_f+0x94>
     c3e:	01 97       	sbiw	r24, 0x01	; 1
     c40:	a1 09       	sbc	r26, r1
     c42:	b1 09       	sbc	r27, r1
     c44:	8e 21       	and	r24, r14
     c46:	9f 21       	and	r25, r15
     c48:	a0 23       	and	r26, r16
     c4a:	b1 23       	and	r27, r17
     c4c:	00 97       	sbiw	r24, 0x00	; 0
     c4e:	a1 05       	cpc	r26, r1
     c50:	b1 05       	cpc	r27, r1
     c52:	21 f0       	breq	.+8      	; 0xc5c <__pack_f+0xbe>
     c54:	81 e0       	ldi	r24, 0x01	; 1
     c56:	90 e0       	ldi	r25, 0x00	; 0
     c58:	a0 e0       	ldi	r26, 0x00	; 0
     c5a:	b0 e0       	ldi	r27, 0x00	; 0
     c5c:	9a 01       	movw	r18, r20
     c5e:	ab 01       	movw	r20, r22
     c60:	28 2b       	or	r18, r24
     c62:	39 2b       	or	r19, r25
     c64:	4a 2b       	or	r20, r26
     c66:	5b 2b       	or	r21, r27
     c68:	da 01       	movw	r26, r20
     c6a:	c9 01       	movw	r24, r18
     c6c:	8f 77       	andi	r24, 0x7F	; 127
     c6e:	90 70       	andi	r25, 0x00	; 0
     c70:	a0 70       	andi	r26, 0x00	; 0
     c72:	b0 70       	andi	r27, 0x00	; 0
     c74:	80 34       	cpi	r24, 0x40	; 64
     c76:	91 05       	cpc	r25, r1
     c78:	a1 05       	cpc	r26, r1
     c7a:	b1 05       	cpc	r27, r1
     c7c:	39 f4       	brne	.+14     	; 0xc8c <__pack_f+0xee>
     c7e:	27 ff       	sbrs	r18, 7
     c80:	09 c0       	rjmp	.+18     	; 0xc94 <__pack_f+0xf6>
     c82:	20 5c       	subi	r18, 0xC0	; 192
     c84:	3f 4f       	sbci	r19, 0xFF	; 255
     c86:	4f 4f       	sbci	r20, 0xFF	; 255
     c88:	5f 4f       	sbci	r21, 0xFF	; 255
     c8a:	04 c0       	rjmp	.+8      	; 0xc94 <__pack_f+0xf6>
     c8c:	21 5c       	subi	r18, 0xC1	; 193
     c8e:	3f 4f       	sbci	r19, 0xFF	; 255
     c90:	4f 4f       	sbci	r20, 0xFF	; 255
     c92:	5f 4f       	sbci	r21, 0xFF	; 255
     c94:	e0 e0       	ldi	r30, 0x00	; 0
     c96:	f0 e0       	ldi	r31, 0x00	; 0
     c98:	20 30       	cpi	r18, 0x00	; 0
     c9a:	a0 e0       	ldi	r26, 0x00	; 0
     c9c:	3a 07       	cpc	r19, r26
     c9e:	a0 e0       	ldi	r26, 0x00	; 0
     ca0:	4a 07       	cpc	r20, r26
     ca2:	a0 e4       	ldi	r26, 0x40	; 64
     ca4:	5a 07       	cpc	r21, r26
     ca6:	10 f0       	brcs	.+4      	; 0xcac <__pack_f+0x10e>
     ca8:	e1 e0       	ldi	r30, 0x01	; 1
     caa:	f0 e0       	ldi	r31, 0x00	; 0
     cac:	79 01       	movw	r14, r18
     cae:	8a 01       	movw	r16, r20
     cb0:	27 c0       	rjmp	.+78     	; 0xd00 <__pack_f+0x162>
     cb2:	60 38       	cpi	r22, 0x80	; 128
     cb4:	71 05       	cpc	r23, r1
     cb6:	64 f5       	brge	.+88     	; 0xd10 <__pack_f+0x172>
     cb8:	fb 01       	movw	r30, r22
     cba:	e1 58       	subi	r30, 0x81	; 129
     cbc:	ff 4f       	sbci	r31, 0xFF	; 255
     cbe:	d8 01       	movw	r26, r16
     cc0:	c7 01       	movw	r24, r14
     cc2:	8f 77       	andi	r24, 0x7F	; 127
     cc4:	90 70       	andi	r25, 0x00	; 0
     cc6:	a0 70       	andi	r26, 0x00	; 0
     cc8:	b0 70       	andi	r27, 0x00	; 0
     cca:	80 34       	cpi	r24, 0x40	; 64
     ccc:	91 05       	cpc	r25, r1
     cce:	a1 05       	cpc	r26, r1
     cd0:	b1 05       	cpc	r27, r1
     cd2:	39 f4       	brne	.+14     	; 0xce2 <__pack_f+0x144>
     cd4:	e7 fe       	sbrs	r14, 7
     cd6:	0d c0       	rjmp	.+26     	; 0xcf2 <__pack_f+0x154>
     cd8:	80 e4       	ldi	r24, 0x40	; 64
     cda:	90 e0       	ldi	r25, 0x00	; 0
     cdc:	a0 e0       	ldi	r26, 0x00	; 0
     cde:	b0 e0       	ldi	r27, 0x00	; 0
     ce0:	04 c0       	rjmp	.+8      	; 0xcea <__pack_f+0x14c>
     ce2:	8f e3       	ldi	r24, 0x3F	; 63
     ce4:	90 e0       	ldi	r25, 0x00	; 0
     ce6:	a0 e0       	ldi	r26, 0x00	; 0
     ce8:	b0 e0       	ldi	r27, 0x00	; 0
     cea:	e8 0e       	add	r14, r24
     cec:	f9 1e       	adc	r15, r25
     cee:	0a 1f       	adc	r16, r26
     cf0:	1b 1f       	adc	r17, r27
     cf2:	17 ff       	sbrs	r17, 7
     cf4:	05 c0       	rjmp	.+10     	; 0xd00 <__pack_f+0x162>
     cf6:	16 95       	lsr	r17
     cf8:	07 95       	ror	r16
     cfa:	f7 94       	ror	r15
     cfc:	e7 94       	ror	r14
     cfe:	31 96       	adiw	r30, 0x01	; 1
     d00:	87 e0       	ldi	r24, 0x07	; 7
     d02:	16 95       	lsr	r17
     d04:	07 95       	ror	r16
     d06:	f7 94       	ror	r15
     d08:	e7 94       	ror	r14
     d0a:	8a 95       	dec	r24
     d0c:	d1 f7       	brne	.-12     	; 0xd02 <__pack_f+0x164>
     d0e:	05 c0       	rjmp	.+10     	; 0xd1a <__pack_f+0x17c>
     d10:	ee 24       	eor	r14, r14
     d12:	ff 24       	eor	r15, r15
     d14:	87 01       	movw	r16, r14
     d16:	ef ef       	ldi	r30, 0xFF	; 255
     d18:	f0 e0       	ldi	r31, 0x00	; 0
     d1a:	6e 2f       	mov	r22, r30
     d1c:	67 95       	ror	r22
     d1e:	66 27       	eor	r22, r22
     d20:	67 95       	ror	r22
     d22:	90 2f       	mov	r25, r16
     d24:	9f 77       	andi	r25, 0x7F	; 127
     d26:	d7 94       	ror	r13
     d28:	dd 24       	eor	r13, r13
     d2a:	d7 94       	ror	r13
     d2c:	8e 2f       	mov	r24, r30
     d2e:	86 95       	lsr	r24
     d30:	49 2f       	mov	r20, r25
     d32:	46 2b       	or	r20, r22
     d34:	58 2f       	mov	r21, r24
     d36:	5d 29       	or	r21, r13
     d38:	b7 01       	movw	r22, r14
     d3a:	ca 01       	movw	r24, r20
     d3c:	1f 91       	pop	r17
     d3e:	0f 91       	pop	r16
     d40:	ff 90       	pop	r15
     d42:	ef 90       	pop	r14
     d44:	df 90       	pop	r13
     d46:	08 95       	ret

00000d48 <__unpack_f>:
     d48:	fc 01       	movw	r30, r24
     d4a:	db 01       	movw	r26, r22
     d4c:	40 81       	ld	r20, Z
     d4e:	51 81       	ldd	r21, Z+1	; 0x01
     d50:	22 81       	ldd	r18, Z+2	; 0x02
     d52:	62 2f       	mov	r22, r18
     d54:	6f 77       	andi	r22, 0x7F	; 127
     d56:	70 e0       	ldi	r23, 0x00	; 0
     d58:	22 1f       	adc	r18, r18
     d5a:	22 27       	eor	r18, r18
     d5c:	22 1f       	adc	r18, r18
     d5e:	93 81       	ldd	r25, Z+3	; 0x03
     d60:	89 2f       	mov	r24, r25
     d62:	88 0f       	add	r24, r24
     d64:	82 2b       	or	r24, r18
     d66:	28 2f       	mov	r18, r24
     d68:	30 e0       	ldi	r19, 0x00	; 0
     d6a:	99 1f       	adc	r25, r25
     d6c:	99 27       	eor	r25, r25
     d6e:	99 1f       	adc	r25, r25
     d70:	11 96       	adiw	r26, 0x01	; 1
     d72:	9c 93       	st	X, r25
     d74:	11 97       	sbiw	r26, 0x01	; 1
     d76:	21 15       	cp	r18, r1
     d78:	31 05       	cpc	r19, r1
     d7a:	a9 f5       	brne	.+106    	; 0xde6 <__unpack_f+0x9e>
     d7c:	41 15       	cp	r20, r1
     d7e:	51 05       	cpc	r21, r1
     d80:	61 05       	cpc	r22, r1
     d82:	71 05       	cpc	r23, r1
     d84:	11 f4       	brne	.+4      	; 0xd8a <__unpack_f+0x42>
     d86:	82 e0       	ldi	r24, 0x02	; 2
     d88:	37 c0       	rjmp	.+110    	; 0xdf8 <__unpack_f+0xb0>
     d8a:	82 e8       	ldi	r24, 0x82	; 130
     d8c:	9f ef       	ldi	r25, 0xFF	; 255
     d8e:	13 96       	adiw	r26, 0x03	; 3
     d90:	9c 93       	st	X, r25
     d92:	8e 93       	st	-X, r24
     d94:	12 97       	sbiw	r26, 0x02	; 2
     d96:	9a 01       	movw	r18, r20
     d98:	ab 01       	movw	r20, r22
     d9a:	67 e0       	ldi	r22, 0x07	; 7
     d9c:	22 0f       	add	r18, r18
     d9e:	33 1f       	adc	r19, r19
     da0:	44 1f       	adc	r20, r20
     da2:	55 1f       	adc	r21, r21
     da4:	6a 95       	dec	r22
     da6:	d1 f7       	brne	.-12     	; 0xd9c <__unpack_f+0x54>
     da8:	83 e0       	ldi	r24, 0x03	; 3
     daa:	8c 93       	st	X, r24
     dac:	0d c0       	rjmp	.+26     	; 0xdc8 <__unpack_f+0x80>
     dae:	22 0f       	add	r18, r18
     db0:	33 1f       	adc	r19, r19
     db2:	44 1f       	adc	r20, r20
     db4:	55 1f       	adc	r21, r21
     db6:	12 96       	adiw	r26, 0x02	; 2
     db8:	8d 91       	ld	r24, X+
     dba:	9c 91       	ld	r25, X
     dbc:	13 97       	sbiw	r26, 0x03	; 3
     dbe:	01 97       	sbiw	r24, 0x01	; 1
     dc0:	13 96       	adiw	r26, 0x03	; 3
     dc2:	9c 93       	st	X, r25
     dc4:	8e 93       	st	-X, r24
     dc6:	12 97       	sbiw	r26, 0x02	; 2
     dc8:	20 30       	cpi	r18, 0x00	; 0
     dca:	80 e0       	ldi	r24, 0x00	; 0
     dcc:	38 07       	cpc	r19, r24
     dce:	80 e0       	ldi	r24, 0x00	; 0
     dd0:	48 07       	cpc	r20, r24
     dd2:	80 e4       	ldi	r24, 0x40	; 64
     dd4:	58 07       	cpc	r21, r24
     dd6:	58 f3       	brcs	.-42     	; 0xdae <__unpack_f+0x66>
     dd8:	14 96       	adiw	r26, 0x04	; 4
     dda:	2d 93       	st	X+, r18
     ddc:	3d 93       	st	X+, r19
     dde:	4d 93       	st	X+, r20
     de0:	5c 93       	st	X, r21
     de2:	17 97       	sbiw	r26, 0x07	; 7
     de4:	08 95       	ret
     de6:	2f 3f       	cpi	r18, 0xFF	; 255
     de8:	31 05       	cpc	r19, r1
     dea:	79 f4       	brne	.+30     	; 0xe0a <__unpack_f+0xc2>
     dec:	41 15       	cp	r20, r1
     dee:	51 05       	cpc	r21, r1
     df0:	61 05       	cpc	r22, r1
     df2:	71 05       	cpc	r23, r1
     df4:	19 f4       	brne	.+6      	; 0xdfc <__unpack_f+0xb4>
     df6:	84 e0       	ldi	r24, 0x04	; 4
     df8:	8c 93       	st	X, r24
     dfa:	08 95       	ret
     dfc:	64 ff       	sbrs	r22, 4
     dfe:	03 c0       	rjmp	.+6      	; 0xe06 <__unpack_f+0xbe>
     e00:	81 e0       	ldi	r24, 0x01	; 1
     e02:	8c 93       	st	X, r24
     e04:	12 c0       	rjmp	.+36     	; 0xe2a <__unpack_f+0xe2>
     e06:	1c 92       	st	X, r1
     e08:	10 c0       	rjmp	.+32     	; 0xe2a <__unpack_f+0xe2>
     e0a:	2f 57       	subi	r18, 0x7F	; 127
     e0c:	30 40       	sbci	r19, 0x00	; 0
     e0e:	13 96       	adiw	r26, 0x03	; 3
     e10:	3c 93       	st	X, r19
     e12:	2e 93       	st	-X, r18
     e14:	12 97       	sbiw	r26, 0x02	; 2
     e16:	83 e0       	ldi	r24, 0x03	; 3
     e18:	8c 93       	st	X, r24
     e1a:	87 e0       	ldi	r24, 0x07	; 7
     e1c:	44 0f       	add	r20, r20
     e1e:	55 1f       	adc	r21, r21
     e20:	66 1f       	adc	r22, r22
     e22:	77 1f       	adc	r23, r23
     e24:	8a 95       	dec	r24
     e26:	d1 f7       	brne	.-12     	; 0xe1c <__unpack_f+0xd4>
     e28:	70 64       	ori	r23, 0x40	; 64
     e2a:	14 96       	adiw	r26, 0x04	; 4
     e2c:	4d 93       	st	X+, r20
     e2e:	5d 93       	st	X+, r21
     e30:	6d 93       	st	X+, r22
     e32:	7c 93       	st	X, r23
     e34:	17 97       	sbiw	r26, 0x07	; 7
     e36:	08 95       	ret

00000e38 <__fpcmp_parts_f>:
     e38:	1f 93       	push	r17
     e3a:	dc 01       	movw	r26, r24
     e3c:	fb 01       	movw	r30, r22
     e3e:	9c 91       	ld	r25, X
     e40:	92 30       	cpi	r25, 0x02	; 2
     e42:	08 f4       	brcc	.+2      	; 0xe46 <__fpcmp_parts_f+0xe>
     e44:	47 c0       	rjmp	.+142    	; 0xed4 <__fpcmp_parts_f+0x9c>
     e46:	80 81       	ld	r24, Z
     e48:	82 30       	cpi	r24, 0x02	; 2
     e4a:	08 f4       	brcc	.+2      	; 0xe4e <__fpcmp_parts_f+0x16>
     e4c:	43 c0       	rjmp	.+134    	; 0xed4 <__fpcmp_parts_f+0x9c>
     e4e:	94 30       	cpi	r25, 0x04	; 4
     e50:	51 f4       	brne	.+20     	; 0xe66 <__fpcmp_parts_f+0x2e>
     e52:	11 96       	adiw	r26, 0x01	; 1
     e54:	1c 91       	ld	r17, X
     e56:	84 30       	cpi	r24, 0x04	; 4
     e58:	99 f5       	brne	.+102    	; 0xec0 <__fpcmp_parts_f+0x88>
     e5a:	81 81       	ldd	r24, Z+1	; 0x01
     e5c:	68 2f       	mov	r22, r24
     e5e:	70 e0       	ldi	r23, 0x00	; 0
     e60:	61 1b       	sub	r22, r17
     e62:	71 09       	sbc	r23, r1
     e64:	3f c0       	rjmp	.+126    	; 0xee4 <__fpcmp_parts_f+0xac>
     e66:	84 30       	cpi	r24, 0x04	; 4
     e68:	21 f0       	breq	.+8      	; 0xe72 <__fpcmp_parts_f+0x3a>
     e6a:	92 30       	cpi	r25, 0x02	; 2
     e6c:	31 f4       	brne	.+12     	; 0xe7a <__fpcmp_parts_f+0x42>
     e6e:	82 30       	cpi	r24, 0x02	; 2
     e70:	b9 f1       	breq	.+110    	; 0xee0 <__fpcmp_parts_f+0xa8>
     e72:	81 81       	ldd	r24, Z+1	; 0x01
     e74:	88 23       	and	r24, r24
     e76:	89 f1       	breq	.+98     	; 0xeda <__fpcmp_parts_f+0xa2>
     e78:	2d c0       	rjmp	.+90     	; 0xed4 <__fpcmp_parts_f+0x9c>
     e7a:	11 96       	adiw	r26, 0x01	; 1
     e7c:	1c 91       	ld	r17, X
     e7e:	11 97       	sbiw	r26, 0x01	; 1
     e80:	82 30       	cpi	r24, 0x02	; 2
     e82:	f1 f0       	breq	.+60     	; 0xec0 <__fpcmp_parts_f+0x88>
     e84:	81 81       	ldd	r24, Z+1	; 0x01
     e86:	18 17       	cp	r17, r24
     e88:	d9 f4       	brne	.+54     	; 0xec0 <__fpcmp_parts_f+0x88>
     e8a:	12 96       	adiw	r26, 0x02	; 2
     e8c:	2d 91       	ld	r18, X+
     e8e:	3c 91       	ld	r19, X
     e90:	13 97       	sbiw	r26, 0x03	; 3
     e92:	82 81       	ldd	r24, Z+2	; 0x02
     e94:	93 81       	ldd	r25, Z+3	; 0x03
     e96:	82 17       	cp	r24, r18
     e98:	93 07       	cpc	r25, r19
     e9a:	94 f0       	brlt	.+36     	; 0xec0 <__fpcmp_parts_f+0x88>
     e9c:	28 17       	cp	r18, r24
     e9e:	39 07       	cpc	r19, r25
     ea0:	bc f0       	brlt	.+46     	; 0xed0 <__fpcmp_parts_f+0x98>
     ea2:	14 96       	adiw	r26, 0x04	; 4
     ea4:	8d 91       	ld	r24, X+
     ea6:	9d 91       	ld	r25, X+
     ea8:	0d 90       	ld	r0, X+
     eaa:	bc 91       	ld	r27, X
     eac:	a0 2d       	mov	r26, r0
     eae:	24 81       	ldd	r18, Z+4	; 0x04
     eb0:	35 81       	ldd	r19, Z+5	; 0x05
     eb2:	46 81       	ldd	r20, Z+6	; 0x06
     eb4:	57 81       	ldd	r21, Z+7	; 0x07
     eb6:	28 17       	cp	r18, r24
     eb8:	39 07       	cpc	r19, r25
     eba:	4a 07       	cpc	r20, r26
     ebc:	5b 07       	cpc	r21, r27
     ebe:	18 f4       	brcc	.+6      	; 0xec6 <__fpcmp_parts_f+0x8e>
     ec0:	11 23       	and	r17, r17
     ec2:	41 f0       	breq	.+16     	; 0xed4 <__fpcmp_parts_f+0x9c>
     ec4:	0a c0       	rjmp	.+20     	; 0xeda <__fpcmp_parts_f+0xa2>
     ec6:	82 17       	cp	r24, r18
     ec8:	93 07       	cpc	r25, r19
     eca:	a4 07       	cpc	r26, r20
     ecc:	b5 07       	cpc	r27, r21
     ece:	40 f4       	brcc	.+16     	; 0xee0 <__fpcmp_parts_f+0xa8>
     ed0:	11 23       	and	r17, r17
     ed2:	19 f0       	breq	.+6      	; 0xeda <__fpcmp_parts_f+0xa2>
     ed4:	61 e0       	ldi	r22, 0x01	; 1
     ed6:	70 e0       	ldi	r23, 0x00	; 0
     ed8:	05 c0       	rjmp	.+10     	; 0xee4 <__fpcmp_parts_f+0xac>
     eda:	6f ef       	ldi	r22, 0xFF	; 255
     edc:	7f ef       	ldi	r23, 0xFF	; 255
     ede:	02 c0       	rjmp	.+4      	; 0xee4 <__fpcmp_parts_f+0xac>
     ee0:	60 e0       	ldi	r22, 0x00	; 0
     ee2:	70 e0       	ldi	r23, 0x00	; 0
     ee4:	cb 01       	movw	r24, r22
     ee6:	1f 91       	pop	r17
     ee8:	08 95       	ret

00000eea <s_list_get_length>:
#include "linked_list.h"
#include "stdlib.h"
u32  s_list_get_length(struct node *list){
    u32 count =0;
    struct node *temp = list;
    while (temp != NULL)
     eea:	00 97       	sbiw	r24, 0x00	; 0
     eec:	29 f4       	brne	.+10     	; 0xef8 <s_list_get_length+0xe>
     eee:	20 e0       	ldi	r18, 0x00	; 0
     ef0:	30 e0       	ldi	r19, 0x00	; 0
     ef2:	40 e0       	ldi	r20, 0x00	; 0
     ef4:	50 e0       	ldi	r21, 0x00	; 0
     ef6:	0e c0       	rjmp	.+28     	; 0xf14 <s_list_get_length+0x2a>
     ef8:	fc 01       	movw	r30, r24
     efa:	20 e0       	ldi	r18, 0x00	; 0
     efc:	30 e0       	ldi	r19, 0x00	; 0
     efe:	40 e0       	ldi	r20, 0x00	; 0
     f00:	50 e0       	ldi	r21, 0x00	; 0
    {
        count ++;
     f02:	2f 5f       	subi	r18, 0xFF	; 255
     f04:	3f 4f       	sbci	r19, 0xFF	; 255
     f06:	4f 4f       	sbci	r20, 0xFF	; 255
     f08:	5f 4f       	sbci	r21, 0xFF	; 255
        temp = temp->node_link;
     f0a:	01 90       	ld	r0, Z+
     f0c:	f0 81       	ld	r31, Z
     f0e:	e0 2d       	mov	r30, r0
#include "linked_list.h"
#include "stdlib.h"
u32  s_list_get_length(struct node *list){
    u32 count =0;
    struct node *temp = list;
    while (temp != NULL)
     f10:	30 97       	sbiw	r30, 0x00	; 0
     f12:	b9 f7       	brne	.-18     	; 0xf02 <s_list_get_length+0x18>
    {
        count ++;
        temp = temp->node_link;
    }
    return count;
}
     f14:	62 2f       	mov	r22, r18
     f16:	73 2f       	mov	r23, r19
     f18:	84 2f       	mov	r24, r20
     f1a:	95 2f       	mov	r25, r21
     f1c:	08 95       	ret

00000f1e <s_list_insert_node_at_end>:
        temp_node->node_link = *list;
        *list = temp_node;
    }
}

void s_list_insert_node_at_end(struct node **list, void* data_ptr){
     f1e:	ef 92       	push	r14
     f20:	ff 92       	push	r15
     f22:	0f 93       	push	r16
     f24:	1f 93       	push	r17
     f26:	cf 93       	push	r28
     f28:	df 93       	push	r29
     f2a:	8c 01       	movw	r16, r24
     f2c:	7b 01       	movw	r14, r22
    struct node *last_node = *list;
     f2e:	fc 01       	movw	r30, r24
     f30:	c0 81       	ld	r28, Z
     f32:	d1 81       	ldd	r29, Z+1	; 0x01
    struct node *temp_node = (struct node *) malloc (sizeof(struct node));
     f34:	84 e0       	ldi	r24, 0x04	; 4
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	0e 94 bf 31 	call	0x637e	; 0x637e <malloc>
     f3c:	dc 01       	movw	r26, r24
    if(NULL == temp_node){}
     f3e:	10 97       	sbiw	r26, 0x00	; 0
     f40:	d1 f0       	breq	.+52     	; 0xf76 <s_list_insert_node_at_end+0x58>
    else{
        temp_node->node_data = data_ptr;
     f42:	13 96       	adiw	r26, 0x03	; 3
     f44:	fc 92       	st	X, r15
     f46:	ee 92       	st	-X, r14
     f48:	12 97       	sbiw	r26, 0x02	; 2
        temp_node->node_link = NULL;
     f4a:	11 96       	adiw	r26, 0x01	; 1
     f4c:	1c 92       	st	X, r1
     f4e:	1e 92       	st	-X, r1
        if(*list == NULL){
     f50:	f8 01       	movw	r30, r16
     f52:	80 81       	ld	r24, Z
     f54:	91 81       	ldd	r25, Z+1	; 0x01
     f56:	89 2b       	or	r24, r25
     f58:	19 f4       	brne	.+6      	; 0xf60 <s_list_insert_node_at_end+0x42>
            *list = temp_node;
     f5a:	b1 83       	std	Z+1, r27	; 0x01
     f5c:	a0 83       	st	Z, r26
     f5e:	0b c0       	rjmp	.+22     	; 0xf76 <s_list_insert_node_at_end+0x58>
        }
        else{
            while (NULL != (last_node->node_link)){
     f60:	8c 2f       	mov	r24, r28
     f62:	9d 2f       	mov	r25, r29
     f64:	09 90       	ld	r0, Y+
     f66:	d8 81       	ld	r29, Y
     f68:	c0 2d       	mov	r28, r0
     f6a:	20 97       	sbiw	r28, 0x00	; 0
     f6c:	c9 f7       	brne	.-14     	; 0xf60 <s_list_insert_node_at_end+0x42>
     f6e:	e8 2f       	mov	r30, r24
     f70:	f9 2f       	mov	r31, r25
                last_node = last_node->node_link;
            }
            last_node->node_link = temp_node;
     f72:	b1 83       	std	Z+1, r27	; 0x01
     f74:	a0 83       	st	Z, r26
        }
    }
}
     f76:	df 91       	pop	r29
     f78:	cf 91       	pop	r28
     f7a:	1f 91       	pop	r17
     f7c:	0f 91       	pop	r16
     f7e:	ff 90       	pop	r15
     f80:	ef 90       	pop	r14
     f82:	08 95       	ret

00000f84 <s_list_insert_node_after_pos>:

void s_list_insert_node_after_pos(struct node *list, u32 node_pos, void* data_ptr){
     f84:	8f 92       	push	r8
     f86:	9f 92       	push	r9
     f88:	af 92       	push	r10
     f8a:	bf 92       	push	r11
     f8c:	cf 92       	push	r12
     f8e:	df 92       	push	r13
     f90:	ef 92       	push	r14
     f92:	ff 92       	push	r15
     f94:	0f 93       	push	r16
     f96:	1f 93       	push	r17
     f98:	df 93       	push	r29
     f9a:	cf 93       	push	r28
     f9c:	00 d0       	rcall	.+0      	; 0xf9e <s_list_insert_node_after_pos+0x1a>
     f9e:	00 d0       	rcall	.+0      	; 0xfa0 <s_list_insert_node_after_pos+0x1c>
     fa0:	cd b7       	in	r28, 0x3d	; 61
     fa2:	de b7       	in	r29, 0x3e	; 62
     fa4:	9a 83       	std	Y+2, r25	; 0x02
     fa6:	89 83       	std	Y+1, r24	; 0x01
     fa8:	7a 01       	movw	r14, r20
     faa:	8b 01       	movw	r16, r22
     fac:	3c 83       	std	Y+4, r19	; 0x04
     fae:	2b 83       	std	Y+3, r18	; 0x03
    u32 count = s_list_get_length(list);
     fb0:	0e 94 75 07 	call	0xeea	; 0xeea <s_list_get_length>
     fb4:	4b 01       	movw	r8, r22
     fb6:	5c 01       	movw	r10, r24
    struct node *node_befor= list;
     fb8:	c9 80       	ldd	r12, Y+1	; 0x01
     fba:	da 80       	ldd	r13, Y+2	; 0x02
    struct node *node_after= list;
    struct node *tempnode= (struct node *)malloc (sizeof(struct node));
     fbc:	84 e0       	ldi	r24, 0x04	; 4
     fbe:	90 e0       	ldi	r25, 0x00	; 0
     fc0:	0e 94 bf 31 	call	0x637e	; 0x637e <malloc>
    if(node_pos > count){}
     fc4:	8e 14       	cp	r8, r14
     fc6:	9f 04       	cpc	r9, r15
     fc8:	a0 06       	cpc	r10, r16
     fca:	b1 06       	cpc	r11, r17
     fcc:	a0 f1       	brcs	.+104    	; 0x1036 <s_list_insert_node_after_pos+0xb2>
    else if(node_pos == count){
     fce:	8e 14       	cp	r8, r14
     fd0:	9f 04       	cpc	r9, r15
     fd2:	a0 06       	cpc	r10, r16
     fd4:	b1 06       	cpc	r11, r17
     fd6:	41 f4       	brne	.+16     	; 0xfe8 <s_list_insert_node_after_pos+0x64>
        s_list_insert_node_at_end(&list, &data_ptr);
     fd8:	ce 01       	movw	r24, r28
     fda:	01 96       	adiw	r24, 0x01	; 1
     fdc:	be 01       	movw	r22, r28
     fde:	6d 5f       	subi	r22, 0xFD	; 253
     fe0:	7f 4f       	sbci	r23, 0xFF	; 255
     fe2:	0e 94 8f 07 	call	0xf1e	; 0xf1e <s_list_insert_node_at_end>
     fe6:	27 c0       	rjmp	.+78     	; 0x1036 <s_list_insert_node_after_pos+0xb2>

void s_list_insert_node_after_pos(struct node *list, u32 node_pos, void* data_ptr){
    u32 count = s_list_get_length(list);
    struct node *node_befor= list;
    struct node *node_after= list;
    struct node *tempnode= (struct node *)malloc (sizeof(struct node));
     fe8:	28 2f       	mov	r18, r24
     fea:	39 2f       	mov	r19, r25
    if(node_pos > count){}
    else if(node_pos == count){
        s_list_insert_node_at_end(&list, &data_ptr);
    }
    else{
        if(tempnode == NULL){}
     fec:	21 15       	cp	r18, r1
     fee:	31 05       	cpc	r19, r1
     ff0:	11 f1       	breq	.+68     	; 0x1036 <s_list_insert_node_after_pos+0xb2>
        else{
            tempnode->node_data = data_ptr;
     ff2:	8b 81       	ldd	r24, Y+3	; 0x03
     ff4:	9c 81       	ldd	r25, Y+4	; 0x04
     ff6:	f9 01       	movw	r30, r18
     ff8:	93 83       	std	Z+3, r25	; 0x03
     ffa:	82 83       	std	Z+2, r24	; 0x02
            u32 node_cout = 1;
            while (node_cout <= node_pos) {
     ffc:	e1 14       	cp	r14, r1
     ffe:	f1 04       	cpc	r15, r1
    1000:	01 05       	cpc	r16, r1
    1002:	11 05       	cpc	r17, r1
    1004:	79 f0       	breq	.+30     	; 0x1024 <s_list_insert_node_after_pos+0xa0>
    1006:	81 e0       	ldi	r24, 0x01	; 1
    1008:	90 e0       	ldi	r25, 0x00	; 0
    100a:	a0 e0       	ldi	r26, 0x00	; 0
    100c:	b0 e0       	ldi	r27, 0x00	; 0
                node_cout ++;
    100e:	01 96       	adiw	r24, 0x01	; 1
    1010:	a1 1d       	adc	r26, r1
    1012:	b1 1d       	adc	r27, r1
                node_befor = node_befor->node_link;
    1014:	f6 01       	movw	r30, r12
    1016:	c0 80       	ld	r12, Z
    1018:	d1 80       	ldd	r13, Z+1	; 0x01
    else{
        if(tempnode == NULL){}
        else{
            tempnode->node_data = data_ptr;
            u32 node_cout = 1;
            while (node_cout <= node_pos) {
    101a:	e8 16       	cp	r14, r24
    101c:	f9 06       	cpc	r15, r25
    101e:	0a 07       	cpc	r16, r26
    1020:	1b 07       	cpc	r17, r27
    1022:	a8 f7       	brcc	.-22     	; 0x100e <s_list_insert_node_after_pos+0x8a>
                node_cout ++;
                node_befor = node_befor->node_link;
            }
            node_after = node_befor->node_link;
            tempnode->node_link = node_after;
    1024:	f6 01       	movw	r30, r12
    1026:	80 81       	ld	r24, Z
    1028:	91 81       	ldd	r25, Z+1	; 0x01
    102a:	f9 01       	movw	r30, r18
    102c:	91 83       	std	Z+1, r25	; 0x01
    102e:	80 83       	st	Z, r24
            node_befor->node_link = tempnode;
    1030:	f6 01       	movw	r30, r12
    1032:	31 83       	std	Z+1, r19	; 0x01
    1034:	20 83       	st	Z, r18
        }
    }
}
    1036:	0f 90       	pop	r0
    1038:	0f 90       	pop	r0
    103a:	0f 90       	pop	r0
    103c:	0f 90       	pop	r0
    103e:	cf 91       	pop	r28
    1040:	df 91       	pop	r29
    1042:	1f 91       	pop	r17
    1044:	0f 91       	pop	r16
    1046:	ff 90       	pop	r15
    1048:	ef 90       	pop	r14
    104a:	df 90       	pop	r13
    104c:	cf 90       	pop	r12
    104e:	bf 90       	pop	r11
    1050:	af 90       	pop	r10
    1052:	9f 90       	pop	r9
    1054:	8f 90       	pop	r8
    1056:	08 95       	ret

00001058 <s_list_insert_node_at_beg>:
        temp = temp->node_link;
    }
    return count;
}

void s_list_insert_node_at_beg(struct node **list, void* data_ptr){
    1058:	0f 93       	push	r16
    105a:	1f 93       	push	r17
    105c:	cf 93       	push	r28
    105e:	df 93       	push	r29
    1060:	ec 01       	movw	r28, r24
    1062:	8b 01       	movw	r16, r22
    struct node *temp_node = (struct node *) malloc (sizeof(struct node));
    1064:	84 e0       	ldi	r24, 0x04	; 4
    1066:	90 e0       	ldi	r25, 0x00	; 0
    1068:	0e 94 bf 31 	call	0x637e	; 0x637e <malloc>
    106c:	fc 01       	movw	r30, r24
    if(NULL == temp_node){    }
    106e:	30 97       	sbiw	r30, 0x00	; 0
    1070:	41 f0       	breq	.+16     	; 0x1082 <s_list_insert_node_at_beg+0x2a>
    else{
        temp_node->node_data = data_ptr;
    1072:	13 83       	std	Z+3, r17	; 0x03
    1074:	02 83       	std	Z+2, r16	; 0x02
        temp_node->node_link = *list;
    1076:	88 81       	ld	r24, Y
    1078:	99 81       	ldd	r25, Y+1	; 0x01
    107a:	91 83       	std	Z+1, r25	; 0x01
    107c:	80 83       	st	Z, r24
        *list = temp_node;
    107e:	f9 83       	std	Y+1, r31	; 0x01
    1080:	e8 83       	st	Y, r30
    }
}
    1082:	df 91       	pop	r29
    1084:	cf 91       	pop	r28
    1086:	1f 91       	pop	r17
    1088:	0f 91       	pop	r16
    108a:	08 95       	ret

0000108c <s_list_delete_node_at_pos>:
    *list = tempnode->node_link;
    tempnode->node_link = NULL;
    free(tempnode);
}

void s_list_delete_node_at_pos(struct node *list, u32 node_pos){
    108c:	8f 92       	push	r8
    108e:	9f 92       	push	r9
    1090:	af 92       	push	r10
    1092:	bf 92       	push	r11
    1094:	cf 92       	push	r12
    1096:	df 92       	push	r13
    1098:	ef 92       	push	r14
    109a:	ff 92       	push	r15
    109c:	0f 93       	push	r16
    109e:	1f 93       	push	r17
    10a0:	cf 93       	push	r28
    10a2:	df 93       	push	r29
    10a4:	98 2e       	mov	r9, r24
    10a6:	89 2e       	mov	r8, r25
    10a8:	5a 01       	movw	r10, r20
    10aa:	6b 01       	movw	r12, r22
    u32 count = s_list_get_length(list);
    10ac:	0e 94 75 07 	call	0xeea	; 0xeea <s_list_get_length>
    10b0:	7b 01       	movw	r14, r22
    10b2:	8c 01       	movw	r16, r24
    struct node *node_befor= list;
    struct node *node_after= list;
    struct node *tempnode= (struct node *)malloc (sizeof(struct node));
    10b4:	84 e0       	ldi	r24, 0x04	; 4
    10b6:	90 e0       	ldi	r25, 0x00	; 0
    10b8:	0e 94 bf 31 	call	0x637e	; 0x637e <malloc>
    if(node_pos > count){}
    10bc:	ea 14       	cp	r14, r10
    10be:	fb 04       	cpc	r15, r11
    10c0:	0c 05       	cpc	r16, r12
    10c2:	1d 05       	cpc	r17, r13
    10c4:	50 f1       	brcs	.+84     	; 0x111a <s_list_delete_node_at_pos+0x8e>
    else{
            u32 node_cout = 1;
            while (node_cout < node_pos-1) {
    10c6:	d6 01       	movw	r26, r12
    10c8:	c5 01       	movw	r24, r10
    10ca:	01 97       	sbiw	r24, 0x01	; 1
    10cc:	a1 09       	sbc	r26, r1
    10ce:	b1 09       	sbc	r27, r1
    10d0:	02 97       	sbiw	r24, 0x02	; 2
    10d2:	a1 05       	cpc	r26, r1
    10d4:	b1 05       	cpc	r27, r1
    10d6:	20 f4       	brcc	.+8      	; 0x10e0 <s_list_delete_node_at_pos+0x54>
    10d8:	29 2d       	mov	r18, r9
    10da:	38 2d       	mov	r19, r8
    10dc:	e9 01       	movw	r28, r18
    10de:	12 c0       	rjmp	.+36     	; 0x1104 <s_list_delete_node_at_pos+0x78>
    10e0:	29 2d       	mov	r18, r9
    10e2:	38 2d       	mov	r19, r8
    10e4:	e9 01       	movw	r28, r18
    10e6:	82 e0       	ldi	r24, 0x02	; 2
    10e8:	90 e0       	ldi	r25, 0x00	; 0
    10ea:	a0 e0       	ldi	r26, 0x00	; 0
    10ec:	b0 e0       	ldi	r27, 0x00	; 0
                node_cout ++;
                node_befor = node_befor->node_link;
    10ee:	09 90       	ld	r0, Y+
    10f0:	d8 81       	ld	r29, Y
    10f2:	c0 2d       	mov	r28, r0
    10f4:	01 96       	adiw	r24, 0x01	; 1
    10f6:	a1 1d       	adc	r26, r1
    10f8:	b1 1d       	adc	r27, r1
    struct node *node_after= list;
    struct node *tempnode= (struct node *)malloc (sizeof(struct node));
    if(node_pos > count){}
    else{
            u32 node_cout = 1;
            while (node_cout < node_pos-1) {
    10fa:	8a 15       	cp	r24, r10
    10fc:	9b 05       	cpc	r25, r11
    10fe:	ac 05       	cpc	r26, r12
    1100:	bd 05       	cpc	r27, r13
    1102:	a9 f7       	brne	.-22     	; 0x10ee <s_list_delete_node_at_pos+0x62>
                node_cout ++;
                node_befor = node_befor->node_link;
            }
            tempnode = node_befor->node_link;
    1104:	e8 81       	ld	r30, Y
    1106:	f9 81       	ldd	r31, Y+1	; 0x01
            node_after = tempnode->node_link;
            node_befor->node_link = node_after;
    1108:	80 81       	ld	r24, Z
    110a:	91 81       	ldd	r25, Z+1	; 0x01
    110c:	99 83       	std	Y+1, r25	; 0x01
    110e:	88 83       	st	Y, r24
            tempnode->node_link = NULL;
    1110:	11 82       	std	Z+1, r1	; 0x01
    1112:	10 82       	st	Z, r1
            free(tempnode);
    1114:	cf 01       	movw	r24, r30
    1116:	0e 94 6c 32 	call	0x64d8	; 0x64d8 <free>
        }
}
    111a:	df 91       	pop	r29
    111c:	cf 91       	pop	r28
    111e:	1f 91       	pop	r17
    1120:	0f 91       	pop	r16
    1122:	ff 90       	pop	r15
    1124:	ef 90       	pop	r14
    1126:	df 90       	pop	r13
    1128:	cf 90       	pop	r12
    112a:	bf 90       	pop	r11
    112c:	af 90       	pop	r10
    112e:	9f 90       	pop	r9
    1130:	8f 90       	pop	r8
    1132:	08 95       	ret

00001134 <s_list_delete_node_at_beg>:
            node_befor->node_link = tempnode;
        }
    }
}

void s_list_delete_node_at_beg(struct node **list){
    1134:	fc 01       	movw	r30, r24
    struct node *tempnode = *list;
    1136:	a0 81       	ld	r26, Z
    1138:	b1 81       	ldd	r27, Z+1	; 0x01
    *list = tempnode->node_link;
    113a:	8d 91       	ld	r24, X+
    113c:	9c 91       	ld	r25, X
    113e:	11 97       	sbiw	r26, 0x01	; 1
    1140:	91 83       	std	Z+1, r25	; 0x01
    1142:	80 83       	st	Z, r24
    tempnode->node_link = NULL;
    1144:	11 96       	adiw	r26, 0x01	; 1
    1146:	1c 92       	st	X, r1
    1148:	1e 92       	st	-X, r1
    free(tempnode);
    114a:	cd 01       	movw	r24, r26
    114c:	0e 94 6c 32 	call	0x64d8	; 0x64d8 <free>
}
    1150:	08 95       	ret

00001152 <WDT_void_Enable>:
#include "../../_MY_LIBS/BIT_MATH.h"

/* ----------------- Section : Software Interfaces Implementation -----------------*/
void WDT_void_Enable (u8 Copy_u8_Time)
{
	switch (Copy_u8_Time)
    1152:	84 30       	cpi	r24, 0x04	; 4
    1154:	d1 f1       	breq	.+116    	; 0x11ca <WDT_void_Enable+0x78>
    1156:	85 30       	cpi	r24, 0x05	; 5
    1158:	40 f4       	brcc	.+16     	; 0x116a <WDT_void_Enable+0x18>
    115a:	82 30       	cpi	r24, 0x02	; 2
    115c:	f1 f0       	breq	.+60     	; 0x119a <WDT_void_Enable+0x48>
    115e:	83 30       	cpi	r24, 0x03	; 3
    1160:	40 f5       	brcc	.+80     	; 0x11b2 <WDT_void_Enable+0x60>
    1162:	81 30       	cpi	r24, 0x01	; 1
    1164:	09 f0       	breq	.+2      	; 0x1168 <WDT_void_Enable+0x16>
    1166:	6c c0       	rjmp	.+216    	; 0x1240 <WDT_void_Enable+0xee>
    1168:	0c c0       	rjmp	.+24     	; 0x1182 <WDT_void_Enable+0x30>
    116a:	86 30       	cpi	r24, 0x06	; 6
    116c:	09 f4       	brne	.+2      	; 0x1170 <WDT_void_Enable+0x1e>
    116e:	45 c0       	rjmp	.+138    	; 0x11fa <WDT_void_Enable+0xa8>
    1170:	86 30       	cpi	r24, 0x06	; 6
    1172:	b8 f1       	brcs	.+110    	; 0x11e2 <WDT_void_Enable+0x90>
    1174:	87 30       	cpi	r24, 0x07	; 7
    1176:	09 f4       	brne	.+2      	; 0x117a <WDT_void_Enable+0x28>
    1178:	4c c0       	rjmp	.+152    	; 0x1212 <WDT_void_Enable+0xc0>
    117a:	88 30       	cpi	r24, 0x08	; 8
    117c:	09 f0       	breq	.+2      	; 0x1180 <WDT_void_Enable+0x2e>
    117e:	60 c0       	rjmp	.+192    	; 0x1240 <WDT_void_Enable+0xee>
    1180:	54 c0       	rjmp	.+168    	; 0x122a <WDT_void_Enable+0xd8>
	{
		case WDT_16_3_ms:
			CLR_BIT(_WDTCR, _WDP0);
    1182:	e1 e4       	ldi	r30, 0x41	; 65
    1184:	f0 e0       	ldi	r31, 0x00	; 0
    1186:	80 81       	ld	r24, Z
    1188:	8e 7f       	andi	r24, 0xFE	; 254
    118a:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP1);
    118c:	80 81       	ld	r24, Z
    118e:	8d 7f       	andi	r24, 0xFD	; 253
    1190:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP2);
    1192:	80 81       	ld	r24, Z
    1194:	8b 7f       	andi	r24, 0xFB	; 251
    1196:	80 83       	st	Z, r24
    1198:	53 c0       	rjmp	.+166    	; 0x1240 <WDT_void_Enable+0xee>
			break;
		case WDT_32_5_ms:
			SET_BIT(_WDTCR, _WDP0);
    119a:	e1 e4       	ldi	r30, 0x41	; 65
    119c:	f0 e0       	ldi	r31, 0x00	; 0
    119e:	80 81       	ld	r24, Z
    11a0:	81 60       	ori	r24, 0x01	; 1
    11a2:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP1);
    11a4:	80 81       	ld	r24, Z
    11a6:	8d 7f       	andi	r24, 0xFD	; 253
    11a8:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP2);
    11aa:	80 81       	ld	r24, Z
    11ac:	8b 7f       	andi	r24, 0xFB	; 251
    11ae:	80 83       	st	Z, r24
    11b0:	47 c0       	rjmp	.+142    	; 0x1240 <WDT_void_Enable+0xee>
			break;
		case WDT_65_0_ms:
			CLR_BIT(_WDTCR, _WDP0);
    11b2:	e1 e4       	ldi	r30, 0x41	; 65
    11b4:	f0 e0       	ldi	r31, 0x00	; 0
    11b6:	80 81       	ld	r24, Z
    11b8:	8e 7f       	andi	r24, 0xFE	; 254
    11ba:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP1);
    11bc:	80 81       	ld	r24, Z
    11be:	82 60       	ori	r24, 0x02	; 2
    11c0:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP2);
    11c2:	80 81       	ld	r24, Z
    11c4:	8b 7f       	andi	r24, 0xFB	; 251
    11c6:	80 83       	st	Z, r24
    11c8:	3b c0       	rjmp	.+118    	; 0x1240 <WDT_void_Enable+0xee>
			break;
		case WDT_0_13_ms:
			SET_BIT(_WDTCR, _WDP0);
    11ca:	e1 e4       	ldi	r30, 0x41	; 65
    11cc:	f0 e0       	ldi	r31, 0x00	; 0
    11ce:	80 81       	ld	r24, Z
    11d0:	81 60       	ori	r24, 0x01	; 1
    11d2:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP1);
    11d4:	80 81       	ld	r24, Z
    11d6:	82 60       	ori	r24, 0x02	; 2
    11d8:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP2);
    11da:	80 81       	ld	r24, Z
    11dc:	8b 7f       	andi	r24, 0xFB	; 251
    11de:	80 83       	st	Z, r24
    11e0:	2f c0       	rjmp	.+94     	; 0x1240 <WDT_void_Enable+0xee>
			break;
		case WDT_0_26_ms:
			CLR_BIT(_WDTCR, _WDP0);
    11e2:	e1 e4       	ldi	r30, 0x41	; 65
    11e4:	f0 e0       	ldi	r31, 0x00	; 0
    11e6:	80 81       	ld	r24, Z
    11e8:	8e 7f       	andi	r24, 0xFE	; 254
    11ea:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP1);
    11ec:	80 81       	ld	r24, Z
    11ee:	8d 7f       	andi	r24, 0xFD	; 253
    11f0:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP2);
    11f2:	80 81       	ld	r24, Z
    11f4:	84 60       	ori	r24, 0x04	; 4
    11f6:	80 83       	st	Z, r24
    11f8:	23 c0       	rjmp	.+70     	; 0x1240 <WDT_void_Enable+0xee>
			break;
		case WDT_0_52_ms:
			SET_BIT(_WDTCR, _WDP0);
    11fa:	e1 e4       	ldi	r30, 0x41	; 65
    11fc:	f0 e0       	ldi	r31, 0x00	; 0
    11fe:	80 81       	ld	r24, Z
    1200:	81 60       	ori	r24, 0x01	; 1
    1202:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP1);
    1204:	80 81       	ld	r24, Z
    1206:	8d 7f       	andi	r24, 0xFD	; 253
    1208:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP2);
    120a:	80 81       	ld	r24, Z
    120c:	84 60       	ori	r24, 0x04	; 4
    120e:	80 83       	st	Z, r24
    1210:	17 c0       	rjmp	.+46     	; 0x1240 <WDT_void_Enable+0xee>
			break;
		case WDT_01_0_ms:
			CLR_BIT(_WDTCR, _WDP0);
    1212:	e1 e4       	ldi	r30, 0x41	; 65
    1214:	f0 e0       	ldi	r31, 0x00	; 0
    1216:	80 81       	ld	r24, Z
    1218:	8e 7f       	andi	r24, 0xFE	; 254
    121a:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP1);
    121c:	80 81       	ld	r24, Z
    121e:	82 60       	ori	r24, 0x02	; 2
    1220:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP2);
    1222:	80 81       	ld	r24, Z
    1224:	84 60       	ori	r24, 0x04	; 4
    1226:	80 83       	st	Z, r24
    1228:	0b c0       	rjmp	.+22     	; 0x1240 <WDT_void_Enable+0xee>
			break;
		case WDT_02_1_ms:
			SET_BIT(_WDTCR, _WDP0);
    122a:	e1 e4       	ldi	r30, 0x41	; 65
    122c:	f0 e0       	ldi	r31, 0x00	; 0
    122e:	80 81       	ld	r24, Z
    1230:	81 60       	ori	r24, 0x01	; 1
    1232:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP1);
    1234:	80 81       	ld	r24, Z
    1236:	82 60       	ori	r24, 0x02	; 2
    1238:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP2);
    123a:	80 81       	ld	r24, Z
    123c:	84 60       	ori	r24, 0x04	; 4
    123e:	80 83       	st	Z, r24
			break;
		default:
			break;
	}
	SET_BIT(_WDTCR, _WDE);
    1240:	e1 e4       	ldi	r30, 0x41	; 65
    1242:	f0 e0       	ldi	r31, 0x00	; 0
    1244:	80 81       	ld	r24, Z
    1246:	88 60       	ori	r24, 0x08	; 8
    1248:	80 83       	st	Z, r24
}
    124a:	08 95       	ret

0000124c <WDT_void_Disable>:

void WDT_void_Disable(void)
{
	_WDTCR = (1<<_WDTOE) | (1<<_WDE);
    124c:	e1 e4       	ldi	r30, 0x41	; 65
    124e:	f0 e0       	ldi	r31, 0x00	; 0
    1250:	88 e1       	ldi	r24, 0x18	; 24
    1252:	80 83       	st	Z, r24
	_WDTCR = 0x00;
    1254:	10 82       	st	Z, r1
}
    1256:	08 95       	ret

00001258 <UART_Init>:

/* ----------------- Section : Software Interfaces Implementation -----------------*/
void UART_Init()
{
	u16 rest = (1000000 /UART_BAUDRATE) - 1;
	_UBRRL = rest;
    1258:	87 e6       	ldi	r24, 0x67	; 103
    125a:	89 b9       	out	0x09, r24	; 9
	switch(UART_SPEED_MODE)
	{
	case ASY_NORMAL_SPEED:
		CLR_BIT(_UCSRA,1);
    125c:	eb e2       	ldi	r30, 0x2B	; 43
    125e:	f0 e0       	ldi	r31, 0x00	; 0
    1260:	80 81       	ld	r24, Z
    1262:	8d 7f       	andi	r24, 0xFD	; 253
    1264:	80 83       	st	Z, r24
	case SYN_MASTER_MODE:
		SET_BIT(_UCSRC, 6);
		break;
	}
	// ENABLE RX TX
	SET_BIT(_UCSRB,4);
    1266:	ea e2       	ldi	r30, 0x2A	; 42
    1268:	f0 e0       	ldi	r31, 0x00	; 0
    126a:	80 81       	ld	r24, Z
    126c:	80 61       	ori	r24, 0x10	; 16
    126e:	80 83       	st	Z, r24
	SET_BIT(_UCSRB,3);
    1270:	80 81       	ld	r24, Z
    1272:	88 60       	ori	r24, 0x08	; 8
    1274:	80 83       	st	Z, r24
}
    1276:	08 95       	ret

00001278 <UART_TransmitData>:

void UART_TransmitData(u8 data)
{
    1278:	98 2f       	mov	r25, r24
	while(!GET_BIT(_UCSRA,5));
    127a:	eb e2       	ldi	r30, 0x2B	; 43
    127c:	f0 e0       	ldi	r31, 0x00	; 0
    127e:	80 81       	ld	r24, Z
    1280:	85 ff       	sbrs	r24, 5
    1282:	fd cf       	rjmp	.-6      	; 0x127e <UART_TransmitData+0x6>
	_UDR = data;
    1284:	9c b9       	out	0x0c, r25	; 12
}
    1286:	08 95       	ret

00001288 <UART_ReceiveData>:

u8 UART_ReceiveData()
{
	while(!GET_BIT(_UCSRA,7));
    1288:	eb e2       	ldi	r30, 0x2B	; 43
    128a:	f0 e0       	ldi	r31, 0x00	; 0
    128c:	80 81       	ld	r24, Z
    128e:	88 23       	and	r24, r24
    1290:	ec f7       	brge	.-6      	; 0x128c <UART_ReceiveData+0x4>
	return _UDR;
    1292:	8c b1       	in	r24, 0x0c	; 12
}
    1294:	08 95       	ret

00001296 <UART_TransmitString>:
    int receivedNumber = atoi(rxBuffer);

    return receivedNumber;
}

void UART_TransmitString(const char* str) {
    1296:	cf 93       	push	r28
    1298:	df 93       	push	r29
    129a:	fc 01       	movw	r30, r24
    // Iterate over each character in the string until the null terminator is reached
    for (int i = 0; str[i] != '\0'; i++) {
    129c:	80 81       	ld	r24, Z
    129e:	88 23       	and	r24, r24
    12a0:	39 f0       	breq	.+14     	; 0x12b0 <UART_TransmitString+0x1a>
    12a2:	ef 01       	movw	r28, r30
        UART_TransmitData(str[i]); // Transmit each character
    12a4:	0e 94 3c 09 	call	0x1278	; 0x1278 <UART_TransmitData>
    return receivedNumber;
}

void UART_TransmitString(const char* str) {
    // Iterate over each character in the string until the null terminator is reached
    for (int i = 0; str[i] != '\0'; i++) {
    12a8:	89 81       	ldd	r24, Y+1	; 0x01
    12aa:	21 96       	adiw	r28, 0x01	; 1
    12ac:	88 23       	and	r24, r24
    12ae:	d1 f7       	brne	.-12     	; 0x12a4 <UART_TransmitString+0xe>
        UART_TransmitData(str[i]); // Transmit each character
    }
}
    12b0:	df 91       	pop	r29
    12b2:	cf 91       	pop	r28
    12b4:	08 95       	ret

000012b6 <UART_ReceiveNumber>:
}



// Function to receive a number over UART, terminated by '\r' (Enter key)
int UART_ReceiveNumber() {
    12b6:	ef 92       	push	r14
    12b8:	ff 92       	push	r15
    12ba:	0f 93       	push	r16
    12bc:	1f 93       	push	r17
    12be:	df 93       	push	r29
    12c0:	cf 93       	push	r28
    12c2:	cd b7       	in	r28, 0x3d	; 61
    12c4:	de b7       	in	r29, 0x3e	; 62
    12c6:	64 97       	sbiw	r28, 0x14	; 20
    12c8:	0f b6       	in	r0, 0x3f	; 63
    12ca:	f8 94       	cli
    12cc:	de bf       	out	0x3e, r29	; 62
    12ce:	0f be       	out	0x3f, r0	; 63
    12d0:	cd bf       	out	0x3d, r28	; 61
    12d2:	60 e0       	ldi	r22, 0x00	; 0
    12d4:	70 e0       	ldi	r23, 0x00	; 0
    char receivedChar;
    u8 endOfNumber = 0;

    // Read characters until Enter ('\r') is received
    while (!endOfNumber) {
        while (!GET_BIT(_UCSRA, 7));  // Wait for a character to be received
    12d6:	ab e2       	ldi	r26, 0x2B	; 43
    12d8:	b0 e0       	ldi	r27, 0x00	; 0
        receivedChar = _UDR;          // Read the received character
    12da:	2c e2       	ldi	r18, 0x2C	; 44
    12dc:	30 e0       	ldi	r19, 0x00	; 0
        if (receivedChar == '\r' || receivedChar == '\n') {
            // If Enter key is received, mark the end of the number
            endOfNumber = 1;
        } else {
            // Store the character in the buffer
            rxBuffer[rxIndex] = receivedChar;
    12de:	8e 01       	movw	r16, r28
    12e0:	0f 5f       	subi	r16, 0xFF	; 255
    12e2:	1f 4f       	sbci	r17, 0xFF	; 255
            rxIndex++;

            // Check if the buffer is full (adjust the buffer size as needed)
            if (rxIndex >= sizeof(rxBuffer)) {
    12e4:	0f 2e       	mov	r0, r31
    12e6:	f3 e1       	ldi	r31, 0x13	; 19
    12e8:	ef 2e       	mov	r14, r31
    12ea:	ff 24       	eor	r15, r15
    12ec:	f0 2d       	mov	r31, r0
    char receivedChar;
    u8 endOfNumber = 0;

    // Read characters until Enter ('\r') is received
    while (!endOfNumber) {
        while (!GET_BIT(_UCSRA, 7));  // Wait for a character to be received
    12ee:	8c 91       	ld	r24, X
    12f0:	88 23       	and	r24, r24
    12f2:	ec f7       	brge	.-6      	; 0x12ee <UART_ReceiveNumber+0x38>
        receivedChar = _UDR;          // Read the received character
    12f4:	f9 01       	movw	r30, r18
    12f6:	80 81       	ld	r24, Z

        if (receivedChar == '\r' || receivedChar == '\n') {
    12f8:	8d 30       	cpi	r24, 0x0D	; 13
    12fa:	79 f0       	breq	.+30     	; 0x131a <UART_ReceiveNumber+0x64>
    12fc:	8a 30       	cpi	r24, 0x0A	; 10
    12fe:	69 f0       	breq	.+26     	; 0x131a <UART_ReceiveNumber+0x64>
            // If Enter key is received, mark the end of the number
            endOfNumber = 1;
        } else {
            // Store the character in the buffer
            rxBuffer[rxIndex] = receivedChar;
            rxIndex++;
    1300:	ab 01       	movw	r20, r22
    1302:	4f 5f       	subi	r20, 0xFF	; 255
    1304:	5f 4f       	sbci	r21, 0xFF	; 255

            // Check if the buffer is full (adjust the buffer size as needed)
            if (rxIndex >= sizeof(rxBuffer)) {
    1306:	44 31       	cpi	r20, 0x14	; 20
    1308:	51 05       	cpc	r21, r1
    130a:	08 f0       	brcs	.+2      	; 0x130e <UART_ReceiveNumber+0x58>
    130c:	a7 01       	movw	r20, r14
        if (receivedChar == '\r' || receivedChar == '\n') {
            // If Enter key is received, mark the end of the number
            endOfNumber = 1;
        } else {
            // Store the character in the buffer
            rxBuffer[rxIndex] = receivedChar;
    130e:	f8 01       	movw	r30, r16
    1310:	e6 0f       	add	r30, r22
    1312:	f7 1f       	adc	r31, r23
    1314:	80 83       	st	Z, r24
    1316:	ba 01       	movw	r22, r20
    1318:	ea cf       	rjmp	.-44     	; 0x12ee <UART_ReceiveNumber+0x38>
            }
        }
    }

    // Null-terminate the string in the buffer
    rxBuffer[rxIndex] = '\0';
    131a:	ce 01       	movw	r24, r28
    131c:	01 96       	adiw	r24, 0x01	; 1
    131e:	fc 01       	movw	r30, r24
    1320:	e6 0f       	add	r30, r22
    1322:	f7 1f       	adc	r31, r23
    1324:	10 82       	st	Z, r1

    // Convert the received string to an integer
    int receivedNumber = atoi(rxBuffer);
    1326:	0e 94 c4 32 	call	0x6588	; 0x6588 <atoi>

    return receivedNumber;
}
    132a:	64 96       	adiw	r28, 0x14	; 20
    132c:	0f b6       	in	r0, 0x3f	; 63
    132e:	f8 94       	cli
    1330:	de bf       	out	0x3e, r29	; 62
    1332:	0f be       	out	0x3f, r0	; 63
    1334:	cd bf       	out	0x3d, r28	; 61
    1336:	cf 91       	pop	r28
    1338:	df 91       	pop	r29
    133a:	1f 91       	pop	r17
    133c:	0f 91       	pop	r16
    133e:	ff 90       	pop	r15
    1340:	ef 90       	pop	r14
    1342:	08 95       	ret

00001344 <TWI_voidInitMaster>:

/* ----------------- Section : Software Interfaces Implementation -----------------*/

void TWI_voidInitMaster(u8 copy_u8MsterAddress)
{
	if ((copy_u8MsterAddress < 128) && (copy_u8MsterAddress > 0))
    1344:	18 16       	cp	r1, r24
    1346:	14 f4       	brge	.+4      	; 0x134c <TWI_voidInitMaster+0x8>
	{
		_TWAR = copy_u8MsterAddress <<1;
    1348:	88 0f       	add	r24, r24
    134a:	82 b9       	out	0x02, r24	; 2
	}
	/* Select SCL as 400KHz */
	_TWBR = 12;
    134c:	8c e0       	ldi	r24, 0x0C	; 12
    134e:	80 b9       	out	0x00, r24	; 0
	//Prescaler 1
	CLR_BIT(_TWSR, _TWPS0);
    1350:	e1 e2       	ldi	r30, 0x21	; 33
    1352:	f0 e0       	ldi	r31, 0x00	; 0
    1354:	80 81       	ld	r24, Z
    1356:	8e 7f       	andi	r24, 0xFE	; 254
    1358:	80 83       	st	Z, r24
	CLR_BIT(_TWSR, _TWPS1);
    135a:	80 81       	ld	r24, Z
    135c:	8d 7f       	andi	r24, 0xFD	; 253
    135e:	80 83       	st	Z, r24

	// Enable ACK, in order to generate status code
	SET_BIT(_TWCR, _TWEA);
    1360:	e6 e5       	ldi	r30, 0x56	; 86
    1362:	f0 e0       	ldi	r31, 0x00	; 0
    1364:	80 81       	ld	r24, Z
    1366:	80 64       	ori	r24, 0x40	; 64
    1368:	80 83       	st	Z, r24

	// Enable TWI
	SET_BIT(_TWCR, _TWEN);
    136a:	80 81       	ld	r24, Z
    136c:	84 60       	ori	r24, 0x04	; 4
    136e:	80 83       	st	Z, r24
}
    1370:	08 95       	ret

00001372 <TWI_voidSendStartCondition>:

void TWI_voidSendStartCondition(void)
{
	// Request Start condition
	SET_BIT(_TWCR, _TWSTA);
    1372:	e6 e5       	ldi	r30, 0x56	; 86
    1374:	f0 e0       	ldi	r31, 0x00	; 0
    1376:	80 81       	ld	r24, Z
    1378:	80 62       	ori	r24, 0x20	; 32
    137a:	80 83       	st	Z, r24
	// Send the start condition
	SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    137c:	80 81       	ld	r24, Z
    137e:	80 68       	ori	r24, 0x80	; 128
    1380:	80 83       	st	Z, r24
	while(0 == GET_BIT(_TWCR, _TWINT));
    1382:	80 81       	ld	r24, Z
    1384:	88 23       	and	r24, r24
    1386:	ec f7       	brge	.-6      	; 0x1382 <TWI_voidSendStartCondition+0x10>
	// Check ACK is Positive
	while(STATUS_VALUE != Start_Condition_ACK);
    1388:	e1 e2       	ldi	r30, 0x21	; 33
    138a:	f0 e0       	ldi	r31, 0x00	; 0
    138c:	80 81       	ld	r24, Z
    138e:	88 7f       	andi	r24, 0xF8	; 248
    1390:	88 30       	cpi	r24, 0x08	; 8
    1392:	e1 f7       	brne	.-8      	; 0x138c <TWI_voidSendStartCondition+0x1a>
}
    1394:	08 95       	ret

00001396 <TWI_voidSendStopCondition>:

void TWI_voidSendStopCondition(void)
{
	// Request STOP condition
	SET_BIT(_TWCR, _TWSTO);
    1396:	e6 e5       	ldi	r30, 0x56	; 86
    1398:	f0 e0       	ldi	r31, 0x00	; 0
    139a:	80 81       	ld	r24, Z
    139c:	80 61       	ori	r24, 0x10	; 16
    139e:	80 83       	st	Z, r24
	// Send the STOP condition
	SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    13a0:	80 81       	ld	r24, Z
    13a2:	80 68       	ori	r24, 0x80	; 128
    13a4:	80 83       	st	Z, r24
}
    13a6:	08 95       	ret

000013a8 <TWI_voidSendReapeatedStartCondition>:

void TWI_voidSendReapeatedStartCondition(void)
{
	// Request Reapeated Start condition
	SET_BIT(_TWCR, _TWSTA);
    13a8:	e6 e5       	ldi	r30, 0x56	; 86
    13aa:	f0 e0       	ldi	r31, 0x00	; 0
    13ac:	80 81       	ld	r24, Z
    13ae:	80 62       	ori	r24, 0x20	; 32
    13b0:	80 83       	st	Z, r24
	// Send the Reapeated start condition
	SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    13b2:	80 81       	ld	r24, Z
    13b4:	80 68       	ori	r24, 0x80	; 128
    13b6:	80 83       	st	Z, r24
	while(0 == GET_BIT(_TWCR, _TWINT));
    13b8:	80 81       	ld	r24, Z
    13ba:	88 23       	and	r24, r24
    13bc:	ec f7       	brge	.-6      	; 0x13b8 <TWI_voidSendReapeatedStartCondition+0x10>
	// Check ACK is Positive
	while(STATUS_VALUE != RepeatedStart_Condition_ACK);
    13be:	e1 e2       	ldi	r30, 0x21	; 33
    13c0:	f0 e0       	ldi	r31, 0x00	; 0
    13c2:	80 81       	ld	r24, Z
    13c4:	88 7f       	andi	r24, 0xF8	; 248
    13c6:	80 31       	cpi	r24, 0x10	; 16
    13c8:	e1 f7       	brne	.-8      	; 0x13c2 <TWI_voidSendReapeatedStartCondition+0x1a>
}
    13ca:	08 95       	ret

000013cc <TWI_voidSendSlaveAdd_WriteRequest>:

void TWI_voidSendSlaveAdd_WriteRequest(u8 copy_u8SlaveAddress)
{
	if ((copy_u8SlaveAddress < 128) && (copy_u8SlaveAddress > 0))
    13cc:	18 16       	cp	r1, r24
    13ce:	c4 f4       	brge	.+48     	; 0x1400 <TWI_voidSendSlaveAdd_WriteRequest+0x34>
	{
		_TWDR = copy_u8SlaveAddress << 1;
    13d0:	88 0f       	add	r24, r24
    13d2:	e3 e2       	ldi	r30, 0x23	; 35
    13d4:	f0 e0       	ldi	r31, 0x00	; 0
    13d6:	80 83       	st	Z, r24
		CLR_BIT(_TWDR, 0);
    13d8:	80 81       	ld	r24, Z
    13da:	8e 7f       	andi	r24, 0xFE	; 254
    13dc:	80 83       	st	Z, r24

		// Clear Start condition Flag
		CLR_BIT(_TWCR, _TWSTA);
    13de:	e6 e5       	ldi	r30, 0x56	; 86
    13e0:	f0 e0       	ldi	r31, 0x00	; 0
    13e2:	80 81       	ld	r24, Z
    13e4:	8f 7d       	andi	r24, 0xDF	; 223
    13e6:	80 83       	st	Z, r24

		SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    13e8:	80 81       	ld	r24, Z
    13ea:	80 68       	ori	r24, 0x80	; 128
    13ec:	80 83       	st	Z, r24
		while(0 == GET_BIT(_TWCR, _TWINT));
    13ee:	80 81       	ld	r24, Z
    13f0:	88 23       	and	r24, r24
    13f2:	ec f7       	brge	.-6      	; 0x13ee <TWI_voidSendSlaveAdd_WriteRequest+0x22>
		// Check ACK is Positive
		while(STATUS_VALUE != SlaveAddress_Write_ACK);
    13f4:	e1 e2       	ldi	r30, 0x21	; 33
    13f6:	f0 e0       	ldi	r31, 0x00	; 0
    13f8:	80 81       	ld	r24, Z
    13fa:	88 7f       	andi	r24, 0xF8	; 248
    13fc:	88 31       	cpi	r24, 0x18	; 24
    13fe:	e1 f7       	brne	.-8      	; 0x13f8 <TWI_voidSendSlaveAdd_WriteRequest+0x2c>
    1400:	08 95       	ret

00001402 <TWI_voidSendSlaveAdd_ReadRequest>:
	}
}

void TWI_voidSendSlaveAdd_ReadRequest(u8 copy_u8SlaveAddress)
{
	if ((copy_u8SlaveAddress < 128) && (copy_u8SlaveAddress > 0))
    1402:	18 16       	cp	r1, r24
    1404:	c4 f4       	brge	.+48     	; 0x1436 <TWI_voidSendSlaveAdd_ReadRequest+0x34>
	{
		_TWDR = copy_u8SlaveAddress << 1;
    1406:	88 0f       	add	r24, r24
    1408:	e3 e2       	ldi	r30, 0x23	; 35
    140a:	f0 e0       	ldi	r31, 0x00	; 0
    140c:	80 83       	st	Z, r24
		SET_BIT(_TWDR, 0);
    140e:	80 81       	ld	r24, Z
    1410:	81 60       	ori	r24, 0x01	; 1
    1412:	80 83       	st	Z, r24

		// Clear Start condition Flag
		CLR_BIT(_TWCR, _TWSTA);
    1414:	e6 e5       	ldi	r30, 0x56	; 86
    1416:	f0 e0       	ldi	r31, 0x00	; 0
    1418:	80 81       	ld	r24, Z
    141a:	8f 7d       	andi	r24, 0xDF	; 223
    141c:	80 83       	st	Z, r24

		SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    141e:	80 81       	ld	r24, Z
    1420:	80 68       	ori	r24, 0x80	; 128
    1422:	80 83       	st	Z, r24
		while(0 == GET_BIT(_TWCR, _TWINT));
    1424:	80 81       	ld	r24, Z
    1426:	88 23       	and	r24, r24
    1428:	ec f7       	brge	.-6      	; 0x1424 <TWI_voidSendSlaveAdd_ReadRequest+0x22>
		// Check ACK is Positive
		while(STATUS_VALUE != SlaveAddress_Read_ACK);
    142a:	e1 e2       	ldi	r30, 0x21	; 33
    142c:	f0 e0       	ldi	r31, 0x00	; 0
    142e:	80 81       	ld	r24, Z
    1430:	88 7f       	andi	r24, 0xF8	; 248
    1432:	80 34       	cpi	r24, 0x40	; 64
    1434:	e1 f7       	brne	.-8      	; 0x142e <TWI_voidSendSlaveAdd_ReadRequest+0x2c>
    1436:	08 95       	ret

00001438 <TWI_voidWriteMasterDataByte>:
	}
}

void TWI_voidWriteMasterDataByte(u8 copy_u8Data)
{
	_TWDR = copy_u8Data;
    1438:	83 b9       	out	0x03, r24	; 3
	// Clear Start condition Flag
	SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    143a:	e6 e5       	ldi	r30, 0x56	; 86
    143c:	f0 e0       	ldi	r31, 0x00	; 0
    143e:	80 81       	ld	r24, Z
    1440:	80 68       	ori	r24, 0x80	; 128
    1442:	80 83       	st	Z, r24
	while(0 == GET_BIT(_TWCR, _TWINT));
    1444:	80 81       	ld	r24, Z
    1446:	88 23       	and	r24, r24
    1448:	ec f7       	brge	.-6      	; 0x1444 <TWI_voidWriteMasterDataByte+0xc>
	// Check ACK is Positive
	while(STATUS_VALUE != Master_Data_Transmit_ACK);
    144a:	e1 e2       	ldi	r30, 0x21	; 33
    144c:	f0 e0       	ldi	r31, 0x00	; 0
    144e:	80 81       	ld	r24, Z
    1450:	88 7f       	andi	r24, 0xF8	; 248
    1452:	88 32       	cpi	r24, 0x28	; 40
    1454:	e1 f7       	brne	.-8      	; 0x144e <TWI_voidWriteMasterDataByte+0x16>
}
    1456:	08 95       	ret

00001458 <TWI_voidReadMasterDataByteNACK>:

void TWI_voidReadMasterDataByteNACK(u8 *copy_u8PtrData)
{
    1458:	dc 01       	movw	r26, r24
	CLR_BIT(_TWCR, _TWEA);	//Disable ACK
    145a:	e6 e5       	ldi	r30, 0x56	; 86
    145c:	f0 e0       	ldi	r31, 0x00	; 0
    145e:	80 81       	ld	r24, Z
    1460:	8f 7b       	andi	r24, 0xBF	; 191
    1462:	80 83       	st	Z, r24
	if (copy_u8PtrData != NULL)
    1464:	10 97       	sbiw	r26, 0x00	; 0
    1466:	71 f0       	breq	.+28     	; 0x1484 <TWI_voidReadMasterDataByteNACK+0x2c>
	{
		// Clear Start condition Flag
		SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    1468:	80 81       	ld	r24, Z
    146a:	80 68       	ori	r24, 0x80	; 128
    146c:	80 83       	st	Z, r24
		while(0 == GET_BIT(_TWCR, _TWINT));
    146e:	80 81       	ld	r24, Z
    1470:	88 23       	and	r24, r24
    1472:	ec f7       	brge	.-6      	; 0x146e <TWI_voidReadMasterDataByteNACK+0x16>
		// Check NACK
	while(STATUS_VALUE != Master_Data_Receive_NACK);
    1474:	e1 e2       	ldi	r30, 0x21	; 33
    1476:	f0 e0       	ldi	r31, 0x00	; 0
    1478:	80 81       	ld	r24, Z
    147a:	88 7f       	andi	r24, 0xF8	; 248
    147c:	88 35       	cpi	r24, 0x58	; 88
    147e:	e1 f7       	brne	.-8      	; 0x1478 <TWI_voidReadMasterDataByteNACK+0x20>
		*copy_u8PtrData = _TWDR;
    1480:	83 b1       	in	r24, 0x03	; 3
    1482:	8c 93       	st	X, r24
	}
	SET_BIT(_TWCR, _TWEA);	// //Enable ACK
    1484:	e6 e5       	ldi	r30, 0x56	; 86
    1486:	f0 e0       	ldi	r31, 0x00	; 0
    1488:	80 81       	ld	r24, Z
    148a:	80 64       	ori	r24, 0x40	; 64
    148c:	80 83       	st	Z, r24
}
    148e:	08 95       	ret

00001490 <TWI_voidReadMasterDataByteACK>:


void TWI_voidReadMasterDataByteACK(u8 *copy_u8PtrData)
{
    1490:	dc 01       	movw	r26, r24
	if (copy_u8PtrData != NULL)
    1492:	00 97       	sbiw	r24, 0x00	; 0
    1494:	81 f0       	breq	.+32     	; 0x14b6 <TWI_voidReadMasterDataByteACK+0x26>
	{
		// Clear Start condition Flag
		SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    1496:	e6 e5       	ldi	r30, 0x56	; 86
    1498:	f0 e0       	ldi	r31, 0x00	; 0
    149a:	80 81       	ld	r24, Z
    149c:	80 68       	ori	r24, 0x80	; 128
    149e:	80 83       	st	Z, r24
		while(0 == GET_BIT(_TWCR, _TWINT));
    14a0:	80 81       	ld	r24, Z
    14a2:	88 23       	and	r24, r24
    14a4:	ec f7       	brge	.-6      	; 0x14a0 <TWI_voidReadMasterDataByteACK+0x10>
		// Check ACK is Positive
		while(STATUS_VALUE != Master_Data_Receive_ACK);
    14a6:	e1 e2       	ldi	r30, 0x21	; 33
    14a8:	f0 e0       	ldi	r31, 0x00	; 0
    14aa:	80 81       	ld	r24, Z
    14ac:	88 7f       	andi	r24, 0xF8	; 248
    14ae:	80 35       	cpi	r24, 0x50	; 80
    14b0:	e1 f7       	brne	.-8      	; 0x14aa <TWI_voidReadMasterDataByteACK+0x1a>
		*copy_u8PtrData = _TWDR;
    14b2:	83 b1       	in	r24, 0x03	; 3
    14b4:	8c 93       	st	X, r24
    14b6:	08 95       	ret

000014b8 <TMR2_voidStop>:
 * @param	void
 * @return	void
 */
void TMR2_voidStop(void)
{
	CLR_BIT(_TCCR2,0);
    14b8:	e5 e4       	ldi	r30, 0x45	; 69
    14ba:	f0 e0       	ldi	r31, 0x00	; 0
    14bc:	80 81       	ld	r24, Z
    14be:	8e 7f       	andi	r24, 0xFE	; 254
    14c0:	80 83       	st	Z, r24
	CLR_BIT(_TCCR2,1);
    14c2:	80 81       	ld	r24, Z
    14c4:	8d 7f       	andi	r24, 0xFD	; 253
    14c6:	80 83       	st	Z, r24
	CLR_BIT(_TCCR2,2);
    14c8:	80 81       	ld	r24, Z
    14ca:	8b 7f       	andi	r24, 0xFB	; 251
    14cc:	80 83       	st	Z, r24
}
    14ce:	08 95       	ret

000014d0 <TMR2_Preload_value_set>:
 * @param	value: The preload value to be set
 * @return	void
 */
void TMR2_Preload_value_set(u8 value)
{
	_TCNT2 = value;
    14d0:	84 bd       	out	0x24, r24	; 36
}
    14d2:	08 95       	ret

000014d4 <TMR2_voidSetDelay_ms_using_CTC>:
#elif TMR2_PRESCALER == 8
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR2_OCR2_val + 1) * 0.5);
#elif TMR2_PRESCALER == 32
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR2_OCR2_val + 1) * 2);
#elif TMR2_PRESCALER == 64
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR2_OCR2_val + 1) * 4);
    14d4:	a0 e0       	ldi	r26, 0x00	; 0
    14d6:	b0 e0       	ldi	r27, 0x00	; 0
    14d8:	bc 01       	movw	r22, r24
    14da:	cd 01       	movw	r24, r26
    14dc:	28 ee       	ldi	r18, 0xE8	; 232
    14de:	33 e0       	ldi	r19, 0x03	; 3
    14e0:	40 e0       	ldi	r20, 0x00	; 0
    14e2:	50 e0       	ldi	r21, 0x00	; 0
    14e4:	0e 94 33 31 	call	0x6266	; 0x6266 <__mulsi3>
    14e8:	0e 94 66 31 	call	0x62cc	; 0x62cc <__udivmodsi4>
    14ec:	30 93 b3 01 	sts	0x01B3, r19
    14f0:	20 93 b2 01 	sts	0x01B2, r18
#elif TMR2_PRESCALER == 256
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR2_OCR2_val + 1) * 16);
#elif TMR2_PRESCALER == 1024
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR2_OCR2_val + 1) * 64);
#endif
}
    14f4:	08 95       	ret

000014f6 <TMR2_voidSetDutyCycle>:
	copy_u8_duty = 100 - copy_u8_duty;
	_OCR2 = (((u16)copy_u8_duty * 256) / 100) - 510;
	#endif	//Phase_correct_PWM_MODE2
	}
#endif // TMR2_MODE
}
    14f6:	08 95       	ret

000014f8 <TMR2_voidSendCallBack_OCM>:
 * @return	void
 */

void TMR2_voidSendCallBack_OCM(void (*PtrF)(void))
{
	if(PtrF != NULL)
    14f8:	00 97       	sbiw	r24, 0x00	; 0
    14fa:	21 f0       	breq	.+8      	; 0x1504 <TMR2_voidSendCallBack_OCM+0xc>
	{
		privatePTR_OC = PtrF;
    14fc:	90 93 b5 01 	sts	0x01B5, r25
    1500:	80 93 b4 01 	sts	0x01B4, r24
    1504:	08 95       	ret

00001506 <TMR2_voidInit>:
	case FastPWM2:
		SET_BIT(_TCCR2, 3);
		SET_BIT(_TCCR2, 6);
		break;
	case CTC2:
		SET_BIT(_TCCR2, 3);
    1506:	e5 e4       	ldi	r30, 0x45	; 69
    1508:	f0 e0       	ldi	r31, 0x00	; 0
    150a:	80 81       	ld	r24, Z
    150c:	88 60       	ori	r24, 0x08	; 8
    150e:	80 83       	st	Z, r24
		CLR_BIT(_TCCR2, 6);
    1510:	80 81       	ld	r24, Z
    1512:	8f 7b       	andi	r24, 0xBF	; 191
    1514:	80 83       	st	Z, r24
	SET_BIT(_TIMSK, 6);
}
#elif TMR2_MODE == TMR2_CTC_MODE
static void Enable_OCI2(void)
{
	SET_BIT(_TIMSK, 7);
    1516:	e9 e5       	ldi	r30, 0x59	; 89
    1518:	f0 e0       	ldi	r31, 0x00	; 0
    151a:	80 81       	ld	r24, Z
    151c:	80 68       	ori	r24, 0x80	; 128
    151e:	80 83       	st	Z, r24
	Enable_OVI2();
	TMR2_Preload_value_set(TMR2_PRELOAD);
#elif TMR2_MODE == TMR2_CTC_MODE
	select_mode(CTC2);
	Enable_OCI2();
	_OCR2 = (TMR2_OCR2_val);
    1520:	89 ef       	ldi	r24, 0xF9	; 249
    1522:	83 bd       	out	0x23, r24	; 35
		SET_BIT(_TCCR2, 4);
		SET_BIT(_TCCR2, 5);
		break;
	}
#endif	// TMR2_MODE
}
    1524:	08 95       	ret

00001526 <TMR2_voidStart>:
		SET_BIT(_TCCR2,0);
		SET_BIT(_TCCR2,1);
		CLR_BIT(_TCCR2,2);
		break;
	case 64:
		CLR_BIT(_TCCR2,0);
    1526:	e5 e4       	ldi	r30, 0x45	; 69
    1528:	f0 e0       	ldi	r31, 0x00	; 0
    152a:	80 81       	ld	r24, Z
    152c:	8e 7f       	andi	r24, 0xFE	; 254
    152e:	80 83       	st	Z, r24
		CLR_BIT(_TCCR2,1);
    1530:	80 81       	ld	r24, Z
    1532:	8d 7f       	andi	r24, 0xFD	; 253
    1534:	80 83       	st	Z, r24
		SET_BIT(_TCCR2,2);
    1536:	80 81       	ld	r24, Z
    1538:	84 60       	ori	r24, 0x04	; 4
    153a:	80 83       	st	Z, r24
 * @return	void
 */
void TMR2_voidStart(void)
{
	PrescalerValue_set((u16)TMR2_PRESCALER);
}
    153c:	08 95       	ret

0000153e <__vector_5>:
// TIMER2 COMP - CTC Mode ISR
void __vector_4(void) __attribute__((signal));


void __vector_5(void)
{
    153e:	1f 92       	push	r1
    1540:	0f 92       	push	r0
    1542:	0f b6       	in	r0, 0x3f	; 63
    1544:	0f 92       	push	r0
    1546:	11 24       	eor	r1, r1
    1548:	2f 93       	push	r18
    154a:	3f 93       	push	r19
    154c:	4f 93       	push	r20
    154e:	5f 93       	push	r21
    1550:	6f 93       	push	r22
    1552:	7f 93       	push	r23
    1554:	8f 93       	push	r24
    1556:	9f 93       	push	r25
    1558:	af 93       	push	r26
    155a:	bf 93       	push	r27
    155c:	ef 93       	push	r30
    155e:	ff 93       	push	r31
	static u16 count = 0;
	count ++;
    1560:	80 91 b8 01 	lds	r24, 0x01B8
    1564:	90 91 b9 01 	lds	r25, 0x01B9
    1568:	01 96       	adiw	r24, 0x01	; 1
    156a:	90 93 b9 01 	sts	0x01B9, r25
    156e:	80 93 b8 01 	sts	0x01B8, r24
	if(count == TMR2_OVERFLOW)
    1572:	81 5d       	subi	r24, 0xD1	; 209
    1574:	93 40       	sbci	r25, 0x03	; 3
    1576:	39 f4       	brne	.+14     	; 0x1586 <__vector_5+0x48>
	{
		TMR2_Preload_value_set(113);
    1578:	81 e7       	ldi	r24, 0x71	; 113
    157a:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <TMR2_Preload_value_set>
		count = 0;
    157e:	10 92 b9 01 	sts	0x01B9, r1
    1582:	10 92 b8 01 	sts	0x01B8, r1
			{
				privatePTR_OV();
			}
	}

}
    1586:	ff 91       	pop	r31
    1588:	ef 91       	pop	r30
    158a:	bf 91       	pop	r27
    158c:	af 91       	pop	r26
    158e:	9f 91       	pop	r25
    1590:	8f 91       	pop	r24
    1592:	7f 91       	pop	r23
    1594:	6f 91       	pop	r22
    1596:	5f 91       	pop	r21
    1598:	4f 91       	pop	r20
    159a:	3f 91       	pop	r19
    159c:	2f 91       	pop	r18
    159e:	0f 90       	pop	r0
    15a0:	0f be       	out	0x3f, r0	; 63
    15a2:	0f 90       	pop	r0
    15a4:	1f 90       	pop	r1
    15a6:	18 95       	reti

000015a8 <__vector_4>:


void __vector_4(void)
{
    15a8:	1f 92       	push	r1
    15aa:	0f 92       	push	r0
    15ac:	0f b6       	in	r0, 0x3f	; 63
    15ae:	0f 92       	push	r0
    15b0:	11 24       	eor	r1, r1
    15b2:	2f 93       	push	r18
    15b4:	3f 93       	push	r19
    15b6:	4f 93       	push	r20
    15b8:	5f 93       	push	r21
    15ba:	6f 93       	push	r22
    15bc:	7f 93       	push	r23
    15be:	8f 93       	push	r24
    15c0:	9f 93       	push	r25
    15c2:	af 93       	push	r26
    15c4:	bf 93       	push	r27
    15c6:	ef 93       	push	r30
    15c8:	ff 93       	push	r31
	static u16 count = 0;
	count ++;
    15ca:	80 91 b6 01 	lds	r24, 0x01B6
    15ce:	90 91 b7 01 	lds	r25, 0x01B7
    15d2:	01 96       	adiw	r24, 0x01	; 1
    15d4:	90 93 b7 01 	sts	0x01B7, r25
    15d8:	80 93 b6 01 	sts	0x01B6, r24
	if(count == private_CTC_counter)
    15dc:	20 91 b2 01 	lds	r18, 0x01B2
    15e0:	30 91 b3 01 	lds	r19, 0x01B3
    15e4:	82 17       	cp	r24, r18
    15e6:	93 07       	cpc	r25, r19
    15e8:	59 f4       	brne	.+22     	; 0x1600 <__vector_4+0x58>
	{
		count = 0;
    15ea:	10 92 b7 01 	sts	0x01B7, r1
    15ee:	10 92 b6 01 	sts	0x01B6, r1
		if(privatePTR_OC !=NULL)
    15f2:	e0 91 b4 01 	lds	r30, 0x01B4
    15f6:	f0 91 b5 01 	lds	r31, 0x01B5
    15fa:	30 97       	sbiw	r30, 0x00	; 0
    15fc:	09 f0       	breq	.+2      	; 0x1600 <__vector_4+0x58>
			{
			privatePTR_OC();
    15fe:	09 95       	icall
			}
	}
}
    1600:	ff 91       	pop	r31
    1602:	ef 91       	pop	r30
    1604:	bf 91       	pop	r27
    1606:	af 91       	pop	r26
    1608:	9f 91       	pop	r25
    160a:	8f 91       	pop	r24
    160c:	7f 91       	pop	r23
    160e:	6f 91       	pop	r22
    1610:	5f 91       	pop	r21
    1612:	4f 91       	pop	r20
    1614:	3f 91       	pop	r19
    1616:	2f 91       	pop	r18
    1618:	0f 90       	pop	r0
    161a:	0f be       	out	0x3f, r0	; 63
    161c:	0f 90       	pop	r0
    161e:	1f 90       	pop	r1
    1620:	18 95       	reti

00001622 <TMR1_voidStop>:
 * @param	void
 * @return	void
 */
void TMR1_voidStop(void)
{
	CLR_BIT(_TCCR1B, _CS10);
    1622:	ee e4       	ldi	r30, 0x4E	; 78
    1624:	f0 e0       	ldi	r31, 0x00	; 0
    1626:	80 81       	ld	r24, Z
    1628:	8e 7f       	andi	r24, 0xFE	; 254
    162a:	80 83       	st	Z, r24
	CLR_BIT(_TCCR1B, _CS11);
    162c:	80 81       	ld	r24, Z
    162e:	8d 7f       	andi	r24, 0xFD	; 253
    1630:	80 83       	st	Z, r24
	CLR_BIT(_TCCR1B, _CS12);
    1632:	80 81       	ld	r24, Z
    1634:	8b 7f       	andi	r24, 0xFB	; 251
    1636:	80 83       	st	Z, r24
}
    1638:	08 95       	ret

0000163a <TMR1_voidSetCompareMatchValueA>:

void TMR1_voidSetCompareMatchValueA(u16 copy_u8CompareMatchValueA){
	_OCR1A = copy_u8CompareMatchValueA;
    163a:	9b bd       	out	0x2b, r25	; 43
    163c:	8a bd       	out	0x2a, r24	; 42
}
    163e:	08 95       	ret

00001640 <TMR1_voidSetFreq_Mode14>:

//under condition ticktime = 4 microsecond
void TMR1_voidSetFreq_Mode14(u16 copy_u16_frequency)
{
#if TMR1_PRESCALER == 64
	_ICR1 = (1000000UL / copy_u16_frequency) / 4 - 1;
    1640:	9c 01       	movw	r18, r24
    1642:	40 e0       	ldi	r20, 0x00	; 0
    1644:	50 e0       	ldi	r21, 0x00	; 0
    1646:	60 e9       	ldi	r22, 0x90	; 144
    1648:	70 ed       	ldi	r23, 0xD0	; 208
    164a:	83 e0       	ldi	r24, 0x03	; 3
    164c:	90 e0       	ldi	r25, 0x00	; 0
    164e:	0e 94 66 31 	call	0x62cc	; 0x62cc <__udivmodsi4>
    1652:	21 50       	subi	r18, 0x01	; 1
    1654:	30 40       	sbci	r19, 0x00	; 0
    1656:	37 bd       	out	0x27, r19	; 39
    1658:	26 bd       	out	0x26, r18	; 38
#endif// TMR1_PRESCALER
}
    165a:	08 95       	ret

0000165c <TMR1_voidInit>:
 * @return	void
 */
void TMR1_voidInit(void)
{
#if TMR1_MODE 	== TMR1_FastPWM_MODE_14
	CLR_BIT(_TCCR1A, _WGM10);
    165c:	af e4       	ldi	r26, 0x4F	; 79
    165e:	b0 e0       	ldi	r27, 0x00	; 0
    1660:	8c 91       	ld	r24, X
    1662:	8e 7f       	andi	r24, 0xFE	; 254
    1664:	8c 93       	st	X, r24
	SET_BIT(_TCCR1A, _WGM11);
    1666:	8c 91       	ld	r24, X
    1668:	82 60       	ori	r24, 0x02	; 2
    166a:	8c 93       	st	X, r24
	SET_BIT(_TCCR1B, _WGM12);
    166c:	ee e4       	ldi	r30, 0x4E	; 78
    166e:	f0 e0       	ldi	r31, 0x00	; 0
    1670:	80 81       	ld	r24, Z
    1672:	88 60       	ori	r24, 0x08	; 8
    1674:	80 83       	st	Z, r24
	SET_BIT(_TCCR1B, _WGM13);
    1676:	80 81       	ld	r24, Z
    1678:	80 61       	ori	r24, 0x10	; 16
    167a:	80 83       	st	Z, r24
	switch(TMR1_FastPWM_14_MODE)
	{
	case non_inverting1:
		CLR_BIT(_TCCR1A, _COM1A0);
    167c:	8c 91       	ld	r24, X
    167e:	8f 7b       	andi	r24, 0xBF	; 191
    1680:	8c 93       	st	X, r24
		SET_BIT(_TCCR1A, _COM1A1);
    1682:	8c 91       	ld	r24, X
    1684:	80 68       	ori	r24, 0x80	; 128
    1686:	8c 93       	st	X, r24
	case inverting1:
		SET_BIT(_TCCR1A, _COM1A0);
		SET_BIT(_TCCR1A, _COM1A1);
		break;
	}
	TMR1_voidSetFreq_Mode14(50);
    1688:	82 e3       	ldi	r24, 0x32	; 50
    168a:	90 e0       	ldi	r25, 0x00	; 0
    168c:	0e 94 20 0b 	call	0x1640	; 0x1640 <TMR1_voidSetFreq_Mode14>
#endif // TMR1_MODE
}
    1690:	08 95       	ret

00001692 <TMR1_voidSetDuty_Mode14>:
	_ICR1 = (1000000UL / copy_u16_frequency) / 4 - 1;
#endif// TMR1_PRESCALER
}

void TMR1_voidSetDuty_Mode14(f32 copy_u8_duty)
{
    1692:	ef 92       	push	r14
    1694:	ff 92       	push	r15
    1696:	0f 93       	push	r16
    1698:	1f 93       	push	r17
    169a:	7b 01       	movw	r14, r22
    169c:	8c 01       	movw	r16, r24
	if(copy_u8_duty <= 100)
    169e:	20 e0       	ldi	r18, 0x00	; 0
    16a0:	30 e0       	ldi	r19, 0x00	; 0
    16a2:	48 ec       	ldi	r20, 0xC8	; 200
    16a4:	52 e4       	ldi	r21, 0x42	; 66
    16a6:	0e 94 25 04 	call	0x84a	; 0x84a <__lesf2>
    16aa:	18 16       	cp	r1, r24
    16ac:	4c f1       	brlt	.+82     	; 0x1700 <TMR1_voidSetDuty_Mode14+0x6e>
		{
		#if TMR1_FastPWM_14_MODE == non_inverting1
			if(copy_u8_duty == 0){
    16ae:	c8 01       	movw	r24, r16
    16b0:	b7 01       	movw	r22, r14
    16b2:	20 e0       	ldi	r18, 0x00	; 0
    16b4:	30 e0       	ldi	r19, 0x00	; 0
    16b6:	40 e0       	ldi	r20, 0x00	; 0
    16b8:	50 e0       	ldi	r21, 0x00	; 0
    16ba:	0e 94 c5 03 	call	0x78a	; 0x78a <__eqsf2>
    16be:	88 23       	and	r24, r24
    16c0:	19 f4       	brne	.+6      	; 0x16c8 <TMR1_voidSetDuty_Mode14+0x36>
				_OCR1A = 0;
    16c2:	1b bc       	out	0x2b, r1	; 43
    16c4:	1a bc       	out	0x2a, r1	; 42
    16c6:	1c c0       	rjmp	.+56     	; 0x1700 <TMR1_voidSetDuty_Mode14+0x6e>
			}
			else{
				_OCR1A = ((copy_u8_duty * (_ICR1+1)) / 100) -1;
    16c8:	66 b5       	in	r22, 0x26	; 38
    16ca:	77 b5       	in	r23, 0x27	; 39
    16cc:	6f 5f       	subi	r22, 0xFF	; 255
    16ce:	7f 4f       	sbci	r23, 0xFF	; 255
    16d0:	80 e0       	ldi	r24, 0x00	; 0
    16d2:	90 e0       	ldi	r25, 0x00	; 0
    16d4:	0e 94 07 05 	call	0xa0e	; 0xa0e <__floatunsisf>
    16d8:	a8 01       	movw	r20, r16
    16da:	97 01       	movw	r18, r14
    16dc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    16e0:	20 e0       	ldi	r18, 0x00	; 0
    16e2:	30 e0       	ldi	r19, 0x00	; 0
    16e4:	48 ec       	ldi	r20, 0xC8	; 200
    16e6:	52 e4       	ldi	r21, 0x42	; 66
    16e8:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    16ec:	20 e0       	ldi	r18, 0x00	; 0
    16ee:	30 e0       	ldi	r19, 0x00	; 0
    16f0:	40 e8       	ldi	r20, 0x80	; 128
    16f2:	5f e3       	ldi	r21, 0x3F	; 63
    16f4:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    16f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16fc:	7b bd       	out	0x2b, r23	; 43
    16fe:	6a bd       	out	0x2a, r22	; 42
				copy_u8_duty = 100 - copy_u8_duty;
				_OCR1A = (((float)copy_u8_duty * (_ICR1+1)) / 100) -1;
			}
		#endif	//TMR1_FastPWM_14_MODE
		}
}
    1700:	1f 91       	pop	r17
    1702:	0f 91       	pop	r16
    1704:	ff 90       	pop	r15
    1706:	ef 90       	pop	r14
    1708:	08 95       	ret

0000170a <TMR1_voidStart>:
		CLR_BIT(_TCCR1B, _CS10);
		SET_BIT(_TCCR1B, _CS11);
		CLR_BIT(_TCCR1B, _CS12);
		break;
	case 64:
		SET_BIT(_TCCR1B, _CS10);
    170a:	ee e4       	ldi	r30, 0x4E	; 78
    170c:	f0 e0       	ldi	r31, 0x00	; 0
    170e:	80 81       	ld	r24, Z
    1710:	81 60       	ori	r24, 0x01	; 1
    1712:	80 83       	st	Z, r24
		SET_BIT(_TCCR1B, _CS11);
    1714:	80 81       	ld	r24, Z
    1716:	82 60       	ori	r24, 0x02	; 2
    1718:	80 83       	st	Z, r24
		CLR_BIT(_TCCR1B, _CS12);
    171a:	80 81       	ld	r24, Z
    171c:	8b 7f       	andi	r24, 0xFB	; 251
    171e:	80 83       	st	Z, r24


void TMR1_voidStart(void)
{
	PrescalerValue_set((u16)TMR1_PRESCALER);
}
    1720:	08 95       	ret

00001722 <TMR0_voidStop>:
 * @param	void
 * @return	void
 */
void TMR0_voidStop(void)
{
	CLR_BIT(_TCCR0,0);
    1722:	e3 e5       	ldi	r30, 0x53	; 83
    1724:	f0 e0       	ldi	r31, 0x00	; 0
    1726:	80 81       	ld	r24, Z
    1728:	8e 7f       	andi	r24, 0xFE	; 254
    172a:	80 83       	st	Z, r24
	CLR_BIT(_TCCR0,1);
    172c:	80 81       	ld	r24, Z
    172e:	8d 7f       	andi	r24, 0xFD	; 253
    1730:	80 83       	st	Z, r24
	CLR_BIT(_TCCR0,2);
    1732:	80 81       	ld	r24, Z
    1734:	8b 7f       	andi	r24, 0xFB	; 251
    1736:	80 83       	st	Z, r24
}
    1738:	08 95       	ret

0000173a <TMR0_Preload_value_set>:
 * @param	value: The preload value to be set
 * @return	void
 */
void TMR0_Preload_value_set(u8 value)
{
	_TCNT0 = value;
    173a:	82 bf       	out	0x32, r24	; 50
}
    173c:	08 95       	ret

0000173e <TMR0_voidSetDelay_ms_using_CTC>:
#if TMR0_PRESCALER == 1
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR0_OCR0_val + 1) * 0.0625);
#elif TMR0_PRESCALER == 8
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR0_OCR0_val + 1) * 0.5);
#elif TMR0_PRESCALER == 64
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR0_OCR0_val + 1) * 4);
    173e:	a0 e0       	ldi	r26, 0x00	; 0
    1740:	b0 e0       	ldi	r27, 0x00	; 0
    1742:	bc 01       	movw	r22, r24
    1744:	cd 01       	movw	r24, r26
    1746:	28 ee       	ldi	r18, 0xE8	; 232
    1748:	33 e0       	ldi	r19, 0x03	; 3
    174a:	40 e0       	ldi	r20, 0x00	; 0
    174c:	50 e0       	ldi	r21, 0x00	; 0
    174e:	0e 94 33 31 	call	0x6266	; 0x6266 <__mulsi3>
    1752:	67 2f       	mov	r22, r23
    1754:	78 2f       	mov	r23, r24
    1756:	89 2f       	mov	r24, r25
    1758:	99 27       	eor	r25, r25
    175a:	70 93 bb 01 	sts	0x01BB, r23
    175e:	60 93 ba 01 	sts	0x01BA, r22
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR0_OCR0_val + 1) * 16);

#elif TMR0_PRESCALER == 1024
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR0_OCR0_val + 1) * 64);
#endif
}
    1762:	08 95       	ret

00001764 <TMR0_voidSetDutyCycle>:
	copy_u8_duty = 100 - copy_u8_duty;
	_OCR0 = (((u16)copy_u8_duty * 256) / 100) - 510;;
	#endif	//Phase_Correct_PWM_MODE
	}
#endif // TMR0_MODE
}
    1764:	08 95       	ret

00001766 <TMR0_voidSendCallBack_OVF>:
 * @param	PtrF: A pointer to the overflow callback function
 * @return	void
 */
void TMR0_voidSendCallBack_OVF(void (*PtrF)(void))
{
	if(PtrF != NULL)
    1766:	00 97       	sbiw	r24, 0x00	; 0
    1768:	21 f0       	breq	.+8      	; 0x1772 <TMR0_voidSendCallBack_OVF+0xc>
	{
		privatePTR_OV = PtrF;
    176a:	90 93 c1 01 	sts	0x01C1, r25
    176e:	80 93 c0 01 	sts	0x01C0, r24
    1772:	08 95       	ret

00001774 <TMR0_voidSendCallBack_OCM>:
 * @return	void
 */

void TMR0_voidSendCallBack_OCM(void (*PtrF)(void))
{
	if(PtrF != NULL)
    1774:	00 97       	sbiw	r24, 0x00	; 0
    1776:	21 f0       	breq	.+8      	; 0x1780 <TMR0_voidSendCallBack_OCM+0xc>
	{
		privatePTR_OC = PtrF;
    1778:	90 93 bd 01 	sts	0x01BD, r25
    177c:	80 93 bc 01 	sts	0x01BC, r24
    1780:	08 95       	ret

00001782 <TMR0_voidInit>:
static void select_mode(u8 mode)
{
	switch(mode)
	{
	case Normal:
		CLR_BIT(_TCCR0, 3);
    1782:	e3 e5       	ldi	r30, 0x53	; 83
    1784:	f0 e0       	ldi	r31, 0x00	; 0
    1786:	80 81       	ld	r24, Z
    1788:	87 7f       	andi	r24, 0xF7	; 247
    178a:	80 83       	st	Z, r24
		CLR_BIT(_TCCR0, 6);
    178c:	80 81       	ld	r24, Z
    178e:	8f 7b       	andi	r24, 0xBF	; 191
    1790:	80 83       	st	Z, r24
}

#if TMR0_MODE 	== TMR0_NORMAL_MODE
static void Enable_OVI0(void)
{
	SET_BIT(_TIMSK, 0);
    1792:	e9 e5       	ldi	r30, 0x59	; 89
    1794:	f0 e0       	ldi	r31, 0x00	; 0
    1796:	80 81       	ld	r24, Z
    1798:	81 60       	ori	r24, 0x01	; 1
    179a:	80 83       	st	Z, r24
void TMR0_voidInit(void)
{
#if TMR0_MODE 	== TMR0_NORMAL_MODE
	select_mode(Normal);
	Enable_OVI0();
	TMR0_Preload_value_set(TMR0_PRELOAD);
    179c:	80 e0       	ldi	r24, 0x00	; 0
    179e:	0e 94 9d 0b 	call	0x173a	; 0x173a <TMR0_Preload_value_set>
		SET_BIT(_TCCR0, 4);
		SET_BIT(_TCCR0, 5);
		break;
	}
#endif
}
    17a2:	08 95       	ret

000017a4 <TMR0_voidStart>:
		CLR_BIT(_TCCR0,0);
		SET_BIT(_TCCR0,1);
		CLR_BIT(_TCCR0,2);
		break;
	case 64:
		SET_BIT(_TCCR0,0);
    17a4:	e3 e5       	ldi	r30, 0x53	; 83
    17a6:	f0 e0       	ldi	r31, 0x00	; 0
    17a8:	80 81       	ld	r24, Z
    17aa:	81 60       	ori	r24, 0x01	; 1
    17ac:	80 83       	st	Z, r24
		SET_BIT(_TCCR0,1);
    17ae:	80 81       	ld	r24, Z
    17b0:	82 60       	ori	r24, 0x02	; 2
    17b2:	80 83       	st	Z, r24
		CLR_BIT(_TCCR0,2);
    17b4:	80 81       	ld	r24, Z
    17b6:	8b 7f       	andi	r24, 0xFB	; 251
    17b8:	80 83       	st	Z, r24
 * @return	void
 */
void TMR0_voidStart(void)
{
	PrescalerValue_set((u16)TMR0_PRESCALER);
}
    17ba:	08 95       	ret

000017bc <__vector_11>:
//CTC Mode ISR
void __vector_10(void) __attribute__((signal));


void __vector_11(void)
{
    17bc:	1f 92       	push	r1
    17be:	0f 92       	push	r0
    17c0:	0f b6       	in	r0, 0x3f	; 63
    17c2:	0f 92       	push	r0
    17c4:	11 24       	eor	r1, r1
    17c6:	2f 93       	push	r18
    17c8:	3f 93       	push	r19
    17ca:	4f 93       	push	r20
    17cc:	5f 93       	push	r21
    17ce:	6f 93       	push	r22
    17d0:	7f 93       	push	r23
    17d2:	8f 93       	push	r24
    17d4:	9f 93       	push	r25
    17d6:	af 93       	push	r26
    17d8:	bf 93       	push	r27
    17da:	ef 93       	push	r30
    17dc:	ff 93       	push	r31
	static u16 local_u16ovCounter = 0;
	local_u16ovCounter++;
    17de:	80 91 c2 01 	lds	r24, 0x01C2
    17e2:	90 91 c3 01 	lds	r25, 0x01C3
    17e6:	01 96       	adiw	r24, 0x01	; 1
    17e8:	90 93 c3 01 	sts	0x01C3, r25
    17ec:	80 93 c2 01 	sts	0x01C2, r24

	if (TMR0_OVERFLOW == local_u16ovCounter) {
    17f0:	06 97       	sbiw	r24, 0x06	; 6
    17f2:	61 f4       	brne	.+24     	; 0x180c <__vector_11+0x50>
		// Reload preload value
		_TCNT0 = TMR0_PRELOAD;
    17f4:	12 be       	out	0x32, r1	; 50
		// Clear the counter
		local_u16ovCounter = 0;
    17f6:	10 92 c3 01 	sts	0x01C3, r1
    17fa:	10 92 c2 01 	sts	0x01C2, r1

		// Call the callback function if assigned
		if (privatePTR_OV != NULL) {
    17fe:	e0 91 c0 01 	lds	r30, 0x01C0
    1802:	f0 91 c1 01 	lds	r31, 0x01C1
    1806:	30 97       	sbiw	r30, 0x00	; 0
    1808:	09 f0       	breq	.+2      	; 0x180c <__vector_11+0x50>
			privatePTR_OV();
    180a:	09 95       	icall
		}
	}
}
    180c:	ff 91       	pop	r31
    180e:	ef 91       	pop	r30
    1810:	bf 91       	pop	r27
    1812:	af 91       	pop	r26
    1814:	9f 91       	pop	r25
    1816:	8f 91       	pop	r24
    1818:	7f 91       	pop	r23
    181a:	6f 91       	pop	r22
    181c:	5f 91       	pop	r21
    181e:	4f 91       	pop	r20
    1820:	3f 91       	pop	r19
    1822:	2f 91       	pop	r18
    1824:	0f 90       	pop	r0
    1826:	0f be       	out	0x3f, r0	; 63
    1828:	0f 90       	pop	r0
    182a:	1f 90       	pop	r1
    182c:	18 95       	reti

0000182e <__vector_10>:


void __vector_10(void)
{
    182e:	1f 92       	push	r1
    1830:	0f 92       	push	r0
    1832:	0f b6       	in	r0, 0x3f	; 63
    1834:	0f 92       	push	r0
    1836:	11 24       	eor	r1, r1
    1838:	2f 93       	push	r18
    183a:	3f 93       	push	r19
    183c:	4f 93       	push	r20
    183e:	5f 93       	push	r21
    1840:	6f 93       	push	r22
    1842:	7f 93       	push	r23
    1844:	8f 93       	push	r24
    1846:	9f 93       	push	r25
    1848:	af 93       	push	r26
    184a:	bf 93       	push	r27
    184c:	ef 93       	push	r30
    184e:	ff 93       	push	r31
	static u16 count = 0;
	count ++;
    1850:	80 91 be 01 	lds	r24, 0x01BE
    1854:	90 91 bf 01 	lds	r25, 0x01BF
    1858:	01 96       	adiw	r24, 0x01	; 1
    185a:	90 93 bf 01 	sts	0x01BF, r25
    185e:	80 93 be 01 	sts	0x01BE, r24
	if(count == private_CTC_counter)
    1862:	20 91 ba 01 	lds	r18, 0x01BA
    1866:	30 91 bb 01 	lds	r19, 0x01BB
    186a:	82 17       	cp	r24, r18
    186c:	93 07       	cpc	r25, r19
    186e:	59 f4       	brne	.+22     	; 0x1886 <__vector_10+0x58>
	{
		count = 0;
    1870:	10 92 bf 01 	sts	0x01BF, r1
    1874:	10 92 be 01 	sts	0x01BE, r1
		if(privatePTR_OC !=NULL)
    1878:	e0 91 bc 01 	lds	r30, 0x01BC
    187c:	f0 91 bd 01 	lds	r31, 0x01BD
    1880:	30 97       	sbiw	r30, 0x00	; 0
    1882:	09 f0       	breq	.+2      	; 0x1886 <__vector_10+0x58>
			{
			privatePTR_OC();
    1884:	09 95       	icall
			}
	}
}
    1886:	ff 91       	pop	r31
    1888:	ef 91       	pop	r30
    188a:	bf 91       	pop	r27
    188c:	af 91       	pop	r26
    188e:	9f 91       	pop	r25
    1890:	8f 91       	pop	r24
    1892:	7f 91       	pop	r23
    1894:	6f 91       	pop	r22
    1896:	5f 91       	pop	r21
    1898:	4f 91       	pop	r20
    189a:	3f 91       	pop	r19
    189c:	2f 91       	pop	r18
    189e:	0f 90       	pop	r0
    18a0:	0f be       	out	0x3f, r0	; 63
    18a2:	0f 90       	pop	r0
    18a4:	1f 90       	pop	r1
    18a6:	18 95       	reti

000018a8 <SPI_voidInit>:
   SET_BIT(_SPCR, 0);
   CLR_BIT(_SPCR, 1);
   CLR_BIT(_SPSR, 0);

#elif SPI_MODE	==	SLAVE
   CLR_BIT(_SPCR, 4);
    18a8:	ed e2       	ldi	r30, 0x2D	; 45
    18aa:	f0 e0       	ldi	r31, 0x00	; 0
    18ac:	80 81       	ld	r24, Z
    18ae:	8f 7e       	andi	r24, 0xEF	; 239
    18b0:	80 83       	st	Z, r24
#endif //SPI_MODE

   // Data Order --> LSB:SET	or  MSB:CLEAR
   SET_BIT(_SPCR, 5);
    18b2:	80 81       	ld	r24, Z
    18b4:	80 62       	ori	r24, 0x20	; 32
    18b6:	80 83       	st	Z, r24

   //POLARITY, PHASE	--> Falling Rising	Setup Sample
   SET_BIT(_SPCR, 3);
    18b8:	80 81       	ld	r24, Z
    18ba:	88 60       	ori	r24, 0x08	; 8
    18bc:	80 83       	st	Z, r24
   SET_BIT(_SPCR, 2);
    18be:	80 81       	ld	r24, Z
    18c0:	84 60       	ori	r24, 0x04	; 4
    18c2:	80 83       	st	Z, r24

   // enable SPI
	SET_BIT(_SPCR, 6);
    18c4:	80 81       	ld	r24, Z
    18c6:	80 64       	ori	r24, 0x40	; 64
    18c8:	80 83       	st	Z, r24
}
    18ca:	08 95       	ret

000018cc <SPI_voidTranseive>:

void SPI_voidTranseive(u8 copy_u8_TX_data, u8 * copy_u8_RX_data)
{
    18cc:	98 2f       	mov	r25, r24
    18ce:	db 01       	movw	r26, r22
	if (copy_u8_RX_data != NULL)
    18d0:	61 15       	cp	r22, r1
    18d2:	71 05       	cpc	r23, r1
    18d4:	69 f0       	breq	.+26     	; 0x18f0 <SPI_voidTranseive+0x24>
	{
		while(GET_BIT(_SPSR, 6));	// To prevent collision (Writing in buffer while still have the data to be sent
    18d6:	ee e2       	ldi	r30, 0x2E	; 46
    18d8:	f0 e0       	ldi	r31, 0x00	; 0
    18da:	80 81       	ld	r24, Z
    18dc:	86 fd       	sbrc	r24, 6
    18de:	fd cf       	rjmp	.-6      	; 0x18da <SPI_voidTranseive+0xe>
		_SPDR = copy_u8_TX_data;	// write buffer >> Data register
    18e0:	9f b9       	out	0x0f, r25	; 15
		while(!GET_BIT(_SPSR, 7));	// blocking
    18e2:	ee e2       	ldi	r30, 0x2E	; 46
    18e4:	f0 e0       	ldi	r31, 0x00	; 0
    18e6:	80 81       	ld	r24, Z
    18e8:	88 23       	and	r24, r24
    18ea:	ec f7       	brge	.-6      	; 0x18e6 <SPI_voidTranseive+0x1a>
		*copy_u8_RX_data =  _SPDR;	// Read data from buffer (Receive)
    18ec:	8f b1       	in	r24, 0x0f	; 15
    18ee:	8c 93       	st	X, r24
    18f0:	08 95       	ret

000018f2 <SPI_voidTransmit_Async>:
		return;
	}
}

void SPI_voidTransmit_Async(u8 copy_u8_TX_data, void(*PtrFunc)(u8 copy_u8_RX_data))
{
    18f2:	98 2f       	mov	r25, r24
	if (PtrFunc != NULL)
    18f4:	61 15       	cp	r22, r1
    18f6:	71 05       	cpc	r23, r1
    18f8:	79 f0       	breq	.+30     	; 0x1918 <SPI_voidTransmit_Async+0x26>
	{
		// Enable SPI Interrupt
		SET_BIT(_SPCR, 7);
    18fa:	ed e2       	ldi	r30, 0x2D	; 45
    18fc:	f0 e0       	ldi	r31, 0x00	; 0
    18fe:	80 81       	ld	r24, Z
    1900:	80 68       	ori	r24, 0x80	; 128
    1902:	80 83       	st	Z, r24

		Private_pCallback = PtrFunc;
    1904:	70 93 c5 01 	sts	0x01C5, r23
    1908:	60 93 c4 01 	sts	0x01C4, r22
		while(GET_BIT(_SPSR, 6));	// To prevent collision (Writing in buffer while still have the data to be sent
    190c:	ee e2       	ldi	r30, 0x2E	; 46
    190e:	f0 e0       	ldi	r31, 0x00	; 0
    1910:	80 81       	ld	r24, Z
    1912:	86 fd       	sbrc	r24, 6
    1914:	fd cf       	rjmp	.-6      	; 0x1910 <SPI_voidTransmit_Async+0x1e>
		_SPDR = copy_u8_TX_data;	// write buffer >> Data register
    1916:	9f b9       	out	0x0f, r25	; 15
    1918:	08 95       	ret

0000191a <__vector_12>:

/* ----------------- Section : ISRs -----------------*/
void __vector_12(void) __attribute__((signal));

void __vector_12(void)
{
    191a:	1f 92       	push	r1
    191c:	0f 92       	push	r0
    191e:	0f b6       	in	r0, 0x3f	; 63
    1920:	0f 92       	push	r0
    1922:	11 24       	eor	r1, r1
    1924:	2f 93       	push	r18
    1926:	3f 93       	push	r19
    1928:	4f 93       	push	r20
    192a:	5f 93       	push	r21
    192c:	6f 93       	push	r22
    192e:	7f 93       	push	r23
    1930:	8f 93       	push	r24
    1932:	9f 93       	push	r25
    1934:	af 93       	push	r26
    1936:	bf 93       	push	r27
    1938:	ef 93       	push	r30
    193a:	ff 93       	push	r31
	if(Private_pCallback)
    193c:	e0 91 c4 01 	lds	r30, 0x01C4
    1940:	f0 91 c5 01 	lds	r31, 0x01C5
    1944:	30 97       	sbiw	r30, 0x00	; 0
    1946:	11 f0       	breq	.+4      	; 0x194c <__vector_12+0x32>
	{
		Private_pCallback(_SPDR);
    1948:	8f b1       	in	r24, 0x0f	; 15
    194a:	09 95       	icall
	}
}
    194c:	ff 91       	pop	r31
    194e:	ef 91       	pop	r30
    1950:	bf 91       	pop	r27
    1952:	af 91       	pop	r26
    1954:	9f 91       	pop	r25
    1956:	8f 91       	pop	r24
    1958:	7f 91       	pop	r23
    195a:	6f 91       	pop	r22
    195c:	5f 91       	pop	r21
    195e:	4f 91       	pop	r20
    1960:	3f 91       	pop	r19
    1962:	2f 91       	pop	r18
    1964:	0f 90       	pop	r0
    1966:	0f be       	out	0x3f, r0	; 63
    1968:	0f 90       	pop	r0
    196a:	1f 90       	pop	r1
    196c:	18 95       	reti

0000196e <Port_Init>:
 * 			   		the function will make PA_4, PA_5 as Output  and PA_6 as Input
 * @param	1- Pin_ConfigType *pins_cfg 	-> which is a pointer to a structure of data type "Pin_ConfigType"
 * @return	void
 */
void Port_Init (Pin_ConfigType *pins_cfg)
{
    196e:	4f 92       	push	r4
    1970:	5f 92       	push	r5
    1972:	6f 92       	push	r6
    1974:	7f 92       	push	r7
    1976:	8f 92       	push	r8
    1978:	9f 92       	push	r9
    197a:	af 92       	push	r10
    197c:	bf 92       	push	r11
    197e:	cf 92       	push	r12
    1980:	df 92       	push	r13
    1982:	ef 92       	push	r14
    1984:	ff 92       	push	r15
    1986:	0f 93       	push	r16
    1988:	1f 93       	push	r17
    198a:	cf 93       	push	r28
    198c:	df 93       	push	r29
    198e:	fc 01       	movw	r30, r24
    1990:	40 e0       	ldi	r20, 0x00	; 0
    1992:	50 e0       	ldi	r21, 0x00	; 0
			{
				SET_BIT(_DDRB, pins_cfg[i].Pin);
			}
			else
			{
				CLR_BIT(_DDRB, pins_cfg[i].Pin);
    1994:	0f 2e       	mov	r0, r31
    1996:	f7 e3       	ldi	r31, 0x37	; 55
    1998:	ef 2e       	mov	r14, r31
    199a:	ff 24       	eor	r15, r15
    199c:	f0 2d       	mov	r31, r0
    199e:	61 e0       	ldi	r22, 0x01	; 1
    19a0:	70 e0       	ldi	r23, 0x00	; 0
				SET_BIT(_PORTB, pins_cfg[i].Pin);
    19a2:	0f 2e       	mov	r0, r31
    19a4:	f8 e3       	ldi	r31, 0x38	; 56
    19a6:	8f 2e       	mov	r8, r31
    19a8:	99 24       	eor	r9, r9
    19aa:	f0 2d       	mov	r31, r0
			{
				SET_BIT(_DDRA, pins_cfg[i].Pin);
			}
			else
			{
				CLR_BIT(_DDRA, pins_cfg[i].Pin);
    19ac:	0a e3       	ldi	r16, 0x3A	; 58
    19ae:	10 e0       	ldi	r17, 0x00	; 0
				SET_BIT(_PORTA, pins_cfg[i].Pin);
    19b0:	0f 2e       	mov	r0, r31
    19b2:	fb e3       	ldi	r31, 0x3B	; 59
    19b4:	6f 2e       	mov	r6, r31
    19b6:	77 24       	eor	r7, r7
    19b8:	f0 2d       	mov	r31, r0
			{
				SET_BIT(_DDRC, pins_cfg[i].Pin);
			}
			else
			{
				CLR_BIT(_DDRC, pins_cfg[i].Pin);
    19ba:	c4 e3       	ldi	r28, 0x34	; 52
    19bc:	d0 e0       	ldi	r29, 0x00	; 0
				SET_BIT(_PORTC, pins_cfg[i].Pin);
    19be:	0f 2e       	mov	r0, r31
    19c0:	f5 e3       	ldi	r31, 0x35	; 53
    19c2:	af 2e       	mov	r10, r31
    19c4:	bb 24       	eor	r11, r11
    19c6:	f0 2d       	mov	r31, r0
			{
				SET_BIT(_DDRD, pins_cfg[i].Pin);
			}
			else
			{
				CLR_BIT(_DDRD, pins_cfg[i].Pin);
    19c8:	0f 2e       	mov	r0, r31
    19ca:	f1 e3       	ldi	r31, 0x31	; 49
    19cc:	4f 2e       	mov	r4, r31
    19ce:	55 24       	eor	r5, r5
    19d0:	f0 2d       	mov	r31, r0
				SET_BIT(_PORTD, pins_cfg[i].Pin);
    19d2:	0f 2e       	mov	r0, r31
    19d4:	f2 e3       	ldi	r31, 0x32	; 50
    19d6:	cf 2e       	mov	r12, r31
    19d8:	dd 24       	eor	r13, r13
    19da:	f0 2d       	mov	r31, r0
	for(int i = 0 ; i < 32 ; i ++)
	{
		if((pins_cfg[i].Port) == -1){
			break;
		}
		switch(pins_cfg[i].Port)
    19dc:	80 81       	ld	r24, Z
    19de:	81 30       	cpi	r24, 0x01	; 1
    19e0:	51 f1       	breq	.+84     	; 0x1a36 <Port_Init+0xc8>
    19e2:	81 30       	cpi	r24, 0x01	; 1
    19e4:	38 f0       	brcs	.+14     	; 0x19f4 <Port_Init+0x86>
    19e6:	82 30       	cpi	r24, 0x02	; 2
    19e8:	09 f4       	brne	.+2      	; 0x19ec <Port_Init+0x7e>
    19ea:	46 c0       	rjmp	.+140    	; 0x1a78 <Port_Init+0x10a>
    19ec:	83 30       	cpi	r24, 0x03	; 3
    19ee:	09 f0       	breq	.+2      	; 0x19f2 <Port_Init+0x84>
    19f0:	82 c0       	rjmp	.+260    	; 0x1af6 <Port_Init+0x188>
    19f2:	61 c0       	rjmp	.+194    	; 0x1ab6 <Port_Init+0x148>
		{
		case Dio_PORTA:
			if((pins_cfg[i].Direction) == STD_OUT)
    19f4:	82 81       	ldd	r24, Z+2	; 0x02
    19f6:	81 30       	cpi	r24, 0x01	; 1
    19f8:	61 f4       	brne	.+24     	; 0x1a12 <Port_Init+0xa4>
			{
				SET_BIT(_DDRA, pins_cfg[i].Pin);
    19fa:	d8 01       	movw	r26, r16
    19fc:	2c 91       	ld	r18, X
    19fe:	cb 01       	movw	r24, r22
    1a00:	01 80       	ldd	r0, Z+1	; 0x01
    1a02:	02 c0       	rjmp	.+4      	; 0x1a08 <Port_Init+0x9a>
    1a04:	88 0f       	add	r24, r24
    1a06:	99 1f       	adc	r25, r25
    1a08:	0a 94       	dec	r0
    1a0a:	e2 f7       	brpl	.-8      	; 0x1a04 <Port_Init+0x96>
    1a0c:	28 2b       	or	r18, r24
    1a0e:	2c 93       	st	X, r18
    1a10:	72 c0       	rjmp	.+228    	; 0x1af6 <Port_Init+0x188>
			}
			else
			{
				CLR_BIT(_DDRA, pins_cfg[i].Pin);
    1a12:	d8 01       	movw	r26, r16
    1a14:	3c 91       	ld	r19, X
    1a16:	cb 01       	movw	r24, r22
    1a18:	01 80       	ldd	r0, Z+1	; 0x01
    1a1a:	02 c0       	rjmp	.+4      	; 0x1a20 <Port_Init+0xb2>
    1a1c:	88 0f       	add	r24, r24
    1a1e:	99 1f       	adc	r25, r25
    1a20:	0a 94       	dec	r0
    1a22:	e2 f7       	brpl	.-8      	; 0x1a1c <Port_Init+0xae>
    1a24:	28 2f       	mov	r18, r24
    1a26:	20 95       	com	r18
    1a28:	23 23       	and	r18, r19
    1a2a:	2c 93       	st	X, r18
				SET_BIT(_PORTA, pins_cfg[i].Pin);
    1a2c:	d3 01       	movw	r26, r6
    1a2e:	2c 91       	ld	r18, X
    1a30:	82 2b       	or	r24, r18
    1a32:	8c 93       	st	X, r24
    1a34:	60 c0       	rjmp	.+192    	; 0x1af6 <Port_Init+0x188>
			}
			break;
		case Dio_PORTB:
			if((pins_cfg[i].Direction) == STD_OUT)
    1a36:	82 81       	ldd	r24, Z+2	; 0x02
    1a38:	81 30       	cpi	r24, 0x01	; 1
    1a3a:	61 f4       	brne	.+24     	; 0x1a54 <Port_Init+0xe6>
			{
				SET_BIT(_DDRB, pins_cfg[i].Pin);
    1a3c:	d7 01       	movw	r26, r14
    1a3e:	2c 91       	ld	r18, X
    1a40:	cb 01       	movw	r24, r22
    1a42:	01 80       	ldd	r0, Z+1	; 0x01
    1a44:	02 c0       	rjmp	.+4      	; 0x1a4a <Port_Init+0xdc>
    1a46:	88 0f       	add	r24, r24
    1a48:	99 1f       	adc	r25, r25
    1a4a:	0a 94       	dec	r0
    1a4c:	e2 f7       	brpl	.-8      	; 0x1a46 <Port_Init+0xd8>
    1a4e:	28 2b       	or	r18, r24
    1a50:	2c 93       	st	X, r18
    1a52:	51 c0       	rjmp	.+162    	; 0x1af6 <Port_Init+0x188>
			}
			else
			{
				CLR_BIT(_DDRB, pins_cfg[i].Pin);
    1a54:	d7 01       	movw	r26, r14
    1a56:	3c 91       	ld	r19, X
    1a58:	cb 01       	movw	r24, r22
    1a5a:	01 80       	ldd	r0, Z+1	; 0x01
    1a5c:	02 c0       	rjmp	.+4      	; 0x1a62 <Port_Init+0xf4>
    1a5e:	88 0f       	add	r24, r24
    1a60:	99 1f       	adc	r25, r25
    1a62:	0a 94       	dec	r0
    1a64:	e2 f7       	brpl	.-8      	; 0x1a5e <Port_Init+0xf0>
    1a66:	28 2f       	mov	r18, r24
    1a68:	20 95       	com	r18
    1a6a:	23 23       	and	r18, r19
    1a6c:	2c 93       	st	X, r18
				SET_BIT(_PORTB, pins_cfg[i].Pin);
    1a6e:	d4 01       	movw	r26, r8
    1a70:	2c 91       	ld	r18, X
    1a72:	82 2b       	or	r24, r18
    1a74:	8c 93       	st	X, r24
    1a76:	3f c0       	rjmp	.+126    	; 0x1af6 <Port_Init+0x188>
			}
			break;
		case Dio_PORTC:
			if((pins_cfg[i].Direction) == STD_OUT)
    1a78:	82 81       	ldd	r24, Z+2	; 0x02
    1a7a:	81 30       	cpi	r24, 0x01	; 1
    1a7c:	59 f4       	brne	.+22     	; 0x1a94 <Port_Init+0x126>
			{
				SET_BIT(_DDRC, pins_cfg[i].Pin);
    1a7e:	28 81       	ld	r18, Y
    1a80:	cb 01       	movw	r24, r22
    1a82:	01 80       	ldd	r0, Z+1	; 0x01
    1a84:	02 c0       	rjmp	.+4      	; 0x1a8a <Port_Init+0x11c>
    1a86:	88 0f       	add	r24, r24
    1a88:	99 1f       	adc	r25, r25
    1a8a:	0a 94       	dec	r0
    1a8c:	e2 f7       	brpl	.-8      	; 0x1a86 <Port_Init+0x118>
    1a8e:	28 2b       	or	r18, r24
    1a90:	28 83       	st	Y, r18
    1a92:	31 c0       	rjmp	.+98     	; 0x1af6 <Port_Init+0x188>
			}
			else
			{
				CLR_BIT(_DDRC, pins_cfg[i].Pin);
    1a94:	38 81       	ld	r19, Y
    1a96:	cb 01       	movw	r24, r22
    1a98:	01 80       	ldd	r0, Z+1	; 0x01
    1a9a:	02 c0       	rjmp	.+4      	; 0x1aa0 <Port_Init+0x132>
    1a9c:	88 0f       	add	r24, r24
    1a9e:	99 1f       	adc	r25, r25
    1aa0:	0a 94       	dec	r0
    1aa2:	e2 f7       	brpl	.-8      	; 0x1a9c <Port_Init+0x12e>
    1aa4:	28 2f       	mov	r18, r24
    1aa6:	20 95       	com	r18
    1aa8:	23 23       	and	r18, r19
    1aaa:	28 83       	st	Y, r18
				SET_BIT(_PORTC, pins_cfg[i].Pin);
    1aac:	d5 01       	movw	r26, r10
    1aae:	2c 91       	ld	r18, X
    1ab0:	82 2b       	or	r24, r18
    1ab2:	8c 93       	st	X, r24
    1ab4:	20 c0       	rjmp	.+64     	; 0x1af6 <Port_Init+0x188>
			}
			break;
		case Dio_PORTD:
			if((pins_cfg[i].Direction) == STD_OUT)
    1ab6:	82 81       	ldd	r24, Z+2	; 0x02
    1ab8:	81 30       	cpi	r24, 0x01	; 1
    1aba:	61 f4       	brne	.+24     	; 0x1ad4 <Port_Init+0x166>
			{
				SET_BIT(_DDRD, pins_cfg[i].Pin);
    1abc:	d2 01       	movw	r26, r4
    1abe:	2c 91       	ld	r18, X
    1ac0:	cb 01       	movw	r24, r22
    1ac2:	01 80       	ldd	r0, Z+1	; 0x01
    1ac4:	02 c0       	rjmp	.+4      	; 0x1aca <Port_Init+0x15c>
    1ac6:	88 0f       	add	r24, r24
    1ac8:	99 1f       	adc	r25, r25
    1aca:	0a 94       	dec	r0
    1acc:	e2 f7       	brpl	.-8      	; 0x1ac6 <Port_Init+0x158>
    1ace:	28 2b       	or	r18, r24
    1ad0:	2c 93       	st	X, r18
    1ad2:	11 c0       	rjmp	.+34     	; 0x1af6 <Port_Init+0x188>
			}
			else
			{
				CLR_BIT(_DDRD, pins_cfg[i].Pin);
    1ad4:	d2 01       	movw	r26, r4
    1ad6:	3c 91       	ld	r19, X
    1ad8:	cb 01       	movw	r24, r22
    1ada:	01 80       	ldd	r0, Z+1	; 0x01
    1adc:	02 c0       	rjmp	.+4      	; 0x1ae2 <Port_Init+0x174>
    1ade:	88 0f       	add	r24, r24
    1ae0:	99 1f       	adc	r25, r25
    1ae2:	0a 94       	dec	r0
    1ae4:	e2 f7       	brpl	.-8      	; 0x1ade <Port_Init+0x170>
    1ae6:	28 2f       	mov	r18, r24
    1ae8:	20 95       	com	r18
    1aea:	23 23       	and	r18, r19
    1aec:	2c 93       	st	X, r18
				SET_BIT(_PORTD, pins_cfg[i].Pin);
    1aee:	d6 01       	movw	r26, r12
    1af0:	2c 91       	ld	r18, X
    1af2:	82 2b       	or	r24, r18
    1af4:	8c 93       	st	X, r24
 * @param	1- Pin_ConfigType *pins_cfg 	-> which is a pointer to a structure of data type "Pin_ConfigType"
 * @return	void
 */
void Port_Init (Pin_ConfigType *pins_cfg)
{
	for(int i = 0 ; i < 32 ; i ++)
    1af6:	4f 5f       	subi	r20, 0xFF	; 255
    1af8:	5f 4f       	sbci	r21, 0xFF	; 255
    1afa:	33 96       	adiw	r30, 0x03	; 3
    1afc:	40 32       	cpi	r20, 0x20	; 32
    1afe:	51 05       	cpc	r21, r1
    1b00:	09 f0       	breq	.+2      	; 0x1b04 <Port_Init+0x196>
    1b02:	6c cf       	rjmp	.-296    	; 0x19dc <Port_Init+0x6e>
			}
			break;
		default: break;
		}
	}
}
    1b04:	df 91       	pop	r29
    1b06:	cf 91       	pop	r28
    1b08:	1f 91       	pop	r17
    1b0a:	0f 91       	pop	r16
    1b0c:	ff 90       	pop	r15
    1b0e:	ef 90       	pop	r14
    1b10:	df 90       	pop	r13
    1b12:	cf 90       	pop	r12
    1b14:	bf 90       	pop	r11
    1b16:	af 90       	pop	r10
    1b18:	9f 90       	pop	r9
    1b1a:	8f 90       	pop	r8
    1b1c:	7f 90       	pop	r7
    1b1e:	6f 90       	pop	r6
    1b20:	5f 90       	pop	r5
    1b22:	4f 90       	pop	r4
    1b24:	08 95       	ret

00001b26 <Port_SetPinDirection>:
 * @param	1- Pin 			-> to choose the PIN to set its Direction  EX: (PA_2)
 * 			2- Direction 	-> to choose the Direction to the PIN  	Ex : (1 for HIGH or 0 for LOW)
 * @return	void
 */
void Port_SetPinDirection (Dio_ChannelType Pin,Dio_DirectionType Direction)
{
    1b26:	48 2f       	mov	r20, r24
	switch(Pin/8)
    1b28:	86 95       	lsr	r24
    1b2a:	86 95       	lsr	r24
    1b2c:	86 95       	lsr	r24
    1b2e:	81 30       	cpi	r24, 0x01	; 1
    1b30:	31 f1       	breq	.+76     	; 0x1b7e <Port_SetPinDirection+0x58>
    1b32:	81 30       	cpi	r24, 0x01	; 1
    1b34:	38 f0       	brcs	.+14     	; 0x1b44 <Port_SetPinDirection+0x1e>
    1b36:	82 30       	cpi	r24, 0x02	; 2
    1b38:	09 f4       	brne	.+2      	; 0x1b3c <Port_SetPinDirection+0x16>
    1b3a:	42 c0       	rjmp	.+132    	; 0x1bc0 <Port_SetPinDirection+0x9a>
    1b3c:	83 30       	cpi	r24, 0x03	; 3
    1b3e:	09 f0       	breq	.+2      	; 0x1b42 <Port_SetPinDirection+0x1c>
    1b40:	80 c0       	rjmp	.+256    	; 0x1c42 <Port_SetPinDirection+0x11c>
    1b42:	5f c0       	rjmp	.+190    	; 0x1c02 <Port_SetPinDirection+0xdc>
	{
	case Dio_PORTA:
		if(Direction == STD_OUT)
    1b44:	61 30       	cpi	r22, 0x01	; 1
    1b46:	69 f4       	brne	.+26     	; 0x1b62 <Port_SetPinDirection+0x3c>
			SET_BIT(_DDRA, Pin);
    1b48:	ea e3       	ldi	r30, 0x3A	; 58
    1b4a:	f0 e0       	ldi	r31, 0x00	; 0
    1b4c:	20 81       	ld	r18, Z
    1b4e:	81 e0       	ldi	r24, 0x01	; 1
    1b50:	90 e0       	ldi	r25, 0x00	; 0
    1b52:	02 c0       	rjmp	.+4      	; 0x1b58 <Port_SetPinDirection+0x32>
    1b54:	88 0f       	add	r24, r24
    1b56:	99 1f       	adc	r25, r25
    1b58:	4a 95       	dec	r20
    1b5a:	e2 f7       	brpl	.-8      	; 0x1b54 <Port_SetPinDirection+0x2e>
    1b5c:	28 2b       	or	r18, r24
    1b5e:	20 83       	st	Z, r18
    1b60:	08 95       	ret
		else
			CLR_BIT(_DDRA, Pin);
    1b62:	ea e3       	ldi	r30, 0x3A	; 58
    1b64:	f0 e0       	ldi	r31, 0x00	; 0
    1b66:	20 81       	ld	r18, Z
    1b68:	81 e0       	ldi	r24, 0x01	; 1
    1b6a:	90 e0       	ldi	r25, 0x00	; 0
    1b6c:	02 c0       	rjmp	.+4      	; 0x1b72 <Port_SetPinDirection+0x4c>
    1b6e:	88 0f       	add	r24, r24
    1b70:	99 1f       	adc	r25, r25
    1b72:	4a 95       	dec	r20
    1b74:	e2 f7       	brpl	.-8      	; 0x1b6e <Port_SetPinDirection+0x48>
    1b76:	80 95       	com	r24
    1b78:	82 23       	and	r24, r18
    1b7a:	80 83       	st	Z, r24
    1b7c:	08 95       	ret
		break;
	case Dio_PORTB:
		if(Direction == STD_OUT)
    1b7e:	61 30       	cpi	r22, 0x01	; 1
    1b80:	79 f4       	brne	.+30     	; 0x1ba0 <Port_SetPinDirection+0x7a>
			SET_BIT(_DDRB, Pin % 8);
    1b82:	e7 e3       	ldi	r30, 0x37	; 55
    1b84:	f0 e0       	ldi	r31, 0x00	; 0
    1b86:	20 81       	ld	r18, Z
    1b88:	34 2f       	mov	r19, r20
    1b8a:	37 70       	andi	r19, 0x07	; 7
    1b8c:	81 e0       	ldi	r24, 0x01	; 1
    1b8e:	90 e0       	ldi	r25, 0x00	; 0
    1b90:	02 c0       	rjmp	.+4      	; 0x1b96 <Port_SetPinDirection+0x70>
    1b92:	88 0f       	add	r24, r24
    1b94:	99 1f       	adc	r25, r25
    1b96:	3a 95       	dec	r19
    1b98:	e2 f7       	brpl	.-8      	; 0x1b92 <Port_SetPinDirection+0x6c>
    1b9a:	28 2b       	or	r18, r24
    1b9c:	20 83       	st	Z, r18
    1b9e:	08 95       	ret
		else
			CLR_BIT(_DDRB, Pin % 8);
    1ba0:	e7 e3       	ldi	r30, 0x37	; 55
    1ba2:	f0 e0       	ldi	r31, 0x00	; 0
    1ba4:	30 81       	ld	r19, Z
    1ba6:	24 2f       	mov	r18, r20
    1ba8:	27 70       	andi	r18, 0x07	; 7
    1baa:	81 e0       	ldi	r24, 0x01	; 1
    1bac:	90 e0       	ldi	r25, 0x00	; 0
    1bae:	02 c0       	rjmp	.+4      	; 0x1bb4 <Port_SetPinDirection+0x8e>
    1bb0:	88 0f       	add	r24, r24
    1bb2:	99 1f       	adc	r25, r25
    1bb4:	2a 95       	dec	r18
    1bb6:	e2 f7       	brpl	.-8      	; 0x1bb0 <Port_SetPinDirection+0x8a>
    1bb8:	80 95       	com	r24
    1bba:	83 23       	and	r24, r19
    1bbc:	80 83       	st	Z, r24
    1bbe:	08 95       	ret
		break;
	case Dio_PORTC:
		if(Direction == STD_OUT)
    1bc0:	61 30       	cpi	r22, 0x01	; 1
    1bc2:	79 f4       	brne	.+30     	; 0x1be2 <Port_SetPinDirection+0xbc>
			SET_BIT(_DDRC, Pin % 8);
    1bc4:	e4 e3       	ldi	r30, 0x34	; 52
    1bc6:	f0 e0       	ldi	r31, 0x00	; 0
    1bc8:	20 81       	ld	r18, Z
    1bca:	34 2f       	mov	r19, r20
    1bcc:	37 70       	andi	r19, 0x07	; 7
    1bce:	81 e0       	ldi	r24, 0x01	; 1
    1bd0:	90 e0       	ldi	r25, 0x00	; 0
    1bd2:	02 c0       	rjmp	.+4      	; 0x1bd8 <Port_SetPinDirection+0xb2>
    1bd4:	88 0f       	add	r24, r24
    1bd6:	99 1f       	adc	r25, r25
    1bd8:	3a 95       	dec	r19
    1bda:	e2 f7       	brpl	.-8      	; 0x1bd4 <Port_SetPinDirection+0xae>
    1bdc:	28 2b       	or	r18, r24
    1bde:	20 83       	st	Z, r18
    1be0:	08 95       	ret
		else
			CLR_BIT(_DDRC, Pin % 8);
    1be2:	e4 e3       	ldi	r30, 0x34	; 52
    1be4:	f0 e0       	ldi	r31, 0x00	; 0
    1be6:	30 81       	ld	r19, Z
    1be8:	24 2f       	mov	r18, r20
    1bea:	27 70       	andi	r18, 0x07	; 7
    1bec:	81 e0       	ldi	r24, 0x01	; 1
    1bee:	90 e0       	ldi	r25, 0x00	; 0
    1bf0:	02 c0       	rjmp	.+4      	; 0x1bf6 <Port_SetPinDirection+0xd0>
    1bf2:	88 0f       	add	r24, r24
    1bf4:	99 1f       	adc	r25, r25
    1bf6:	2a 95       	dec	r18
    1bf8:	e2 f7       	brpl	.-8      	; 0x1bf2 <Port_SetPinDirection+0xcc>
    1bfa:	80 95       	com	r24
    1bfc:	83 23       	and	r24, r19
    1bfe:	80 83       	st	Z, r24
    1c00:	08 95       	ret
		break;
	case Dio_PORTD:
		if(Direction == STD_OUT)
    1c02:	61 30       	cpi	r22, 0x01	; 1
    1c04:	79 f4       	brne	.+30     	; 0x1c24 <Port_SetPinDirection+0xfe>
			SET_BIT(_DDRD, Pin % 8);
    1c06:	e1 e3       	ldi	r30, 0x31	; 49
    1c08:	f0 e0       	ldi	r31, 0x00	; 0
    1c0a:	20 81       	ld	r18, Z
    1c0c:	34 2f       	mov	r19, r20
    1c0e:	37 70       	andi	r19, 0x07	; 7
    1c10:	81 e0       	ldi	r24, 0x01	; 1
    1c12:	90 e0       	ldi	r25, 0x00	; 0
    1c14:	02 c0       	rjmp	.+4      	; 0x1c1a <Port_SetPinDirection+0xf4>
    1c16:	88 0f       	add	r24, r24
    1c18:	99 1f       	adc	r25, r25
    1c1a:	3a 95       	dec	r19
    1c1c:	e2 f7       	brpl	.-8      	; 0x1c16 <Port_SetPinDirection+0xf0>
    1c1e:	28 2b       	or	r18, r24
    1c20:	20 83       	st	Z, r18
    1c22:	08 95       	ret
		else
			CLR_BIT(_DDRD, Pin % 8);
    1c24:	e1 e3       	ldi	r30, 0x31	; 49
    1c26:	f0 e0       	ldi	r31, 0x00	; 0
    1c28:	30 81       	ld	r19, Z
    1c2a:	24 2f       	mov	r18, r20
    1c2c:	27 70       	andi	r18, 0x07	; 7
    1c2e:	81 e0       	ldi	r24, 0x01	; 1
    1c30:	90 e0       	ldi	r25, 0x00	; 0
    1c32:	02 c0       	rjmp	.+4      	; 0x1c38 <Port_SetPinDirection+0x112>
    1c34:	88 0f       	add	r24, r24
    1c36:	99 1f       	adc	r25, r25
    1c38:	2a 95       	dec	r18
    1c3a:	e2 f7       	brpl	.-8      	; 0x1c34 <Port_SetPinDirection+0x10e>
    1c3c:	80 95       	com	r24
    1c3e:	83 23       	and	r24, r19
    1c40:	80 83       	st	Z, r24
    1c42:	08 95       	ret

00001c44 <ICU_voidInit>:
/* ----------------- Section : Software Interfaces Implementation -----------------*/

void ICU_voidInit(void)
{
	// Timer 1 mode --> Normal
	CLR_BIT(_TCCR1A, _WGM10);
    1c44:	ef e4       	ldi	r30, 0x4F	; 79
    1c46:	f0 e0       	ldi	r31, 0x00	; 0
    1c48:	80 81       	ld	r24, Z
    1c4a:	8e 7f       	andi	r24, 0xFE	; 254
    1c4c:	80 83       	st	Z, r24
	CLR_BIT(_TCCR1A, _WGM11);
    1c4e:	80 81       	ld	r24, Z
    1c50:	8d 7f       	andi	r24, 0xFD	; 253
    1c52:	80 83       	st	Z, r24
	CLR_BIT(_TCCR1B, _WGM12);
    1c54:	ee e4       	ldi	r30, 0x4E	; 78
    1c56:	f0 e0       	ldi	r31, 0x00	; 0
    1c58:	80 81       	ld	r24, Z
    1c5a:	87 7f       	andi	r24, 0xF7	; 247
    1c5c:	80 83       	st	Z, r24
	CLR_BIT(_TCCR1B, _WGM13);
    1c5e:	80 81       	ld	r24, Z
    1c60:	8f 7e       	andi	r24, 0xEF	; 239
    1c62:	80 83       	st	Z, r24
#if ICU_Starting_Edge == FAIILING
	// Edge select --> Falling
	CLR_BIT(_TCCR1B, _ICES1);
#elif ICU_Starting_Edge == RISING
	SET_BIT(_TCCR1B, _ICES1);
    1c64:	80 81       	ld	r24, Z
    1c66:	80 64       	ori	r24, 0x40	; 64
    1c68:	80 83       	st	Z, r24
#endif
	// ICU Interrupt Enable
	SET_BIT(_TIMSK, _TICIE1);
    1c6a:	a9 e5       	ldi	r26, 0x59	; 89
    1c6c:	b0 e0       	ldi	r27, 0x00	; 0
    1c6e:	8c 91       	ld	r24, X
    1c70:	80 62       	ori	r24, 0x20	; 32
    1c72:	8c 93       	st	X, r24

	// Start Timer  --> for 64 prescaler
	SET_BIT(_TCCR1B, _CS10);
    1c74:	80 81       	ld	r24, Z
    1c76:	81 60       	ori	r24, 0x01	; 1
    1c78:	80 83       	st	Z, r24
	SET_BIT(_TCCR1B, _CS11);
    1c7a:	80 81       	ld	r24, Z
    1c7c:	82 60       	ori	r24, 0x02	; 2
    1c7e:	80 83       	st	Z, r24
	CLR_BIT(_TCCR1B, _CS12);
    1c80:	80 81       	ld	r24, Z
    1c82:	8b 7f       	andi	r24, 0xFB	; 251
    1c84:	80 83       	st	Z, r24

}
    1c86:	08 95       	ret

00001c88 <ICU_voidGetDutyCycle>:

void ICU_voidGetDutyCycle(u8 * copy_u8_duty)
{
    1c88:	cf 92       	push	r12
    1c8a:	df 92       	push	r13
    1c8c:	ef 92       	push	r14
    1c8e:	ff 92       	push	r15
    1c90:	0f 93       	push	r16
    1c92:	1f 93       	push	r17
    1c94:	cf 93       	push	r28
    1c96:	df 93       	push	r29
    1c98:	ec 01       	movw	r28, r24
	if(copy_u8_duty != NULL)
    1c9a:	00 97       	sbiw	r24, 0x00	; 0
    1c9c:	e9 f0       	breq	.+58     	; 0x1cd8 <ICU_voidGetDutyCycle+0x50>
	{
		*copy_u8_duty = ((u32) private_u16_On_Period * 100 ) / (private_u16_On_Period + private_u16_Off_Period);
    1c9e:	60 91 ca 01 	lds	r22, 0x01CA
    1ca2:	70 91 cb 01 	lds	r23, 0x01CB
    1ca6:	c0 90 ca 01 	lds	r12, 0x01CA
    1caa:	d0 90 cb 01 	lds	r13, 0x01CB
    1cae:	e0 90 cc 01 	lds	r14, 0x01CC
    1cb2:	f0 90 cd 01 	lds	r15, 0x01CD
    1cb6:	80 e0       	ldi	r24, 0x00	; 0
    1cb8:	90 e0       	ldi	r25, 0x00	; 0
    1cba:	24 e6       	ldi	r18, 0x64	; 100
    1cbc:	30 e0       	ldi	r19, 0x00	; 0
    1cbe:	40 e0       	ldi	r20, 0x00	; 0
    1cc0:	50 e0       	ldi	r21, 0x00	; 0
    1cc2:	0e 94 33 31 	call	0x6266	; 0x6266 <__mulsi3>
    1cc6:	ec 0c       	add	r14, r12
    1cc8:	fd 1c       	adc	r15, r13
    1cca:	00 e0       	ldi	r16, 0x00	; 0
    1ccc:	10 e0       	ldi	r17, 0x00	; 0
    1cce:	a8 01       	movw	r20, r16
    1cd0:	97 01       	movw	r18, r14
    1cd2:	0e 94 66 31 	call	0x62cc	; 0x62cc <__udivmodsi4>
    1cd6:	28 83       	st	Y, r18
	}
}
    1cd8:	df 91       	pop	r29
    1cda:	cf 91       	pop	r28
    1cdc:	1f 91       	pop	r17
    1cde:	0f 91       	pop	r16
    1ce0:	ff 90       	pop	r15
    1ce2:	ef 90       	pop	r14
    1ce4:	df 90       	pop	r13
    1ce6:	cf 90       	pop	r12
    1ce8:	08 95       	ret

00001cea <ICU_voidGetFrequency>:

void ICU_voidGetFrequency(u32 * copy_u32_freq_HZ)
{
    1cea:	cf 93       	push	r28
    1cec:	df 93       	push	r29
    1cee:	ec 01       	movw	r28, r24
	if(copy_u32_freq_HZ != NULL)
    1cf0:	00 97       	sbiw	r24, 0x00	; 0
    1cf2:	b1 f0       	breq	.+44     	; 0x1d20 <ICU_voidGetFrequency+0x36>
	{
		*copy_u32_freq_HZ = 1000000UL / (private_u16_On_Period + private_u16_Off_Period);		// 1 S = 1000000 us
    1cf4:	80 91 ca 01 	lds	r24, 0x01CA
    1cf8:	90 91 cb 01 	lds	r25, 0x01CB
    1cfc:	20 91 cc 01 	lds	r18, 0x01CC
    1d00:	30 91 cd 01 	lds	r19, 0x01CD
    1d04:	28 0f       	add	r18, r24
    1d06:	39 1f       	adc	r19, r25
    1d08:	40 e0       	ldi	r20, 0x00	; 0
    1d0a:	50 e0       	ldi	r21, 0x00	; 0
    1d0c:	60 e4       	ldi	r22, 0x40	; 64
    1d0e:	72 e4       	ldi	r23, 0x42	; 66
    1d10:	8f e0       	ldi	r24, 0x0F	; 15
    1d12:	90 e0       	ldi	r25, 0x00	; 0
    1d14:	0e 94 66 31 	call	0x62cc	; 0x62cc <__udivmodsi4>
    1d18:	28 83       	st	Y, r18
    1d1a:	39 83       	std	Y+1, r19	; 0x01
    1d1c:	4a 83       	std	Y+2, r20	; 0x02
    1d1e:	5b 83       	std	Y+3, r21	; 0x03
	}
}
    1d20:	df 91       	pop	r29
    1d22:	cf 91       	pop	r28
    1d24:	08 95       	ret

00001d26 <ICU_u32GetFallingEdgeTime>:

u32 ICU_u32GetFallingEdgeTime(void)
{
    // Assuming the time is in microseconds
    return (u32)private_u16_On_Period;
    1d26:	20 91 ca 01 	lds	r18, 0x01CA
    1d2a:	30 91 cb 01 	lds	r19, 0x01CB
    1d2e:	40 e0       	ldi	r20, 0x00	; 0
    1d30:	50 e0       	ldi	r21, 0x00	; 0
}
    1d32:	62 2f       	mov	r22, r18
    1d34:	73 2f       	mov	r23, r19
    1d36:	84 2f       	mov	r24, r20
    1d38:	95 2f       	mov	r25, r21
    1d3a:	08 95       	ret

00001d3c <__vector_6>:

//ICU ISR
void __vector_6(void) __attribute__((signal));

void __vector_6(void)
{
    1d3c:	1f 92       	push	r1
    1d3e:	0f 92       	push	r0
    1d40:	0f b6       	in	r0, 0x3f	; 63
    1d42:	0f 92       	push	r0
    1d44:	11 24       	eor	r1, r1
    1d46:	2f 93       	push	r18
    1d48:	3f 93       	push	r19
    1d4a:	4f 93       	push	r20
    1d4c:	5f 93       	push	r21
    1d4e:	8f 93       	push	r24
    1d50:	9f 93       	push	r25
    1d52:	ef 93       	push	r30
    1d54:	ff 93       	push	r31
	static u8 local_edge_falg = ICU_Starting_Edge;
	static u16 local_u16_OldValue = 0 ;
	static u16 local_u16_CounterValue = 0 ;

	local_u16_CounterValue = _ICR1;
    1d56:	26 b5       	in	r18, 0x26	; 38
    1d58:	37 b5       	in	r19, 0x27	; 39
    1d5a:	30 93 c7 01 	sts	0x01C7, r19
    1d5e:	20 93 c6 01 	sts	0x01C6, r18

	if(local_edge_falg == RISING)
    1d62:	80 91 76 01 	lds	r24, 0x0176
    1d66:	81 30       	cpi	r24, 0x01	; 1
    1d68:	c9 f4       	brne	.+50     	; 0x1d9c <__vector_6+0x60>
	{
		private_u16_Off_Period = (local_u16_CounterValue - local_u16_OldValue) * 4;   // 4 : tick time for 64 prescaler
    1d6a:	80 91 c8 01 	lds	r24, 0x01C8
    1d6e:	90 91 c9 01 	lds	r25, 0x01C9
    1d72:	a9 01       	movw	r20, r18
    1d74:	48 1b       	sub	r20, r24
    1d76:	59 0b       	sbc	r21, r25
    1d78:	ca 01       	movw	r24, r20
    1d7a:	88 0f       	add	r24, r24
    1d7c:	99 1f       	adc	r25, r25
    1d7e:	88 0f       	add	r24, r24
    1d80:	99 1f       	adc	r25, r25
    1d82:	90 93 cd 01 	sts	0x01CD, r25
    1d86:	80 93 cc 01 	sts	0x01CC, r24
		CLR_BIT(_TCCR1B, _ICES1);
    1d8a:	ee e4       	ldi	r30, 0x4E	; 78
    1d8c:	f0 e0       	ldi	r31, 0x00	; 0
    1d8e:	80 81       	ld	r24, Z
    1d90:	8f 7b       	andi	r24, 0xBF	; 191
    1d92:	80 83       	st	Z, r24
		local_edge_falg = FALLING;
    1d94:	82 e0       	ldi	r24, 0x02	; 2
    1d96:	80 93 76 01 	sts	0x0176, r24
    1d9a:	1a c0       	rjmp	.+52     	; 0x1dd0 <__vector_6+0x94>
	}
	else if(local_edge_falg == FALLING)
    1d9c:	82 30       	cpi	r24, 0x02	; 2
    1d9e:	c1 f4       	brne	.+48     	; 0x1dd0 <__vector_6+0x94>
	{
		private_u16_On_Period = (local_u16_CounterValue - local_u16_OldValue) * 4;   // 4 : tick time for 64 prescaler
    1da0:	80 91 c8 01 	lds	r24, 0x01C8
    1da4:	90 91 c9 01 	lds	r25, 0x01C9
    1da8:	a9 01       	movw	r20, r18
    1daa:	48 1b       	sub	r20, r24
    1dac:	59 0b       	sbc	r21, r25
    1dae:	ca 01       	movw	r24, r20
    1db0:	88 0f       	add	r24, r24
    1db2:	99 1f       	adc	r25, r25
    1db4:	88 0f       	add	r24, r24
    1db6:	99 1f       	adc	r25, r25
    1db8:	90 93 cb 01 	sts	0x01CB, r25
    1dbc:	80 93 ca 01 	sts	0x01CA, r24
		SET_BIT(_TCCR1B, _ICES1);
    1dc0:	ee e4       	ldi	r30, 0x4E	; 78
    1dc2:	f0 e0       	ldi	r31, 0x00	; 0
    1dc4:	80 81       	ld	r24, Z
    1dc6:	80 64       	ori	r24, 0x40	; 64
    1dc8:	80 83       	st	Z, r24
		local_edge_falg = RISING;
    1dca:	81 e0       	ldi	r24, 0x01	; 1
    1dcc:	80 93 76 01 	sts	0x0176, r24
	}
	local_u16_OldValue = _ICR1;
    1dd0:	86 b5       	in	r24, 0x26	; 38
    1dd2:	97 b5       	in	r25, 0x27	; 39
    1dd4:	90 93 c9 01 	sts	0x01C9, r25
    1dd8:	80 93 c8 01 	sts	0x01C8, r24
}
    1ddc:	ff 91       	pop	r31
    1dde:	ef 91       	pop	r30
    1de0:	9f 91       	pop	r25
    1de2:	8f 91       	pop	r24
    1de4:	5f 91       	pop	r21
    1de6:	4f 91       	pop	r20
    1de8:	3f 91       	pop	r19
    1dea:	2f 91       	pop	r18
    1dec:	0f 90       	pop	r0
    1dee:	0f be       	out	0x3f, r0	; 63
    1df0:	0f 90       	pop	r0
    1df2:	1f 90       	pop	r1
    1df4:	18 95       	reti

00001df6 <GI_voidEnable>:
 * @param	void
 * @return	void
 */
void GI_voidEnable(void)
{
	SET_BIT(_SREG, GLE);
    1df6:	ef e5       	ldi	r30, 0x5F	; 95
    1df8:	f0 e0       	ldi	r31, 0x00	; 0
    1dfa:	80 81       	ld	r24, Z
    1dfc:	80 68       	ori	r24, 0x80	; 128
    1dfe:	80 83       	st	Z, r24
}
    1e00:	08 95       	ret

00001e02 <GI_voidDisable>:
 * @param	void
 * @return	void
 */
void GI_voidDisable(void)
{
	CLR_BIT(_SREG, GLE);
    1e02:	ef e5       	ldi	r30, 0x5F	; 95
    1e04:	f0 e0       	ldi	r31, 0x00	; 0
    1e06:	80 81       	ld	r24, Z
    1e08:	8f 77       	andi	r24, 0x7F	; 127
    1e0a:	80 83       	st	Z, r24
}
    1e0c:	08 95       	ret

00001e0e <EXTI_voidInit>:
 * 			2- copy_u8SenseControl		-> External interrupt Modes (RISING_EDGE, FALLING_EDGE, LOW_LEVEL or LOGICAL_CHANGE)
 * @return	void
 */
void EXTI_voidInit(u8 copy_u8InterruptSource, u8 copy_u8SenseControl)
{
	switch (copy_u8InterruptSource)
    1e0e:	81 30       	cpi	r24, 0x01	; 1
    1e10:	81 f1       	breq	.+96     	; 0x1e72 <EXTI_voidInit+0x64>
    1e12:	81 30       	cpi	r24, 0x01	; 1
    1e14:	20 f0       	brcs	.+8      	; 0x1e1e <EXTI_voidInit+0x10>
    1e16:	82 30       	cpi	r24, 0x02	; 2
    1e18:	09 f0       	breq	.+2      	; 0x1e1c <EXTI_voidInit+0xe>
    1e1a:	62 c0       	rjmp	.+196    	; 0x1ee0 <EXTI_voidInit+0xd2>
    1e1c:	54 c0       	rjmp	.+168    	; 0x1ec6 <EXTI_voidInit+0xb8>
	{
	case EXTI_INT0:
		switch (copy_u8SenseControl)
    1e1e:	62 30       	cpi	r22, 0x02	; 2
    1e20:	f9 f0       	breq	.+62     	; 0x1e60 <EXTI_voidInit+0x52>
    1e22:	63 30       	cpi	r22, 0x03	; 3
    1e24:	a1 f0       	breq	.+40     	; 0x1e4e <EXTI_voidInit+0x40>
    1e26:	61 30       	cpi	r22, 0x01	; 1
    1e28:	49 f0       	breq	.+18     	; 0x1e3c <EXTI_voidInit+0x2e>
		{
		default:
		case RISING_EDGE:
			SET_BIT(_MCUCR, ISC00);
    1e2a:	e5 e5       	ldi	r30, 0x55	; 85
    1e2c:	f0 e0       	ldi	r31, 0x00	; 0
    1e2e:	80 81       	ld	r24, Z
    1e30:	81 60       	ori	r24, 0x01	; 1
    1e32:	80 83       	st	Z, r24
			SET_BIT(_MCUCR, ISC01);
    1e34:	80 81       	ld	r24, Z
    1e36:	82 60       	ori	r24, 0x02	; 2
    1e38:	80 83       	st	Z, r24
    1e3a:	08 95       	ret
			break;
		case FALLING_EDGE:
			CLR_BIT(_MCUCR, ISC00);
    1e3c:	e5 e5       	ldi	r30, 0x55	; 85
    1e3e:	f0 e0       	ldi	r31, 0x00	; 0
    1e40:	80 81       	ld	r24, Z
    1e42:	8e 7f       	andi	r24, 0xFE	; 254
    1e44:	80 83       	st	Z, r24
			SET_BIT(_MCUCR, ISC01);
    1e46:	80 81       	ld	r24, Z
    1e48:	82 60       	ori	r24, 0x02	; 2
    1e4a:	80 83       	st	Z, r24
    1e4c:	08 95       	ret
			break;
		case LOGICAL_CHANGE:
			SET_BIT(_MCUCR, ISC00);
    1e4e:	e5 e5       	ldi	r30, 0x55	; 85
    1e50:	f0 e0       	ldi	r31, 0x00	; 0
    1e52:	80 81       	ld	r24, Z
    1e54:	81 60       	ori	r24, 0x01	; 1
    1e56:	80 83       	st	Z, r24
			CLR_BIT(_MCUCR, ISC01);
    1e58:	80 81       	ld	r24, Z
    1e5a:	8d 7f       	andi	r24, 0xFD	; 253
    1e5c:	80 83       	st	Z, r24
    1e5e:	08 95       	ret
			break;
		case LOW_LEVEL:
			CLR_BIT(_MCUCR, ISC00);
    1e60:	e5 e5       	ldi	r30, 0x55	; 85
    1e62:	f0 e0       	ldi	r31, 0x00	; 0
    1e64:	80 81       	ld	r24, Z
    1e66:	8e 7f       	andi	r24, 0xFE	; 254
    1e68:	80 83       	st	Z, r24
			CLR_BIT(_MCUCR, ISC01);
    1e6a:	80 81       	ld	r24, Z
    1e6c:	8d 7f       	andi	r24, 0xFD	; 253
    1e6e:	80 83       	st	Z, r24
    1e70:	08 95       	ret
			break;
		}
		break;

	case EXTI_INT1:
		switch (copy_u8SenseControl)
    1e72:	62 30       	cpi	r22, 0x02	; 2
    1e74:	f9 f0       	breq	.+62     	; 0x1eb4 <EXTI_voidInit+0xa6>
    1e76:	63 30       	cpi	r22, 0x03	; 3
    1e78:	a1 f0       	breq	.+40     	; 0x1ea2 <EXTI_voidInit+0x94>
    1e7a:	61 30       	cpi	r22, 0x01	; 1
    1e7c:	49 f0       	breq	.+18     	; 0x1e90 <EXTI_voidInit+0x82>
		{
		default:
		case RISING_EDGE:
			SET_BIT(_MCUCR, ISC10);
    1e7e:	e5 e5       	ldi	r30, 0x55	; 85
    1e80:	f0 e0       	ldi	r31, 0x00	; 0
    1e82:	80 81       	ld	r24, Z
    1e84:	84 60       	ori	r24, 0x04	; 4
    1e86:	80 83       	st	Z, r24
			SET_BIT(_MCUCR, ISC11);
    1e88:	80 81       	ld	r24, Z
    1e8a:	88 60       	ori	r24, 0x08	; 8
    1e8c:	80 83       	st	Z, r24
    1e8e:	08 95       	ret
			break;
		case FALLING_EDGE:
			CLR_BIT(_MCUCR, ISC10);
    1e90:	e5 e5       	ldi	r30, 0x55	; 85
    1e92:	f0 e0       	ldi	r31, 0x00	; 0
    1e94:	80 81       	ld	r24, Z
    1e96:	8b 7f       	andi	r24, 0xFB	; 251
    1e98:	80 83       	st	Z, r24
			SET_BIT(_MCUCR, ISC11);
    1e9a:	80 81       	ld	r24, Z
    1e9c:	88 60       	ori	r24, 0x08	; 8
    1e9e:	80 83       	st	Z, r24
    1ea0:	08 95       	ret
			break;
		case LOGICAL_CHANGE:
			SET_BIT(_MCUCR, ISC10);
    1ea2:	e5 e5       	ldi	r30, 0x55	; 85
    1ea4:	f0 e0       	ldi	r31, 0x00	; 0
    1ea6:	80 81       	ld	r24, Z
    1ea8:	84 60       	ori	r24, 0x04	; 4
    1eaa:	80 83       	st	Z, r24
			CLR_BIT(_MCUCR, ISC11);
    1eac:	80 81       	ld	r24, Z
    1eae:	87 7f       	andi	r24, 0xF7	; 247
    1eb0:	80 83       	st	Z, r24
    1eb2:	08 95       	ret
			break;
		case LOW_LEVEL:
			CLR_BIT(_MCUCR, ISC10);
    1eb4:	e5 e5       	ldi	r30, 0x55	; 85
    1eb6:	f0 e0       	ldi	r31, 0x00	; 0
    1eb8:	80 81       	ld	r24, Z
    1eba:	8b 7f       	andi	r24, 0xFB	; 251
    1ebc:	80 83       	st	Z, r24
			CLR_BIT(_MCUCR, ISC11);
    1ebe:	80 81       	ld	r24, Z
    1ec0:	87 7f       	andi	r24, 0xF7	; 247
    1ec2:	80 83       	st	Z, r24
    1ec4:	08 95       	ret
			break;
		}
		break;

	case EXTI_INT2:
		switch (copy_u8SenseControl)
    1ec6:	61 30       	cpi	r22, 0x01	; 1
    1ec8:	31 f0       	breq	.+12     	; 0x1ed6 <EXTI_voidInit+0xc8>
		{
		default:
		case RISING_EDGE:
			SET_BIT(_MCUCSR, ISC2);
    1eca:	e4 e5       	ldi	r30, 0x54	; 84
    1ecc:	f0 e0       	ldi	r31, 0x00	; 0
    1ece:	80 81       	ld	r24, Z
    1ed0:	80 64       	ori	r24, 0x40	; 64
    1ed2:	80 83       	st	Z, r24
    1ed4:	08 95       	ret
			break;
		case FALLING_EDGE:
			CLR_BIT(_MCUCSR, ISC2);
    1ed6:	e4 e5       	ldi	r30, 0x54	; 84
    1ed8:	f0 e0       	ldi	r31, 0x00	; 0
    1eda:	80 81       	ld	r24, Z
    1edc:	8f 7b       	andi	r24, 0xBF	; 191
    1ede:	80 83       	st	Z, r24
    1ee0:	08 95       	ret

00001ee2 <EXTI_voidEnable>:
 * @param	1- copy_u8InterruptSource 	-> External interrupt source (EXTI_INTx where x = (0, 1 or 2))
 * @return	void
 */
void EXTI_voidEnable(u8 copy_u8InterruptSource)
{
	switch (copy_u8InterruptSource)
    1ee2:	81 30       	cpi	r24, 0x01	; 1
    1ee4:	59 f0       	breq	.+22     	; 0x1efc <EXTI_voidEnable+0x1a>
    1ee6:	81 30       	cpi	r24, 0x01	; 1
    1ee8:	18 f0       	brcs	.+6      	; 0x1ef0 <EXTI_voidEnable+0xe>
    1eea:	82 30       	cpi	r24, 0x02	; 2
    1eec:	91 f4       	brne	.+36     	; 0x1f12 <EXTI_voidEnable+0x30>
    1eee:	0c c0       	rjmp	.+24     	; 0x1f08 <EXTI_voidEnable+0x26>
	{
	case EXTI_INT0:
		SET_BIT(_GICR, INT0);
    1ef0:	eb e5       	ldi	r30, 0x5B	; 91
    1ef2:	f0 e0       	ldi	r31, 0x00	; 0
    1ef4:	80 81       	ld	r24, Z
    1ef6:	80 64       	ori	r24, 0x40	; 64
    1ef8:	80 83       	st	Z, r24
    1efa:	08 95       	ret
		break;
	case EXTI_INT1:
		SET_BIT(_GICR, INT1);
    1efc:	eb e5       	ldi	r30, 0x5B	; 91
    1efe:	f0 e0       	ldi	r31, 0x00	; 0
    1f00:	80 81       	ld	r24, Z
    1f02:	80 68       	ori	r24, 0x80	; 128
    1f04:	80 83       	st	Z, r24
    1f06:	08 95       	ret
		break;
	case EXTI_INT2:
		SET_BIT(_GICR, INT2);
    1f08:	eb e5       	ldi	r30, 0x5B	; 91
    1f0a:	f0 e0       	ldi	r31, 0x00	; 0
    1f0c:	80 81       	ld	r24, Z
    1f0e:	80 62       	ori	r24, 0x20	; 32
    1f10:	80 83       	st	Z, r24
    1f12:	08 95       	ret

00001f14 <EXTI_voidDisable>:
 * @param	1- copy_u8InterruptSource 	-> External interrupt source (EXTI_INTx where x = (0, 1 or 2))
 * @return	void
 */
void EXTI_voidDisable(u8 copy_u8InterruptSource)
{
	switch (copy_u8InterruptSource)
    1f14:	81 30       	cpi	r24, 0x01	; 1
    1f16:	59 f0       	breq	.+22     	; 0x1f2e <EXTI_voidDisable+0x1a>
    1f18:	81 30       	cpi	r24, 0x01	; 1
    1f1a:	18 f0       	brcs	.+6      	; 0x1f22 <EXTI_voidDisable+0xe>
    1f1c:	82 30       	cpi	r24, 0x02	; 2
    1f1e:	91 f4       	brne	.+36     	; 0x1f44 <EXTI_voidDisable+0x30>
    1f20:	0c c0       	rjmp	.+24     	; 0x1f3a <EXTI_voidDisable+0x26>
	{
	case EXTI_INT0:
		CLR_BIT(_GICR, INT0);
    1f22:	eb e5       	ldi	r30, 0x5B	; 91
    1f24:	f0 e0       	ldi	r31, 0x00	; 0
    1f26:	80 81       	ld	r24, Z
    1f28:	8f 7b       	andi	r24, 0xBF	; 191
    1f2a:	80 83       	st	Z, r24
    1f2c:	08 95       	ret
		break;
	case EXTI_INT1:
		CLR_BIT(_GICR, INT1);
    1f2e:	eb e5       	ldi	r30, 0x5B	; 91
    1f30:	f0 e0       	ldi	r31, 0x00	; 0
    1f32:	80 81       	ld	r24, Z
    1f34:	8f 77       	andi	r24, 0x7F	; 127
    1f36:	80 83       	st	Z, r24
    1f38:	08 95       	ret
		break;
	case EXTI_INT2:
		CLR_BIT(_GICR, INT2);
    1f3a:	eb e5       	ldi	r30, 0x5B	; 91
    1f3c:	f0 e0       	ldi	r31, 0x00	; 0
    1f3e:	80 81       	ld	r24, Z
    1f40:	8f 7d       	andi	r24, 0xDF	; 223
    1f42:	80 83       	st	Z, r24
    1f44:	08 95       	ret

00001f46 <EXTI0_voidSendCallBack>:
}

//CallBack Functions Implementation for EXTI0, 1, 2
void EXTI0_voidSendCallBack(void (*PtrF0)(void))
{
	if(PtrF0 !=NULL)
    1f46:	00 97       	sbiw	r24, 0x00	; 0
    1f48:	21 f0       	breq	.+8      	; 0x1f52 <EXTI0_voidSendCallBack+0xc>
	{
		EXTI_prviate_PtrCallBack0 = PtrF0;
    1f4a:	90 93 d3 01 	sts	0x01D3, r25
    1f4e:	80 93 d2 01 	sts	0x01D2, r24
    1f52:	08 95       	ret

00001f54 <EXTI1_voidSendCallBack>:
	}
}

void EXTI1_voidSendCallBack(void (*PtrF1)(void))
{
	if(PtrF1 !=NULL)
    1f54:	00 97       	sbiw	r24, 0x00	; 0
    1f56:	21 f0       	breq	.+8      	; 0x1f60 <EXTI1_voidSendCallBack+0xc>
	{
		EXTI_prviate_PtrCallBack1 = PtrF1;
    1f58:	90 93 d1 01 	sts	0x01D1, r25
    1f5c:	80 93 d0 01 	sts	0x01D0, r24
    1f60:	08 95       	ret

00001f62 <EXTI2_voidSendCallBack>:
	}
}

void EXTI2_voidSendCallBack(void (*PtrF2)(void))
{
	if(PtrF2 !=NULL)
    1f62:	00 97       	sbiw	r24, 0x00	; 0
    1f64:	21 f0       	breq	.+8      	; 0x1f6e <EXTI2_voidSendCallBack+0xc>
	{
		EXTI_prviate_PtrCallBack2 = PtrF2;
    1f66:	90 93 cf 01 	sts	0x01CF, r25
    1f6a:	80 93 ce 01 	sts	0x01CE, r24
    1f6e:	08 95       	ret

00001f70 <__vector_1>:
//EXTI2 ISR
void __vector_3(void) __attribute__((signal));


void __vector_1(void)
{
    1f70:	1f 92       	push	r1
    1f72:	0f 92       	push	r0
    1f74:	0f b6       	in	r0, 0x3f	; 63
    1f76:	0f 92       	push	r0
    1f78:	11 24       	eor	r1, r1
    1f7a:	2f 93       	push	r18
    1f7c:	3f 93       	push	r19
    1f7e:	4f 93       	push	r20
    1f80:	5f 93       	push	r21
    1f82:	6f 93       	push	r22
    1f84:	7f 93       	push	r23
    1f86:	8f 93       	push	r24
    1f88:	9f 93       	push	r25
    1f8a:	af 93       	push	r26
    1f8c:	bf 93       	push	r27
    1f8e:	ef 93       	push	r30
    1f90:	ff 93       	push	r31
	if(EXTI_prviate_PtrCallBack0 !=NULL)
    1f92:	e0 91 d2 01 	lds	r30, 0x01D2
    1f96:	f0 91 d3 01 	lds	r31, 0x01D3
    1f9a:	30 97       	sbiw	r30, 0x00	; 0
    1f9c:	09 f0       	breq	.+2      	; 0x1fa0 <__vector_1+0x30>
	{
		EXTI_prviate_PtrCallBack0();
    1f9e:	09 95       	icall
	}
}
    1fa0:	ff 91       	pop	r31
    1fa2:	ef 91       	pop	r30
    1fa4:	bf 91       	pop	r27
    1fa6:	af 91       	pop	r26
    1fa8:	9f 91       	pop	r25
    1faa:	8f 91       	pop	r24
    1fac:	7f 91       	pop	r23
    1fae:	6f 91       	pop	r22
    1fb0:	5f 91       	pop	r21
    1fb2:	4f 91       	pop	r20
    1fb4:	3f 91       	pop	r19
    1fb6:	2f 91       	pop	r18
    1fb8:	0f 90       	pop	r0
    1fba:	0f be       	out	0x3f, r0	; 63
    1fbc:	0f 90       	pop	r0
    1fbe:	1f 90       	pop	r1
    1fc0:	18 95       	reti

00001fc2 <__vector_2>:

void __vector_2(void)
{
    1fc2:	1f 92       	push	r1
    1fc4:	0f 92       	push	r0
    1fc6:	0f b6       	in	r0, 0x3f	; 63
    1fc8:	0f 92       	push	r0
    1fca:	11 24       	eor	r1, r1
    1fcc:	2f 93       	push	r18
    1fce:	3f 93       	push	r19
    1fd0:	4f 93       	push	r20
    1fd2:	5f 93       	push	r21
    1fd4:	6f 93       	push	r22
    1fd6:	7f 93       	push	r23
    1fd8:	8f 93       	push	r24
    1fda:	9f 93       	push	r25
    1fdc:	af 93       	push	r26
    1fde:	bf 93       	push	r27
    1fe0:	ef 93       	push	r30
    1fe2:	ff 93       	push	r31
	if(EXTI_prviate_PtrCallBack1 !=NULL)
    1fe4:	e0 91 d0 01 	lds	r30, 0x01D0
    1fe8:	f0 91 d1 01 	lds	r31, 0x01D1
    1fec:	30 97       	sbiw	r30, 0x00	; 0
    1fee:	09 f0       	breq	.+2      	; 0x1ff2 <__vector_2+0x30>
	{
		EXTI_prviate_PtrCallBack1();
    1ff0:	09 95       	icall
	}
}
    1ff2:	ff 91       	pop	r31
    1ff4:	ef 91       	pop	r30
    1ff6:	bf 91       	pop	r27
    1ff8:	af 91       	pop	r26
    1ffa:	9f 91       	pop	r25
    1ffc:	8f 91       	pop	r24
    1ffe:	7f 91       	pop	r23
    2000:	6f 91       	pop	r22
    2002:	5f 91       	pop	r21
    2004:	4f 91       	pop	r20
    2006:	3f 91       	pop	r19
    2008:	2f 91       	pop	r18
    200a:	0f 90       	pop	r0
    200c:	0f be       	out	0x3f, r0	; 63
    200e:	0f 90       	pop	r0
    2010:	1f 90       	pop	r1
    2012:	18 95       	reti

00002014 <__vector_3>:

void __vector_3(void)
{
    2014:	1f 92       	push	r1
    2016:	0f 92       	push	r0
    2018:	0f b6       	in	r0, 0x3f	; 63
    201a:	0f 92       	push	r0
    201c:	11 24       	eor	r1, r1
    201e:	2f 93       	push	r18
    2020:	3f 93       	push	r19
    2022:	4f 93       	push	r20
    2024:	5f 93       	push	r21
    2026:	6f 93       	push	r22
    2028:	7f 93       	push	r23
    202a:	8f 93       	push	r24
    202c:	9f 93       	push	r25
    202e:	af 93       	push	r26
    2030:	bf 93       	push	r27
    2032:	ef 93       	push	r30
    2034:	ff 93       	push	r31
	if(EXTI_prviate_PtrCallBack2 !=NULL)
    2036:	e0 91 ce 01 	lds	r30, 0x01CE
    203a:	f0 91 cf 01 	lds	r31, 0x01CF
    203e:	30 97       	sbiw	r30, 0x00	; 0
    2040:	09 f0       	breq	.+2      	; 0x2044 <__vector_3+0x30>
	{
		EXTI_prviate_PtrCallBack2();
    2042:	09 95       	icall
	}
}
    2044:	ff 91       	pop	r31
    2046:	ef 91       	pop	r30
    2048:	bf 91       	pop	r27
    204a:	af 91       	pop	r26
    204c:	9f 91       	pop	r25
    204e:	8f 91       	pop	r24
    2050:	7f 91       	pop	r23
    2052:	6f 91       	pop	r22
    2054:	5f 91       	pop	r21
    2056:	4f 91       	pop	r20
    2058:	3f 91       	pop	r19
    205a:	2f 91       	pop	r18
    205c:	0f 90       	pop	r0
    205e:	0f be       	out	0x3f, r0	; 63
    2060:	0f 90       	pop	r0
    2062:	1f 90       	pop	r1
    2064:	18 95       	reti

00002066 <Dio_WriteChannel>:
 * @param	1- ChannelId 	-> to choose the right PIN  EX: (PA_0) refers to PIN0 in PORTA
 * 			2- Level		-> to choose the level on that PIN	(0 or 1)
 * @return	void
 */
void Dio_WriteChannel(Dio_ChannelType ChannelId, Dio_LevelType Level)
{
    2066:	48 2f       	mov	r20, r24
	switch(ChannelId/8)
    2068:	86 95       	lsr	r24
    206a:	86 95       	lsr	r24
    206c:	86 95       	lsr	r24
    206e:	81 30       	cpi	r24, 0x01	; 1
    2070:	31 f1       	breq	.+76     	; 0x20be <Dio_WriteChannel+0x58>
    2072:	81 30       	cpi	r24, 0x01	; 1
    2074:	38 f0       	brcs	.+14     	; 0x2084 <Dio_WriteChannel+0x1e>
    2076:	82 30       	cpi	r24, 0x02	; 2
    2078:	09 f4       	brne	.+2      	; 0x207c <Dio_WriteChannel+0x16>
    207a:	42 c0       	rjmp	.+132    	; 0x2100 <Dio_WriteChannel+0x9a>
    207c:	83 30       	cpi	r24, 0x03	; 3
    207e:	09 f0       	breq	.+2      	; 0x2082 <Dio_WriteChannel+0x1c>
    2080:	80 c0       	rjmp	.+256    	; 0x2182 <Dio_WriteChannel+0x11c>
    2082:	5f c0       	rjmp	.+190    	; 0x2142 <Dio_WriteChannel+0xdc>
	{
	case Dio_PORTA:
		if(Level == 1)
    2084:	61 30       	cpi	r22, 0x01	; 1
    2086:	69 f4       	brne	.+26     	; 0x20a2 <Dio_WriteChannel+0x3c>
			SET_BIT(_PORTA, ChannelId);
    2088:	eb e3       	ldi	r30, 0x3B	; 59
    208a:	f0 e0       	ldi	r31, 0x00	; 0
    208c:	20 81       	ld	r18, Z
    208e:	81 e0       	ldi	r24, 0x01	; 1
    2090:	90 e0       	ldi	r25, 0x00	; 0
    2092:	02 c0       	rjmp	.+4      	; 0x2098 <Dio_WriteChannel+0x32>
    2094:	88 0f       	add	r24, r24
    2096:	99 1f       	adc	r25, r25
    2098:	4a 95       	dec	r20
    209a:	e2 f7       	brpl	.-8      	; 0x2094 <Dio_WriteChannel+0x2e>
    209c:	28 2b       	or	r18, r24
    209e:	20 83       	st	Z, r18
    20a0:	08 95       	ret
		else
			CLR_BIT(_PORTA, ChannelId);
    20a2:	eb e3       	ldi	r30, 0x3B	; 59
    20a4:	f0 e0       	ldi	r31, 0x00	; 0
    20a6:	20 81       	ld	r18, Z
    20a8:	81 e0       	ldi	r24, 0x01	; 1
    20aa:	90 e0       	ldi	r25, 0x00	; 0
    20ac:	02 c0       	rjmp	.+4      	; 0x20b2 <Dio_WriteChannel+0x4c>
    20ae:	88 0f       	add	r24, r24
    20b0:	99 1f       	adc	r25, r25
    20b2:	4a 95       	dec	r20
    20b4:	e2 f7       	brpl	.-8      	; 0x20ae <Dio_WriteChannel+0x48>
    20b6:	80 95       	com	r24
    20b8:	82 23       	and	r24, r18
    20ba:	80 83       	st	Z, r24
    20bc:	08 95       	ret
		break;
	case Dio_PORTB:
		if(Level == 1)
    20be:	61 30       	cpi	r22, 0x01	; 1
    20c0:	79 f4       	brne	.+30     	; 0x20e0 <Dio_WriteChannel+0x7a>
			SET_BIT(_PORTB, ChannelId % 8);
    20c2:	e8 e3       	ldi	r30, 0x38	; 56
    20c4:	f0 e0       	ldi	r31, 0x00	; 0
    20c6:	20 81       	ld	r18, Z
    20c8:	34 2f       	mov	r19, r20
    20ca:	37 70       	andi	r19, 0x07	; 7
    20cc:	81 e0       	ldi	r24, 0x01	; 1
    20ce:	90 e0       	ldi	r25, 0x00	; 0
    20d0:	02 c0       	rjmp	.+4      	; 0x20d6 <Dio_WriteChannel+0x70>
    20d2:	88 0f       	add	r24, r24
    20d4:	99 1f       	adc	r25, r25
    20d6:	3a 95       	dec	r19
    20d8:	e2 f7       	brpl	.-8      	; 0x20d2 <Dio_WriteChannel+0x6c>
    20da:	28 2b       	or	r18, r24
    20dc:	20 83       	st	Z, r18
    20de:	08 95       	ret
		else
			CLR_BIT(_PORTB, ChannelId % 8);
    20e0:	e8 e3       	ldi	r30, 0x38	; 56
    20e2:	f0 e0       	ldi	r31, 0x00	; 0
    20e4:	30 81       	ld	r19, Z
    20e6:	24 2f       	mov	r18, r20
    20e8:	27 70       	andi	r18, 0x07	; 7
    20ea:	81 e0       	ldi	r24, 0x01	; 1
    20ec:	90 e0       	ldi	r25, 0x00	; 0
    20ee:	02 c0       	rjmp	.+4      	; 0x20f4 <Dio_WriteChannel+0x8e>
    20f0:	88 0f       	add	r24, r24
    20f2:	99 1f       	adc	r25, r25
    20f4:	2a 95       	dec	r18
    20f6:	e2 f7       	brpl	.-8      	; 0x20f0 <Dio_WriteChannel+0x8a>
    20f8:	80 95       	com	r24
    20fa:	83 23       	and	r24, r19
    20fc:	80 83       	st	Z, r24
    20fe:	08 95       	ret
		break;
	case Dio_PORTC:
		if(Level == 1)
    2100:	61 30       	cpi	r22, 0x01	; 1
    2102:	79 f4       	brne	.+30     	; 0x2122 <Dio_WriteChannel+0xbc>
			SET_BIT(_PORTC, ChannelId % 8);
    2104:	e5 e3       	ldi	r30, 0x35	; 53
    2106:	f0 e0       	ldi	r31, 0x00	; 0
    2108:	20 81       	ld	r18, Z
    210a:	34 2f       	mov	r19, r20
    210c:	37 70       	andi	r19, 0x07	; 7
    210e:	81 e0       	ldi	r24, 0x01	; 1
    2110:	90 e0       	ldi	r25, 0x00	; 0
    2112:	02 c0       	rjmp	.+4      	; 0x2118 <Dio_WriteChannel+0xb2>
    2114:	88 0f       	add	r24, r24
    2116:	99 1f       	adc	r25, r25
    2118:	3a 95       	dec	r19
    211a:	e2 f7       	brpl	.-8      	; 0x2114 <Dio_WriteChannel+0xae>
    211c:	28 2b       	or	r18, r24
    211e:	20 83       	st	Z, r18
    2120:	08 95       	ret
		else
			CLR_BIT(_PORTC, ChannelId % 8);
    2122:	e5 e3       	ldi	r30, 0x35	; 53
    2124:	f0 e0       	ldi	r31, 0x00	; 0
    2126:	30 81       	ld	r19, Z
    2128:	24 2f       	mov	r18, r20
    212a:	27 70       	andi	r18, 0x07	; 7
    212c:	81 e0       	ldi	r24, 0x01	; 1
    212e:	90 e0       	ldi	r25, 0x00	; 0
    2130:	02 c0       	rjmp	.+4      	; 0x2136 <Dio_WriteChannel+0xd0>
    2132:	88 0f       	add	r24, r24
    2134:	99 1f       	adc	r25, r25
    2136:	2a 95       	dec	r18
    2138:	e2 f7       	brpl	.-8      	; 0x2132 <Dio_WriteChannel+0xcc>
    213a:	80 95       	com	r24
    213c:	83 23       	and	r24, r19
    213e:	80 83       	st	Z, r24
    2140:	08 95       	ret
		break;
	case Dio_PORTD:
		if(Level == 1)
    2142:	61 30       	cpi	r22, 0x01	; 1
    2144:	79 f4       	brne	.+30     	; 0x2164 <Dio_WriteChannel+0xfe>
			SET_BIT(_PORTD, ChannelId % 8);
    2146:	e2 e3       	ldi	r30, 0x32	; 50
    2148:	f0 e0       	ldi	r31, 0x00	; 0
    214a:	20 81       	ld	r18, Z
    214c:	34 2f       	mov	r19, r20
    214e:	37 70       	andi	r19, 0x07	; 7
    2150:	81 e0       	ldi	r24, 0x01	; 1
    2152:	90 e0       	ldi	r25, 0x00	; 0
    2154:	02 c0       	rjmp	.+4      	; 0x215a <Dio_WriteChannel+0xf4>
    2156:	88 0f       	add	r24, r24
    2158:	99 1f       	adc	r25, r25
    215a:	3a 95       	dec	r19
    215c:	e2 f7       	brpl	.-8      	; 0x2156 <Dio_WriteChannel+0xf0>
    215e:	28 2b       	or	r18, r24
    2160:	20 83       	st	Z, r18
    2162:	08 95       	ret
		else
			CLR_BIT(_PORTD, ChannelId % 8);
    2164:	e2 e3       	ldi	r30, 0x32	; 50
    2166:	f0 e0       	ldi	r31, 0x00	; 0
    2168:	30 81       	ld	r19, Z
    216a:	24 2f       	mov	r18, r20
    216c:	27 70       	andi	r18, 0x07	; 7
    216e:	81 e0       	ldi	r24, 0x01	; 1
    2170:	90 e0       	ldi	r25, 0x00	; 0
    2172:	02 c0       	rjmp	.+4      	; 0x2178 <Dio_WriteChannel+0x112>
    2174:	88 0f       	add	r24, r24
    2176:	99 1f       	adc	r25, r25
    2178:	2a 95       	dec	r18
    217a:	e2 f7       	brpl	.-8      	; 0x2174 <Dio_WriteChannel+0x10e>
    217c:	80 95       	com	r24
    217e:	83 23       	and	r24, r19
    2180:	80 83       	st	Z, r24
    2182:	08 95       	ret

00002184 <Dio_ReadChannel>:
 * Dio_ReadChannel : This function READ the level on a PIN
 * @param	1- ChannelId 	-> to choose the PIN to read from  EX: (PA_0) refers to PIN0 in PORTA
 * @return	Dio_LevelType 	-> if 1 then the level id HIGH, if 0 then the level id LOW
 */
Dio_LevelType Dio_ReadChannel(Dio_ChannelType ChannelId)
{
    2184:	28 2f       	mov	r18, r24
	Dio_LevelType ret = STD_LOW;
	switch(ChannelId /8)
    2186:	86 95       	lsr	r24
    2188:	86 95       	lsr	r24
    218a:	86 95       	lsr	r24
    218c:	81 30       	cpi	r24, 0x01	; 1
    218e:	89 f0       	breq	.+34     	; 0x21b2 <Dio_ReadChannel+0x2e>
    2190:	81 30       	cpi	r24, 0x01	; 1
    2192:	30 f0       	brcs	.+12     	; 0x21a0 <Dio_ReadChannel+0x1c>
    2194:	82 30       	cpi	r24, 0x02	; 2
    2196:	b9 f0       	breq	.+46     	; 0x21c6 <Dio_ReadChannel+0x42>
    2198:	83 30       	cpi	r24, 0x03	; 3
    219a:	f9 f0       	breq	.+62     	; 0x21da <Dio_ReadChannel+0x56>
    219c:	80 e0       	ldi	r24, 0x00	; 0
    219e:	08 95       	ret
	{
	case Dio_PORTA:
		ret = GET_BIT(_PINA, ChannelId);
    21a0:	89 b3       	in	r24, 0x19	; 25
    21a2:	90 e0       	ldi	r25, 0x00	; 0
    21a4:	02 c0       	rjmp	.+4      	; 0x21aa <Dio_ReadChannel+0x26>
    21a6:	95 95       	asr	r25
    21a8:	87 95       	ror	r24
    21aa:	2a 95       	dec	r18
    21ac:	e2 f7       	brpl	.-8      	; 0x21a6 <Dio_ReadChannel+0x22>
    21ae:	81 70       	andi	r24, 0x01	; 1
    21b0:	08 95       	ret
		break;
	case Dio_PORTB:
		ret = GET_BIT(_PINB, ChannelId %8);
    21b2:	86 b3       	in	r24, 0x16	; 22
    21b4:	90 e0       	ldi	r25, 0x00	; 0
    21b6:	27 70       	andi	r18, 0x07	; 7
    21b8:	02 c0       	rjmp	.+4      	; 0x21be <Dio_ReadChannel+0x3a>
    21ba:	95 95       	asr	r25
    21bc:	87 95       	ror	r24
    21be:	2a 95       	dec	r18
    21c0:	e2 f7       	brpl	.-8      	; 0x21ba <Dio_ReadChannel+0x36>
    21c2:	81 70       	andi	r24, 0x01	; 1
    21c4:	08 95       	ret
		break;
	case Dio_PORTC:
		ret = GET_BIT(_PINC, ChannelId % 8);
    21c6:	83 b3       	in	r24, 0x13	; 19
    21c8:	90 e0       	ldi	r25, 0x00	; 0
    21ca:	27 70       	andi	r18, 0x07	; 7
    21cc:	02 c0       	rjmp	.+4      	; 0x21d2 <Dio_ReadChannel+0x4e>
    21ce:	95 95       	asr	r25
    21d0:	87 95       	ror	r24
    21d2:	2a 95       	dec	r18
    21d4:	e2 f7       	brpl	.-8      	; 0x21ce <Dio_ReadChannel+0x4a>
    21d6:	81 70       	andi	r24, 0x01	; 1
    21d8:	08 95       	ret
		break;
	case Dio_PORTD:
		ret = GET_BIT(_PIND, ChannelId % 8);
    21da:	80 b3       	in	r24, 0x10	; 16
    21dc:	90 e0       	ldi	r25, 0x00	; 0
    21de:	27 70       	andi	r18, 0x07	; 7
    21e0:	02 c0       	rjmp	.+4      	; 0x21e6 <Dio_ReadChannel+0x62>
    21e2:	95 95       	asr	r25
    21e4:	87 95       	ror	r24
    21e6:	2a 95       	dec	r18
    21e8:	e2 f7       	brpl	.-8      	; 0x21e2 <Dio_ReadChannel+0x5e>
    21ea:	81 70       	andi	r24, 0x01	; 1
		break;
	default:	break;
	}
	return ret;
}
    21ec:	08 95       	ret

000021ee <Dio_FlipChannel>:
 * Dio_FlipChannel : This function toggle the level on a PIN
 * @param	1- ChannelId 	-> to choose the PIN to toggle its level  EX: (PA_0) refers to PIN0 in PORTA
 * @return	Dio_LevelType 	-> return the level of the pin after toggling --> 1 for level HIGH,  0 for level LOW
 */
Dio_LevelType Dio_FlipChannel(Dio_ChannelType ChannelId)
{
    21ee:	38 2f       	mov	r19, r24
	Dio_LevelType ret = STD_LOW;
	switch(ChannelId / 8)
    21f0:	86 95       	lsr	r24
    21f2:	86 95       	lsr	r24
    21f4:	86 95       	lsr	r24
    21f6:	81 30       	cpi	r24, 0x01	; 1
    21f8:	f9 f0       	breq	.+62     	; 0x2238 <Dio_FlipChannel+0x4a>
    21fa:	81 30       	cpi	r24, 0x01	; 1
    21fc:	38 f0       	brcs	.+14     	; 0x220c <Dio_FlipChannel+0x1e>
    21fe:	82 30       	cpi	r24, 0x02	; 2
    2200:	a9 f1       	breq	.+106    	; 0x226c <Dio_FlipChannel+0x7e>
    2202:	83 30       	cpi	r24, 0x03	; 3
    2204:	09 f4       	brne	.+2      	; 0x2208 <Dio_FlipChannel+0x1a>
    2206:	4c c0       	rjmp	.+152    	; 0x22a0 <Dio_FlipChannel+0xb2>
    2208:	80 e0       	ldi	r24, 0x00	; 0
    220a:	08 95       	ret
	{
	case Dio_PORTA:
		TOG_BIT(_PORTA, ChannelId);
    220c:	eb e3       	ldi	r30, 0x3B	; 59
    220e:	f0 e0       	ldi	r31, 0x00	; 0
    2210:	20 81       	ld	r18, Z
    2212:	81 e0       	ldi	r24, 0x01	; 1
    2214:	90 e0       	ldi	r25, 0x00	; 0
    2216:	03 2e       	mov	r0, r19
    2218:	02 c0       	rjmp	.+4      	; 0x221e <Dio_FlipChannel+0x30>
    221a:	88 0f       	add	r24, r24
    221c:	99 1f       	adc	r25, r25
    221e:	0a 94       	dec	r0
    2220:	e2 f7       	brpl	.-8      	; 0x221a <Dio_FlipChannel+0x2c>
    2222:	28 27       	eor	r18, r24
    2224:	20 83       	st	Z, r18
		ret = GET_BIT(_PORTA, ChannelId);
    2226:	80 81       	ld	r24, Z
    2228:	90 e0       	ldi	r25, 0x00	; 0
    222a:	02 c0       	rjmp	.+4      	; 0x2230 <Dio_FlipChannel+0x42>
    222c:	95 95       	asr	r25
    222e:	87 95       	ror	r24
    2230:	3a 95       	dec	r19
    2232:	e2 f7       	brpl	.-8      	; 0x222c <Dio_FlipChannel+0x3e>
    2234:	81 70       	andi	r24, 0x01	; 1
    2236:	08 95       	ret
		break;
	case Dio_PORTB:
		TOG_BIT(_PORTB, ChannelId % 8);
    2238:	e8 e3       	ldi	r30, 0x38	; 56
    223a:	f0 e0       	ldi	r31, 0x00	; 0
    223c:	40 81       	ld	r20, Z
    223e:	23 2f       	mov	r18, r19
    2240:	30 e0       	ldi	r19, 0x00	; 0
    2242:	27 70       	andi	r18, 0x07	; 7
    2244:	30 70       	andi	r19, 0x00	; 0
    2246:	81 e0       	ldi	r24, 0x01	; 1
    2248:	90 e0       	ldi	r25, 0x00	; 0
    224a:	02 2e       	mov	r0, r18
    224c:	02 c0       	rjmp	.+4      	; 0x2252 <Dio_FlipChannel+0x64>
    224e:	88 0f       	add	r24, r24
    2250:	99 1f       	adc	r25, r25
    2252:	0a 94       	dec	r0
    2254:	e2 f7       	brpl	.-8      	; 0x224e <Dio_FlipChannel+0x60>
    2256:	48 27       	eor	r20, r24
    2258:	40 83       	st	Z, r20
		ret = GET_BIT(_PORTB, ChannelId %8);
    225a:	80 81       	ld	r24, Z
    225c:	90 e0       	ldi	r25, 0x00	; 0
    225e:	02 c0       	rjmp	.+4      	; 0x2264 <Dio_FlipChannel+0x76>
    2260:	95 95       	asr	r25
    2262:	87 95       	ror	r24
    2264:	2a 95       	dec	r18
    2266:	e2 f7       	brpl	.-8      	; 0x2260 <Dio_FlipChannel+0x72>
    2268:	81 70       	andi	r24, 0x01	; 1
    226a:	08 95       	ret
		break;
	case Dio_PORTC:
		TOG_BIT(_PORTC, ChannelId % 8);
    226c:	e5 e3       	ldi	r30, 0x35	; 53
    226e:	f0 e0       	ldi	r31, 0x00	; 0
    2270:	40 81       	ld	r20, Z
    2272:	23 2f       	mov	r18, r19
    2274:	30 e0       	ldi	r19, 0x00	; 0
    2276:	27 70       	andi	r18, 0x07	; 7
    2278:	30 70       	andi	r19, 0x00	; 0
    227a:	81 e0       	ldi	r24, 0x01	; 1
    227c:	90 e0       	ldi	r25, 0x00	; 0
    227e:	02 2e       	mov	r0, r18
    2280:	02 c0       	rjmp	.+4      	; 0x2286 <Dio_FlipChannel+0x98>
    2282:	88 0f       	add	r24, r24
    2284:	99 1f       	adc	r25, r25
    2286:	0a 94       	dec	r0
    2288:	e2 f7       	brpl	.-8      	; 0x2282 <Dio_FlipChannel+0x94>
    228a:	48 27       	eor	r20, r24
    228c:	40 83       	st	Z, r20
		ret = GET_BIT(_PORTC, ChannelId % 8);
    228e:	80 81       	ld	r24, Z
    2290:	90 e0       	ldi	r25, 0x00	; 0
    2292:	02 c0       	rjmp	.+4      	; 0x2298 <Dio_FlipChannel+0xaa>
    2294:	95 95       	asr	r25
    2296:	87 95       	ror	r24
    2298:	2a 95       	dec	r18
    229a:	e2 f7       	brpl	.-8      	; 0x2294 <Dio_FlipChannel+0xa6>
    229c:	81 70       	andi	r24, 0x01	; 1
    229e:	08 95       	ret
		break;
	case Dio_PORTD:
		TOG_BIT(_PORTD, ChannelId % 8);
    22a0:	e2 e3       	ldi	r30, 0x32	; 50
    22a2:	f0 e0       	ldi	r31, 0x00	; 0
    22a4:	40 81       	ld	r20, Z
    22a6:	23 2f       	mov	r18, r19
    22a8:	30 e0       	ldi	r19, 0x00	; 0
    22aa:	27 70       	andi	r18, 0x07	; 7
    22ac:	30 70       	andi	r19, 0x00	; 0
    22ae:	81 e0       	ldi	r24, 0x01	; 1
    22b0:	90 e0       	ldi	r25, 0x00	; 0
    22b2:	02 2e       	mov	r0, r18
    22b4:	02 c0       	rjmp	.+4      	; 0x22ba <Dio_FlipChannel+0xcc>
    22b6:	88 0f       	add	r24, r24
    22b8:	99 1f       	adc	r25, r25
    22ba:	0a 94       	dec	r0
    22bc:	e2 f7       	brpl	.-8      	; 0x22b6 <Dio_FlipChannel+0xc8>
    22be:	48 27       	eor	r20, r24
    22c0:	40 83       	st	Z, r20
		ret = GET_BIT(_PORTD, ChannelId % 8);
    22c2:	80 81       	ld	r24, Z
    22c4:	90 e0       	ldi	r25, 0x00	; 0
    22c6:	02 c0       	rjmp	.+4      	; 0x22cc <Dio_FlipChannel+0xde>
    22c8:	95 95       	asr	r25
    22ca:	87 95       	ror	r24
    22cc:	2a 95       	dec	r18
    22ce:	e2 f7       	brpl	.-8      	; 0x22c8 <Dio_FlipChannel+0xda>
    22d0:	81 70       	andi	r24, 0x01	; 1
		break;
	default:	break;
	}
	return ret;
}
    22d2:	08 95       	ret

000022d4 <Dio_ReadPort>:
 * @return	Dio_PortLevelType 	-> return the level of the PORT
 */
Dio_PortLevelType Dio_ReadPort(Dio_PortType PortId)
{
	Dio_PortLevelType ret = 0;
	switch(PortId)
    22d4:	81 30       	cpi	r24, 0x01	; 1
    22d6:	51 f0       	breq	.+20     	; 0x22ec <Dio_ReadPort+0x18>
    22d8:	81 30       	cpi	r24, 0x01	; 1
    22da:	30 f0       	brcs	.+12     	; 0x22e8 <Dio_ReadPort+0x14>
    22dc:	82 30       	cpi	r24, 0x02	; 2
    22de:	41 f0       	breq	.+16     	; 0x22f0 <Dio_ReadPort+0x1c>
    22e0:	83 30       	cpi	r24, 0x03	; 3
    22e2:	41 f0       	breq	.+16     	; 0x22f4 <Dio_ReadPort+0x20>
    22e4:	80 e0       	ldi	r24, 0x00	; 0
    22e6:	08 95       	ret
	{
	case Dio_PORTA:
		ret = _PINA;
    22e8:	89 b3       	in	r24, 0x19	; 25
    22ea:	08 95       	ret
		break;
	case Dio_PORTB:
		ret = _PINB;
    22ec:	86 b3       	in	r24, 0x16	; 22
    22ee:	08 95       	ret
		break;
	case Dio_PORTC:
		ret = _PINC;
    22f0:	83 b3       	in	r24, 0x13	; 19
    22f2:	08 95       	ret
		break;
	case Dio_PORTD:
		ret =_PIND;
    22f4:	80 b3       	in	r24, 0x10	; 16
			break;
	}
	return ret;
}
    22f6:	08 95       	ret

000022f8 <Dio_WritePort>:
 * 			2- Level 	-> the level to write 	Ex : (255) to write 1111 1111
 * @return	Dio_LevelType 	-> return the level of the PORT
 */
void Dio_WritePort(Dio_PortType PortId,Dio_PortLevelType Level)
{
	switch(PortId)
    22f8:	81 30       	cpi	r24, 0x01	; 1
    22fa:	49 f0       	breq	.+18     	; 0x230e <Dio_WritePort+0x16>
    22fc:	81 30       	cpi	r24, 0x01	; 1
    22fe:	28 f0       	brcs	.+10     	; 0x230a <Dio_WritePort+0x12>
    2300:	82 30       	cpi	r24, 0x02	; 2
    2302:	39 f0       	breq	.+14     	; 0x2312 <Dio_WritePort+0x1a>
    2304:	83 30       	cpi	r24, 0x03	; 3
    2306:	41 f4       	brne	.+16     	; 0x2318 <Dio_WritePort+0x20>
    2308:	06 c0       	rjmp	.+12     	; 0x2316 <Dio_WritePort+0x1e>
		{
		case Dio_PORTA:
			_PORTA = Level;
    230a:	6b bb       	out	0x1b, r22	; 27
    230c:	08 95       	ret
			break;
		case Dio_PORTB:
			_PORTB = Level;
    230e:	68 bb       	out	0x18, r22	; 24
    2310:	08 95       	ret
			break;
		case Dio_PORTC:
			_PORTC = Level;
    2312:	65 bb       	out	0x15, r22	; 21
    2314:	08 95       	ret
			break;
		case Dio_PORTD:
			_PORTD = Level;
    2316:	62 bb       	out	0x12, r22	; 18
    2318:	08 95       	ret

0000231a <ADC_void_Init>:
	case AREF:
		CLR_BIT(_ADMUX, 6);
		CLR_BIT(_ADMUX, 7);
		break;
	case AVCC :
		SET_BIT(_ADMUX, 6);
    231a:	e7 e2       	ldi	r30, 0x27	; 39
    231c:	f0 e0       	ldi	r31, 0x00	; 0
    231e:	80 81       	ld	r24, Z
    2320:	80 64       	ori	r24, 0x40	; 64
    2322:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 7);
    2324:	80 81       	ld	r24, Z
    2326:	8f 77       	andi	r24, 0x7F	; 127
    2328:	80 83       	st	Z, r24
static void ADC_voidLeft_Adjust_Result(void)
{
	switch(ADC_Left_Adjust_Result)
	{
	case LEFT:
		SET_BIT(_ADMUX, 5);
    232a:	80 81       	ld	r24, Z
    232c:	80 62       	ori	r24, 0x20	; 32
    232e:	80 83       	st	Z, r24
		CLR_BIT(_ADCSRA, 0);
		SET_BIT(_ADCSRA, 1);
		SET_BIT(_ADCSRA, 2);
		break;
	case 128:
		SET_BIT(_ADCSRA, 0);
    2330:	e6 e2       	ldi	r30, 0x26	; 38
    2332:	f0 e0       	ldi	r31, 0x00	; 0
    2334:	80 81       	ld	r24, Z
    2336:	81 60       	ori	r24, 0x01	; 1
    2338:	80 83       	st	Z, r24
		SET_BIT(_ADCSRA, 1);
    233a:	80 81       	ld	r24, Z
    233c:	82 60       	ori	r24, 0x02	; 2
    233e:	80 83       	st	Z, r24
		SET_BIT(_ADCSRA, 2);
    2340:	80 81       	ld	r24, Z
    2342:	84 60       	ori	r24, 0x04	; 4
    2344:	80 83       	st	Z, r24
void ADC_void_Init(void)
{
	ADC_voidSetVoltageReference();
	ADC_voidLeft_Adjust_Result();
	ADC_voidSet_Prescaler();
	SET_BIT(_ADCSRA, 7); // Enable ADC
    2346:	80 81       	ld	r24, Z
    2348:	80 68       	ori	r24, 0x80	; 128
    234a:	80 83       	st	Z, r24
}
    234c:	08 95       	ret

0000234e <ADC_void_Read_CH>:
	default: break;
	}
}
static void ADC_Select_Channel(u8 u8_Copy_CH)
{
	switch(u8_Copy_CH)
    234e:	83 30       	cpi	r24, 0x03	; 3
    2350:	09 f4       	brne	.+2      	; 0x2354 <ADC_void_Read_CH+0x6>
    2352:	4a c0       	rjmp	.+148    	; 0x23e8 <ADC_void_Read_CH+0x9a>
    2354:	84 30       	cpi	r24, 0x04	; 4
    2356:	28 f4       	brcc	.+10     	; 0x2362 <ADC_void_Read_CH+0x14>
    2358:	81 30       	cpi	r24, 0x01	; 1
    235a:	11 f1       	breq	.+68     	; 0x23a0 <ADC_void_Read_CH+0x52>
    235c:	82 30       	cpi	r24, 0x02	; 2
    235e:	90 f5       	brcc	.+100    	; 0x23c4 <ADC_void_Read_CH+0x76>
    2360:	0d c0       	rjmp	.+26     	; 0x237c <ADC_void_Read_CH+0x2e>
    2362:	85 30       	cpi	r24, 0x05	; 5
    2364:	09 f4       	brne	.+2      	; 0x2368 <ADC_void_Read_CH+0x1a>
    2366:	64 c0       	rjmp	.+200    	; 0x2430 <ADC_void_Read_CH+0xe2>
    2368:	85 30       	cpi	r24, 0x05	; 5
    236a:	08 f4       	brcc	.+2      	; 0x236e <ADC_void_Read_CH+0x20>
    236c:	4f c0       	rjmp	.+158    	; 0x240c <ADC_void_Read_CH+0xbe>
    236e:	86 30       	cpi	r24, 0x06	; 6
    2370:	09 f4       	brne	.+2      	; 0x2374 <ADC_void_Read_CH+0x26>
    2372:	70 c0       	rjmp	.+224    	; 0x2454 <ADC_void_Read_CH+0x106>
    2374:	87 30       	cpi	r24, 0x07	; 7
    2376:	09 f0       	breq	.+2      	; 0x237a <ADC_void_Read_CH+0x2c>
    2378:	90 c0       	rjmp	.+288    	; 0x249a <ADC_void_Read_CH+0x14c>
    237a:	7e c0       	rjmp	.+252    	; 0x2478 <ADC_void_Read_CH+0x12a>
	{
	case(ADC0_SE):
		CLR_BIT(_ADMUX, 0);
    237c:	e7 e2       	ldi	r30, 0x27	; 39
    237e:	f0 e0       	ldi	r31, 0x00	; 0
    2380:	80 81       	ld	r24, Z
    2382:	8e 7f       	andi	r24, 0xFE	; 254
    2384:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 1);
    2386:	80 81       	ld	r24, Z
    2388:	8d 7f       	andi	r24, 0xFD	; 253
    238a:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 2);
    238c:	80 81       	ld	r24, Z
    238e:	8b 7f       	andi	r24, 0xFB	; 251
    2390:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    2392:	80 81       	ld	r24, Z
    2394:	87 7f       	andi	r24, 0xF7	; 247
    2396:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    2398:	80 81       	ld	r24, Z
    239a:	8f 7e       	andi	r24, 0xEF	; 239
    239c:	80 83       	st	Z, r24
    239e:	7d c0       	rjmp	.+250    	; 0x249a <ADC_void_Read_CH+0x14c>
		break;
	case(ADC1_SE):
		SET_BIT(_ADMUX, 0);
    23a0:	e7 e2       	ldi	r30, 0x27	; 39
    23a2:	f0 e0       	ldi	r31, 0x00	; 0
    23a4:	80 81       	ld	r24, Z
    23a6:	81 60       	ori	r24, 0x01	; 1
    23a8:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 1);
    23aa:	80 81       	ld	r24, Z
    23ac:	8d 7f       	andi	r24, 0xFD	; 253
    23ae:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 2);
    23b0:	80 81       	ld	r24, Z
    23b2:	8b 7f       	andi	r24, 0xFB	; 251
    23b4:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    23b6:	80 81       	ld	r24, Z
    23b8:	87 7f       	andi	r24, 0xF7	; 247
    23ba:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    23bc:	80 81       	ld	r24, Z
    23be:	8f 7e       	andi	r24, 0xEF	; 239
    23c0:	80 83       	st	Z, r24
    23c2:	6b c0       	rjmp	.+214    	; 0x249a <ADC_void_Read_CH+0x14c>
		break;
	case(ADC2_SE):
		CLR_BIT(_ADMUX, 0);
    23c4:	e7 e2       	ldi	r30, 0x27	; 39
    23c6:	f0 e0       	ldi	r31, 0x00	; 0
    23c8:	80 81       	ld	r24, Z
    23ca:	8e 7f       	andi	r24, 0xFE	; 254
    23cc:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 1);
    23ce:	80 81       	ld	r24, Z
    23d0:	82 60       	ori	r24, 0x02	; 2
    23d2:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 2);
    23d4:	80 81       	ld	r24, Z
    23d6:	8b 7f       	andi	r24, 0xFB	; 251
    23d8:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    23da:	80 81       	ld	r24, Z
    23dc:	87 7f       	andi	r24, 0xF7	; 247
    23de:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    23e0:	80 81       	ld	r24, Z
    23e2:	8f 7e       	andi	r24, 0xEF	; 239
    23e4:	80 83       	st	Z, r24
    23e6:	59 c0       	rjmp	.+178    	; 0x249a <ADC_void_Read_CH+0x14c>
		break;
	case(ADC3_SE):
		SET_BIT(_ADMUX, 0);
    23e8:	e7 e2       	ldi	r30, 0x27	; 39
    23ea:	f0 e0       	ldi	r31, 0x00	; 0
    23ec:	80 81       	ld	r24, Z
    23ee:	81 60       	ori	r24, 0x01	; 1
    23f0:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 1);
    23f2:	80 81       	ld	r24, Z
    23f4:	82 60       	ori	r24, 0x02	; 2
    23f6:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 2);
    23f8:	80 81       	ld	r24, Z
    23fa:	8b 7f       	andi	r24, 0xFB	; 251
    23fc:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    23fe:	80 81       	ld	r24, Z
    2400:	87 7f       	andi	r24, 0xF7	; 247
    2402:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    2404:	80 81       	ld	r24, Z
    2406:	8f 7e       	andi	r24, 0xEF	; 239
    2408:	80 83       	st	Z, r24
    240a:	47 c0       	rjmp	.+142    	; 0x249a <ADC_void_Read_CH+0x14c>
		break;
	case(ADC4_SE):
		CLR_BIT(_ADMUX, 0);
    240c:	e7 e2       	ldi	r30, 0x27	; 39
    240e:	f0 e0       	ldi	r31, 0x00	; 0
    2410:	80 81       	ld	r24, Z
    2412:	8e 7f       	andi	r24, 0xFE	; 254
    2414:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 1);
    2416:	80 81       	ld	r24, Z
    2418:	8d 7f       	andi	r24, 0xFD	; 253
    241a:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 2);
    241c:	80 81       	ld	r24, Z
    241e:	84 60       	ori	r24, 0x04	; 4
    2420:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    2422:	80 81       	ld	r24, Z
    2424:	87 7f       	andi	r24, 0xF7	; 247
    2426:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    2428:	80 81       	ld	r24, Z
    242a:	8f 7e       	andi	r24, 0xEF	; 239
    242c:	80 83       	st	Z, r24
    242e:	35 c0       	rjmp	.+106    	; 0x249a <ADC_void_Read_CH+0x14c>
		break;
	case(ADC5_SE):
		SET_BIT(_ADMUX, 0);
    2430:	e7 e2       	ldi	r30, 0x27	; 39
    2432:	f0 e0       	ldi	r31, 0x00	; 0
    2434:	80 81       	ld	r24, Z
    2436:	81 60       	ori	r24, 0x01	; 1
    2438:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 1);
    243a:	80 81       	ld	r24, Z
    243c:	8d 7f       	andi	r24, 0xFD	; 253
    243e:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 2);
    2440:	80 81       	ld	r24, Z
    2442:	84 60       	ori	r24, 0x04	; 4
    2444:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    2446:	80 81       	ld	r24, Z
    2448:	87 7f       	andi	r24, 0xF7	; 247
    244a:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    244c:	80 81       	ld	r24, Z
    244e:	8f 7e       	andi	r24, 0xEF	; 239
    2450:	80 83       	st	Z, r24
    2452:	23 c0       	rjmp	.+70     	; 0x249a <ADC_void_Read_CH+0x14c>
		break;
	case(ADC6_SE):
		CLR_BIT(_ADMUX, 0);
    2454:	e7 e2       	ldi	r30, 0x27	; 39
    2456:	f0 e0       	ldi	r31, 0x00	; 0
    2458:	80 81       	ld	r24, Z
    245a:	8e 7f       	andi	r24, 0xFE	; 254
    245c:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 1);
    245e:	80 81       	ld	r24, Z
    2460:	82 60       	ori	r24, 0x02	; 2
    2462:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 2);
    2464:	80 81       	ld	r24, Z
    2466:	84 60       	ori	r24, 0x04	; 4
    2468:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    246a:	80 81       	ld	r24, Z
    246c:	87 7f       	andi	r24, 0xF7	; 247
    246e:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    2470:	80 81       	ld	r24, Z
    2472:	8f 7e       	andi	r24, 0xEF	; 239
    2474:	80 83       	st	Z, r24
    2476:	11 c0       	rjmp	.+34     	; 0x249a <ADC_void_Read_CH+0x14c>
		break;
	case(ADC7_SE):
		SET_BIT(_ADMUX, 0);
    2478:	e7 e2       	ldi	r30, 0x27	; 39
    247a:	f0 e0       	ldi	r31, 0x00	; 0
    247c:	80 81       	ld	r24, Z
    247e:	81 60       	ori	r24, 0x01	; 1
    2480:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 1);
    2482:	80 81       	ld	r24, Z
    2484:	82 60       	ori	r24, 0x02	; 2
    2486:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 2);
    2488:	80 81       	ld	r24, Z
    248a:	84 60       	ori	r24, 0x04	; 4
    248c:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    248e:	80 81       	ld	r24, Z
    2490:	87 7f       	andi	r24, 0xF7	; 247
    2492:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    2494:	80 81       	ld	r24, Z
    2496:	8f 7e       	andi	r24, 0xEF	; 239
    2498:	80 83       	st	Z, r24

u16 ADC_void_Read_CH(u8 u8_Copychannel)
{
	u16 result = 0;
	ADC_Select_Channel(u8_Copychannel);
	SET_BIT(_ADCSRA , 6); // ADC start conversion
    249a:	e6 e2       	ldi	r30, 0x26	; 38
    249c:	f0 e0       	ldi	r31, 0x00	; 0
    249e:	80 81       	ld	r24, Z
    24a0:	80 64       	ori	r24, 0x40	; 64
    24a2:	80 83       	st	Z, r24
	while(_ADCSRA & (1 << 6));
    24a4:	80 81       	ld	r24, Z
    24a6:	86 fd       	sbrc	r24, 6
    24a8:	fd cf       	rjmp	.-6      	; 0x24a4 <ADC_void_Read_CH+0x156>
	switch(ADC_Left_Adjust_Result)
	{
	case LEFT:
		 result = (_ADCL >> 6);
    24aa:	84 b1       	in	r24, 0x04	; 4
    24ac:	82 95       	swap	r24
    24ae:	86 95       	lsr	r24
    24b0:	86 95       	lsr	r24
    24b2:	83 70       	andi	r24, 0x03	; 3
    24b4:	90 e0       	ldi	r25, 0x00	; 0
		 result |= (_ADCH << 2);
    24b6:	25 b1       	in	r18, 0x05	; 5
    24b8:	30 e0       	ldi	r19, 0x00	; 0
    24ba:	22 0f       	add	r18, r18
    24bc:	33 1f       	adc	r19, r19
    24be:	22 0f       	add	r18, r18
    24c0:	33 1f       	adc	r19, r19
    24c2:	28 2b       	or	r18, r24
    24c4:	39 2b       	or	r19, r25
		 result = _ADCL;
		 result |= (_ADCH << 8);
		break;
	}
	return result;
}
    24c6:	82 2f       	mov	r24, r18
    24c8:	93 2f       	mov	r25, r19
    24ca:	08 95       	ret

000024cc <Ultra_Sonic_Distance_in_cm>:
	_delay_ms(60);
}

u16 Ultra_Sonic_Distance_in_cm(void)
{
	return (ICU_u32GetFallingEdgeTime() / 58);
    24cc:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <ICU_u32GetFallingEdgeTime>
    24d0:	2a e3       	ldi	r18, 0x3A	; 58
    24d2:	30 e0       	ldi	r19, 0x00	; 0
    24d4:	40 e0       	ldi	r20, 0x00	; 0
    24d6:	50 e0       	ldi	r21, 0x00	; 0
    24d8:	0e 94 66 31 	call	0x62cc	; 0x62cc <__udivmodsi4>
    24dc:	82 2f       	mov	r24, r18
    24de:	93 2f       	mov	r25, r19
}
    24e0:	08 95       	ret

000024e2 <Ultra_Sonic_void_trigger>:
#include "../../_MY_LIBS/BIT_MATH.h"
#include "../../_MCAL/HICU/ICU_Interface.h"
#include "util/delay.h"

void Ultra_Sonic_void_trigger(u8 channel)
{
    24e2:	1f 93       	push	r17
    24e4:	18 2f       	mov	r17, r24
	Dio_WriteChannel(channel, 1);
    24e6:	61 e0       	ldi	r22, 0x01	; 1
    24e8:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    24ec:	85 e3       	ldi	r24, 0x35	; 53
    24ee:	8a 95       	dec	r24
    24f0:	f1 f7       	brne	.-4      	; 0x24ee <Ultra_Sonic_void_trigger+0xc>
	_delay_us(10);
	Dio_WriteChannel(channel, 0);
    24f2:	81 2f       	mov	r24, r17
    24f4:	60 e0       	ldi	r22, 0x00	; 0
    24f6:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    24fa:	28 e5       	ldi	r18, 0x58	; 88
    24fc:	32 e0       	ldi	r19, 0x02	; 2
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    24fe:	40 e9       	ldi	r20, 0x90	; 144
    2500:	51 e0       	ldi	r21, 0x01	; 1
    2502:	ca 01       	movw	r24, r20
    2504:	01 97       	sbiw	r24, 0x01	; 1
    2506:	f1 f7       	brne	.-4      	; 0x2504 <Ultra_Sonic_void_trigger+0x22>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2508:	21 50       	subi	r18, 0x01	; 1
    250a:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    250c:	d1 f7       	brne	.-12     	; 0x2502 <Ultra_Sonic_void_trigger+0x20>
	_delay_ms(60);
}
    250e:	1f 91       	pop	r17
    2510:	08 95       	ret

00002512 <Simple_Scheduler>:
    TMR0_voidSendCallBack_OVF(Simple_Scheduler);
}

/*-----------------------------------------------------*/
static void Simple_Scheduler(void)
{
    2512:	cf 92       	push	r12
    2514:	df 92       	push	r13
    2516:	ef 92       	push	r14
    2518:	ff 92       	push	r15
    251a:	1f 93       	push	r17
    251c:	cf 93       	push	r28
    251e:	df 93       	push	r29
    2520:	10 e0       	ldi	r17, 0x00	; 0
    for (u8 i = 0; i <= created_tasks_number ; i++)
    {
    	if (My_Tasks[i].Task_FuncPtr == NULL)
    2522:	0f 2e       	mov	r0, r31
    2524:	fb e2       	ldi	r31, 0x2B	; 43
    2526:	cf 2e       	mov	r12, r31
    2528:	f8 e0       	ldi	r31, 0x08	; 8
    252a:	df 2e       	mov	r13, r31
    252c:	f0 2d       	mov	r31, r0
    	{
    		continue;
    	}
        if (temp_priodicity[i] == 0)
    252e:	0f 2e       	mov	r0, r31
    2530:	ff e1       	ldi	r31, 0x1F	; 31
    2532:	ef 2e       	mov	r14, r31
    2534:	f8 e0       	ldi	r31, 0x08	; 8
    2536:	ff 2e       	mov	r15, r31
    2538:	f0 2d       	mov	r31, r0
/*-----------------------------------------------------*/
static void Simple_Scheduler(void)
{
    for (u8 i = 0; i <= created_tasks_number ; i++)
    {
    	if (My_Tasks[i].Task_FuncPtr == NULL)
    253a:	c1 2f       	mov	r28, r17
    253c:	d0 e0       	ldi	r29, 0x00	; 0
    253e:	ce 01       	movw	r24, r28
    2540:	88 0f       	add	r24, r24
    2542:	99 1f       	adc	r25, r25
    2544:	88 0f       	add	r24, r24
    2546:	99 1f       	adc	r25, r25
    2548:	88 0f       	add	r24, r24
    254a:	99 1f       	adc	r25, r25
    254c:	8c 1b       	sub	r24, r28
    254e:	9d 0b       	sbc	r25, r29
    2550:	f6 01       	movw	r30, r12
    2552:	e8 0f       	add	r30, r24
    2554:	f9 1f       	adc	r31, r25
    2556:	40 81       	ld	r20, Z
    2558:	51 81       	ldd	r21, Z+1	; 0x01
    255a:	41 15       	cp	r20, r1
    255c:	51 05       	cpc	r21, r1
    255e:	71 f1       	breq	.+92     	; 0x25bc <Simple_Scheduler+0xaa>
    	{
    		continue;
    	}
        if (temp_priodicity[i] == 0)
    2560:	ce 01       	movw	r24, r28
    2562:	88 0f       	add	r24, r24
    2564:	99 1f       	adc	r25, r25
    2566:	f7 01       	movw	r30, r14
    2568:	e8 0f       	add	r30, r24
    256a:	f9 1f       	adc	r31, r25
    256c:	20 81       	ld	r18, Z
    256e:	31 81       	ldd	r19, Z+1	; 0x01
    2570:	21 15       	cp	r18, r1
    2572:	31 05       	cpc	r19, r1
    2574:	c9 f4       	brne	.+50     	; 0x25a8 <Simple_Scheduler+0x96>
        {
            My_Tasks[i].Task_FuncPtr();
    2576:	fa 01       	movw	r30, r20
    2578:	09 95       	icall
            temp_priodicity[i] = My_Tasks[i].Task_Periodicity;
    257a:	ce 01       	movw	r24, r28
    257c:	88 0f       	add	r24, r24
    257e:	99 1f       	adc	r25, r25
    2580:	d7 01       	movw	r26, r14
    2582:	a8 0f       	add	r26, r24
    2584:	b9 1f       	adc	r27, r25
    2586:	ce 01       	movw	r24, r28
    2588:	88 0f       	add	r24, r24
    258a:	99 1f       	adc	r25, r25
    258c:	88 0f       	add	r24, r24
    258e:	99 1f       	adc	r25, r25
    2590:	88 0f       	add	r24, r24
    2592:	99 1f       	adc	r25, r25
    2594:	8c 1b       	sub	r24, r28
    2596:	9d 0b       	sbc	r25, r29
    2598:	f6 01       	movw	r30, r12
    259a:	e8 0f       	add	r30, r24
    259c:	f9 1f       	adc	r31, r25
    259e:	82 81       	ldd	r24, Z+2	; 0x02
    25a0:	93 81       	ldd	r25, Z+3	; 0x03
    25a2:	8d 93       	st	X+, r24
    25a4:	9c 93       	st	X, r25
    25a6:	0a c0       	rjmp	.+20     	; 0x25bc <Simple_Scheduler+0xaa>
        }
        else
        {
        	temp_priodicity[i]--;
    25a8:	ce 01       	movw	r24, r28
    25aa:	88 0f       	add	r24, r24
    25ac:	99 1f       	adc	r25, r25
    25ae:	f7 01       	movw	r30, r14
    25b0:	e8 0f       	add	r30, r24
    25b2:	f9 1f       	adc	r31, r25
    25b4:	c9 01       	movw	r24, r18
    25b6:	01 97       	sbiw	r24, 0x01	; 1
    25b8:	91 83       	std	Z+1, r25	; 0x01
    25ba:	80 83       	st	Z, r24
}

/*-----------------------------------------------------*/
static void Simple_Scheduler(void)
{
    for (u8 i = 0; i <= created_tasks_number ; i++)
    25bc:	1f 5f       	subi	r17, 0xFF	; 255
    25be:	80 91 d4 01 	lds	r24, 0x01D4
    25c2:	81 17       	cp	r24, r17
    25c4:	08 f0       	brcs	.+2      	; 0x25c8 <Simple_Scheduler+0xb6>
    25c6:	b9 cf       	rjmp	.-142    	; 0x253a <Simple_Scheduler+0x28>
        else
        {
        	temp_priodicity[i]--;
        }
    }
}
    25c8:	df 91       	pop	r29
    25ca:	cf 91       	pop	r28
    25cc:	1f 91       	pop	r17
    25ce:	ff 90       	pop	r15
    25d0:	ef 90       	pop	r14
    25d2:	df 90       	pop	r13
    25d4:	cf 90       	pop	r12
    25d6:	08 95       	ret

000025d8 <Task_Creat>:
static void Simple_Scheduler(void);
static void shift_array_index(u8 index);

/* ----------------- Section : Software Interfaces Implementation -----------------*/
void Task_Creat(u8 Copy_u8Priority, u16 Copy_u8Periodicity, void (*Fptr)(void), u16 Copy_u16InitialDelay)
{
    25d8:	cf 92       	push	r12
    25da:	df 92       	push	r13
    25dc:	ef 92       	push	r14
    25de:	ff 92       	push	r15
    25e0:	1f 93       	push	r17
    25e2:	cf 93       	push	r28
    25e4:	df 93       	push	r29
    25e6:	18 2f       	mov	r17, r24
    25e8:	6b 01       	movw	r12, r22
    25ea:	7a 01       	movw	r14, r20
    25ec:	e9 01       	movw	r28, r18
	u8 flag = 0;
	//check if the priority (index) is repeated
	for (int i = 0; i<created_tasks_number ; i++)
    25ee:	60 91 d4 01 	lds	r22, 0x01D4
    25f2:	46 2f       	mov	r20, r22
    25f4:	50 e0       	ldi	r21, 0x00	; 0
    25f6:	14 16       	cp	r1, r20
    25f8:	15 06       	cpc	r1, r21
    25fa:	0c f0       	brlt	.+2      	; 0x25fe <Task_Creat+0x26>
    25fc:	42 c0       	rjmp	.+132    	; 0x2682 <Task_Creat+0xaa>
	{
		if (Copy_u8Priority == My_Tasks[i].Task_Priority)
    25fe:	80 91 31 08 	lds	r24, 0x0831
    2602:	81 17       	cp	r24, r17
    2604:	79 f0       	breq	.+30     	; 0x2624 <Task_Creat+0x4c>
    2606:	e8 e3       	ldi	r30, 0x38	; 56
    2608:	f8 e0       	ldi	r31, 0x08	; 8
    260a:	20 e0       	ldi	r18, 0x00	; 0
    260c:	30 e0       	ldi	r19, 0x00	; 0
    260e:	04 c0       	rjmp	.+8      	; 0x2618 <Task_Creat+0x40>
    2610:	80 81       	ld	r24, Z
    2612:	37 96       	adiw	r30, 0x07	; 7
    2614:	81 17       	cp	r24, r17
    2616:	31 f0       	breq	.+12     	; 0x2624 <Task_Creat+0x4c>
/* ----------------- Section : Software Interfaces Implementation -----------------*/
void Task_Creat(u8 Copy_u8Priority, u16 Copy_u8Periodicity, void (*Fptr)(void), u16 Copy_u16InitialDelay)
{
	u8 flag = 0;
	//check if the priority (index) is repeated
	for (int i = 0; i<created_tasks_number ; i++)
    2618:	2f 5f       	subi	r18, 0xFF	; 255
    261a:	3f 4f       	sbci	r19, 0xFF	; 255
    261c:	24 17       	cp	r18, r20
    261e:	35 07       	cpc	r19, r21
    2620:	bc f3       	brlt	.-18     	; 0x2610 <Task_Creat+0x38>
    2622:	2f c0       	rjmp	.+94     	; 0x2682 <Task_Creat+0xaa>
    }
}

static void shift_array_index(u8 index)
{
	for(int i = index; i< created_tasks_number-1 ; i ++)
    2624:	21 2f       	mov	r18, r17
    2626:	30 e0       	ldi	r19, 0x00	; 0
    2628:	ca 01       	movw	r24, r20
    262a:	01 97       	sbiw	r24, 0x01	; 1
    262c:	28 17       	cp	r18, r24
    262e:	39 07       	cpc	r19, r25
    2630:	3c f5       	brge	.+78     	; 0x2680 <Task_Creat+0xa8>
    2632:	c9 01       	movw	r24, r18
    2634:	88 0f       	add	r24, r24
    2636:	99 1f       	adc	r25, r25
    2638:	88 0f       	add	r24, r24
    263a:	99 1f       	adc	r25, r25
    263c:	88 0f       	add	r24, r24
    263e:	99 1f       	adc	r25, r25
    2640:	82 1b       	sub	r24, r18
    2642:	93 0b       	sbc	r25, r19
    2644:	fc 01       	movw	r30, r24
    2646:	ef 5c       	subi	r30, 0xCF	; 207
    2648:	f7 4f       	sbci	r31, 0xF7	; 247
    264a:	ac 01       	movw	r20, r24
    264c:	40 95       	com	r20
    264e:	50 95       	com	r21
    2650:	86 2f       	mov	r24, r22
    2652:	90 e0       	ldi	r25, 0x00	; 0
    2654:	28 0f       	add	r18, r24
    2656:	39 1f       	adc	r19, r25
    2658:	c9 01       	movw	r24, r18
    265a:	88 0f       	add	r24, r24
    265c:	99 1f       	adc	r25, r25
    265e:	88 0f       	add	r24, r24
    2660:	99 1f       	adc	r25, r25
    2662:	88 0f       	add	r24, r24
    2664:	99 1f       	adc	r25, r25
    2666:	82 1b       	sub	r24, r18
    2668:	93 0b       	sbc	r25, r19
    266a:	85 5d       	subi	r24, 0xD5	; 213
    266c:	97 4f       	sbci	r25, 0xF7	; 247
    266e:	48 0f       	add	r20, r24
    2670:	59 1f       	adc	r21, r25
	{
		My_Tasks[i].Task_Priority++;
    2672:	80 81       	ld	r24, Z
    2674:	8f 5f       	subi	r24, 0xFF	; 255
    2676:	80 83       	st	Z, r24
    2678:	37 96       	adiw	r30, 0x07	; 7
    }
}

static void shift_array_index(u8 index)
{
	for(int i = index; i< created_tasks_number-1 ; i ++)
    267a:	e4 17       	cp	r30, r20
    267c:	f5 07       	cpc	r31, r21
    267e:	c9 f7       	brne	.-14     	; 0x2672 <Task_Creat+0x9a>
	}

	if (flag == 1)
	{
		shift_array_index(Copy_u8Priority);
		Copy_u8Priority++;
    2680:	1f 5f       	subi	r17, 0xFF	; 255
	}
	My_Tasks[Copy_u8Priority].Task_FuncPtr = Fptr;
    2682:	81 2f       	mov	r24, r17
    2684:	90 e0       	ldi	r25, 0x00	; 0
    2686:	dc 01       	movw	r26, r24
    2688:	aa 0f       	add	r26, r26
    268a:	bb 1f       	adc	r27, r27
    268c:	aa 0f       	add	r26, r26
    268e:	bb 1f       	adc	r27, r27
    2690:	aa 0f       	add	r26, r26
    2692:	bb 1f       	adc	r27, r27
    2694:	a8 1b       	sub	r26, r24
    2696:	b9 0b       	sbc	r27, r25
    2698:	a5 5d       	subi	r26, 0xD5	; 213
    269a:	b7 4f       	sbci	r27, 0xF7	; 247
    269c:	fd 01       	movw	r30, r26
    269e:	e1 92       	st	Z+, r14
    26a0:	f1 92       	st	Z+, r15
	My_Tasks[Copy_u8Priority].Task_Periodicity = Copy_u8Periodicity;
    26a2:	d1 82       	std	Z+1, r13	; 0x01
    26a4:	c0 82       	st	Z, r12
	My_Tasks[Copy_u8Priority].Task_Priority = Copy_u8Priority;
    26a6:	16 96       	adiw	r26, 0x06	; 6
    26a8:	1c 93       	st	X, r17
    26aa:	16 97       	sbiw	r26, 0x06	; 6
	My_Tasks[Copy_u8Priority].Task_InitialDelay = Copy_u16InitialDelay;
    26ac:	15 96       	adiw	r26, 0x05	; 5
    26ae:	dc 93       	st	X, r29
    26b0:	ce 93       	st	-X, r28
    26b2:	14 97       	sbiw	r26, 0x04	; 4

    temp_priodicity[Copy_u8Priority] = Copy_u16InitialDelay;
    26b4:	88 0f       	add	r24, r24
    26b6:	99 1f       	adc	r25, r25
    26b8:	81 5e       	subi	r24, 0xE1	; 225
    26ba:	97 4f       	sbci	r25, 0xF7	; 247
    26bc:	fc 01       	movw	r30, r24
    26be:	d1 83       	std	Z+1, r29	; 0x01
    26c0:	c0 83       	st	Z, r28
    created_tasks_number++;
    26c2:	86 2f       	mov	r24, r22
    26c4:	8f 5f       	subi	r24, 0xFF	; 255
    26c6:	80 93 d4 01 	sts	0x01D4, r24
}
    26ca:	df 91       	pop	r29
    26cc:	cf 91       	pop	r28
    26ce:	1f 91       	pop	r17
    26d0:	ff 90       	pop	r15
    26d2:	ef 90       	pop	r14
    26d4:	df 90       	pop	r13
    26d6:	cf 90       	pop	r12
    26d8:	08 95       	ret

000026da <Scheduler_Start>:

void Scheduler_Start(void) {
    TMR0_voidInit();
    26da:	0e 94 c1 0b 	call	0x1782	; 0x1782 <TMR0_voidInit>
    TMR0_voidStart();
    26de:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <TMR0_voidStart>
    TMR0_voidSendCallBack_OVF(Simple_Scheduler);
    26e2:	89 e8       	ldi	r24, 0x89	; 137
    26e4:	92 e1       	ldi	r25, 0x12	; 18
    26e6:	0e 94 b3 0b 	call	0x1766	; 0x1766 <TMR0_voidSendCallBack_OVF>
}
    26ea:	08 95       	ret

000026ec <SRVM_voidOff>:


void SRVM_voidOff(void)
{
	/* TMR1 stop */
	TMR1_voidStop();
    26ec:	0e 94 11 0b 	call	0x1622	; 0x1622 <TMR1_voidStop>
}
    26f0:	08 95       	ret

000026f2 <SRVM_voidOn>:
/*------------------- Statics -------------------------*/
static u8 timer1Initialized = 0;		// the purpose of it is to init TMR0 only once

/* ----------------- Section : Software Interfaces Implementation -----------------*/
void SRVM_voidOn(u8 Copy_u8Angle)
{
    26f2:	1f 93       	push	r17
    26f4:	18 2f       	mov	r17, r24
	if (timer1Initialized == 0)
    26f6:	80 91 d5 01 	lds	r24, 0x01D5
    26fa:	88 23       	and	r24, r24
    26fc:	29 f4       	brne	.+10     	; 0x2708 <SRVM_voidOn+0x16>
	{
	/* TMR1 init at pwm mode 14 */
	TMR1_voidInit();
    26fe:	0e 94 2e 0b 	call	0x165c	; 0x165c <TMR1_voidInit>

	timer1Initialized = 1;
    2702:	81 e0       	ldi	r24, 0x01	; 1
    2704:	80 93 d5 01 	sts	0x01D5, r24
	}

	/* Set pwm duty cycle between 5 : 10
	 depend on desired angle[0 : 180] */
	f32 duty_cycle = (f32) ( 5 + (Copy_u8Angle *(5/ 180.0) ));
	TMR1_voidSetDuty_Mode14(duty_cycle);
    2708:	61 2f       	mov	r22, r17
    270a:	70 e0       	ldi	r23, 0x00	; 0
    270c:	88 27       	eor	r24, r24
    270e:	77 fd       	sbrc	r23, 7
    2710:	80 95       	com	r24
    2712:	98 2f       	mov	r25, r24
    2714:	0e 94 55 04 	call	0x8aa	; 0x8aa <__floatsisf>
    2718:	29 e3       	ldi	r18, 0x39	; 57
    271a:	3e e8       	ldi	r19, 0x8E	; 142
    271c:	43 ee       	ldi	r20, 0xE3	; 227
    271e:	5c e3       	ldi	r21, 0x3C	; 60
    2720:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2724:	20 e0       	ldi	r18, 0x00	; 0
    2726:	30 e0       	ldi	r19, 0x00	; 0
    2728:	40 ea       	ldi	r20, 0xA0	; 160
    272a:	50 e4       	ldi	r21, 0x40	; 64
    272c:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    2730:	0e 94 49 0b 	call	0x1692	; 0x1692 <TMR1_voidSetDuty_Mode14>

	/* TMR1 start */
	TMR1_voidStart();
    2734:	0e 94 85 0b 	call	0x170a	; 0x170a <TMR1_voidStart>
}
    2738:	1f 91       	pop	r17
    273a:	08 95       	ret

0000273c <LCD4_Command_Write>:
	Dio_WriteChannel(EN,STD_LOW);
	_delay_ms(1);
}

void LCD4_Command_Write(u8 command)
{
    273c:	ef 92       	push	r14
    273e:	ff 92       	push	r15
    2740:	1f 93       	push	r17
    2742:	18 2f       	mov	r17, r24
	Dio_WriteChannel(RS,STD_LOW);
    2744:	83 e0       	ldi	r24, 0x03	; 3
    2746:	60 e0       	ldi	r22, 0x00	; 0
    2748:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>

	Dio_WriteChannel(D4,GET_BIT(command,4));
    274c:	61 2f       	mov	r22, r17
    274e:	62 95       	swap	r22
    2750:	6f 70       	andi	r22, 0x0F	; 15
    2752:	61 70       	andi	r22, 0x01	; 1
    2754:	88 e0       	ldi	r24, 0x08	; 8
    2756:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D5,GET_BIT(command,5));
    275a:	61 2f       	mov	r22, r17
    275c:	62 95       	swap	r22
    275e:	66 95       	lsr	r22
    2760:	67 70       	andi	r22, 0x07	; 7
    2762:	61 70       	andi	r22, 0x01	; 1
    2764:	89 e0       	ldi	r24, 0x09	; 9
    2766:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D6,GET_BIT(command,6));
    276a:	61 2f       	mov	r22, r17
    276c:	62 95       	swap	r22
    276e:	66 95       	lsr	r22
    2770:	66 95       	lsr	r22
    2772:	63 70       	andi	r22, 0x03	; 3
    2774:	61 70       	andi	r22, 0x01	; 1
    2776:	8a e0       	ldi	r24, 0x0A	; 10
    2778:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D7,GET_BIT(command,7));
    277c:	61 2f       	mov	r22, r17
    277e:	66 1f       	adc	r22, r22
    2780:	66 27       	eor	r22, r22
    2782:	66 1f       	adc	r22, r22
    2784:	8b e0       	ldi	r24, 0x0B	; 11
    2786:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(EN,STD_HIGH);
    278a:	82 e0       	ldi	r24, 0x02	; 2
    278c:	61 e0       	ldi	r22, 0x01	; 1
    278e:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    2792:	0f 2e       	mov	r0, r31
    2794:	f0 ea       	ldi	r31, 0xA0	; 160
    2796:	ef 2e       	mov	r14, r31
    2798:	ff e0       	ldi	r31, 0x0F	; 15
    279a:	ff 2e       	mov	r15, r31
    279c:	f0 2d       	mov	r31, r0
    279e:	c7 01       	movw	r24, r14
    27a0:	01 97       	sbiw	r24, 0x01	; 1
    27a2:	f1 f7       	brne	.-4      	; 0x27a0 <LCD4_Command_Write+0x64>
	_delay_ms(1);
	Dio_WriteChannel(EN,STD_LOW);
    27a4:	82 e0       	ldi	r24, 0x02	; 2
    27a6:	60 e0       	ldi	r22, 0x00	; 0
    27a8:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    27ac:	c7 01       	movw	r24, r14
    27ae:	01 97       	sbiw	r24, 0x01	; 1
    27b0:	f1 f7       	brne	.-4      	; 0x27ae <LCD4_Command_Write+0x72>
	_delay_ms(1);

	Dio_WriteChannel(D4,GET_BIT(command,0));
    27b2:	61 2f       	mov	r22, r17
    27b4:	61 70       	andi	r22, 0x01	; 1
    27b6:	88 e0       	ldi	r24, 0x08	; 8
    27b8:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D5,GET_BIT(command,1));
    27bc:	61 2f       	mov	r22, r17
    27be:	66 95       	lsr	r22
    27c0:	61 70       	andi	r22, 0x01	; 1
    27c2:	89 e0       	ldi	r24, 0x09	; 9
    27c4:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D6,GET_BIT(command,2));
    27c8:	61 2f       	mov	r22, r17
    27ca:	66 95       	lsr	r22
    27cc:	66 95       	lsr	r22
    27ce:	61 70       	andi	r22, 0x01	; 1
    27d0:	8a e0       	ldi	r24, 0x0A	; 10
    27d2:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D7,GET_BIT(command,3));
    27d6:	16 95       	lsr	r17
    27d8:	16 95       	lsr	r17
    27da:	16 95       	lsr	r17
    27dc:	11 70       	andi	r17, 0x01	; 1
    27de:	8b e0       	ldi	r24, 0x0B	; 11
    27e0:	61 2f       	mov	r22, r17
    27e2:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(EN,STD_HIGH);
    27e6:	82 e0       	ldi	r24, 0x02	; 2
    27e8:	61 e0       	ldi	r22, 0x01	; 1
    27ea:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    27ee:	c7 01       	movw	r24, r14
    27f0:	01 97       	sbiw	r24, 0x01	; 1
    27f2:	f1 f7       	brne	.-4      	; 0x27f0 <LCD4_Command_Write+0xb4>
	_delay_ms(1);
	Dio_WriteChannel(EN,STD_LOW);
    27f4:	82 e0       	ldi	r24, 0x02	; 2
    27f6:	60 e0       	ldi	r22, 0x00	; 0
    27f8:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    27fc:	c7 01       	movw	r24, r14
    27fe:	01 97       	sbiw	r24, 0x01	; 1
    2800:	f1 f7       	brne	.-4      	; 0x27fe <LCD4_Command_Write+0xc2>
	_delay_ms(1);
}
    2802:	1f 91       	pop	r17
    2804:	ff 90       	pop	r15
    2806:	ef 90       	pop	r14
    2808:	08 95       	ret

0000280a <lcd4_set_cursor>:
	}
	lcd4_disply_char_at_X_Y(MemPos, row, col);
}

void lcd4_set_cursor(u8 row, u8 coul){
    coul--;
    280a:	61 50       	subi	r22, 0x01	; 1
    switch (row){
    280c:	82 30       	cpi	r24, 0x02	; 2
    280e:	89 f0       	breq	.+34     	; 0x2832 <lcd4_set_cursor+0x28>
    2810:	83 30       	cpi	r24, 0x03	; 3
    2812:	18 f4       	brcc	.+6      	; 0x281a <lcd4_set_cursor+0x10>
    2814:	81 30       	cpi	r24, 0x01	; 1
    2816:	21 f5       	brne	.+72     	; 0x2860 <lcd4_set_cursor+0x56>
    2818:	05 c0       	rjmp	.+10     	; 0x2824 <lcd4_set_cursor+0x1a>
    281a:	83 30       	cpi	r24, 0x03	; 3
    281c:	91 f0       	breq	.+36     	; 0x2842 <lcd4_set_cursor+0x38>
    281e:	84 30       	cpi	r24, 0x04	; 4
    2820:	f9 f4       	brne	.+62     	; 0x2860 <lcd4_set_cursor+0x56>
    2822:	17 c0       	rjmp	.+46     	; 0x2852 <lcd4_set_cursor+0x48>
        case ROW1:
            LCD4_Command_Write(0x80+coul);
    2824:	86 2f       	mov	r24, r22
    2826:	80 58       	subi	r24, 0x80	; 128
    2828:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
            current_pos = 0;
    282c:	10 92 d6 01 	sts	0x01D6, r1
    2830:	08 95       	ret
        break;
        case ROW2:
            LCD4_Command_Write(0xC0+coul);
    2832:	86 2f       	mov	r24, r22
    2834:	80 54       	subi	r24, 0x40	; 64
    2836:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
            current_pos = 20;
    283a:	84 e1       	ldi	r24, 0x14	; 20
    283c:	80 93 d6 01 	sts	0x01D6, r24
    2840:	08 95       	ret
        break;
        case ROW3:
            LCD4_Command_Write(0x94+coul);
    2842:	86 2f       	mov	r24, r22
    2844:	8c 56       	subi	r24, 0x6C	; 108
    2846:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
            current_pos = 40;
    284a:	88 e2       	ldi	r24, 0x28	; 40
    284c:	80 93 d6 01 	sts	0x01D6, r24
    2850:	08 95       	ret
        break;
        case ROW4:
            LCD4_Command_Write(0xD4+coul);
    2852:	86 2f       	mov	r24, r22
    2854:	8c 52       	subi	r24, 0x2C	; 44
    2856:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
            current_pos = 60;
    285a:	8c e3       	ldi	r24, 0x3C	; 60
    285c:	80 93 d6 01 	sts	0x01D6, r24
    2860:	08 95       	ret

00002862 <lcd4_CLR>:
 * @param	void
 * @return	void
 */
void lcd4_CLR(void)
{
	LCD4_Command_Write(0x01);
    2862:	81 e0       	ldi	r24, 0x01	; 1
    2864:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
	current_pos = 0;
    2868:	10 92 d6 01 	sts	0x01D6, r1
}
    286c:	08 95       	ret

0000286e <lcd4_Init>:
 * lcd4_Init : This function initializes the LCD 4bit
 * @param	void
 * @return	void
 */
void lcd4_Init(void)
{
    286e:	0f 93       	push	r16
    2870:	1f 93       	push	r17
    2872:	24 ef       	ldi	r18, 0xF4	; 244
    2874:	31 e0       	ldi	r19, 0x01	; 1
    2876:	40 e9       	ldi	r20, 0x90	; 144
    2878:	51 e0       	ldi	r21, 0x01	; 1
    287a:	ca 01       	movw	r24, r20
    287c:	01 97       	sbiw	r24, 0x01	; 1
    287e:	f1 f7       	brne	.-4      	; 0x287c <lcd4_Init+0xe>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2880:	21 50       	subi	r18, 0x01	; 1
    2882:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2884:	d1 f7       	brne	.-12     	; 0x287a <lcd4_Init+0xc>
	_delay_ms(50);
	LCD4_Command_Write(LCD_CURSOR_HOME);
    2886:	82 e0       	ldi	r24, 0x02	; 2
    2888:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
	LCD4_Command_Write(LCD_FUNCTION_SET_4_BIT_2_LINE_8_DOTS);	//LCD 4bit mode, 2 line
    288c:	88 e2       	ldi	r24, 0x28	; 40
    288e:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
    2892:	00 ea       	ldi	r16, 0xA0	; 160
    2894:	1f e0       	ldi	r17, 0x0F	; 15
    2896:	c8 01       	movw	r24, r16
    2898:	01 97       	sbiw	r24, 0x01	; 1
    289a:	f1 f7       	brne	.-4      	; 0x2898 <lcd4_Init+0x2a>
	_delay_ms(1);
	LCD4_Command_Write(LCD_DISPLAY_ON_UNDER_LINE_CURSOR_ON_BLOCK_CURSOR_ON); //cursor on off,blink  0x0f,0x0c,0x0e
    289c:	8f e0       	ldi	r24, 0x0F	; 15
    289e:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
    28a2:	c8 01       	movw	r24, r16
    28a4:	01 97       	sbiw	r24, 0x01	; 1
    28a6:	f1 f7       	brne	.-4      	; 0x28a4 <lcd4_Init+0x36>
	_delay_ms(1);
	LCD4_Command_Write(LCD_CLEAR_COMMAND); //clear screen
    28a8:	81 e0       	ldi	r24, 0x01	; 1
    28aa:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
    28ae:	80 e4       	ldi	r24, 0x40	; 64
    28b0:	9f e1       	ldi	r25, 0x1F	; 31
    28b2:	01 97       	sbiw	r24, 0x01	; 1
    28b4:	f1 f7       	brne	.-4      	; 0x28b2 <lcd4_Init+0x44>
	_delay_ms(2);
	LCD4_Command_Write(LCD_ENTRY_MODE_INC_SHIFT_OFF);	//increase DDRAM address
    28b6:	86 e0       	ldi	r24, 0x06	; 6
    28b8:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
    28bc:	c8 01       	movw	r24, r16
    28be:	01 97       	sbiw	r24, 0x01	; 1
    28c0:	f1 f7       	brne	.-4      	; 0x28be <lcd4_Init+0x50>
	_delay_ms(1);

	LCD4_Command_Write(LCD_DISPLAY_ON_UNDER_LINE_CURSOR_OFF_BLOCK_CURSOR_OFF);
    28c2:	8c e0       	ldi	r24, 0x0C	; 12
    28c4:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
	LCD4_Command_Write(LCD_DDRAM_START);
    28c8:	80 e8       	ldi	r24, 0x80	; 128
    28ca:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
}
    28ce:	1f 91       	pop	r17
    28d0:	0f 91       	pop	r16
    28d2:	08 95       	ret

000028d4 <LCD_Data_write>:
    }
}
/* ----------------- Section : Static "Private" Functions Declaration Implementation -----------------*/

static void LCD_Data_write(u8 data)
{
    28d4:	ef 92       	push	r14
    28d6:	ff 92       	push	r15
    28d8:	1f 93       	push	r17
    28da:	18 2f       	mov	r17, r24
	Dio_WriteChannel(RS,STD_HIGH);
    28dc:	83 e0       	ldi	r24, 0x03	; 3
    28de:	61 e0       	ldi	r22, 0x01	; 1
    28e0:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>

	Dio_WriteChannel(D4,GET_BIT(data,4));
    28e4:	61 2f       	mov	r22, r17
    28e6:	62 95       	swap	r22
    28e8:	6f 70       	andi	r22, 0x0F	; 15
    28ea:	61 70       	andi	r22, 0x01	; 1
    28ec:	88 e0       	ldi	r24, 0x08	; 8
    28ee:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D5,GET_BIT(data,5));
    28f2:	61 2f       	mov	r22, r17
    28f4:	62 95       	swap	r22
    28f6:	66 95       	lsr	r22
    28f8:	67 70       	andi	r22, 0x07	; 7
    28fa:	61 70       	andi	r22, 0x01	; 1
    28fc:	89 e0       	ldi	r24, 0x09	; 9
    28fe:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D6,GET_BIT(data,6));
    2902:	61 2f       	mov	r22, r17
    2904:	62 95       	swap	r22
    2906:	66 95       	lsr	r22
    2908:	66 95       	lsr	r22
    290a:	63 70       	andi	r22, 0x03	; 3
    290c:	61 70       	andi	r22, 0x01	; 1
    290e:	8a e0       	ldi	r24, 0x0A	; 10
    2910:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D7,GET_BIT(data,7));
    2914:	61 2f       	mov	r22, r17
    2916:	66 1f       	adc	r22, r22
    2918:	66 27       	eor	r22, r22
    291a:	66 1f       	adc	r22, r22
    291c:	8b e0       	ldi	r24, 0x0B	; 11
    291e:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(EN,STD_HIGH);
    2922:	82 e0       	ldi	r24, 0x02	; 2
    2924:	61 e0       	ldi	r22, 0x01	; 1
    2926:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    292a:	0f 2e       	mov	r0, r31
    292c:	f0 ea       	ldi	r31, 0xA0	; 160
    292e:	ef 2e       	mov	r14, r31
    2930:	ff e0       	ldi	r31, 0x0F	; 15
    2932:	ff 2e       	mov	r15, r31
    2934:	f0 2d       	mov	r31, r0
    2936:	c7 01       	movw	r24, r14
    2938:	01 97       	sbiw	r24, 0x01	; 1
    293a:	f1 f7       	brne	.-4      	; 0x2938 <LCD_Data_write+0x64>
	_delay_ms(1);
	Dio_WriteChannel(EN,STD_LOW);
    293c:	82 e0       	ldi	r24, 0x02	; 2
    293e:	60 e0       	ldi	r22, 0x00	; 0
    2940:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    2944:	c7 01       	movw	r24, r14
    2946:	01 97       	sbiw	r24, 0x01	; 1
    2948:	f1 f7       	brne	.-4      	; 0x2946 <LCD_Data_write+0x72>
	_delay_ms(1);

	Dio_WriteChannel(D4,GET_BIT(data,0));
    294a:	61 2f       	mov	r22, r17
    294c:	61 70       	andi	r22, 0x01	; 1
    294e:	88 e0       	ldi	r24, 0x08	; 8
    2950:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D5,GET_BIT(data,1));
    2954:	61 2f       	mov	r22, r17
    2956:	66 95       	lsr	r22
    2958:	61 70       	andi	r22, 0x01	; 1
    295a:	89 e0       	ldi	r24, 0x09	; 9
    295c:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D6,GET_BIT(data,2));
    2960:	61 2f       	mov	r22, r17
    2962:	66 95       	lsr	r22
    2964:	66 95       	lsr	r22
    2966:	61 70       	andi	r22, 0x01	; 1
    2968:	8a e0       	ldi	r24, 0x0A	; 10
    296a:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D7,GET_BIT(data,3));
    296e:	16 95       	lsr	r17
    2970:	16 95       	lsr	r17
    2972:	16 95       	lsr	r17
    2974:	11 70       	andi	r17, 0x01	; 1
    2976:	8b e0       	ldi	r24, 0x0B	; 11
    2978:	61 2f       	mov	r22, r17
    297a:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(EN,STD_HIGH);
    297e:	82 e0       	ldi	r24, 0x02	; 2
    2980:	61 e0       	ldi	r22, 0x01	; 1
    2982:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    2986:	c7 01       	movw	r24, r14
    2988:	01 97       	sbiw	r24, 0x01	; 1
    298a:	f1 f7       	brne	.-4      	; 0x2988 <LCD_Data_write+0xb4>
	_delay_ms(1);
	Dio_WriteChannel(EN,STD_LOW);
    298c:	82 e0       	ldi	r24, 0x02	; 2
    298e:	60 e0       	ldi	r22, 0x00	; 0
    2990:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    2994:	c7 01       	movw	r24, r14
    2996:	01 97       	sbiw	r24, 0x01	; 1
    2998:	f1 f7       	brne	.-4      	; 0x2996 <LCD_Data_write+0xc2>
	_delay_ms(1);
}
    299a:	1f 91       	pop	r17
    299c:	ff 90       	pop	r15
    299e:	ef 90       	pop	r14
    29a0:	08 95       	ret

000029a2 <lcd4_disply_char_at_X_Y>:
 * 			3- col : the Column position of the character
 * 			Ex ('A', 2, 3) -> will display A @ [2,3]
 * @return	void
 */
void lcd4_disply_char_at_X_Y (u8 data, u8 row, u8 col)
{
    29a2:	1f 93       	push	r17
    29a4:	18 2f       	mov	r17, r24
    29a6:	86 2f       	mov	r24, r22
	lcd4_set_cursor(row, col);
    29a8:	64 2f       	mov	r22, r20
    29aa:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
	LCD_Data_write(data);
    29ae:	81 2f       	mov	r24, r17
    29b0:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <LCD_Data_write>
}
    29b4:	1f 91       	pop	r17
    29b6:	08 95       	ret

000029b8 <lcd4_disply_CustomCharacter>:
 * 			Ex: u8 customChar[] = {0x0E, 0x1B, 0x1F, 0x1F, 0x1F, 0x1F, 0x1B, 0x0E};
 * 				lcd4_disply_CustomCharacter(1, 5, customChar, 0);
 * @return	void
 */
void lcd4_disply_CustomCharacter(u8 row, u8 col, u8* CustomCharacter, u8 MemPos)
{
    29b8:	df 92       	push	r13
    29ba:	ef 92       	push	r14
    29bc:	ff 92       	push	r15
    29be:	0f 93       	push	r16
    29c0:	1f 93       	push	r17
    29c2:	cf 93       	push	r28
    29c4:	df 93       	push	r29
    29c6:	e8 2e       	mov	r14, r24
    29c8:	d6 2e       	mov	r13, r22
    29ca:	8a 01       	movw	r16, r20
    29cc:	f2 2e       	mov	r15, r18
	LCD4_Command_Write(LCD_CGRAM_START + (MemPos * 8));
    29ce:	82 2f       	mov	r24, r18
    29d0:	88 0f       	add	r24, r24
    29d2:	88 0f       	add	r24, r24
    29d4:	88 0f       	add	r24, r24
    29d6:	80 5c       	subi	r24, 0xC0	; 192
    29d8:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
    29dc:	c0 e0       	ldi	r28, 0x00	; 0
    29de:	d0 e0       	ldi	r29, 0x00	; 0
	for(int i = 0 ; i < 8 ; i++)
	{
		LCD_Data_write(CustomCharacter[i]);
    29e0:	f8 01       	movw	r30, r16
    29e2:	ec 0f       	add	r30, r28
    29e4:	fd 1f       	adc	r31, r29
    29e6:	80 81       	ld	r24, Z
    29e8:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <LCD_Data_write>
 * @return	void
 */
void lcd4_disply_CustomCharacter(u8 row, u8 col, u8* CustomCharacter, u8 MemPos)
{
	LCD4_Command_Write(LCD_CGRAM_START + (MemPos * 8));
	for(int i = 0 ; i < 8 ; i++)
    29ec:	21 96       	adiw	r28, 0x01	; 1
    29ee:	c8 30       	cpi	r28, 0x08	; 8
    29f0:	d1 05       	cpc	r29, r1
    29f2:	b1 f7       	brne	.-20     	; 0x29e0 <lcd4_disply_CustomCharacter+0x28>
	{
		LCD_Data_write(CustomCharacter[i]);
	}
	lcd4_disply_char_at_X_Y(MemPos, row, col);
    29f4:	8f 2d       	mov	r24, r15
    29f6:	6e 2d       	mov	r22, r14
    29f8:	4d 2d       	mov	r20, r13
    29fa:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <lcd4_disply_char_at_X_Y>
}
    29fe:	df 91       	pop	r29
    2a00:	cf 91       	pop	r28
    2a02:	1f 91       	pop	r17
    2a04:	0f 91       	pop	r16
    2a06:	ff 90       	pop	r15
    2a08:	ef 90       	pop	r14
    2a0a:	df 90       	pop	r13
    2a0c:	08 95       	ret

00002a0e <lcd4_disply_char>:
 * lcd4_disply_char : This function displays a character on the LCD 4bit
 * @param	data which is the character to display Ex: 'A'
 * @return	void
 */
void lcd4_disply_char (const u8 character)
{
    2a0e:	1f 93       	push	r17
    2a10:	18 2f       	mov	r17, r24
	if(current_pos == 20 )
    2a12:	80 91 d6 01 	lds	r24, 0x01D6
    2a16:	84 31       	cpi	r24, 0x14	; 20
    2a18:	29 f4       	brne	.+10     	; 0x2a24 <lcd4_disply_char+0x16>
	{
		lcd4_set_cursor(2, 1);
    2a1a:	82 e0       	ldi	r24, 0x02	; 2
    2a1c:	61 e0       	ldi	r22, 0x01	; 1
    2a1e:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
    2a22:	16 c0       	rjmp	.+44     	; 0x2a50 <lcd4_disply_char+0x42>
	}
	else if(current_pos == 40 )
    2a24:	88 32       	cpi	r24, 0x28	; 40
    2a26:	29 f4       	brne	.+10     	; 0x2a32 <lcd4_disply_char+0x24>
	{
		lcd4_set_cursor(3, 1);
    2a28:	83 e0       	ldi	r24, 0x03	; 3
    2a2a:	61 e0       	ldi	r22, 0x01	; 1
    2a2c:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
    2a30:	0f c0       	rjmp	.+30     	; 0x2a50 <lcd4_disply_char+0x42>
	}
	else if(current_pos == 60 )
    2a32:	8c 33       	cpi	r24, 0x3C	; 60
    2a34:	29 f4       	brne	.+10     	; 0x2a40 <lcd4_disply_char+0x32>
	{
		lcd4_set_cursor(4, 1);
    2a36:	84 e0       	ldi	r24, 0x04	; 4
    2a38:	61 e0       	ldi	r22, 0x01	; 1
    2a3a:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
    2a3e:	08 c0       	rjmp	.+16     	; 0x2a50 <lcd4_disply_char+0x42>
	}
	else if (current_pos == 80)
    2a40:	80 35       	cpi	r24, 0x50	; 80
    2a42:	31 f4       	brne	.+12     	; 0x2a50 <lcd4_disply_char+0x42>
	{
		lcd4_set_cursor(1, 1);
    2a44:	81 e0       	ldi	r24, 0x01	; 1
    2a46:	61 e0       	ldi	r22, 0x01	; 1
    2a48:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
		current_pos = 0;
    2a4c:	10 92 d6 01 	sts	0x01D6, r1
	}
	LCD_Data_write(character);
    2a50:	81 2f       	mov	r24, r17
    2a52:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <LCD_Data_write>
	current_pos ++;
    2a56:	80 91 d6 01 	lds	r24, 0x01D6
    2a5a:	8f 5f       	subi	r24, 0xFF	; 255
    2a5c:	80 93 d6 01 	sts	0x01D6, r24
}
    2a60:	1f 91       	pop	r17
    2a62:	08 95       	ret

00002a64 <displayTextAnimated>:
        default:
        	break;
    }
}

void displayTextAnimated(const char *text) {
    2a64:	cf 92       	push	r12
    2a66:	df 92       	push	r13
    2a68:	ef 92       	push	r14
    2a6a:	ff 92       	push	r15
    2a6c:	0f 93       	push	r16
    2a6e:	1f 93       	push	r17
    2a70:	cf 93       	push	r28
    2a72:	df 93       	push	r29
    2a74:	fc 01       	movw	r30, r24
    for (int i = 0; text[i] != '\0'; i++) {
    2a76:	20 81       	ld	r18, Z
    2a78:	22 23       	and	r18, r18
    2a7a:	e9 f0       	breq	.+58     	; 0x2ab6 <displayTextAnimated+0x52>
    2a7c:	7c 01       	movw	r14, r24
        lcd4_disply_char(text[i]);
    2a7e:	0f 2e       	mov	r0, r31
    2a80:	f4 ef       	ldi	r31, 0xF4	; 244
    2a82:	cf 2e       	mov	r12, r31
    2a84:	f1 e0       	ldi	r31, 0x01	; 1
    2a86:	df 2e       	mov	r13, r31
    2a88:	f0 2d       	mov	r31, r0
    2a8a:	c0 e9       	ldi	r28, 0x90	; 144
    2a8c:	d1 e0       	ldi	r29, 0x01	; 1
    2a8e:	ce 01       	movw	r24, r28
    2a90:	0c 2f       	mov	r16, r28
    2a92:	19 2f       	mov	r17, r25
    2a94:	82 2f       	mov	r24, r18
    2a96:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <lcd4_disply_char>
    2a9a:	96 01       	movw	r18, r12
    2a9c:	ce 01       	movw	r24, r28
    2a9e:	01 97       	sbiw	r24, 0x01	; 1
    2aa0:	f1 f7       	brne	.-4      	; 0x2a9e <displayTextAnimated+0x3a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2aa2:	21 50       	subi	r18, 0x01	; 1
    2aa4:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2aa6:	d1 f7       	brne	.-12     	; 0x2a9c <displayTextAnimated+0x38>
        	break;
    }
}

void displayTextAnimated(const char *text) {
    for (int i = 0; text[i] != '\0'; i++) {
    2aa8:	f7 01       	movw	r30, r14
    2aaa:	21 81       	ldd	r18, Z+1	; 0x01
    2aac:	08 94       	sec
    2aae:	e1 1c       	adc	r14, r1
    2ab0:	f1 1c       	adc	r15, r1
    2ab2:	22 23       	and	r18, r18
    2ab4:	79 f7       	brne	.-34     	; 0x2a94 <displayTextAnimated+0x30>
        lcd4_disply_char(text[i]);
        _delay_ms(50); // Adjust the delay as needed
    }
}
    2ab6:	df 91       	pop	r29
    2ab8:	cf 91       	pop	r28
    2aba:	1f 91       	pop	r17
    2abc:	0f 91       	pop	r16
    2abe:	ff 90       	pop	r15
    2ac0:	ef 90       	pop	r14
    2ac2:	df 90       	pop	r13
    2ac4:	cf 90       	pop	r12
    2ac6:	08 95       	ret

00002ac8 <lcd4_disply_string>:
 * lcd4_disply_string : This function displays whole string on the LCD 4bit
 * @param	data which is the string to display Ex: "Mahmoud El Arabi"
 * @return	void
 */
void lcd4_disply_string (const u8* str)
{
    2ac8:	cf 93       	push	r28
    2aca:	df 93       	push	r29
    2acc:	ec 01       	movw	r28, r24
	 while (*str){
    2ace:	88 81       	ld	r24, Y
    2ad0:	88 23       	and	r24, r24
    2ad2:	31 f0       	breq	.+12     	; 0x2ae0 <lcd4_disply_string+0x18>
	lcd4_disply_char(*str);
    2ad4:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <lcd4_disply_char>
	str++;
    2ad8:	21 96       	adiw	r28, 0x01	; 1
 * @param	data which is the string to display Ex: "Mahmoud El Arabi"
 * @return	void
 */
void lcd4_disply_string (const u8* str)
{
	 while (*str){
    2ada:	88 81       	ld	r24, Y
    2adc:	88 23       	and	r24, r24
    2ade:	d1 f7       	brne	.-12     	; 0x2ad4 <lcd4_disply_string+0xc>
	lcd4_disply_char(*str);
	str++;
	}
}
    2ae0:	df 91       	pop	r29
    2ae2:	cf 91       	pop	r28
    2ae4:	08 95       	ret

00002ae6 <lcd4_disply_string_at_X_Y>:
 * 			3- col : the Column position of the 1st character of the string which is 'M' here
 * 			Ex ("Mahmoud El Arabi", 2, 3) -> will display "Mahmoud El Arabi" @ [2,3]
 * @return	void
 */
void lcd4_disply_string_at_X_Y(u8* data, u8 row, u8 col)
{
    2ae6:	0f 93       	push	r16
    2ae8:	1f 93       	push	r17
    2aea:	8c 01       	movw	r16, r24
    2aec:	86 2f       	mov	r24, r22
	lcd4_set_cursor(row, col);
    2aee:	64 2f       	mov	r22, r20
    2af0:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
	lcd4_disply_string(data);
    2af4:	c8 01       	movw	r24, r16
    2af6:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <lcd4_disply_string>
}
    2afa:	1f 91       	pop	r17
    2afc:	0f 91       	pop	r16
    2afe:	08 95       	ret

00002b00 <lcd4_disply_num>:
/**
 * lcd4_disply_num : This function converts the nu,ber to string and displays it on the LCD 4bit
 * @param	num which is the number to display
 * @return	void
 */
void lcd4_disply_num(u16 num) {
    2b00:	0f 93       	push	r16
    2b02:	1f 93       	push	r17
    2b04:	df 93       	push	r29
    2b06:	cf 93       	push	r28
    2b08:	cd b7       	in	r28, 0x3d	; 61
    2b0a:	de b7       	in	r29, 0x3e	; 62
    2b0c:	27 97       	sbiw	r28, 0x07	; 7
    2b0e:	0f b6       	in	r0, 0x3f	; 63
    2b10:	f8 94       	cli
    2b12:	de bf       	out	0x3e, r29	; 62
    2b14:	0f be       	out	0x3f, r0	; 63
    2b16:	cd bf       	out	0x3d, r28	; 61
    char num_str[7];  // Assuming a 7-character buffer is sufficient
    snprintf(num_str, sizeof(num_str), "%d", num);
    2b18:	2d b7       	in	r18, 0x3d	; 61
    2b1a:	3e b7       	in	r19, 0x3e	; 62
    2b1c:	28 50       	subi	r18, 0x08	; 8
    2b1e:	30 40       	sbci	r19, 0x00	; 0
    2b20:	0f b6       	in	r0, 0x3f	; 63
    2b22:	f8 94       	cli
    2b24:	3e bf       	out	0x3e, r19	; 62
    2b26:	0f be       	out	0x3f, r0	; 63
    2b28:	2d bf       	out	0x3d, r18	; 61
    2b2a:	ed b7       	in	r30, 0x3d	; 61
    2b2c:	fe b7       	in	r31, 0x3e	; 62
    2b2e:	31 96       	adiw	r30, 0x01	; 1
    2b30:	9e 01       	movw	r18, r28
    2b32:	2f 5f       	subi	r18, 0xFF	; 255
    2b34:	3f 4f       	sbci	r19, 0xFF	; 255
    2b36:	31 83       	std	Z+1, r19	; 0x01
    2b38:	20 83       	st	Z, r18
    2b3a:	27 e0       	ldi	r18, 0x07	; 7
    2b3c:	30 e0       	ldi	r19, 0x00	; 0
    2b3e:	33 83       	std	Z+3, r19	; 0x03
    2b40:	22 83       	std	Z+2, r18	; 0x02
    2b42:	20 e6       	ldi	r18, 0x60	; 96
    2b44:	30 e0       	ldi	r19, 0x00	; 0
    2b46:	35 83       	std	Z+5, r19	; 0x05
    2b48:	24 83       	std	Z+4, r18	; 0x04
    2b4a:	97 83       	std	Z+7, r25	; 0x07
    2b4c:	86 83       	std	Z+6, r24	; 0x06
    2b4e:	0e 94 f3 32 	call	0x65e6	; 0x65e6 <snprintf>

    // Display the string on the LCD character by character
    for (int i = 0; num_str[i] != '\0'; i++) {
    2b52:	89 81       	ldd	r24, Y+1	; 0x01
    2b54:	ed b7       	in	r30, 0x3d	; 61
    2b56:	fe b7       	in	r31, 0x3e	; 62
    2b58:	38 96       	adiw	r30, 0x08	; 8
    2b5a:	0f b6       	in	r0, 0x3f	; 63
    2b5c:	f8 94       	cli
    2b5e:	fe bf       	out	0x3e, r31	; 62
    2b60:	0f be       	out	0x3f, r0	; 63
    2b62:	ed bf       	out	0x3d, r30	; 61
    2b64:	88 23       	and	r24, r24
    2b66:	51 f0       	breq	.+20     	; 0x2b7c <lcd4_disply_num+0x7c>
    2b68:	8e 01       	movw	r16, r28
    2b6a:	0e 5f       	subi	r16, 0xFE	; 254
    2b6c:	1f 4f       	sbci	r17, 0xFF	; 255
        lcd4_disply_char(num_str[i]);
    2b6e:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <lcd4_disply_char>
void lcd4_disply_num(u16 num) {
    char num_str[7];  // Assuming a 7-character buffer is sufficient
    snprintf(num_str, sizeof(num_str), "%d", num);

    // Display the string on the LCD character by character
    for (int i = 0; num_str[i] != '\0'; i++) {
    2b72:	f8 01       	movw	r30, r16
    2b74:	81 91       	ld	r24, Z+
    2b76:	8f 01       	movw	r16, r30
    2b78:	88 23       	and	r24, r24
    2b7a:	c9 f7       	brne	.-14     	; 0x2b6e <lcd4_disply_num+0x6e>
        lcd4_disply_char(num_str[i]);
    }
}
    2b7c:	27 96       	adiw	r28, 0x07	; 7
    2b7e:	0f b6       	in	r0, 0x3f	; 63
    2b80:	f8 94       	cli
    2b82:	de bf       	out	0x3e, r29	; 62
    2b84:	0f be       	out	0x3f, r0	; 63
    2b86:	cd bf       	out	0x3d, r28	; 61
    2b88:	cf 91       	pop	r28
    2b8a:	df 91       	pop	r29
    2b8c:	1f 91       	pop	r17
    2b8e:	0f 91       	pop	r16
    2b90:	08 95       	ret

00002b92 <Keypad_Init>:
														{'1','2','3','-'},
														{'#','0','=','+'}};

void Keypad_Init(void)
{
	Dio_WriteChannel(R1, 1);
    2b92:	80 e1       	ldi	r24, 0x10	; 16
    2b94:	61 e0       	ldi	r22, 0x01	; 1
    2b96:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(R2, 1);
    2b9a:	81 e1       	ldi	r24, 0x11	; 17
    2b9c:	61 e0       	ldi	r22, 0x01	; 1
    2b9e:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(R3, 1);
    2ba2:	82 e1       	ldi	r24, 0x12	; 18
    2ba4:	61 e0       	ldi	r22, 0x01	; 1
    2ba6:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(R4, 1);
    2baa:	83 e1       	ldi	r24, 0x13	; 19
    2bac:	61 e0       	ldi	r22, 0x01	; 1
    2bae:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
}
    2bb2:	08 95       	ret

00002bb4 <Keypad_Get_value>:

void Keypad_Get_value(u8 *value) {
    2bb4:	4f 92       	push	r4
    2bb6:	5f 92       	push	r5
    2bb8:	7f 92       	push	r7
    2bba:	8f 92       	push	r8
    2bbc:	9f 92       	push	r9
    2bbe:	af 92       	push	r10
    2bc0:	bf 92       	push	r11
    2bc2:	cf 92       	push	r12
    2bc4:	df 92       	push	r13
    2bc6:	ef 92       	push	r14
    2bc8:	ff 92       	push	r15
    2bca:	0f 93       	push	r16
    2bcc:	1f 93       	push	r17
    2bce:	df 93       	push	r29
    2bd0:	cf 93       	push	r28
    2bd2:	00 d0       	rcall	.+0      	; 0x2bd4 <Keypad_Get_value+0x20>
    2bd4:	00 d0       	rcall	.+0      	; 0x2bd6 <Keypad_Get_value+0x22>
    2bd6:	cd b7       	in	r28, 0x3d	; 61
    2bd8:	de b7       	in	r29, 0x3e	; 62
    2bda:	2c 01       	movw	r4, r24
    u8 rows[keypad_rows] = {R1, R2, R3, R4};
    2bdc:	80 e1       	ldi	r24, 0x10	; 16
    2bde:	89 83       	std	Y+1, r24	; 0x01
    2be0:	81 e1       	ldi	r24, 0x11	; 17
    2be2:	8a 83       	std	Y+2, r24	; 0x02
    2be4:	82 e1       	ldi	r24, 0x12	; 18
    2be6:	8b 83       	std	Y+3, r24	; 0x03
    2be8:	83 e1       	ldi	r24, 0x13	; 19
    2bea:	8c 83       	std	Y+4, r24	; 0x04
    u8 columns[keypad_coul] = {C1, C2, C3, C4};
    2bec:	00 e0       	ldi	r16, 0x00	; 0
    2bee:	10 e0       	ldi	r17, 0x00	; 0

    // Loop through rows and columns to scan for a pressed key
    u8 row, col;
    for (row = 0; row < keypad_rows; row++) {
        Dio_WriteChannel(rows[row], STD_LOW);
    2bf0:	5e 01       	movw	r10, r28
    2bf2:	08 94       	sec
    2bf4:	a1 1c       	adc	r10, r1
    2bf6:	b1 1c       	adc	r11, r1
        for (col = 0; col < keypad_coul; col++) {
            if (Dio_ReadChannel(columns[col]) == STD_LOW) {
    2bf8:	0f 2e       	mov	r0, r31
    2bfa:	f4 e1       	ldi	r31, 0x14	; 20
    2bfc:	9f 2e       	mov	r9, r31
    2bfe:	f0 2d       	mov	r31, r0
    2c00:	0f 2e       	mov	r0, r31
    2c02:	f5 e1       	ldi	r31, 0x15	; 21
    2c04:	8f 2e       	mov	r8, r31
    2c06:	f0 2d       	mov	r31, r0
    2c08:	0f 2e       	mov	r0, r31
    2c0a:	f6 e1       	ldi	r31, 0x16	; 22
    2c0c:	7f 2e       	mov	r7, r31
    2c0e:	f0 2d       	mov	r31, r0
	Dio_WriteChannel(R4, 1);
}

void Keypad_Get_value(u8 *value) {
    u8 rows[keypad_rows] = {R1, R2, R3, R4};
    u8 columns[keypad_coul] = {C1, C2, C3, C4};
    2c10:	68 01       	movw	r12, r16

    // Loop through rows and columns to scan for a pressed key
    u8 row, col;
    for (row = 0; row < keypad_rows; row++) {
        Dio_WriteChannel(rows[row], STD_LOW);
    2c12:	f5 01       	movw	r30, r10
    2c14:	e0 0f       	add	r30, r16
    2c16:	f1 1f       	adc	r31, r17
    2c18:	e0 80       	ld	r14, Z
    2c1a:	8e 2d       	mov	r24, r14
    2c1c:	60 e0       	ldi	r22, 0x00	; 0
    2c1e:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
        for (col = 0; col < keypad_coul; col++) {
            if (Dio_ReadChannel(columns[col]) == STD_LOW) {
    2c22:	f9 2c       	mov	r15, r9
    2c24:	89 2d       	mov	r24, r9
    2c26:	0e 94 c2 10 	call	0x2184	; 0x2184 <Dio_ReadChannel>
    2c2a:	88 23       	and	r24, r24
    2c2c:	19 f4       	brne	.+6      	; 0x2c34 <Keypad_Get_value+0x80>
    2c2e:	80 e0       	ldi	r24, 0x00	; 0
    2c30:	90 e0       	ldi	r25, 0x00	; 0
    2c32:	1d c0       	rjmp	.+58     	; 0x2c6e <Keypad_Get_value+0xba>
    2c34:	f8 2c       	mov	r15, r8
    2c36:	88 2d       	mov	r24, r8
    2c38:	0e 94 c2 10 	call	0x2184	; 0x2184 <Dio_ReadChannel>
    2c3c:	88 23       	and	r24, r24
    2c3e:	19 f4       	brne	.+6      	; 0x2c46 <Keypad_Get_value+0x92>
    2c40:	81 e0       	ldi	r24, 0x01	; 1
    2c42:	90 e0       	ldi	r25, 0x00	; 0
    2c44:	14 c0       	rjmp	.+40     	; 0x2c6e <Keypad_Get_value+0xba>
    2c46:	f7 2c       	mov	r15, r7
    2c48:	87 2d       	mov	r24, r7
    2c4a:	0e 94 c2 10 	call	0x2184	; 0x2184 <Dio_ReadChannel>
    2c4e:	88 23       	and	r24, r24
    2c50:	19 f4       	brne	.+6      	; 0x2c58 <Keypad_Get_value+0xa4>
    2c52:	82 e0       	ldi	r24, 0x02	; 2
    2c54:	90 e0       	ldi	r25, 0x00	; 0
    2c56:	0b c0       	rjmp	.+22     	; 0x2c6e <Keypad_Get_value+0xba>
    2c58:	87 e1       	ldi	r24, 0x17	; 23
    2c5a:	0e 94 c2 10 	call	0x2184	; 0x2184 <Dio_ReadChannel>
    2c5e:	88 23       	and	r24, r24
    2c60:	c1 f4       	brne	.+48     	; 0x2c92 <Keypad_Get_value+0xde>
    2c62:	83 e0       	ldi	r24, 0x03	; 3
    2c64:	90 e0       	ldi	r25, 0x00	; 0
    2c66:	0f 2e       	mov	r0, r31
    2c68:	f7 e1       	ldi	r31, 0x17	; 23
    2c6a:	ff 2e       	mov	r15, r31
    2c6c:	f0 2d       	mov	r31, r0
                *value = btn_values[row][col];
    2c6e:	f6 01       	movw	r30, r12
    2c70:	ee 0f       	add	r30, r30
    2c72:	ff 1f       	adc	r31, r31
    2c74:	ee 0f       	add	r30, r30
    2c76:	ff 1f       	adc	r31, r31
    2c78:	e8 0f       	add	r30, r24
    2c7a:	f9 1f       	adc	r31, r25
    2c7c:	ee 55       	subi	r30, 0x5E	; 94
    2c7e:	fe 4f       	sbci	r31, 0xFE	; 254
    2c80:	80 81       	ld	r24, Z
    2c82:	f2 01       	movw	r30, r4
    2c84:	80 83       	st	Z, r24
                while (Dio_ReadChannel(columns[col]) == STD_LOW);
    2c86:	8f 2d       	mov	r24, r15
    2c88:	0e 94 c2 10 	call	0x2184	; 0x2184 <Dio_ReadChannel>
    2c8c:	88 23       	and	r24, r24
    2c8e:	d9 f3       	breq	.-10     	; 0x2c86 <Keypad_Get_value+0xd2>
    2c90:	0d c0       	rjmp	.+26     	; 0x2cac <Keypad_Get_value+0xf8>
                return;
            }
        }
        Dio_WriteChannel(rows[row], STD_HIGH);
    2c92:	8e 2d       	mov	r24, r14
    2c94:	61 e0       	ldi	r22, 0x01	; 1
    2c96:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    2c9a:	0f 5f       	subi	r16, 0xFF	; 255
    2c9c:	1f 4f       	sbci	r17, 0xFF	; 255
    u8 rows[keypad_rows] = {R1, R2, R3, R4};
    u8 columns[keypad_coul] = {C1, C2, C3, C4};

    // Loop through rows and columns to scan for a pressed key
    u8 row, col;
    for (row = 0; row < keypad_rows; row++) {
    2c9e:	04 30       	cpi	r16, 0x04	; 4
    2ca0:	11 05       	cpc	r17, r1
    2ca2:	09 f0       	breq	.+2      	; 0x2ca6 <Keypad_Get_value+0xf2>
    2ca4:	b5 cf       	rjmp	.-150    	; 0x2c10 <Keypad_Get_value+0x5c>
                return;
            }
        }
        Dio_WriteChannel(rows[row], STD_HIGH);
    }
    *value = 'T';
    2ca6:	84 e5       	ldi	r24, 0x54	; 84
    2ca8:	f2 01       	movw	r30, r4
    2caa:	80 83       	st	Z, r24
}
    2cac:	0f 90       	pop	r0
    2cae:	0f 90       	pop	r0
    2cb0:	0f 90       	pop	r0
    2cb2:	0f 90       	pop	r0
    2cb4:	cf 91       	pop	r28
    2cb6:	df 91       	pop	r29
    2cb8:	1f 91       	pop	r17
    2cba:	0f 91       	pop	r16
    2cbc:	ff 90       	pop	r15
    2cbe:	ef 90       	pop	r14
    2cc0:	df 90       	pop	r13
    2cc2:	cf 90       	pop	r12
    2cc4:	bf 90       	pop	r11
    2cc6:	af 90       	pop	r10
    2cc8:	9f 90       	pop	r9
    2cca:	8f 90       	pop	r8
    2ccc:	7f 90       	pop	r7
    2cce:	5f 90       	pop	r5
    2cd0:	4f 90       	pop	r4
    2cd2:	08 95       	ret

00002cd4 <EEPROM_voidRead_Page>:
	TWI_voidSendStopCondition();
	_delay_ms(5);	// delay to eeprom to store the data
}

void EEPROM_voidRead_Page(u16 copy_u16WordAdd, u8 *copy_u8PtrReceivedData, u8 copy_u8Size)
{
    2cd4:	af 92       	push	r10
    2cd6:	bf 92       	push	r11
    2cd8:	cf 92       	push	r12
    2cda:	df 92       	push	r13
    2cdc:	ef 92       	push	r14
    2cde:	ff 92       	push	r15
    2ce0:	0f 93       	push	r16
    2ce2:	1f 93       	push	r17
    2ce4:	cf 93       	push	r28
    2ce6:	df 93       	push	r29
    2ce8:	18 2f       	mov	r17, r24
    2cea:	6b 01       	movw	r12, r22
    2cec:	f4 2e       	mov	r15, r20
//	SET_BIT(_TWCR, _TWEA);
    u8 local_u8Add = (copy_u16WordAdd >> 8) | EEPROM_FIXED_ADDRESS;
    2cee:	09 2f       	mov	r16, r25
    2cf0:	00 65       	ori	r16, 0x50	; 80
    TWI_voidSendStartCondition();
    2cf2:	0e 94 b9 09 	call	0x1372	; 0x1372 <TWI_voidSendStartCondition>
    TWI_voidSendSlaveAdd_WriteRequest(local_u8Add);
    2cf6:	80 2f       	mov	r24, r16
    2cf8:	0e 94 e6 09 	call	0x13cc	; 0x13cc <TWI_voidSendSlaveAdd_WriteRequest>
    TWI_voidWriteMasterDataByte((u8)copy_u16WordAdd);
    2cfc:	81 2f       	mov	r24, r17
    2cfe:	0e 94 1c 0a 	call	0x1438	; 0x1438 <TWI_voidWriteMasterDataByte>

    TWI_voidSendReapeatedStartCondition();
    2d02:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <TWI_voidSendReapeatedStartCondition>

    TWI_voidSendSlaveAdd_ReadRequest(local_u8Add);
    2d06:	80 2f       	mov	r24, r16
    2d08:	0e 94 01 0a 	call	0x1402	; 0x1402 <TWI_voidSendSlaveAdd_ReadRequest>

    for (int i = 0; i < copy_u8Size; i++)
    2d0c:	cf 2d       	mov	r28, r15
    2d0e:	d0 e0       	ldi	r29, 0x00	; 0
    2d10:	1c 16       	cp	r1, r28
    2d12:	1d 06       	cpc	r1, r29
    2d14:	e4 f4       	brge	.+56     	; 0x2d4e <EEPROM_voidRead_Page+0x7a>
    2d16:	00 e0       	ldi	r16, 0x00	; 0
    2d18:	10 e0       	ldi	r17, 0x00	; 0
    {
    	TWI_voidReadMasterDataByteACK(&copy_u8PtrReceivedData[i]);
    	if(i == copy_u8Size -1)
    2d1a:	7e 01       	movw	r14, r28
    2d1c:	08 94       	sec
    2d1e:	e1 08       	sbc	r14, r1
    2d20:	f1 08       	sbc	r15, r1
    	{
    		CLR_BIT(_TWCR, _TWEA);
    2d22:	0f 2e       	mov	r0, r31
    2d24:	f6 e5       	ldi	r31, 0x56	; 86
    2d26:	af 2e       	mov	r10, r31
    2d28:	bb 24       	eor	r11, r11
    2d2a:	f0 2d       	mov	r31, r0

    TWI_voidSendSlaveAdd_ReadRequest(local_u8Add);

    for (int i = 0; i < copy_u8Size; i++)
    {
    	TWI_voidReadMasterDataByteACK(&copy_u8PtrReceivedData[i]);
    2d2c:	c6 01       	movw	r24, r12
    2d2e:	80 0f       	add	r24, r16
    2d30:	91 1f       	adc	r25, r17
    2d32:	0e 94 48 0a 	call	0x1490	; 0x1490 <TWI_voidReadMasterDataByteACK>
    	if(i == copy_u8Size -1)
    2d36:	e0 16       	cp	r14, r16
    2d38:	f1 06       	cpc	r15, r17
    2d3a:	21 f4       	brne	.+8      	; 0x2d44 <EEPROM_voidRead_Page+0x70>
    	{
    		CLR_BIT(_TWCR, _TWEA);
    2d3c:	f5 01       	movw	r30, r10
    2d3e:	80 81       	ld	r24, Z
    2d40:	8f 7b       	andi	r24, 0xBF	; 191
    2d42:	80 83       	st	Z, r24

    TWI_voidSendReapeatedStartCondition();

    TWI_voidSendSlaveAdd_ReadRequest(local_u8Add);

    for (int i = 0; i < copy_u8Size; i++)
    2d44:	0f 5f       	subi	r16, 0xFF	; 255
    2d46:	1f 4f       	sbci	r17, 0xFF	; 255
    2d48:	0c 17       	cp	r16, r28
    2d4a:	1d 07       	cpc	r17, r29
    2d4c:	7c f3       	brlt	.-34     	; 0x2d2c <EEPROM_voidRead_Page+0x58>
    	if(i == copy_u8Size -1)
    	{
    		CLR_BIT(_TWCR, _TWEA);
    	}
    }
    TWI_voidSendStopCondition();
    2d4e:	0e 94 cb 09 	call	0x1396	; 0x1396 <TWI_voidSendStopCondition>
    2d52:	80 e2       	ldi	r24, 0x20	; 32
    2d54:	9e e4       	ldi	r25, 0x4E	; 78
    2d56:	01 97       	sbiw	r24, 0x01	; 1
    2d58:	f1 f7       	brne	.-4      	; 0x2d56 <EEPROM_voidRead_Page+0x82>

    _delay_ms(5);  // Delay for EEPROM to store the data
}
    2d5a:	df 91       	pop	r29
    2d5c:	cf 91       	pop	r28
    2d5e:	1f 91       	pop	r17
    2d60:	0f 91       	pop	r16
    2d62:	ff 90       	pop	r15
    2d64:	ef 90       	pop	r14
    2d66:	df 90       	pop	r13
    2d68:	cf 90       	pop	r12
    2d6a:	bf 90       	pop	r11
    2d6c:	af 90       	pop	r10
    2d6e:	08 95       	ret

00002d70 <EEPROM_voidWrite_Page>:
	}
}


void EEPROM_voidWrite_Page(u16 copy_u16WordAdd, u8 *copy_u8Data, u8 copy_u8Size)
{
    2d70:	cf 92       	push	r12
    2d72:	df 92       	push	r13
    2d74:	ff 92       	push	r15
    2d76:	0f 93       	push	r16
    2d78:	1f 93       	push	r17
    2d7a:	cf 93       	push	r28
    2d7c:	df 93       	push	r29
    2d7e:	18 2f       	mov	r17, r24
    2d80:	09 2f       	mov	r16, r25
    2d82:	6b 01       	movw	r12, r22
    2d84:	f4 2e       	mov	r15, r20

	u8 local_u8Add = (copy_u16WordAdd >> 8) | EEPROM_FIXED_ADDRESS ;
	TWI_voidSendStartCondition();
    2d86:	0e 94 b9 09 	call	0x1372	; 0x1372 <TWI_voidSendStartCondition>
	TWI_voidSendSlaveAdd_WriteRequest(local_u8Add);
    2d8a:	80 2f       	mov	r24, r16
    2d8c:	80 65       	ori	r24, 0x50	; 80
    2d8e:	0e 94 e6 09 	call	0x13cc	; 0x13cc <TWI_voidSendSlaveAdd_WriteRequest>

	TWI_voidWriteMasterDataByte((u8)copy_u16WordAdd);
    2d92:	81 2f       	mov	r24, r17
    2d94:	0e 94 1c 0a 	call	0x1438	; 0x1438 <TWI_voidWriteMasterDataByte>
	for (int i = 0; i <copy_u8Size ; i++ )
    2d98:	cf 2d       	mov	r28, r15
    2d9a:	d0 e0       	ldi	r29, 0x00	; 0
    2d9c:	1c 16       	cp	r1, r28
    2d9e:	1d 06       	cpc	r1, r29
    2da0:	6c f4       	brge	.+26     	; 0x2dbc <EEPROM_voidWrite_Page+0x4c>
    2da2:	00 e0       	ldi	r16, 0x00	; 0
    2da4:	10 e0       	ldi	r17, 0x00	; 0
		{
			TWI_voidWriteMasterDataByte(copy_u8Data[i]);
    2da6:	f6 01       	movw	r30, r12
    2da8:	e0 0f       	add	r30, r16
    2daa:	f1 1f       	adc	r31, r17
    2dac:	80 81       	ld	r24, Z
    2dae:	0e 94 1c 0a 	call	0x1438	; 0x1438 <TWI_voidWriteMasterDataByte>
	u8 local_u8Add = (copy_u16WordAdd >> 8) | EEPROM_FIXED_ADDRESS ;
	TWI_voidSendStartCondition();
	TWI_voidSendSlaveAdd_WriteRequest(local_u8Add);

	TWI_voidWriteMasterDataByte((u8)copy_u16WordAdd);
	for (int i = 0; i <copy_u8Size ; i++ )
    2db2:	0f 5f       	subi	r16, 0xFF	; 255
    2db4:	1f 4f       	sbci	r17, 0xFF	; 255
    2db6:	0c 17       	cp	r16, r28
    2db8:	1d 07       	cpc	r17, r29
    2dba:	ac f3       	brlt	.-22     	; 0x2da6 <EEPROM_voidWrite_Page+0x36>
		{
			TWI_voidWriteMasterDataByte(copy_u8Data[i]);
		}

	TWI_voidSendStopCondition();
    2dbc:	0e 94 cb 09 	call	0x1396	; 0x1396 <TWI_voidSendStopCondition>
    2dc0:	80 e2       	ldi	r24, 0x20	; 32
    2dc2:	9e e4       	ldi	r25, 0x4E	; 78
    2dc4:	01 97       	sbiw	r24, 0x01	; 1
    2dc6:	f1 f7       	brne	.-4      	; 0x2dc4 <EEPROM_voidWrite_Page+0x54>
	_delay_ms(5);	// delay to eeprom to store the data
}
    2dc8:	df 91       	pop	r29
    2dca:	cf 91       	pop	r28
    2dcc:	1f 91       	pop	r17
    2dce:	0f 91       	pop	r16
    2dd0:	ff 90       	pop	r15
    2dd2:	df 90       	pop	r13
    2dd4:	cf 90       	pop	r12
    2dd6:	08 95       	ret

00002dd8 <EEPROM_voidWrite_Byte>:
{
	TWI_voidInitMaster(255);
}

void EEPROM_voidWrite_Byte(u16 copy_u16WordAdd, u8 copy_u8Data)
{
    2dd8:	ff 92       	push	r15
    2dda:	0f 93       	push	r16
    2ddc:	1f 93       	push	r17
    2dde:	18 2f       	mov	r17, r24
    2de0:	09 2f       	mov	r16, r25
    2de2:	f6 2e       	mov	r15, r22
	u8 local_u8Add = (copy_u16WordAdd >> 8) | EEPROM_FIXED_ADDRESS ;
	TWI_voidSendStartCondition();
    2de4:	0e 94 b9 09 	call	0x1372	; 0x1372 <TWI_voidSendStartCondition>
	TWI_voidSendSlaveAdd_WriteRequest(local_u8Add);
    2de8:	80 2f       	mov	r24, r16
    2dea:	80 65       	ori	r24, 0x50	; 80
    2dec:	0e 94 e6 09 	call	0x13cc	; 0x13cc <TWI_voidSendSlaveAdd_WriteRequest>

	TWI_voidWriteMasterDataByte((u8)copy_u16WordAdd);
    2df0:	81 2f       	mov	r24, r17
    2df2:	0e 94 1c 0a 	call	0x1438	; 0x1438 <TWI_voidWriteMasterDataByte>
	TWI_voidWriteMasterDataByte(copy_u8Data);
    2df6:	8f 2d       	mov	r24, r15
    2df8:	0e 94 1c 0a 	call	0x1438	; 0x1438 <TWI_voidWriteMasterDataByte>
	TWI_voidSendStopCondition();
    2dfc:	0e 94 cb 09 	call	0x1396	; 0x1396 <TWI_voidSendStopCondition>
    2e00:	80 e2       	ldi	r24, 0x20	; 32
    2e02:	9e e4       	ldi	r25, 0x4E	; 78
    2e04:	01 97       	sbiw	r24, 0x01	; 1
    2e06:	f1 f7       	brne	.-4      	; 0x2e04 <EEPROM_voidWrite_Byte+0x2c>
	_delay_ms(5);	// delay to eeprom to store the data
}
    2e08:	1f 91       	pop	r17
    2e0a:	0f 91       	pop	r16
    2e0c:	ff 90       	pop	r15
    2e0e:	08 95       	ret

00002e10 <EEPROM_voidRead_Byte>:

void EEPROM_voidRead_Byte(u16 copy_u16WordAdd, u8 *copy_u8PtrReceivedData)
{
    2e10:	0f 93       	push	r16
    2e12:	1f 93       	push	r17
    2e14:	cf 93       	push	r28
    2e16:	df 93       	push	r29
    2e18:	08 2f       	mov	r16, r24
    2e1a:	eb 01       	movw	r28, r22
	if(copy_u8PtrReceivedData != NULL)
    2e1c:	61 15       	cp	r22, r1
    2e1e:	71 05       	cpc	r23, r1
    2e20:	c1 f0       	breq	.+48     	; 0x2e52 <EEPROM_voidRead_Byte+0x42>
	{
		// CLR_BIT(_TWCR, _TWEA);
		u8 local_u8Add = (copy_u16WordAdd >> 8) | EEPROM_FIXED_ADDRESS ;
    2e22:	19 2f       	mov	r17, r25
    2e24:	10 65       	ori	r17, 0x50	; 80
		TWI_voidSendStartCondition();
    2e26:	0e 94 b9 09 	call	0x1372	; 0x1372 <TWI_voidSendStartCondition>
		TWI_voidSendSlaveAdd_WriteRequest(local_u8Add);
    2e2a:	81 2f       	mov	r24, r17
    2e2c:	0e 94 e6 09 	call	0x13cc	; 0x13cc <TWI_voidSendSlaveAdd_WriteRequest>
		TWI_voidWriteMasterDataByte((u8)copy_u16WordAdd);
    2e30:	80 2f       	mov	r24, r16
    2e32:	0e 94 1c 0a 	call	0x1438	; 0x1438 <TWI_voidWriteMasterDataByte>

		TWI_voidSendReapeatedStartCondition();
    2e36:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <TWI_voidSendReapeatedStartCondition>

		TWI_voidSendSlaveAdd_ReadRequest(local_u8Add);
    2e3a:	81 2f       	mov	r24, r17
    2e3c:	0e 94 01 0a 	call	0x1402	; 0x1402 <TWI_voidSendSlaveAdd_ReadRequest>

		TWI_voidReadMasterDataByteNACK(copy_u8PtrReceivedData);
    2e40:	ce 01       	movw	r24, r28
    2e42:	0e 94 2c 0a 	call	0x1458	; 0x1458 <TWI_voidReadMasterDataByteNACK>

		TWI_voidSendStopCondition();
    2e46:	0e 94 cb 09 	call	0x1396	; 0x1396 <TWI_voidSendStopCondition>
    2e4a:	80 e2       	ldi	r24, 0x20	; 32
    2e4c:	9e e4       	ldi	r25, 0x4E	; 78
    2e4e:	01 97       	sbiw	r24, 0x01	; 1
    2e50:	f1 f7       	brne	.-4      	; 0x2e4e <EEPROM_voidRead_Byte+0x3e>

		_delay_ms(5);	// delay to eeprom to store the data
	}
}
    2e52:	df 91       	pop	r29
    2e54:	cf 91       	pop	r28
    2e56:	1f 91       	pop	r17
    2e58:	0f 91       	pop	r16
    2e5a:	08 95       	ret

00002e5c <EEPROM_Init>:
#include <util/delay.h>

/* ----------------- Section : Software Interfaces Implementation -----------------*/
void EEPROM_Init(void)
{
	TWI_voidInitMaster(255);
    2e5c:	8f ef       	ldi	r24, 0xFF	; 255
    2e5e:	0e 94 a2 09 	call	0x1344	; 0x1344 <TWI_voidInitMaster>
}
    2e62:	08 95       	ret

00002e64 <DCM_voidOff>:
 * @param	void
 * @return	void
 */
void DCM_voidOff(void)
{
	TMR0_voidStop();
    2e64:	0e 94 91 0b 	call	0x1722	; 0x1722 <TMR0_voidStop>
	timerInitialized =0;
    2e68:	10 92 d7 01 	sts	0x01D7, r1
	Dio_WriteChannel(DC_MOTOR_EN_PIN, 0);
    2e6c:	8e e0       	ldi	r24, 0x0E	; 14
    2e6e:	60 e0       	ldi	r22, 0x00	; 0
    2e70:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
}
    2e74:	08 95       	ret

00002e76 <DCM_voidControlSpeed>:
 * DCM_voidControlSpeed : control the speed of a DC motor connected to an H-Bridge motor driver using PWM from TIMERS
 * @param	Copy_u8Speed --> [0 : 100] the desired speed of the motor. Ranges from 0  to 100
 * @return	void
 */
void DCM_voidControlSpeed(u8 Copy_u8Speed)
{
    2e76:	1f 93       	push	r17
    2e78:	18 2f       	mov	r17, r24
	if (timerInitialized == 0)
    2e7a:	80 91 d7 01 	lds	r24, 0x01D7
    2e7e:	88 23       	and	r24, r24
    2e80:	29 f4       	brne	.+10     	; 0x2e8c <DCM_voidControlSpeed+0x16>
	{
		TMR0_voidInit();
    2e82:	0e 94 c1 0b 	call	0x1782	; 0x1782 <TMR0_voidInit>
		timerInitialized = 1;  // Set the flag to indicate initialization
    2e86:	81 e0       	ldi	r24, 0x01	; 1
    2e88:	80 93 d7 01 	sts	0x01D7, r24
	}
	TMR0_voidSetDutyCycle(Copy_u8Speed);
    2e8c:	81 2f       	mov	r24, r17
    2e8e:	0e 94 b2 0b 	call	0x1764	; 0x1764 <TMR0_voidSetDutyCycle>
	TMR0_voidStart();
    2e92:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <TMR0_voidStart>
}
    2e96:	1f 91       	pop	r17
    2e98:	08 95       	ret

00002e9a <DCM_voidOn>:
 * DCM_voidOn : used to turn on a DC motor using an H-Bridge motor driver on FARES PCB Kit
 * @param	Copy_u8Direction --> the desired direction of the motor --> [DCM_CLOCK_WISE or DCM_COUNTER_CLOCK_WISE]
 * @return	void
 */
void DCM_voidOn(u8 Copy_u8Direction)
{
    2e9a:	1f 93       	push	r17
    2e9c:	18 2f       	mov	r17, r24
	Dio_WriteChannel(DC_MOTOR_EN_PIN, 1);
    2e9e:	8e e0       	ldi	r24, 0x0E	; 14
    2ea0:	61 e0       	ldi	r22, 0x01	; 1
    2ea2:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	DCM_voidControlSpeed(100);
    2ea6:	84 e6       	ldi	r24, 0x64	; 100
    2ea8:	0e 94 3b 17 	call	0x2e76	; 0x2e76 <DCM_voidControlSpeed>
	switch(Copy_u8Direction)
    2eac:	11 30       	cpi	r17, 0x01	; 1
    2eae:	19 f0       	breq	.+6      	; 0x2eb6 <DCM_voidOn+0x1c>
    2eb0:	12 30       	cpi	r17, 0x02	; 2
    2eb2:	51 f4       	brne	.+20     	; 0x2ec8 <DCM_voidOn+0x2e>
    2eb4:	05 c0       	rjmp	.+10     	; 0x2ec0 <DCM_voidOn+0x26>
	{
	case DCM_CLOCK_WISE:
		Dio_WriteChannel(DC_MOTOR_DIR_PIN, 1);
    2eb6:	8d e0       	ldi	r24, 0x0D	; 13
    2eb8:	61 e0       	ldi	r22, 0x01	; 1
    2eba:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    2ebe:	04 c0       	rjmp	.+8      	; 0x2ec8 <DCM_voidOn+0x2e>
		break;
	case DCM_COUNTER_CLOCK_WISE:
		Dio_WriteChannel(DC_MOTOR_DIR_PIN, 0);
    2ec0:	8d e0       	ldi	r24, 0x0D	; 13
    2ec2:	60 e0       	ldi	r22, 0x00	; 0
    2ec4:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
		break;
	default: break;
	}
}
    2ec8:	1f 91       	pop	r17
    2eca:	08 95       	ret

00002ecc <Segment_Write>:
 * @param	1- num : which is the number to display
 * 			2- seg_index : which is the number of the segment 0, 1, 2 or 3
 * @return	void
 */
void Segment_Write(u8 num, u8 seg_index)
{
    2ecc:	1f 93       	push	r17
    2ece:	18 2f       	mov	r17, r24
	switch(seg_index)
    2ed0:	61 30       	cpi	r22, 0x01	; 1
    2ed2:	c9 f0       	breq	.+50     	; 0x2f06 <Segment_Write+0x3a>
    2ed4:	61 30       	cpi	r22, 0x01	; 1
    2ed6:	30 f0       	brcs	.+12     	; 0x2ee4 <Segment_Write+0x18>
    2ed8:	62 30       	cpi	r22, 0x02	; 2
    2eda:	31 f1       	breq	.+76     	; 0x2f28 <Segment_Write+0x5c>
    2edc:	63 30       	cpi	r22, 0x03	; 3
    2ede:	09 f0       	breq	.+2      	; 0x2ee2 <Segment_Write+0x16>
    2ee0:	44 c0       	rjmp	.+136    	; 0x2f6a <Segment_Write+0x9e>
    2ee2:	33 c0       	rjmp	.+102    	; 0x2f4a <Segment_Write+0x7e>
	{
	case 0:
		CLR_BIT(_PORTA, 3);
    2ee4:	eb e3       	ldi	r30, 0x3B	; 59
    2ee6:	f0 e0       	ldi	r31, 0x00	; 0
    2ee8:	80 81       	ld	r24, Z
    2eea:	87 7f       	andi	r24, 0xF7	; 247
    2eec:	80 83       	st	Z, r24
		SET_BIT(_PORTA, 2);
    2eee:	80 81       	ld	r24, Z
    2ef0:	84 60       	ori	r24, 0x04	; 4
    2ef2:	80 83       	st	Z, r24
		SET_BIT(_PORTB, 5);
    2ef4:	e8 e3       	ldi	r30, 0x38	; 56
    2ef6:	f0 e0       	ldi	r31, 0x00	; 0
    2ef8:	80 81       	ld	r24, Z
    2efa:	80 62       	ori	r24, 0x20	; 32
    2efc:	80 83       	st	Z, r24
		SET_BIT(_PORTB, 6);
    2efe:	80 81       	ld	r24, Z
    2f00:	80 64       	ori	r24, 0x40	; 64
    2f02:	80 83       	st	Z, r24
    2f04:	32 c0       	rjmp	.+100    	; 0x2f6a <Segment_Write+0x9e>
		break;
	case 1:
		SET_BIT(_PORTA, 3);
    2f06:	eb e3       	ldi	r30, 0x3B	; 59
    2f08:	f0 e0       	ldi	r31, 0x00	; 0
    2f0a:	80 81       	ld	r24, Z
    2f0c:	88 60       	ori	r24, 0x08	; 8
    2f0e:	80 83       	st	Z, r24
		CLR_BIT(_PORTA, 2);
    2f10:	80 81       	ld	r24, Z
    2f12:	8b 7f       	andi	r24, 0xFB	; 251
    2f14:	80 83       	st	Z, r24
		SET_BIT(_PORTB, 5);
    2f16:	e8 e3       	ldi	r30, 0x38	; 56
    2f18:	f0 e0       	ldi	r31, 0x00	; 0
    2f1a:	80 81       	ld	r24, Z
    2f1c:	80 62       	ori	r24, 0x20	; 32
    2f1e:	80 83       	st	Z, r24
		SET_BIT(_PORTB, 6);
    2f20:	80 81       	ld	r24, Z
    2f22:	80 64       	ori	r24, 0x40	; 64
    2f24:	80 83       	st	Z, r24
    2f26:	21 c0       	rjmp	.+66     	; 0x2f6a <Segment_Write+0x9e>
		break;
	case 2:
		SET_BIT(_PORTA, 3);
    2f28:	eb e3       	ldi	r30, 0x3B	; 59
    2f2a:	f0 e0       	ldi	r31, 0x00	; 0
    2f2c:	80 81       	ld	r24, Z
    2f2e:	88 60       	ori	r24, 0x08	; 8
    2f30:	80 83       	st	Z, r24
		SET_BIT(_PORTA, 2);
    2f32:	80 81       	ld	r24, Z
    2f34:	84 60       	ori	r24, 0x04	; 4
    2f36:	80 83       	st	Z, r24
		CLR_BIT(_PORTB, 5);
    2f38:	e8 e3       	ldi	r30, 0x38	; 56
    2f3a:	f0 e0       	ldi	r31, 0x00	; 0
    2f3c:	80 81       	ld	r24, Z
    2f3e:	8f 7d       	andi	r24, 0xDF	; 223
    2f40:	80 83       	st	Z, r24
		SET_BIT(_PORTB, 6);
    2f42:	80 81       	ld	r24, Z
    2f44:	80 64       	ori	r24, 0x40	; 64
    2f46:	80 83       	st	Z, r24
    2f48:	10 c0       	rjmp	.+32     	; 0x2f6a <Segment_Write+0x9e>
		break;
	case 3:
		SET_BIT(_PORTA, 3);
    2f4a:	eb e3       	ldi	r30, 0x3B	; 59
    2f4c:	f0 e0       	ldi	r31, 0x00	; 0
    2f4e:	80 81       	ld	r24, Z
    2f50:	88 60       	ori	r24, 0x08	; 8
    2f52:	80 83       	st	Z, r24
		SET_BIT(_PORTA, 2);
    2f54:	80 81       	ld	r24, Z
    2f56:	84 60       	ori	r24, 0x04	; 4
    2f58:	80 83       	st	Z, r24
		SET_BIT(_PORTB, 5);
    2f5a:	e8 e3       	ldi	r30, 0x38	; 56
    2f5c:	f0 e0       	ldi	r31, 0x00	; 0
    2f5e:	80 81       	ld	r24, Z
    2f60:	80 62       	ori	r24, 0x20	; 32
    2f62:	80 83       	st	Z, r24
		CLR_BIT(_PORTB, 6);
    2f64:	80 81       	ld	r24, Z
    2f66:	8f 7b       	andi	r24, 0xBF	; 191
    2f68:	80 83       	st	Z, r24
		break;
	}
	if (num >9){
    2f6a:	1a 30       	cpi	r17, 0x0A	; 10
    2f6c:	d0 f4       	brcc	.+52     	; 0x2fa2 <Segment_Write+0xd6>
		return;
	}
	else{
		Dio_WriteChannel(PB_0 , (num & 0x01));
    2f6e:	61 2f       	mov	r22, r17
    2f70:	61 70       	andi	r22, 0x01	; 1
    2f72:	88 e0       	ldi	r24, 0x08	; 8
    2f74:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
		Dio_WriteChannel(PB_1 , ((num>>1) & 0x01));
    2f78:	61 2f       	mov	r22, r17
    2f7a:	66 95       	lsr	r22
    2f7c:	61 70       	andi	r22, 0x01	; 1
    2f7e:	89 e0       	ldi	r24, 0x09	; 9
    2f80:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
		Dio_WriteChannel(PB_2 , ((num>>2) & 0x01));
    2f84:	61 2f       	mov	r22, r17
    2f86:	66 95       	lsr	r22
    2f88:	66 95       	lsr	r22
    2f8a:	61 70       	andi	r22, 0x01	; 1
    2f8c:	8a e0       	ldi	r24, 0x0A	; 10
    2f8e:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
		Dio_WriteChannel(PB_4 , ((num>>3) & 0x01));
    2f92:	61 2f       	mov	r22, r17
    2f94:	66 95       	lsr	r22
    2f96:	66 95       	lsr	r22
    2f98:	66 95       	lsr	r22
    2f9a:	61 70       	andi	r22, 0x01	; 1
    2f9c:	8c e0       	ldi	r24, 0x0C	; 12
    2f9e:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	}
}
    2fa2:	1f 91       	pop	r17
    2fa4:	08 95       	ret

00002fa6 <main>:

u8 Received = 0;

u16 distanceArray[4] = { 0 };

int main() {
    2fa6:	4f 92       	push	r4
    2fa8:	5f 92       	push	r5
    2faa:	6f 92       	push	r6
    2fac:	7f 92       	push	r7
    2fae:	8f 92       	push	r8
    2fb0:	9f 92       	push	r9
    2fb2:	af 92       	push	r10
    2fb4:	bf 92       	push	r11
    2fb6:	cf 92       	push	r12
    2fb8:	df 92       	push	r13
    2fba:	ef 92       	push	r14
    2fbc:	ff 92       	push	r15
    2fbe:	0f 93       	push	r16
    2fc0:	1f 93       	push	r17
    2fc2:	cf 93       	push	r28
    2fc4:	df 93       	push	r29
	Port_Init(pins);
    2fc6:	87 e7       	ldi	r24, 0x77	; 119
    2fc8:	91 e0       	ldi	r25, 0x01	; 1
    2fca:	0e 94 b7 0c 	call	0x196e	; 0x196e <Port_Init>
	GI_voidEnable();
    2fce:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <GI_voidEnable>
	lcd4_Init();
    2fd2:	0e 94 37 14 	call	0x286e	; 0x286e <lcd4_Init>
	ICU_voidInit();
    2fd6:	0e 94 22 0e 	call	0x1c44	; 0x1c44 <ICU_voidInit>
	SPI_voidInit();
    2fda:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <SPI_voidInit>
    2fde:	10 e0       	ldi	r17, 0x00	; 0
				Ultra_Sonic_void_trigger(PC_0);
				distanceArray[0] = Ultra_Sonic_Distance_in_cm();
				break;
			case 1:
				Ultra_Sonic_void_trigger(PC_1);
				distanceArray[1] = Ultra_Sonic_Distance_in_cm();
    2fe0:	0f 2e       	mov	r0, r31
    2fe2:	fb ed       	ldi	r31, 0xDB	; 219
    2fe4:	8f 2e       	mov	r8, r31
    2fe6:	f1 e0       	ldi	r31, 0x01	; 1
    2fe8:	9f 2e       	mov	r9, r31
    2fea:	f0 2d       	mov	r31, r0
	while (1) {
		for (u8 channel = 0; channel < 4; channel++) {
			switch (channel) {
			case 0:
				Ultra_Sonic_void_trigger(PC_0);
				distanceArray[0] = Ultra_Sonic_Distance_in_cm();
    2fec:	c9 ed       	ldi	r28, 0xD9	; 217
    2fee:	d1 e0       	ldi	r29, 0x01	; 1
				Ultra_Sonic_void_trigger(PC_1);
				distanceArray[1] = Ultra_Sonic_Distance_in_cm();
				break;
			case 2:
				Ultra_Sonic_void_trigger(PC_2);
				distanceArray[2] = Ultra_Sonic_Distance_in_cm();
    2ff0:	0f 2e       	mov	r0, r31
    2ff2:	fd ed       	ldi	r31, 0xDD	; 221
    2ff4:	6f 2e       	mov	r6, r31
    2ff6:	f1 e0       	ldi	r31, 0x01	; 1
    2ff8:	7f 2e       	mov	r7, r31
    2ffa:	f0 2d       	mov	r31, r0
				break;
			case 3:
				Ultra_Sonic_void_trigger(PC_3);
				distanceArray[3] = Ultra_Sonic_Distance_in_cm();
    2ffc:	0f 2e       	mov	r0, r31
    2ffe:	ff ed       	ldi	r31, 0xDF	; 223
    3000:	4f 2e       	mov	r4, r31
    3002:	f1 e0       	ldi	r31, 0x01	; 1
    3004:	5f 2e       	mov	r5, r31
    3006:	f0 2d       	mov	r31, r0
		}
		lcd4_CLR();
		lcd4_set_cursor(1, 1);
		lcd4_disply_num(distanceArray[0]);
		lcd4_set_cursor(2, 1);
		lcd4_disply_num(distanceArray[1]);
    3008:	aa 24       	eor	r10, r10
    300a:	bb 24       	eor	r11, r11
    300c:	68 94       	set
    300e:	a1 f8       	bld	r10, 1
    3010:	ac 0e       	add	r10, r28
    3012:	bd 1e       	adc	r11, r29
		lcd4_set_cursor(3, 1);
		lcd4_disply_num(distanceArray[2]);
    3014:	cc 24       	eor	r12, r12
    3016:	dd 24       	eor	r13, r13
    3018:	68 94       	set
    301a:	c2 f8       	bld	r12, 2
    301c:	cc 0e       	add	r12, r28
    301e:	dd 1e       	adc	r13, r29
		lcd4_set_cursor(4, 1);
		lcd4_disply_num(distanceArray[3]);
    3020:	0f 2e       	mov	r0, r31
    3022:	f6 e0       	ldi	r31, 0x06	; 6
    3024:	ef 2e       	mov	r14, r31
    3026:	ff 24       	eor	r15, r15
    3028:	f0 2d       	mov	r31, r0
    302a:	ec 0e       	add	r14, r28
    302c:	fd 1e       	adc	r15, r29
    302e:	00 e0       	ldi	r16, 0x00	; 0
    3030:	2c c0       	rjmp	.+88     	; 0x308a <main+0xe4>
	ICU_voidInit();
	SPI_voidInit();

	while (1) {
		for (u8 channel = 0; channel < 4; channel++) {
			switch (channel) {
    3032:	11 30       	cpi	r17, 0x01	; 1
    3034:	79 f0       	breq	.+30     	; 0x3054 <main+0xae>
    3036:	11 30       	cpi	r17, 0x01	; 1
    3038:	28 f0       	brcs	.+10     	; 0x3044 <main+0x9e>
    303a:	12 30       	cpi	r17, 0x02	; 2
    303c:	a1 f0       	breq	.+40     	; 0x3066 <main+0xc0>
    303e:	13 30       	cpi	r17, 0x03	; 3
    3040:	19 f5       	brne	.+70     	; 0x3088 <main+0xe2>
    3042:	1a c0       	rjmp	.+52     	; 0x3078 <main+0xd2>
			case 0:
				Ultra_Sonic_void_trigger(PC_0);
    3044:	80 e1       	ldi	r24, 0x10	; 16
    3046:	0e 94 71 12 	call	0x24e2	; 0x24e2 <Ultra_Sonic_void_trigger>
				distanceArray[0] = Ultra_Sonic_Distance_in_cm();
    304a:	0e 94 66 12 	call	0x24cc	; 0x24cc <Ultra_Sonic_Distance_in_cm>
    304e:	99 83       	std	Y+1, r25	; 0x01
    3050:	88 83       	st	Y, r24
    3052:	1a c0       	rjmp	.+52     	; 0x3088 <main+0xe2>
				break;
			case 1:
				Ultra_Sonic_void_trigger(PC_1);
    3054:	81 e1       	ldi	r24, 0x11	; 17
    3056:	0e 94 71 12 	call	0x24e2	; 0x24e2 <Ultra_Sonic_void_trigger>
				distanceArray[1] = Ultra_Sonic_Distance_in_cm();
    305a:	0e 94 66 12 	call	0x24cc	; 0x24cc <Ultra_Sonic_Distance_in_cm>
    305e:	f4 01       	movw	r30, r8
    3060:	91 83       	std	Z+1, r25	; 0x01
    3062:	80 83       	st	Z, r24
    3064:	11 c0       	rjmp	.+34     	; 0x3088 <main+0xe2>
				break;
			case 2:
				Ultra_Sonic_void_trigger(PC_2);
    3066:	82 e1       	ldi	r24, 0x12	; 18
    3068:	0e 94 71 12 	call	0x24e2	; 0x24e2 <Ultra_Sonic_void_trigger>
				distanceArray[2] = Ultra_Sonic_Distance_in_cm();
    306c:	0e 94 66 12 	call	0x24cc	; 0x24cc <Ultra_Sonic_Distance_in_cm>
    3070:	f3 01       	movw	r30, r6
    3072:	91 83       	std	Z+1, r25	; 0x01
    3074:	80 83       	st	Z, r24
    3076:	08 c0       	rjmp	.+16     	; 0x3088 <main+0xe2>
				break;
			case 3:
				Ultra_Sonic_void_trigger(PC_3);
    3078:	83 e1       	ldi	r24, 0x13	; 19
    307a:	0e 94 71 12 	call	0x24e2	; 0x24e2 <Ultra_Sonic_void_trigger>
				distanceArray[3] = Ultra_Sonic_Distance_in_cm();
    307e:	0e 94 66 12 	call	0x24cc	; 0x24cc <Ultra_Sonic_Distance_in_cm>
    3082:	f2 01       	movw	r30, r4
    3084:	91 83       	std	Z+1, r25	; 0x01
    3086:	80 83       	st	Z, r24
	lcd4_Init();
	ICU_voidInit();
	SPI_voidInit();

	while (1) {
		for (u8 channel = 0; channel < 4; channel++) {
    3088:	1f 5f       	subi	r17, 0xFF	; 255
    308a:	14 30       	cpi	r17, 0x04	; 4
    308c:	90 f2       	brcs	.-92     	; 0x3032 <main+0x8c>
				Ultra_Sonic_void_trigger(PC_3);
				distanceArray[3] = Ultra_Sonic_Distance_in_cm();
				break;
			}
		}
		lcd4_CLR();
    308e:	0e 94 31 14 	call	0x2862	; 0x2862 <lcd4_CLR>
		lcd4_set_cursor(1, 1);
    3092:	81 e0       	ldi	r24, 0x01	; 1
    3094:	61 e0       	ldi	r22, 0x01	; 1
    3096:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
		lcd4_disply_num(distanceArray[0]);
    309a:	88 81       	ld	r24, Y
    309c:	99 81       	ldd	r25, Y+1	; 0x01
    309e:	0e 94 80 15 	call	0x2b00	; 0x2b00 <lcd4_disply_num>
		lcd4_set_cursor(2, 1);
    30a2:	82 e0       	ldi	r24, 0x02	; 2
    30a4:	61 e0       	ldi	r22, 0x01	; 1
    30a6:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
		lcd4_disply_num(distanceArray[1]);
    30aa:	f5 01       	movw	r30, r10
    30ac:	80 81       	ld	r24, Z
    30ae:	91 81       	ldd	r25, Z+1	; 0x01
    30b0:	0e 94 80 15 	call	0x2b00	; 0x2b00 <lcd4_disply_num>
		lcd4_set_cursor(3, 1);
    30b4:	83 e0       	ldi	r24, 0x03	; 3
    30b6:	61 e0       	ldi	r22, 0x01	; 1
    30b8:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
		lcd4_disply_num(distanceArray[2]);
    30bc:	f6 01       	movw	r30, r12
    30be:	80 81       	ld	r24, Z
    30c0:	91 81       	ldd	r25, Z+1	; 0x01
    30c2:	0e 94 80 15 	call	0x2b00	; 0x2b00 <lcd4_disply_num>
		lcd4_set_cursor(4, 1);
    30c6:	84 e0       	ldi	r24, 0x04	; 4
    30c8:	61 e0       	ldi	r22, 0x01	; 1
    30ca:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
		lcd4_disply_num(distanceArray[3]);
    30ce:	f7 01       	movw	r30, r14
    30d0:	80 81       	ld	r24, Z
    30d2:	91 81       	ldd	r25, Z+1	; 0x01
    30d4:	0e 94 80 15 	call	0x2b00	; 0x2b00 <lcd4_disply_num>
    30d8:	10 2f       	mov	r17, r16
    30da:	d7 cf       	rjmp	.-82     	; 0x308a <main+0xe4>

000030dc <vPortFree>:
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
    30dc:	08 95       	ret

000030de <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
    30de:	10 92 e2 01 	sts	0x01E2, r1
    30e2:	10 92 e1 01 	sts	0x01E1, r1
}
    30e6:	08 95       	ret

000030e8 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    30e8:	80 91 e1 01 	lds	r24, 0x01E1
    30ec:	90 91 e2 01 	lds	r25, 0x01E2
    30f0:	2b ed       	ldi	r18, 0xDB	; 219
    30f2:	35 e0       	ldi	r19, 0x05	; 5
    30f4:	28 1b       	sub	r18, r24
    30f6:	39 0b       	sbc	r19, r25
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
}
    30f8:	82 2f       	mov	r24, r18
    30fa:	93 2f       	mov	r25, r19
    30fc:	08 95       	ret

000030fe <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    30fe:	cf 93       	push	r28
    3100:	df 93       	push	r29
    3102:	ec 01       	movw	r28, r24
            }
        }
    }
    #endif /* if ( portBYTE_ALIGNMENT != 1 ) */

    vTaskSuspendAll();
    3104:	0e 94 81 25 	call	0x4b02	; 0x4b02 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
    3108:	80 91 e3 01 	lds	r24, 0x01E3
    310c:	90 91 e4 01 	lds	r25, 0x01E4
    3110:	89 2b       	or	r24, r25
    3112:	31 f4       	brne	.+12     	; 0x3120 <pvPortMalloc+0x22>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    3114:	85 ee       	ldi	r24, 0xE5	; 229
    3116:	91 e0       	ldi	r25, 0x01	; 1
    3118:	90 93 e4 01 	sts	0x01E4, r25
    311c:	80 93 e3 01 	sts	0x01E3, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
    3120:	20 97       	sbiw	r28, 0x00	; 0
    3122:	d1 f0       	breq	.+52     	; 0x3158 <pvPortMalloc+0x5a>
    3124:	40 91 e1 01 	lds	r20, 0x01E1
    3128:	50 91 e2 01 	lds	r21, 0x01E2
    312c:	9e 01       	movw	r18, r28
    312e:	24 0f       	add	r18, r20
    3130:	35 1f       	adc	r19, r21
    3132:	85 e0       	ldi	r24, 0x05	; 5
    3134:	2b 3d       	cpi	r18, 0xDB	; 219
    3136:	38 07       	cpc	r19, r24
    3138:	78 f4       	brcc	.+30     	; 0x3158 <pvPortMalloc+0x5a>
    313a:	42 17       	cp	r20, r18
    313c:	53 07       	cpc	r21, r19
    313e:	60 f4       	brcc	.+24     	; 0x3158 <pvPortMalloc+0x5a>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
    3140:	80 91 e3 01 	lds	r24, 0x01E3
    3144:	90 91 e4 01 	lds	r25, 0x01E4
    3148:	ec 01       	movw	r28, r24
    314a:	c4 0f       	add	r28, r20
    314c:	d5 1f       	adc	r29, r21
            xNextFreeByte += xWantedSize;
    314e:	30 93 e2 01 	sts	0x01E2, r19
    3152:	20 93 e1 01 	sts	0x01E1, r18
    3156:	02 c0       	rjmp	.+4      	; 0x315c <pvPortMalloc+0x5e>
    3158:	c0 e0       	ldi	r28, 0x00	; 0
    315a:	d0 e0       	ldi	r29, 0x00	; 0
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    315c:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>
        }
    }
    #endif

    return pvReturn;
}
    3160:	8c 2f       	mov	r24, r28
    3162:	9d 2f       	mov	r25, r29
    3164:	df 91       	pop	r29
    3166:	cf 91       	pop	r28
    3168:	08 95       	ret

0000316a <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    316a:	fc 01       	movw	r30, r24
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    316c:	91 e1       	ldi	r25, 0x11	; 17
    316e:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    3170:	22 e2       	ldi	r18, 0x22	; 34
    3172:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    3174:	83 e3       	ldi	r24, 0x33	; 51
    3176:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    3178:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    317a:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    317c:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    317e:	80 e8       	ldi	r24, 0x80	; 128
    3180:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    3182:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    3184:	82 e0       	ldi	r24, 0x02	; 2
    3186:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    3188:	83 e0       	ldi	r24, 0x03	; 3
    318a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    318c:	84 e0       	ldi	r24, 0x04	; 4
    318e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    3190:	85 e0       	ldi	r24, 0x05	; 5
    3192:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    3194:	86 e0       	ldi	r24, 0x06	; 6
    3196:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    3198:	87 e0       	ldi	r24, 0x07	; 7
    319a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    319c:	88 e0       	ldi	r24, 0x08	; 8
    319e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    31a0:	89 e0       	ldi	r24, 0x09	; 9
    31a2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    31a4:	80 e1       	ldi	r24, 0x10	; 16
    31a6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    31a8:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    31aa:	82 e1       	ldi	r24, 0x12	; 18
    31ac:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    31ae:	83 e1       	ldi	r24, 0x13	; 19
    31b0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    31b2:	84 e1       	ldi	r24, 0x14	; 20
    31b4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    31b6:	85 e1       	ldi	r24, 0x15	; 21
    31b8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    31ba:	86 e1       	ldi	r24, 0x16	; 22
    31bc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    31be:	87 e1       	ldi	r24, 0x17	; 23
    31c0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    31c2:	88 e1       	ldi	r24, 0x18	; 24
    31c4:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    31c6:	89 e1       	ldi	r24, 0x19	; 25
    31c8:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    31ca:	80 e2       	ldi	r24, 0x20	; 32
    31cc:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    31ce:	81 e2       	ldi	r24, 0x21	; 33
    31d0:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    31d2:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    31d4:	83 e2       	ldi	r24, 0x23	; 35
    31d6:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    31d8:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    31da:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    31dc:	86 e2       	ldi	r24, 0x26	; 38
    31de:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    31e0:	87 e2       	ldi	r24, 0x27	; 39
    31e2:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    31e4:	88 e2       	ldi	r24, 0x28	; 40
    31e6:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    31e8:	89 e2       	ldi	r24, 0x29	; 41
    31ea:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    31ec:	80 e3       	ldi	r24, 0x30	; 48
    31ee:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    31f0:	81 e3       	ldi	r24, 0x31	; 49
    31f2:	82 93       	st	-Z, r24
    31f4:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    31f6:	8e 2f       	mov	r24, r30
    31f8:	9f 2f       	mov	r25, r31
    31fa:	08 95       	ret

000031fc <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    31fc:	08 95       	ret

000031fe <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    31fe:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    3200:	89 ef       	ldi	r24, 0xF9	; 249
    3202:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    3204:	8b e0       	ldi	r24, 0x0B	; 11
    3206:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    3208:	e9 e5       	ldi	r30, 0x59	; 89
    320a:	f0 e0       	ldi	r31, 0x00	; 0
    320c:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    320e:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    3210:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    3212:	a0 91 c1 07 	lds	r26, 0x07C1
    3216:	b0 91 c2 07 	lds	r27, 0x07C2
    321a:	cd 91       	ld	r28, X+
    321c:	cd bf       	out	0x3d, r28	; 61
    321e:	dd 91       	ld	r29, X+
    3220:	de bf       	out	0x3e, r29	; 62
    3222:	ff 91       	pop	r31
    3224:	ef 91       	pop	r30
    3226:	df 91       	pop	r29
    3228:	cf 91       	pop	r28
    322a:	bf 91       	pop	r27
    322c:	af 91       	pop	r26
    322e:	9f 91       	pop	r25
    3230:	8f 91       	pop	r24
    3232:	7f 91       	pop	r23
    3234:	6f 91       	pop	r22
    3236:	5f 91       	pop	r21
    3238:	4f 91       	pop	r20
    323a:	3f 91       	pop	r19
    323c:	2f 91       	pop	r18
    323e:	1f 91       	pop	r17
    3240:	0f 91       	pop	r16
    3242:	ff 90       	pop	r15
    3244:	ef 90       	pop	r14
    3246:	df 90       	pop	r13
    3248:	cf 90       	pop	r12
    324a:	bf 90       	pop	r11
    324c:	af 90       	pop	r10
    324e:	9f 90       	pop	r9
    3250:	8f 90       	pop	r8
    3252:	7f 90       	pop	r7
    3254:	6f 90       	pop	r6
    3256:	5f 90       	pop	r5
    3258:	4f 90       	pop	r4
    325a:	3f 90       	pop	r3
    325c:	2f 90       	pop	r2
    325e:	1f 90       	pop	r1
    3260:	0f 90       	pop	r0
    3262:	0f be       	out	0x3f, r0	; 63
    3264:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    3266:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    3268:	81 e0       	ldi	r24, 0x01	; 1
    326a:	08 95       	ret

0000326c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    326c:	0f 92       	push	r0
    326e:	0f b6       	in	r0, 0x3f	; 63
    3270:	f8 94       	cli
    3272:	0f 92       	push	r0
    3274:	1f 92       	push	r1
    3276:	11 24       	eor	r1, r1
    3278:	2f 92       	push	r2
    327a:	3f 92       	push	r3
    327c:	4f 92       	push	r4
    327e:	5f 92       	push	r5
    3280:	6f 92       	push	r6
    3282:	7f 92       	push	r7
    3284:	8f 92       	push	r8
    3286:	9f 92       	push	r9
    3288:	af 92       	push	r10
    328a:	bf 92       	push	r11
    328c:	cf 92       	push	r12
    328e:	df 92       	push	r13
    3290:	ef 92       	push	r14
    3292:	ff 92       	push	r15
    3294:	0f 93       	push	r16
    3296:	1f 93       	push	r17
    3298:	2f 93       	push	r18
    329a:	3f 93       	push	r19
    329c:	4f 93       	push	r20
    329e:	5f 93       	push	r21
    32a0:	6f 93       	push	r22
    32a2:	7f 93       	push	r23
    32a4:	8f 93       	push	r24
    32a6:	9f 93       	push	r25
    32a8:	af 93       	push	r26
    32aa:	bf 93       	push	r27
    32ac:	cf 93       	push	r28
    32ae:	df 93       	push	r29
    32b0:	ef 93       	push	r30
    32b2:	ff 93       	push	r31
    32b4:	a0 91 c1 07 	lds	r26, 0x07C1
    32b8:	b0 91 c2 07 	lds	r27, 0x07C2
    32bc:	0d b6       	in	r0, 0x3d	; 61
    32be:	0d 92       	st	X+, r0
    32c0:	0e b6       	in	r0, 0x3e	; 62
    32c2:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    32c4:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <xTaskIncrementTick>
    32c8:	88 23       	and	r24, r24
    32ca:	11 f0       	breq	.+4      	; 0x32d0 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    32cc:	0e 94 a9 25 	call	0x4b52	; 0x4b52 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    32d0:	a0 91 c1 07 	lds	r26, 0x07C1
    32d4:	b0 91 c2 07 	lds	r27, 0x07C2
    32d8:	cd 91       	ld	r28, X+
    32da:	cd bf       	out	0x3d, r28	; 61
    32dc:	dd 91       	ld	r29, X+
    32de:	de bf       	out	0x3e, r29	; 62
    32e0:	ff 91       	pop	r31
    32e2:	ef 91       	pop	r30
    32e4:	df 91       	pop	r29
    32e6:	cf 91       	pop	r28
    32e8:	bf 91       	pop	r27
    32ea:	af 91       	pop	r26
    32ec:	9f 91       	pop	r25
    32ee:	8f 91       	pop	r24
    32f0:	7f 91       	pop	r23
    32f2:	6f 91       	pop	r22
    32f4:	5f 91       	pop	r21
    32f6:	4f 91       	pop	r20
    32f8:	3f 91       	pop	r19
    32fa:	2f 91       	pop	r18
    32fc:	1f 91       	pop	r17
    32fe:	0f 91       	pop	r16
    3300:	ff 90       	pop	r15
    3302:	ef 90       	pop	r14
    3304:	df 90       	pop	r13
    3306:	cf 90       	pop	r12
    3308:	bf 90       	pop	r11
    330a:	af 90       	pop	r10
    330c:	9f 90       	pop	r9
    330e:	8f 90       	pop	r8
    3310:	7f 90       	pop	r7
    3312:	6f 90       	pop	r6
    3314:	5f 90       	pop	r5
    3316:	4f 90       	pop	r4
    3318:	3f 90       	pop	r3
    331a:	2f 90       	pop	r2
    331c:	1f 90       	pop	r1
    331e:	0f 90       	pop	r0
    3320:	0f be       	out	0x3f, r0	; 63
    3322:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3324:	08 95       	ret

00003326 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    3326:	0e 94 36 19 	call	0x326c	; 0x326c <vPortYieldFromTick>
		asm volatile ( "reti" );
    332a:	18 95       	reti

0000332c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    332c:	0f 92       	push	r0
    332e:	0f b6       	in	r0, 0x3f	; 63
    3330:	f8 94       	cli
    3332:	0f 92       	push	r0
    3334:	1f 92       	push	r1
    3336:	11 24       	eor	r1, r1
    3338:	2f 92       	push	r2
    333a:	3f 92       	push	r3
    333c:	4f 92       	push	r4
    333e:	5f 92       	push	r5
    3340:	6f 92       	push	r6
    3342:	7f 92       	push	r7
    3344:	8f 92       	push	r8
    3346:	9f 92       	push	r9
    3348:	af 92       	push	r10
    334a:	bf 92       	push	r11
    334c:	cf 92       	push	r12
    334e:	df 92       	push	r13
    3350:	ef 92       	push	r14
    3352:	ff 92       	push	r15
    3354:	0f 93       	push	r16
    3356:	1f 93       	push	r17
    3358:	2f 93       	push	r18
    335a:	3f 93       	push	r19
    335c:	4f 93       	push	r20
    335e:	5f 93       	push	r21
    3360:	6f 93       	push	r22
    3362:	7f 93       	push	r23
    3364:	8f 93       	push	r24
    3366:	9f 93       	push	r25
    3368:	af 93       	push	r26
    336a:	bf 93       	push	r27
    336c:	cf 93       	push	r28
    336e:	df 93       	push	r29
    3370:	ef 93       	push	r30
    3372:	ff 93       	push	r31
    3374:	a0 91 c1 07 	lds	r26, 0x07C1
    3378:	b0 91 c2 07 	lds	r27, 0x07C2
    337c:	0d b6       	in	r0, 0x3d	; 61
    337e:	0d 92       	st	X+, r0
    3380:	0e b6       	in	r0, 0x3e	; 62
    3382:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3384:	0e 94 a9 25 	call	0x4b52	; 0x4b52 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3388:	a0 91 c1 07 	lds	r26, 0x07C1
    338c:	b0 91 c2 07 	lds	r27, 0x07C2
    3390:	cd 91       	ld	r28, X+
    3392:	cd bf       	out	0x3d, r28	; 61
    3394:	dd 91       	ld	r29, X+
    3396:	de bf       	out	0x3e, r29	; 62
    3398:	ff 91       	pop	r31
    339a:	ef 91       	pop	r30
    339c:	df 91       	pop	r29
    339e:	cf 91       	pop	r28
    33a0:	bf 91       	pop	r27
    33a2:	af 91       	pop	r26
    33a4:	9f 91       	pop	r25
    33a6:	8f 91       	pop	r24
    33a8:	7f 91       	pop	r23
    33aa:	6f 91       	pop	r22
    33ac:	5f 91       	pop	r21
    33ae:	4f 91       	pop	r20
    33b0:	3f 91       	pop	r19
    33b2:	2f 91       	pop	r18
    33b4:	1f 91       	pop	r17
    33b6:	0f 91       	pop	r16
    33b8:	ff 90       	pop	r15
    33ba:	ef 90       	pop	r14
    33bc:	df 90       	pop	r13
    33be:	cf 90       	pop	r12
    33c0:	bf 90       	pop	r11
    33c2:	af 90       	pop	r10
    33c4:	9f 90       	pop	r9
    33c6:	8f 90       	pop	r8
    33c8:	7f 90       	pop	r7
    33ca:	6f 90       	pop	r6
    33cc:	5f 90       	pop	r5
    33ce:	4f 90       	pop	r4
    33d0:	3f 90       	pop	r3
    33d2:	2f 90       	pop	r2
    33d4:	1f 90       	pop	r1
    33d6:	0f 90       	pop	r0
    33d8:	0f be       	out	0x3f, r0	; 63
    33da:	0f 90       	pop	r0

	asm volatile ( "ret" );
    33dc:	08 95       	ret

000033de <xEventGroupClearBits>:
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    33de:	fc 01       	movw	r30, r24
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    33e0:	0f b6       	in	r0, 0x3f	; 63
    33e2:	f8 94       	cli
    33e4:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    33e6:	20 81       	ld	r18, Z
    33e8:	31 81       	ldd	r19, Z+1	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    33ea:	60 95       	com	r22
    33ec:	70 95       	com	r23
    33ee:	62 23       	and	r22, r18
    33f0:	73 23       	and	r23, r19
    33f2:	71 83       	std	Z+1, r23	; 0x01
    33f4:	60 83       	st	Z, r22
    }
    taskEXIT_CRITICAL();
    33f6:	0f 90       	pop	r0
    33f8:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
}
    33fa:	82 2f       	mov	r24, r18
    33fc:	93 2f       	mov	r25, r19
    33fe:	08 95       	ret

00003400 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    3400:	fc 01       	movw	r30, r24
        uxReturn = pxEventBits->uxEventBits;
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    3402:	80 81       	ld	r24, Z
    3404:	91 81       	ldd	r25, Z+1	; 0x01
    3406:	08 95       	ret

00003408 <vEventGroupClearBitsCallback>:
/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    3408:	ba 01       	movw	r22, r20
    340a:	0e 94 ef 19 	call	0x33de	; 0x33de <xEventGroupClearBits>
}
    340e:	08 95       	ret

00003410 <prvTestWaitCondition>:
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    BaseType_t xWaitConditionMet = pdFALSE;

    if( xWaitForAllBits == pdFALSE )
    3410:	44 23       	and	r20, r20
    3412:	39 f4       	brne	.+14     	; 0x3422 <prvTestWaitCondition+0x12>
    3414:	20 e0       	ldi	r18, 0x00	; 0
    3416:	86 23       	and	r24, r22
    3418:	97 23       	and	r25, r23
    341a:	89 2b       	or	r24, r25
    341c:	49 f0       	breq	.+18     	; 0x3430 <prvTestWaitCondition+0x20>
    341e:	21 e0       	ldi	r18, 0x01	; 1
    3420:	07 c0       	rjmp	.+14     	; 0x3430 <prvTestWaitCondition+0x20>
    3422:	20 e0       	ldi	r18, 0x00	; 0
    3424:	86 23       	and	r24, r22
    3426:	97 23       	and	r25, r23
    3428:	86 17       	cp	r24, r22
    342a:	97 07       	cpc	r25, r23
    342c:	09 f4       	brne	.+2      	; 0x3430 <prvTestWaitCondition+0x20>
    342e:	21 e0       	ldi	r18, 0x01	; 1
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
}
    3430:	82 2f       	mov	r24, r18
    3432:	08 95       	ret

00003434 <xEventGroupSetBits>:
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    3434:	cf 92       	push	r12
    3436:	df 92       	push	r13
    3438:	ef 92       	push	r14
    343a:	ff 92       	push	r15
    343c:	0f 93       	push	r16
    343e:	1f 93       	push	r17
    3440:	cf 93       	push	r28
    3442:	df 93       	push	r29
    3444:	ec 01       	movw	r28, r24
    3446:	8b 01       	movw	r16, r22
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3448:	0f 2e       	mov	r0, r31
    344a:	f5 e0       	ldi	r31, 0x05	; 5
    344c:	cf 2e       	mov	r12, r31
    344e:	dd 24       	eor	r13, r13
    3450:	f0 2d       	mov	r31, r0
    3452:	c8 0e       	add	r12, r24
    3454:	d9 1e       	adc	r13, r25
    vTaskSuspendAll();
    3456:	0e 94 81 25 	call	0x4b02	; 0x4b02 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    345a:	ef 81       	ldd	r30, Y+7	; 0x07
    345c:	f8 85       	ldd	r31, Y+8	; 0x08

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    345e:	88 81       	ld	r24, Y
    3460:	99 81       	ldd	r25, Y+1	; 0x01
    3462:	80 2b       	or	r24, r16
    3464:	91 2b       	or	r25, r17
    3466:	99 83       	std	Y+1, r25	; 0x01
    3468:	88 83       	st	Y, r24

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    346a:	ce 16       	cp	r12, r30
    346c:	df 06       	cpc	r13, r31
    346e:	49 f1       	breq	.+82     	; 0x34c2 <xEventGroupSetBits+0x8e>
    3470:	ee 24       	eor	r14, r14
    3472:	ff 24       	eor	r15, r15
        {
            pxNext = listGET_NEXT( pxListItem );
    3474:	02 81       	ldd	r16, Z+2	; 0x02
    3476:	13 81       	ldd	r17, Z+3	; 0x03
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    3478:	80 81       	ld	r24, Z
    347a:	91 81       	ldd	r25, Z+1	; 0x01
            xMatchFound = pdFALSE;

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    347c:	ac 01       	movw	r20, r24
    347e:	40 70       	andi	r20, 0x00	; 0
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    3480:	9c 01       	movw	r18, r24
    3482:	30 70       	andi	r19, 0x00	; 0

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    3484:	92 fd       	sbrc	r25, 2
    3486:	07 c0       	rjmp	.+14     	; 0x3496 <xEventGroupSetBits+0x62>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    3488:	88 81       	ld	r24, Y
    348a:	99 81       	ldd	r25, Y+1	; 0x01
    348c:	82 23       	and	r24, r18
    348e:	93 23       	and	r25, r19
    3490:	89 2b       	or	r24, r25
    3492:	41 f4       	brne	.+16     	; 0x34a4 <xEventGroupSetBits+0x70>
    3494:	11 c0       	rjmp	.+34     	; 0x34b8 <xEventGroupSetBits+0x84>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    3496:	88 81       	ld	r24, Y
    3498:	99 81       	ldd	r25, Y+1	; 0x01
    349a:	82 23       	and	r24, r18
    349c:	93 23       	and	r25, r19
    349e:	82 17       	cp	r24, r18
    34a0:	93 07       	cpc	r25, r19
    34a2:	51 f4       	brne	.+20     	; 0x34b8 <xEventGroupSetBits+0x84>
            }

            if( xMatchFound != pdFALSE )
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    34a4:	50 ff       	sbrs	r21, 0
    34a6:	02 c0       	rjmp	.+4      	; 0x34ac <xEventGroupSetBits+0x78>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    34a8:	e2 2a       	or	r14, r18
    34aa:	f3 2a       	or	r15, r19
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    34ac:	68 81       	ld	r22, Y
    34ae:	79 81       	ldd	r23, Y+1	; 0x01
    34b0:	72 60       	ori	r23, 0x02	; 2
    34b2:	cf 01       	movw	r24, r30
    34b4:	0e 94 a6 26 	call	0x4d4c	; 0x4d4c <vTaskRemoveFromUnorderedEventList>

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    34b8:	c0 16       	cp	r12, r16
    34ba:	d1 06       	cpc	r13, r17
    34bc:	21 f0       	breq	.+8      	; 0x34c6 <xEventGroupSetBits+0x92>
    34be:	f8 01       	movw	r30, r16
    34c0:	d9 cf       	rjmp	.-78     	; 0x3474 <xEventGroupSetBits+0x40>
    34c2:	ee 24       	eor	r14, r14
    34c4:	ff 24       	eor	r15, r15
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    34c6:	97 01       	movw	r18, r14
    34c8:	20 95       	com	r18
    34ca:	30 95       	com	r19
    34cc:	88 81       	ld	r24, Y
    34ce:	99 81       	ldd	r25, Y+1	; 0x01
    34d0:	82 23       	and	r24, r18
    34d2:	93 23       	and	r25, r19
    34d4:	99 83       	std	Y+1, r25	; 0x01
    34d6:	88 83       	st	Y, r24
    }
    ( void ) xTaskResumeAll();
    34d8:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
}
    34dc:	88 81       	ld	r24, Y
    34de:	99 81       	ldd	r25, Y+1	; 0x01
    34e0:	df 91       	pop	r29
    34e2:	cf 91       	pop	r28
    34e4:	1f 91       	pop	r17
    34e6:	0f 91       	pop	r16
    34e8:	ff 90       	pop	r15
    34ea:	ef 90       	pop	r14
    34ec:	df 90       	pop	r13
    34ee:	cf 90       	pop	r12
    34f0:	08 95       	ret

000034f2 <vEventGroupSetBitsCallback>:
/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    34f2:	ba 01       	movw	r22, r20
    34f4:	0e 94 1a 1a 	call	0x3434	; 0x3434 <xEventGroupSetBits>
}
    34f8:	08 95       	ret

000034fa <vEventGroupDelete>:
    return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    34fa:	cf 93       	push	r28
    34fc:	df 93       	push	r29
    34fe:	ec 01       	movw	r28, r24

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

    vTaskSuspendAll();
    3500:	0e 94 81 25 	call	0x4b02	; 0x4b02 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    3504:	8a 81       	ldd	r24, Y+2	; 0x02
    3506:	88 23       	and	r24, r24
    3508:	49 f0       	breq	.+18     	; 0x351c <vEventGroupDelete+0x22>
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    350a:	8f 81       	ldd	r24, Y+7	; 0x07
    350c:	98 85       	ldd	r25, Y+8	; 0x08
    350e:	60 e0       	ldi	r22, 0x00	; 0
    3510:	72 e0       	ldi	r23, 0x02	; 2
    3512:	0e 94 a6 26 	call	0x4d4c	; 0x4d4c <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    3516:	8a 81       	ldd	r24, Y+2	; 0x02
    3518:	88 23       	and	r24, r24
    351a:	b9 f7       	brne	.-18     	; 0x350a <vEventGroupDelete+0x10>
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
        }
    }
    ( void ) xTaskResumeAll();
    351c:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The event group can only have been allocated dynamically - free
         * it again. */
        vPortFree( pxEventBits );
    3520:	ce 01       	movw	r24, r28
    3522:	0e 94 6e 18 	call	0x30dc	; 0x30dc <vPortFree>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3526:	df 91       	pop	r29
    3528:	cf 91       	pop	r28
    352a:	08 95       	ret

0000352c <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    352c:	af 92       	push	r10
    352e:	bf 92       	push	r11
    3530:	cf 92       	push	r12
    3532:	df 92       	push	r13
    3534:	ef 92       	push	r14
    3536:	ff 92       	push	r15
    3538:	0f 93       	push	r16
    353a:	1f 93       	push	r17
    353c:	cf 93       	push	r28
    353e:	df 93       	push	r29
    3540:	6c 01       	movw	r12, r24
    3542:	7b 01       	movw	r14, r22
    3544:	a4 2e       	mov	r10, r20
    3546:	b2 2e       	mov	r11, r18
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
    3548:	0e 94 81 25 	call	0x4b02	; 0x4b02 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    354c:	f6 01       	movw	r30, r12
    354e:	c0 81       	ld	r28, Z
    3550:	d1 81       	ldd	r29, Z+1	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    3552:	ce 01       	movw	r24, r28
    3554:	b7 01       	movw	r22, r14
    3556:	4b 2d       	mov	r20, r11
    3558:	0e 94 08 1a 	call	0x3410	; 0x3410 <prvTestWaitCondition>

        if( xWaitConditionMet != pdFALSE )
    355c:	88 23       	and	r24, r24
    355e:	59 f0       	breq	.+22     	; 0x3576 <xEventGroupWaitBits+0x4a>
             * block. */
            uxReturn = uxCurrentEventBits;
            xTicksToWait = ( TickType_t ) 0;

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    3560:	aa 20       	and	r10, r10
    3562:	09 f1       	breq	.+66     	; 0x35a6 <xEventGroupWaitBits+0x7a>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    3564:	c7 01       	movw	r24, r14
    3566:	80 95       	com	r24
    3568:	90 95       	com	r25
    356a:	8c 23       	and	r24, r28
    356c:	9d 23       	and	r25, r29
    356e:	f6 01       	movw	r30, r12
    3570:	91 83       	std	Z+1, r25	; 0x01
    3572:	80 83       	st	Z, r24
    3574:	18 c0       	rjmp	.+48     	; 0x35a6 <xEventGroupWaitBits+0x7a>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    3576:	01 15       	cp	r16, r1
    3578:	11 05       	cpc	r17, r1
    357a:	a9 f0       	breq	.+42     	; 0x35a6 <xEventGroupWaitBits+0x7a>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    357c:	aa 20       	and	r10, r10
    357e:	19 f0       	breq	.+6      	; 0x3586 <xEventGroupWaitBits+0x5a>
    3580:	60 e0       	ldi	r22, 0x00	; 0
    3582:	71 e0       	ldi	r23, 0x01	; 1
    3584:	02 c0       	rjmp	.+4      	; 0x358a <xEventGroupWaitBits+0x5e>
    3586:	60 e0       	ldi	r22, 0x00	; 0
    3588:	70 e0       	ldi	r23, 0x00	; 0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    358a:	b1 10       	cpse	r11, r1
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    358c:	74 60       	ori	r23, 0x04	; 4
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    358e:	6e 29       	or	r22, r14
    3590:	7f 29       	or	r23, r15
    3592:	c6 01       	movw	r24, r12
    3594:	02 96       	adiw	r24, 0x02	; 2
    3596:	a8 01       	movw	r20, r16
    3598:	0e 94 a2 2e 	call	0x5d44	; 0x5d44 <vTaskPlaceOnUnorderedEventList>
            uxReturn = 0;

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    359c:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>

    if( xTicksToWait != ( TickType_t ) 0 )
    {
        if( xAlreadyYielded == pdFALSE )
    35a0:	88 23       	and	r24, r24
    35a2:	39 f4       	brne	.+14     	; 0x35b2 <xEventGroupWaitBits+0x86>
    35a4:	04 c0       	rjmp	.+8      	; 0x35ae <xEventGroupWaitBits+0x82>
            uxReturn = 0;

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    35a6:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>
    35aa:	9e 01       	movw	r18, r28
    35ac:	22 c0       	rjmp	.+68     	; 0x35f2 <xEventGroupWaitBits+0xc6>

    if( xTicksToWait != ( TickType_t ) 0 )
    {
        if( xAlreadyYielded == pdFALSE )
        {
            portYIELD_WITHIN_API();
    35ae:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    35b2:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <uxTaskResetEventItemValue>
    35b6:	ec 01       	movw	r28, r24

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    35b8:	91 fd       	sbrc	r25, 1
    35ba:	19 c0       	rjmp	.+50     	; 0x35ee <xEventGroupWaitBits+0xc2>
        {
            taskENTER_CRITICAL();
    35bc:	0f b6       	in	r0, 0x3f	; 63
    35be:	f8 94       	cli
    35c0:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    35c2:	f6 01       	movw	r30, r12
    35c4:	c0 81       	ld	r28, Z
    35c6:	d1 81       	ldd	r29, Z+1	; 0x01

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    35c8:	ce 01       	movw	r24, r28
    35ca:	b7 01       	movw	r22, r14
    35cc:	4b 2d       	mov	r20, r11
    35ce:	0e 94 08 1a 	call	0x3410	; 0x3410 <prvTestWaitCondition>
    35d2:	88 23       	and	r24, r24
    35d4:	51 f0       	breq	.+20     	; 0x35ea <xEventGroupWaitBits+0xbe>
                {
                    if( xClearOnExit != pdFALSE )
    35d6:	aa 20       	and	r10, r10
    35d8:	41 f0       	breq	.+16     	; 0x35ea <xEventGroupWaitBits+0xbe>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    35da:	c7 01       	movw	r24, r14
    35dc:	80 95       	com	r24
    35de:	90 95       	com	r25
    35e0:	8c 23       	and	r24, r28
    35e2:	9d 23       	and	r25, r29
    35e4:	f6 01       	movw	r30, r12
    35e6:	91 83       	std	Z+1, r25	; 0x01
    35e8:	80 83       	st	Z, r24
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
            }
            taskEXIT_CRITICAL();
    35ea:	0f 90       	pop	r0
    35ec:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    35ee:	9e 01       	movw	r18, r28
    35f0:	30 70       	andi	r19, 0x00	; 0

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
}
    35f2:	82 2f       	mov	r24, r18
    35f4:	93 2f       	mov	r25, r19
    35f6:	df 91       	pop	r29
    35f8:	cf 91       	pop	r28
    35fa:	1f 91       	pop	r17
    35fc:	0f 91       	pop	r16
    35fe:	ff 90       	pop	r15
    3600:	ef 90       	pop	r14
    3602:	df 90       	pop	r13
    3604:	cf 90       	pop	r12
    3606:	bf 90       	pop	r11
    3608:	af 90       	pop	r10
    360a:	08 95       	ret

0000360c <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    360c:	af 92       	push	r10
    360e:	bf 92       	push	r11
    3610:	cf 92       	push	r12
    3612:	df 92       	push	r13
    3614:	ef 92       	push	r14
    3616:	ff 92       	push	r15
    3618:	0f 93       	push	r16
    361a:	1f 93       	push	r17
    361c:	cf 93       	push	r28
    361e:	df 93       	push	r29
    3620:	ec 01       	movw	r28, r24
    3622:	7b 01       	movw	r14, r22
    3624:	6a 01       	movw	r12, r20
    3626:	59 01       	movw	r10, r18
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
    3628:	0e 94 81 25 	call	0x4b02	; 0x4b02 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    362c:	08 81       	ld	r16, Y
    362e:	19 81       	ldd	r17, Y+1	; 0x01

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    3630:	ce 01       	movw	r24, r28
    3632:	b7 01       	movw	r22, r14
    3634:	0e 94 1a 1a 	call	0x3434	; 0x3434 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    3638:	e0 2a       	or	r14, r16
    363a:	f1 2a       	or	r15, r17
    363c:	96 01       	movw	r18, r12
    363e:	2e 21       	and	r18, r14
    3640:	3f 21       	and	r19, r15
    3642:	2c 15       	cp	r18, r12
    3644:	3d 05       	cpc	r19, r13
    3646:	49 f4       	brne	.+18     	; 0x365a <xEventGroupSync+0x4e>
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    3648:	20 95       	com	r18
    364a:	30 95       	com	r19
    364c:	88 81       	ld	r24, Y
    364e:	99 81       	ldd	r25, Y+1	; 0x01
    3650:	82 23       	and	r24, r18
    3652:	93 23       	and	r25, r19
    3654:	99 83       	std	Y+1, r25	; 0x01
    3656:	88 83       	st	Y, r24
    3658:	11 c0       	rjmp	.+34     	; 0x367c <xEventGroupSync+0x70>

            xTicksToWait = 0;
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    365a:	a1 14       	cp	r10, r1
    365c:	b1 04       	cpc	r11, r1
    365e:	61 f0       	breq	.+24     	; 0x3678 <xEventGroupSync+0x6c>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    3660:	b6 01       	movw	r22, r12
    3662:	75 60       	ori	r23, 0x05	; 5
    3664:	ce 01       	movw	r24, r28
    3666:	02 96       	adiw	r24, 0x02	; 2
    3668:	a5 01       	movw	r20, r10
    366a:	0e 94 a2 2e 	call	0x5d44	; 0x5d44 <vTaskPlaceOnUnorderedEventList>
                uxReturn = pxEventBits->uxEventBits;
                xTimeoutOccurred = pdTRUE;
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    366e:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>

    if( xTicksToWait != ( TickType_t ) 0 )
    {
        if( xAlreadyYielded == pdFALSE )
    3672:	88 23       	and	r24, r24
    3674:	41 f4       	brne	.+16     	; 0x3686 <xEventGroupSync+0x7a>
    3676:	05 c0       	rjmp	.+10     	; 0x3682 <xEventGroupSync+0x76>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    3678:	e8 80       	ld	r14, Y
    367a:	f9 80       	ldd	r15, Y+1	; 0x01
                xTimeoutOccurred = pdTRUE;
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    367c:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>
    3680:	1d c0       	rjmp	.+58     	; 0x36bc <xEventGroupSync+0xb0>

    if( xTicksToWait != ( TickType_t ) 0 )
    {
        if( xAlreadyYielded == pdFALSE )
        {
            portYIELD_WITHIN_API();
    3682:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    3686:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <uxTaskResetEventItemValue>
    368a:	7c 01       	movw	r14, r24

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    368c:	91 fd       	sbrc	r25, 1
    368e:	13 c0       	rjmp	.+38     	; 0x36b6 <xEventGroupSync+0xaa>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    3690:	0f b6       	in	r0, 0x3f	; 63
    3692:	f8 94       	cli
    3694:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    3696:	e8 80       	ld	r14, Y
    3698:	f9 80       	ldd	r15, Y+1	; 0x01

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    369a:	c6 01       	movw	r24, r12
    369c:	8e 21       	and	r24, r14
    369e:	9f 21       	and	r25, r15
    36a0:	8c 15       	cp	r24, r12
    36a2:	9d 05       	cpc	r25, r13
    36a4:	31 f4       	brne	.+12     	; 0x36b2 <xEventGroupSync+0xa6>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    36a6:	80 95       	com	r24
    36a8:	90 95       	com	r25
    36aa:	8e 21       	and	r24, r14
    36ac:	9f 21       	and	r25, r15
    36ae:	99 83       	std	Y+1, r25	; 0x01
    36b0:	88 83       	st	Y, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    36b2:	0f 90       	pop	r0
    36b4:	0f be       	out	0x3f, r0	; 63
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    36b6:	8f ef       	ldi	r24, 0xFF	; 255
    36b8:	e8 22       	and	r14, r24
    36ba:	ff 24       	eor	r15, r15

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
}
    36bc:	8e 2d       	mov	r24, r14
    36be:	9f 2d       	mov	r25, r15
    36c0:	df 91       	pop	r29
    36c2:	cf 91       	pop	r28
    36c4:	1f 91       	pop	r17
    36c6:	0f 91       	pop	r16
    36c8:	ff 90       	pop	r15
    36ca:	ef 90       	pop	r14
    36cc:	df 90       	pop	r13
    36ce:	cf 90       	pop	r12
    36d0:	bf 90       	pop	r11
    36d2:	af 90       	pop	r10
    36d4:	08 95       	ret

000036d6 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    36d6:	cf 93       	push	r28
    36d8:	df 93       	push	r29
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    36da:	8b e0       	ldi	r24, 0x0B	; 11
    36dc:	90 e0       	ldi	r25, 0x00	; 0
    36de:	0e 94 7f 18 	call	0x30fe	; 0x30fe <pvPortMalloc>
    36e2:	ec 01       	movw	r28, r24

        if( pxEventBits != NULL )
    36e4:	20 97       	sbiw	r28, 0x00	; 0
    36e6:	31 f0       	breq	.+12     	; 0x36f4 <xEventGroupCreate+0x1e>
        {
            pxEventBits->uxEventBits = 0;
    36e8:	fe 01       	movw	r30, r28
    36ea:	11 92       	st	Z+, r1
    36ec:	11 92       	st	Z+, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    36ee:	cf 01       	movw	r24, r30
    36f0:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <vListInitialise>
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    }
    36f4:	8c 2f       	mov	r24, r28
    36f6:	9d 2f       	mov	r25, r29
    36f8:	df 91       	pop	r29
    36fa:	cf 91       	pop	r28
    36fc:	08 95       	ret

000036fe <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    36fe:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3700:	9c 01       	movw	r18, r24
    3702:	2d 5f       	subi	r18, 0xFD	; 253
    3704:	3f 4f       	sbci	r19, 0xFF	; 255
    3706:	32 83       	std	Z+2, r19	; 0x02
    3708:	21 83       	std	Z+1, r18	; 0x01

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    370a:	8f ef       	ldi	r24, 0xFF	; 255
    370c:	9f ef       	ldi	r25, 0xFF	; 255
    370e:	94 83       	std	Z+4, r25	; 0x04
    3710:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3712:	36 83       	std	Z+6, r19	; 0x06
    3714:	25 83       	std	Z+5, r18	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3716:	30 87       	std	Z+8, r19	; 0x08
    3718:	27 83       	std	Z+7, r18	; 0x07
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    371a:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    371c:	08 95       	ret

0000371e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    371e:	fc 01       	movw	r30, r24
    3720:	11 86       	std	Z+9, r1	; 0x09
    3722:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    3724:	08 95       	ret

00003726 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    3726:	ac 01       	movw	r20, r24
    ListItem_t * const pxIndex = pxList->pxIndex;
    3728:	fc 01       	movw	r30, r24
    372a:	a1 81       	ldd	r26, Z+1	; 0x01
    372c:	b2 81       	ldd	r27, Z+2	; 0x02
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    372e:	fb 01       	movw	r30, r22
    3730:	b3 83       	std	Z+3, r27	; 0x03
    3732:	a2 83       	std	Z+2, r26	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    3734:	14 96       	adiw	r26, 0x04	; 4
    3736:	8d 91       	ld	r24, X+
    3738:	9c 91       	ld	r25, X
    373a:	15 97       	sbiw	r26, 0x05	; 5
    373c:	95 83       	std	Z+5, r25	; 0x05
    373e:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    3740:	14 96       	adiw	r26, 0x04	; 4
    3742:	ed 91       	ld	r30, X+
    3744:	fc 91       	ld	r31, X
    3746:	15 97       	sbiw	r26, 0x05	; 5
    3748:	73 83       	std	Z+3, r23	; 0x03
    374a:	62 83       	std	Z+2, r22	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    374c:	15 96       	adiw	r26, 0x05	; 5
    374e:	7c 93       	st	X, r23
    3750:	6e 93       	st	-X, r22
    3752:	14 97       	sbiw	r26, 0x04	; 4

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    3754:	fb 01       	movw	r30, r22
    3756:	51 87       	std	Z+9, r21	; 0x09
    3758:	40 87       	std	Z+8, r20	; 0x08

    ( pxList->uxNumberOfItems )++;
    375a:	fa 01       	movw	r30, r20
    375c:	80 81       	ld	r24, Z
    375e:	8f 5f       	subi	r24, 0xFF	; 255
    3760:	80 83       	st	Z, r24
}
    3762:	08 95       	ret

00003764 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    3764:	cf 93       	push	r28
    3766:	df 93       	push	r29
    3768:	ac 01       	movw	r20, r24
    376a:	eb 01       	movw	r28, r22
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    376c:	28 81       	ld	r18, Y
    376e:	39 81       	ldd	r19, Y+1	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    3770:	8f ef       	ldi	r24, 0xFF	; 255
    3772:	2f 3f       	cpi	r18, 0xFF	; 255
    3774:	38 07       	cpc	r19, r24
    3776:	21 f4       	brne	.+8      	; 0x3780 <vListInsert+0x1c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    3778:	fa 01       	movw	r30, r20
    377a:	a7 81       	ldd	r26, Z+7	; 0x07
    377c:	b0 85       	ldd	r27, Z+8	; 0x08
    377e:	0d c0       	rjmp	.+26     	; 0x379a <vListInsert+0x36>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    3780:	da 01       	movw	r26, r20
    3782:	13 96       	adiw	r26, 0x03	; 3
    3784:	12 96       	adiw	r26, 0x02	; 2
    3786:	ed 91       	ld	r30, X+
    3788:	fc 91       	ld	r31, X
    378a:	13 97       	sbiw	r26, 0x03	; 3
    378c:	80 81       	ld	r24, Z
    378e:	91 81       	ldd	r25, Z+1	; 0x01
    3790:	28 17       	cp	r18, r24
    3792:	39 07       	cpc	r19, r25
    3794:	10 f0       	brcs	.+4      	; 0x379a <vListInsert+0x36>
    3796:	df 01       	movw	r26, r30
    3798:	f5 cf       	rjmp	.-22     	; 0x3784 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    379a:	12 96       	adiw	r26, 0x02	; 2
    379c:	ed 91       	ld	r30, X+
    379e:	fc 91       	ld	r31, X
    37a0:	13 97       	sbiw	r26, 0x03	; 3
    37a2:	fb 83       	std	Y+3, r31	; 0x03
    37a4:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    37a6:	d5 83       	std	Z+5, r29	; 0x05
    37a8:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    37aa:	bd 83       	std	Y+5, r27	; 0x05
    37ac:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    37ae:	13 96       	adiw	r26, 0x03	; 3
    37b0:	dc 93       	st	X, r29
    37b2:	ce 93       	st	-X, r28
    37b4:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    37b6:	59 87       	std	Y+9, r21	; 0x09
    37b8:	48 87       	std	Y+8, r20	; 0x08

    ( pxList->uxNumberOfItems )++;
    37ba:	fa 01       	movw	r30, r20
    37bc:	80 81       	ld	r24, Z
    37be:	8f 5f       	subi	r24, 0xFF	; 255
    37c0:	80 83       	st	Z, r24
}
    37c2:	df 91       	pop	r29
    37c4:	cf 91       	pop	r28
    37c6:	08 95       	ret

000037c8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    37c8:	cf 93       	push	r28
    37ca:	df 93       	push	r29
    37cc:	ec 01       	movw	r28, r24
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    37ce:	28 85       	ldd	r18, Y+8	; 0x08
    37d0:	39 85       	ldd	r19, Y+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    37d2:	ea 81       	ldd	r30, Y+2	; 0x02
    37d4:	fb 81       	ldd	r31, Y+3	; 0x03
    37d6:	8c 81       	ldd	r24, Y+4	; 0x04
    37d8:	9d 81       	ldd	r25, Y+5	; 0x05
    37da:	95 83       	std	Z+5, r25	; 0x05
    37dc:	84 83       	std	Z+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    37de:	ac 81       	ldd	r26, Y+4	; 0x04
    37e0:	bd 81       	ldd	r27, Y+5	; 0x05
    37e2:	13 96       	adiw	r26, 0x03	; 3
    37e4:	fc 93       	st	X, r31
    37e6:	ee 93       	st	-X, r30
    37e8:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    37ea:	d9 01       	movw	r26, r18
    37ec:	11 96       	adiw	r26, 0x01	; 1
    37ee:	ed 91       	ld	r30, X+
    37f0:	fc 91       	ld	r31, X
    37f2:	12 97       	sbiw	r26, 0x02	; 2
    37f4:	ec 17       	cp	r30, r28
    37f6:	fd 07       	cpc	r31, r29
    37f8:	31 f4       	brne	.+12     	; 0x3806 <uxListRemove+0x3e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    37fa:	84 81       	ldd	r24, Z+4	; 0x04
    37fc:	95 81       	ldd	r25, Z+5	; 0x05
    37fe:	12 96       	adiw	r26, 0x02	; 2
    3800:	9c 93       	st	X, r25
    3802:	8e 93       	st	-X, r24
    3804:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    3806:	19 86       	std	Y+9, r1	; 0x09
    3808:	18 86       	std	Y+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    380a:	f9 01       	movw	r30, r18
    380c:	80 81       	ld	r24, Z
    380e:	81 50       	subi	r24, 0x01	; 1
    3810:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    3812:	80 81       	ld	r24, Z
}
    3814:	df 91       	pop	r29
    3816:	cf 91       	pop	r28
    3818:	08 95       	ret

0000381a <uxQueueMessagesWaiting>:
    return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    381a:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    381c:	0f b6       	in	r0, 0x3f	; 63
    381e:	f8 94       	cli
    3820:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    3822:	82 8d       	ldd	r24, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
    3824:	0f 90       	pop	r0
    3826:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3828:	08 95       	ret

0000382a <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    382a:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    382c:	0f b6       	in	r0, 0x3f	; 63
    382e:	f8 94       	cli
    3830:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    3832:	92 8d       	ldd	r25, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
    3834:	0f 90       	pop	r0
    3836:	0f be       	out	0x3f, r0	; 63
    3838:	83 8d       	ldd	r24, Z+27	; 0x1b

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    383a:	89 1b       	sub	r24, r25
    383c:	08 95       	ret

0000383e <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    383e:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    3840:	82 8d       	ldd	r24, Z+26	; 0x1a

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    3842:	08 95       	ret

00003844 <prvIsQueueEmpty>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    3844:	fc 01       	movw	r30, r24
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    3846:	0f b6       	in	r0, 0x3f	; 63
    3848:	f8 94       	cli
    384a:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    384c:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    384e:	0f 90       	pop	r0
    3850:	0f be       	out	0x3f, r0	; 63
    3852:	90 e0       	ldi	r25, 0x00	; 0
    3854:	88 23       	and	r24, r24
    3856:	09 f4       	brne	.+2      	; 0x385a <prvIsQueueEmpty+0x16>
    3858:	91 e0       	ldi	r25, 0x01	; 1

    return xReturn;
}
    385a:	89 2f       	mov	r24, r25
    385c:	08 95       	ret

0000385e <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    385e:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    3860:	82 8d       	ldd	r24, Z+26	; 0x1a
    3862:	90 e0       	ldi	r25, 0x00	; 0
    3864:	88 23       	and	r24, r24
    3866:	09 f4       	brne	.+2      	; 0x386a <xQueueIsQueueEmptyFromISR+0xc>
    3868:	91 e0       	ldi	r25, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    386a:	89 2f       	mov	r24, r25
    386c:	08 95       	ret

0000386e <xQueueIsQueueFullFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    386e:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3870:	92 8d       	ldd	r25, Z+26	; 0x1a
    3872:	20 e0       	ldi	r18, 0x00	; 0
    3874:	83 8d       	ldd	r24, Z+27	; 0x1b
    3876:	98 17       	cp	r25, r24
    3878:	09 f4       	brne	.+2      	; 0x387c <xQueueIsQueueFullFromISR+0xe>
    387a:	21 e0       	ldi	r18, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    387c:	82 2f       	mov	r24, r18
    387e:	08 95       	ret

00003880 <vQueueDelete>:

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
    3880:	0e 94 6e 18 	call	0x30dc	; 0x30dc <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3884:	08 95       	ret

00003886 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    3886:	fc 01       	movw	r30, r24
    3888:	56 2f       	mov	r21, r22
    388a:	a7 2f       	mov	r26, r23
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    388c:	24 8d       	ldd	r18, Z+28	; 0x1c
    388e:	22 23       	and	r18, r18
    3890:	b9 f0       	breq	.+46     	; 0x38c0 <prvCopyDataFromQueue+0x3a>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3892:	86 81       	ldd	r24, Z+6	; 0x06
    3894:	97 81       	ldd	r25, Z+7	; 0x07
    3896:	82 0f       	add	r24, r18
    3898:	91 1d       	adc	r25, r1
    389a:	97 83       	std	Z+7, r25	; 0x07
    389c:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    389e:	24 81       	ldd	r18, Z+4	; 0x04
    38a0:	35 81       	ldd	r19, Z+5	; 0x05
    38a2:	82 17       	cp	r24, r18
    38a4:	93 07       	cpc	r25, r19
    38a6:	20 f0       	brcs	.+8      	; 0x38b0 <prvCopyDataFromQueue+0x2a>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    38a8:	80 81       	ld	r24, Z
    38aa:	91 81       	ldd	r25, Z+1	; 0x01
    38ac:	97 83       	std	Z+7, r25	; 0x07
    38ae:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    38b0:	44 8d       	ldd	r20, Z+28	; 0x1c
    38b2:	66 81       	ldd	r22, Z+6	; 0x06
    38b4:	77 81       	ldd	r23, Z+7	; 0x07
    38b6:	85 2f       	mov	r24, r21
    38b8:	9a 2f       	mov	r25, r26
    38ba:	50 e0       	ldi	r21, 0x00	; 0
    38bc:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <memcpy>
    38c0:	08 95       	ret

000038c2 <xQueuePeekFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    38c2:	0f 93       	push	r16
    38c4:	1f 93       	push	r17
    38c6:	cf 93       	push	r28
    38c8:	df 93       	push	r29
    38ca:	ec 01       	movw	r28, r24
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    38cc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    38ce:	88 23       	and	r24, r24
    38d0:	41 f0       	breq	.+16     	; 0x38e2 <xQueuePeekFromISR+0x20>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    38d2:	0e 81       	ldd	r16, Y+6	; 0x06
    38d4:	1f 81       	ldd	r17, Y+7	; 0x07
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    38d6:	ce 01       	movw	r24, r28
    38d8:	0e 94 43 1c 	call	0x3886	; 0x3886 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    38dc:	1f 83       	std	Y+7, r17	; 0x07
    38de:	0e 83       	std	Y+6, r16	; 0x06
    38e0:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    38e2:	df 91       	pop	r29
    38e4:	cf 91       	pop	r28
    38e6:	1f 91       	pop	r17
    38e8:	0f 91       	pop	r16
    38ea:	08 95       	ret

000038ec <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    38ec:	0f 93       	push	r16
    38ee:	1f 93       	push	r17
    38f0:	cf 93       	push	r28
    38f2:	df 93       	push	r29
    38f4:	ec 01       	movw	r28, r24
    38f6:	04 2f       	mov	r16, r20
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    38f8:	1a 8d       	ldd	r17, Y+26	; 0x1a

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    38fa:	4c 8d       	ldd	r20, Y+28	; 0x1c
    38fc:	44 23       	and	r20, r20
    38fe:	a1 f1       	breq	.+104    	; 0x3968 <prvCopyDataToQueue+0x7c>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    3900:	00 23       	and	r16, r16
    3902:	b1 f4       	brne	.+44     	; 0x3930 <prvCopyDataToQueue+0x44>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3904:	8a 81       	ldd	r24, Y+2	; 0x02
    3906:	9b 81       	ldd	r25, Y+3	; 0x03
    3908:	50 e0       	ldi	r21, 0x00	; 0
    390a:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    390e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    3910:	2a 81       	ldd	r18, Y+2	; 0x02
    3912:	3b 81       	ldd	r19, Y+3	; 0x03
    3914:	28 0f       	add	r18, r24
    3916:	31 1d       	adc	r19, r1
    3918:	3b 83       	std	Y+3, r19	; 0x03
    391a:	2a 83       	std	Y+2, r18	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    391c:	8c 81       	ldd	r24, Y+4	; 0x04
    391e:	9d 81       	ldd	r25, Y+5	; 0x05
    3920:	28 17       	cp	r18, r24
    3922:	39 07       	cpc	r19, r25
    3924:	08 f1       	brcs	.+66     	; 0x3968 <prvCopyDataToQueue+0x7c>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    3926:	88 81       	ld	r24, Y
    3928:	99 81       	ldd	r25, Y+1	; 0x01
    392a:	9b 83       	std	Y+3, r25	; 0x03
    392c:	8a 83       	std	Y+2, r24	; 0x02
    392e:	1c c0       	rjmp	.+56     	; 0x3968 <prvCopyDataToQueue+0x7c>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    3930:	8e 81       	ldd	r24, Y+6	; 0x06
    3932:	9f 81       	ldd	r25, Y+7	; 0x07
    3934:	50 e0       	ldi	r21, 0x00	; 0
    3936:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    393a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    393c:	2e 81       	ldd	r18, Y+6	; 0x06
    393e:	3f 81       	ldd	r19, Y+7	; 0x07
    3940:	28 1b       	sub	r18, r24
    3942:	31 09       	sbc	r19, r1
    3944:	3f 83       	std	Y+7, r19	; 0x07
    3946:	2e 83       	std	Y+6, r18	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    3948:	88 81       	ld	r24, Y
    394a:	99 81       	ldd	r25, Y+1	; 0x01
    394c:	28 17       	cp	r18, r24
    394e:	39 07       	cpc	r19, r25
    3950:	38 f4       	brcc	.+14     	; 0x3960 <prvCopyDataToQueue+0x74>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    3952:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3954:	8c 81       	ldd	r24, Y+4	; 0x04
    3956:	9d 81       	ldd	r25, Y+5	; 0x05
    3958:	82 1b       	sub	r24, r18
    395a:	91 09       	sbc	r25, r1
    395c:	9f 83       	std	Y+7, r25	; 0x07
    395e:	8e 83       	std	Y+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    3960:	02 30       	cpi	r16, 0x02	; 2
    3962:	11 f4       	brne	.+4      	; 0x3968 <prvCopyDataToQueue+0x7c>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3964:	11 11       	cpse	r17, r1
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    3966:	11 50       	subi	r17, 0x01	; 1
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3968:	81 2f       	mov	r24, r17
    396a:	8f 5f       	subi	r24, 0xFF	; 255
    396c:	8a 8f       	std	Y+26, r24	; 0x1a

    return xReturn;
}
    396e:	80 e0       	ldi	r24, 0x00	; 0
    3970:	df 91       	pop	r29
    3972:	cf 91       	pop	r28
    3974:	1f 91       	pop	r17
    3976:	0f 91       	pop	r16
    3978:	08 95       	ret

0000397a <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    397a:	ef 92       	push	r14
    397c:	ff 92       	push	r15
    397e:	0f 93       	push	r16
    3980:	1f 93       	push	r17
    3982:	cf 93       	push	r28
    3984:	df 93       	push	r29
    3986:	ec 01       	movw	r28, r24
    3988:	7a 01       	movw	r14, r20
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    398a:	1a 8d       	ldd	r17, Y+26	; 0x1a

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    398c:	11 23       	and	r17, r17
    398e:	11 f4       	brne	.+4      	; 0x3994 <xQueueReceiveFromISR+0x1a>
    3990:	80 e0       	ldi	r24, 0x00	; 0
    3992:	22 c0       	rjmp	.+68     	; 0x39d8 <xQueueReceiveFromISR+0x5e>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    3994:	0d 8d       	ldd	r16, Y+29	; 0x1d

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    3996:	0e 94 43 1c 	call	0x3886	; 0x3886 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    399a:	81 2f       	mov	r24, r17
    399c:	81 50       	subi	r24, 0x01	; 1
    399e:	8a 8f       	std	Y+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    39a0:	0f 3f       	cpi	r16, 0xFF	; 255
    39a2:	81 f4       	brne	.+32     	; 0x39c4 <xQueueReceiveFromISR+0x4a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    39a4:	88 85       	ldd	r24, Y+8	; 0x08
    39a6:	88 23       	and	r24, r24
    39a8:	b1 f0       	breq	.+44     	; 0x39d6 <xQueueReceiveFromISR+0x5c>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    39aa:	ce 01       	movw	r24, r28
    39ac:	08 96       	adiw	r24, 0x08	; 8
    39ae:	0e 94 ef 25 	call	0x4bde	; 0x4bde <xTaskRemoveFromEventList>
    39b2:	88 23       	and	r24, r24
    39b4:	81 f0       	breq	.+32     	; 0x39d6 <xQueueReceiveFromISR+0x5c>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    39b6:	e1 14       	cp	r14, r1
    39b8:	f1 04       	cpc	r15, r1
    39ba:	69 f0       	breq	.+26     	; 0x39d6 <xQueueReceiveFromISR+0x5c>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    39bc:	81 e0       	ldi	r24, 0x01	; 1
    39be:	f7 01       	movw	r30, r14
    39c0:	80 83       	st	Z, r24
    39c2:	0a c0       	rjmp	.+20     	; 0x39d8 <xQueueReceiveFromISR+0x5e>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
    39c4:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <uxTaskGetNumberOfTasks>
    39c8:	08 17       	cp	r16, r24
    39ca:	28 f4       	brcc	.+10     	; 0x39d6 <xQueueReceiveFromISR+0x5c>
    39cc:	80 2f       	mov	r24, r16
    39ce:	8f 5f       	subi	r24, 0xFF	; 255
    39d0:	8d 8f       	std	Y+29, r24	; 0x1d
    39d2:	81 e0       	ldi	r24, 0x01	; 1
    39d4:	01 c0       	rjmp	.+2      	; 0x39d8 <xQueueReceiveFromISR+0x5e>
    39d6:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    39d8:	df 91       	pop	r29
    39da:	cf 91       	pop	r28
    39dc:	1f 91       	pop	r17
    39de:	0f 91       	pop	r16
    39e0:	ff 90       	pop	r15
    39e2:	ef 90       	pop	r14
    39e4:	08 95       	ret

000039e6 <xQueueGiveFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    39e6:	ef 92       	push	r14
    39e8:	ff 92       	push	r15
    39ea:	1f 93       	push	r17
    39ec:	cf 93       	push	r28
    39ee:	df 93       	push	r29
    39f0:	ec 01       	movw	r28, r24
    39f2:	7b 01       	movw	r14, r22
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    39f4:	9a 8d       	ldd	r25, Y+26	; 0x1a

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    39f6:	8b 8d       	ldd	r24, Y+27	; 0x1b
    39f8:	98 17       	cp	r25, r24
    39fa:	10 f0       	brcs	.+4      	; 0x3a00 <xQueueGiveFromISR+0x1a>
    39fc:	80 e0       	ldi	r24, 0x00	; 0
    39fe:	20 c0       	rjmp	.+64     	; 0x3a40 <xQueueGiveFromISR+0x5a>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    3a00:	1e 8d       	ldd	r17, Y+30	; 0x1e
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3a02:	89 2f       	mov	r24, r25
    3a04:	8f 5f       	subi	r24, 0xFF	; 255
    3a06:	8a 8f       	std	Y+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    3a08:	1f 3f       	cpi	r17, 0xFF	; 255
    3a0a:	81 f4       	brne	.+32     	; 0x3a2c <xQueueGiveFromISR+0x46>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3a0c:	89 89       	ldd	r24, Y+17	; 0x11
    3a0e:	88 23       	and	r24, r24
    3a10:	b1 f0       	breq	.+44     	; 0x3a3e <xQueueGiveFromISR+0x58>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3a12:	ce 01       	movw	r24, r28
    3a14:	41 96       	adiw	r24, 0x11	; 17
    3a16:	0e 94 ef 25 	call	0x4bde	; 0x4bde <xTaskRemoveFromEventList>
    3a1a:	88 23       	and	r24, r24
    3a1c:	81 f0       	breq	.+32     	; 0x3a3e <xQueueGiveFromISR+0x58>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    3a1e:	e1 14       	cp	r14, r1
    3a20:	f1 04       	cpc	r15, r1
    3a22:	69 f0       	breq	.+26     	; 0x3a3e <xQueueGiveFromISR+0x58>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    3a24:	81 e0       	ldi	r24, 0x01	; 1
    3a26:	f7 01       	movw	r30, r14
    3a28:	80 83       	st	Z, r24
    3a2a:	0a c0       	rjmp	.+20     	; 0x3a40 <xQueueGiveFromISR+0x5a>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    3a2c:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <uxTaskGetNumberOfTasks>
    3a30:	18 17       	cp	r17, r24
    3a32:	28 f4       	brcc	.+10     	; 0x3a3e <xQueueGiveFromISR+0x58>
    3a34:	81 2f       	mov	r24, r17
    3a36:	8f 5f       	subi	r24, 0xFF	; 255
    3a38:	8e 8f       	std	Y+30, r24	; 0x1e
    3a3a:	81 e0       	ldi	r24, 0x01	; 1
    3a3c:	01 c0       	rjmp	.+2      	; 0x3a40 <xQueueGiveFromISR+0x5a>
    3a3e:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    3a40:	df 91       	pop	r29
    3a42:	cf 91       	pop	r28
    3a44:	1f 91       	pop	r17
    3a46:	ff 90       	pop	r15
    3a48:	ef 90       	pop	r14
    3a4a:	08 95       	ret

00003a4c <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    3a4c:	ef 92       	push	r14
    3a4e:	ff 92       	push	r15
    3a50:	1f 93       	push	r17
    3a52:	cf 93       	push	r28
    3a54:	df 93       	push	r29
    3a56:	ec 01       	movw	r28, r24
    3a58:	7a 01       	movw	r14, r20
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3a5a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3a5c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3a5e:	98 17       	cp	r25, r24
    3a60:	20 f0       	brcs	.+8      	; 0x3a6a <xQueueGenericSendFromISR+0x1e>
    3a62:	22 30       	cpi	r18, 0x02	; 2
    3a64:	11 f0       	breq	.+4      	; 0x3a6a <xQueueGenericSendFromISR+0x1e>
    3a66:	80 e0       	ldi	r24, 0x00	; 0
    3a68:	22 c0       	rjmp	.+68     	; 0x3aae <xQueueGenericSendFromISR+0x62>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    3a6a:	1e 8d       	ldd	r17, Y+30	; 0x1e
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    3a6c:	8a 8d       	ldd	r24, Y+26	; 0x1a
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3a6e:	ce 01       	movw	r24, r28
    3a70:	42 2f       	mov	r20, r18
    3a72:	0e 94 76 1c 	call	0x38ec	; 0x38ec <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    3a76:	1f 3f       	cpi	r17, 0xFF	; 255
    3a78:	81 f4       	brne	.+32     	; 0x3a9a <xQueueGenericSendFromISR+0x4e>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3a7a:	89 89       	ldd	r24, Y+17	; 0x11
    3a7c:	88 23       	and	r24, r24
    3a7e:	b1 f0       	breq	.+44     	; 0x3aac <xQueueGenericSendFromISR+0x60>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3a80:	ce 01       	movw	r24, r28
    3a82:	41 96       	adiw	r24, 0x11	; 17
    3a84:	0e 94 ef 25 	call	0x4bde	; 0x4bde <xTaskRemoveFromEventList>
    3a88:	88 23       	and	r24, r24
    3a8a:	81 f0       	breq	.+32     	; 0x3aac <xQueueGenericSendFromISR+0x60>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    3a8c:	e1 14       	cp	r14, r1
    3a8e:	f1 04       	cpc	r15, r1
    3a90:	69 f0       	breq	.+26     	; 0x3aac <xQueueGenericSendFromISR+0x60>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    3a92:	81 e0       	ldi	r24, 0x01	; 1
    3a94:	f7 01       	movw	r30, r14
    3a96:	80 83       	st	Z, r24
    3a98:	0a c0       	rjmp	.+20     	; 0x3aae <xQueueGenericSendFromISR+0x62>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    3a9a:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <uxTaskGetNumberOfTasks>
    3a9e:	18 17       	cp	r17, r24
    3aa0:	28 f4       	brcc	.+10     	; 0x3aac <xQueueGenericSendFromISR+0x60>
    3aa2:	81 2f       	mov	r24, r17
    3aa4:	8f 5f       	subi	r24, 0xFF	; 255
    3aa6:	8e 8f       	std	Y+30, r24	; 0x1e
    3aa8:	81 e0       	ldi	r24, 0x01	; 1
    3aaa:	01 c0       	rjmp	.+2      	; 0x3aae <xQueueGenericSendFromISR+0x62>
    3aac:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    3aae:	df 91       	pop	r29
    3ab0:	cf 91       	pop	r28
    3ab2:	1f 91       	pop	r17
    3ab4:	ff 90       	pop	r15
    3ab6:	ef 90       	pop	r14
    3ab8:	08 95       	ret

00003aba <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3aba:	ef 92       	push	r14
    3abc:	ff 92       	push	r15
    3abe:	1f 93       	push	r17
    3ac0:	cf 93       	push	r28
    3ac2:	df 93       	push	r29
    3ac4:	ec 01       	movw	r28, r24

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    3ac6:	0f b6       	in	r0, 0x3f	; 63
    3ac8:	f8 94       	cli
    3aca:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    3acc:	1e 8d       	ldd	r17, Y+30	; 0x1e

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    3ace:	11 16       	cp	r1, r17
    3ad0:	c4 f4       	brge	.+48     	; 0x3b02 <prvUnlockQueue+0x48>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3ad2:	89 89       	ldd	r24, Y+17	; 0x11
    3ad4:	88 23       	and	r24, r24
    3ad6:	a9 f0       	breq	.+42     	; 0x3b02 <prvUnlockQueue+0x48>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3ad8:	0f 2e       	mov	r0, r31
    3ada:	f1 e1       	ldi	r31, 0x11	; 17
    3adc:	ef 2e       	mov	r14, r31
    3ade:	ff 24       	eor	r15, r15
    3ae0:	f0 2d       	mov	r31, r0
    3ae2:	ec 0e       	add	r14, r28
    3ae4:	fd 1e       	adc	r15, r29
    3ae6:	03 c0       	rjmp	.+6      	; 0x3aee <prvUnlockQueue+0x34>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3ae8:	89 89       	ldd	r24, Y+17	; 0x11
    3aea:	88 23       	and	r24, r24
    3aec:	51 f0       	breq	.+20     	; 0x3b02 <prvUnlockQueue+0x48>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3aee:	c7 01       	movw	r24, r14
    3af0:	0e 94 ef 25 	call	0x4bde	; 0x4bde <xTaskRemoveFromEventList>
    3af4:	88 23       	and	r24, r24
    3af6:	11 f0       	breq	.+4      	; 0x3afc <prvUnlockQueue+0x42>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
    3af8:	0e 94 90 27 	call	0x4f20	; 0x4f20 <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    3afc:	11 50       	subi	r17, 0x01	; 1
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    3afe:	11 16       	cp	r1, r17
    3b00:	9c f3       	brlt	.-26     	; 0x3ae8 <prvUnlockQueue+0x2e>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    3b02:	8f ef       	ldi	r24, 0xFF	; 255
    3b04:	8e 8f       	std	Y+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    3b06:	0f 90       	pop	r0
    3b08:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    3b0a:	0f b6       	in	r0, 0x3f	; 63
    3b0c:	f8 94       	cli
    3b0e:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    3b10:	1d 8d       	ldd	r17, Y+29	; 0x1d

        while( cRxLock > queueLOCKED_UNMODIFIED )
    3b12:	11 16       	cp	r1, r17
    3b14:	bc f4       	brge	.+46     	; 0x3b44 <prvUnlockQueue+0x8a>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3b16:	88 85       	ldd	r24, Y+8	; 0x08
    3b18:	88 23       	and	r24, r24
    3b1a:	a1 f0       	breq	.+40     	; 0x3b44 <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3b1c:	ee 24       	eor	r14, r14
    3b1e:	ff 24       	eor	r15, r15
    3b20:	68 94       	set
    3b22:	e3 f8       	bld	r14, 3
    3b24:	ec 0e       	add	r14, r28
    3b26:	fd 1e       	adc	r15, r29
    3b28:	03 c0       	rjmp	.+6      	; 0x3b30 <prvUnlockQueue+0x76>
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3b2a:	88 85       	ldd	r24, Y+8	; 0x08
    3b2c:	88 23       	and	r24, r24
    3b2e:	51 f0       	breq	.+20     	; 0x3b44 <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3b30:	c7 01       	movw	r24, r14
    3b32:	0e 94 ef 25 	call	0x4bde	; 0x4bde <xTaskRemoveFromEventList>
    3b36:	88 23       	and	r24, r24
    3b38:	11 f0       	breq	.+4      	; 0x3b3e <prvUnlockQueue+0x84>
                {
                    vTaskMissedYield();
    3b3a:	0e 94 90 27 	call	0x4f20	; 0x4f20 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    3b3e:	11 50       	subi	r17, 0x01	; 1
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    3b40:	11 16       	cp	r1, r17
    3b42:	9c f3       	brlt	.-26     	; 0x3b2a <prvUnlockQueue+0x70>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    3b44:	8f ef       	ldi	r24, 0xFF	; 255
    3b46:	8d 8f       	std	Y+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    3b48:	0f 90       	pop	r0
    3b4a:	0f be       	out	0x3f, r0	; 63
}
    3b4c:	df 91       	pop	r29
    3b4e:	cf 91       	pop	r28
    3b50:	1f 91       	pop	r17
    3b52:	ff 90       	pop	r15
    3b54:	ef 90       	pop	r14
    3b56:	08 95       	ret

00003b58 <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    3b58:	6f 92       	push	r6
    3b5a:	7f 92       	push	r7
    3b5c:	8f 92       	push	r8
    3b5e:	9f 92       	push	r9
    3b60:	af 92       	push	r10
    3b62:	bf 92       	push	r11
    3b64:	cf 92       	push	r12
    3b66:	df 92       	push	r13
    3b68:	ef 92       	push	r14
    3b6a:	ff 92       	push	r15
    3b6c:	0f 93       	push	r16
    3b6e:	1f 93       	push	r17
    3b70:	df 93       	push	r29
    3b72:	cf 93       	push	r28
    3b74:	00 d0       	rcall	.+0      	; 0x3b76 <xQueuePeek+0x1e>
    3b76:	00 d0       	rcall	.+0      	; 0x3b78 <xQueuePeek+0x20>
    3b78:	0f 92       	push	r0
    3b7a:	cd b7       	in	r28, 0x3d	; 61
    3b7c:	de b7       	in	r29, 0x3e	; 62
    3b7e:	7c 01       	movw	r14, r24
    3b80:	3b 01       	movw	r6, r22
    3b82:	5d 83       	std	Y+5, r21	; 0x05
    3b84:	4c 83       	std	Y+4, r20	; 0x04
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3b86:	0f 2e       	mov	r0, r31
    3b88:	f1 e1       	ldi	r31, 0x11	; 17
    3b8a:	8f 2e       	mov	r8, r31
    3b8c:	99 24       	eor	r9, r9
    3b8e:	f0 2d       	mov	r31, r0
    3b90:	88 0e       	add	r8, r24
    3b92:	99 1e       	adc	r9, r25
    3b94:	00 e0       	ldi	r16, 0x00	; 0
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3b96:	6e 01       	movw	r12, r28
    3b98:	08 94       	sec
    3b9a:	c1 1c       	adc	r12, r1
    3b9c:	d1 1c       	adc	r13, r1
    3b9e:	11 e0       	ldi	r17, 0x01	; 1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3ba0:	aa 24       	eor	r10, r10
    3ba2:	bb 24       	eor	r11, r11
    3ba4:	68 94       	set
    3ba6:	a2 f8       	bld	r10, 2
    3ba8:	ac 0e       	add	r10, r28
    3baa:	bd 1e       	adc	r11, r29
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3bac:	0f b6       	in	r0, 0x3f	; 63
    3bae:	f8 94       	cli
    3bb0:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3bb2:	f7 01       	movw	r30, r14
    3bb4:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3bb6:	88 23       	and	r24, r24
    3bb8:	b9 f0       	breq	.+46     	; 0x3be8 <xQueuePeek+0x90>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3bba:	06 81       	ldd	r16, Z+6	; 0x06
    3bbc:	17 81       	ldd	r17, Z+7	; 0x07

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    3bbe:	c7 01       	movw	r24, r14
    3bc0:	b3 01       	movw	r22, r6
    3bc2:	0e 94 43 1c 	call	0x3886	; 0x3886 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3bc6:	f7 01       	movw	r30, r14
    3bc8:	17 83       	std	Z+7, r17	; 0x07
    3bca:	06 83       	std	Z+6, r16	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3bcc:	81 89       	ldd	r24, Z+17	; 0x11
    3bce:	88 23       	and	r24, r24
    3bd0:	39 f0       	breq	.+14     	; 0x3be0 <xQueuePeek+0x88>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3bd2:	c4 01       	movw	r24, r8
    3bd4:	0e 94 ef 25 	call	0x4bde	; 0x4bde <xTaskRemoveFromEventList>
    3bd8:	88 23       	and	r24, r24
    3bda:	11 f0       	breq	.+4      	; 0x3be0 <xQueuePeek+0x88>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    3bdc:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3be0:	0f 90       	pop	r0
    3be2:	0f be       	out	0x3f, r0	; 63
    3be4:	81 e0       	ldi	r24, 0x01	; 1
    3be6:	4e c0       	rjmp	.+156    	; 0x3c84 <xQueuePeek+0x12c>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3be8:	8c 81       	ldd	r24, Y+4	; 0x04
    3bea:	9d 81       	ldd	r25, Y+5	; 0x05
    3bec:	89 2b       	or	r24, r25
    3bee:	21 f4       	brne	.+8      	; 0x3bf8 <xQueuePeek+0xa0>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3bf0:	0f 90       	pop	r0
    3bf2:	0f be       	out	0x3f, r0	; 63
    3bf4:	80 e0       	ldi	r24, 0x00	; 0
    3bf6:	46 c0       	rjmp	.+140    	; 0x3c84 <xQueuePeek+0x12c>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    3bf8:	00 23       	and	r16, r16
    3bfa:	21 f4       	brne	.+8      	; 0x3c04 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3bfc:	c6 01       	movw	r24, r12
    3bfe:	0e 94 55 27 	call	0x4eaa	; 0x4eaa <vTaskInternalSetTimeOutState>
    3c02:	01 2f       	mov	r16, r17
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3c04:	0f 90       	pop	r0
    3c06:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    3c08:	0e 94 81 25 	call	0x4b02	; 0x4b02 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3c0c:	0f b6       	in	r0, 0x3f	; 63
    3c0e:	f8 94       	cli
    3c10:	0f 92       	push	r0
    3c12:	f7 01       	movw	r30, r14
    3c14:	85 8d       	ldd	r24, Z+29	; 0x1d
    3c16:	8f 3f       	cpi	r24, 0xFF	; 255
    3c18:	09 f4       	brne	.+2      	; 0x3c1c <xQueuePeek+0xc4>
    3c1a:	15 8e       	std	Z+29, r1	; 0x1d
    3c1c:	f7 01       	movw	r30, r14
    3c1e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c20:	8f 3f       	cpi	r24, 0xFF	; 255
    3c22:	09 f4       	brne	.+2      	; 0x3c26 <xQueuePeek+0xce>
    3c24:	16 8e       	std	Z+30, r1	; 0x1e
    3c26:	0f 90       	pop	r0
    3c28:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3c2a:	c6 01       	movw	r24, r12
    3c2c:	b5 01       	movw	r22, r10
    3c2e:	0e 94 60 27 	call	0x4ec0	; 0x4ec0 <xTaskCheckForTimeOut>
    3c32:	88 23       	and	r24, r24
    3c34:	d9 f4       	brne	.+54     	; 0x3c6c <xQueuePeek+0x114>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3c36:	c7 01       	movw	r24, r14
    3c38:	0e 94 22 1c 	call	0x3844	; 0x3844 <prvIsQueueEmpty>
    3c3c:	88 23       	and	r24, r24
    3c3e:	81 f0       	breq	.+32     	; 0x3c60 <xQueuePeek+0x108>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3c40:	6c 81       	ldd	r22, Y+4	; 0x04
    3c42:	7d 81       	ldd	r23, Y+5	; 0x05
    3c44:	c4 01       	movw	r24, r8
    3c46:	0e 94 33 2f 	call	0x5e66	; 0x5e66 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    3c4a:	c7 01       	movw	r24, r14
    3c4c:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    3c50:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>
    3c54:	88 23       	and	r24, r24
    3c56:	09 f0       	breq	.+2      	; 0x3c5a <xQueuePeek+0x102>
    3c58:	a9 cf       	rjmp	.-174    	; 0x3bac <xQueuePeek+0x54>
                {
                    portYIELD_WITHIN_API();
    3c5a:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
    3c5e:	a6 cf       	rjmp	.-180    	; 0x3bac <xQueuePeek+0x54>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    3c60:	c7 01       	movw	r24, r14
    3c62:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3c66:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>
    3c6a:	a0 cf       	rjmp	.-192    	; 0x3bac <xQueuePeek+0x54>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    3c6c:	c7 01       	movw	r24, r14
    3c6e:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3c72:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3c76:	c7 01       	movw	r24, r14
    3c78:	0e 94 22 1c 	call	0x3844	; 0x3844 <prvIsQueueEmpty>
    3c7c:	88 23       	and	r24, r24
    3c7e:	09 f4       	brne	.+2      	; 0x3c82 <xQueuePeek+0x12a>
    3c80:	95 cf       	rjmp	.-214    	; 0x3bac <xQueuePeek+0x54>
    3c82:	80 e0       	ldi	r24, 0x00	; 0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    3c84:	0f 90       	pop	r0
    3c86:	0f 90       	pop	r0
    3c88:	0f 90       	pop	r0
    3c8a:	0f 90       	pop	r0
    3c8c:	0f 90       	pop	r0
    3c8e:	cf 91       	pop	r28
    3c90:	df 91       	pop	r29
    3c92:	1f 91       	pop	r17
    3c94:	0f 91       	pop	r16
    3c96:	ff 90       	pop	r15
    3c98:	ef 90       	pop	r14
    3c9a:	df 90       	pop	r13
    3c9c:	cf 90       	pop	r12
    3c9e:	bf 90       	pop	r11
    3ca0:	af 90       	pop	r10
    3ca2:	9f 90       	pop	r9
    3ca4:	8f 90       	pop	r8
    3ca6:	7f 90       	pop	r7
    3ca8:	6f 90       	pop	r6
    3caa:	08 95       	ret

00003cac <xQueueSemaphoreTake>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    3cac:	8f 92       	push	r8
    3cae:	9f 92       	push	r9
    3cb0:	af 92       	push	r10
    3cb2:	bf 92       	push	r11
    3cb4:	cf 92       	push	r12
    3cb6:	df 92       	push	r13
    3cb8:	ef 92       	push	r14
    3cba:	ff 92       	push	r15
    3cbc:	0f 93       	push	r16
    3cbe:	1f 93       	push	r17
    3cc0:	df 93       	push	r29
    3cc2:	cf 93       	push	r28
    3cc4:	00 d0       	rcall	.+0      	; 0x3cc6 <xQueueSemaphoreTake+0x1a>
    3cc6:	00 d0       	rcall	.+0      	; 0x3cc8 <xQueueSemaphoreTake+0x1c>
    3cc8:	0f 92       	push	r0
    3cca:	cd b7       	in	r28, 0x3d	; 61
    3ccc:	de b7       	in	r29, 0x3e	; 62
    3cce:	8c 01       	movw	r16, r24
    3cd0:	7d 83       	std	Y+5, r23	; 0x05
    3cd2:	6c 83       	std	Y+4, r22	; 0x04
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3cd4:	0f 2e       	mov	r0, r31
    3cd6:	f1 e1       	ldi	r31, 0x11	; 17
    3cd8:	8f 2e       	mov	r8, r31
    3cda:	99 24       	eor	r9, r9
    3cdc:	f0 2d       	mov	r31, r0
    3cde:	88 0e       	add	r8, r24
    3ce0:	99 1e       	adc	r9, r25
    3ce2:	ff 24       	eor	r15, r15
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3ce4:	6e 01       	movw	r12, r28
    3ce6:	08 94       	sec
    3ce8:	c1 1c       	adc	r12, r1
    3cea:	d1 1c       	adc	r13, r1
    3cec:	ee 24       	eor	r14, r14
    3cee:	e3 94       	inc	r14

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3cf0:	aa 24       	eor	r10, r10
    3cf2:	bb 24       	eor	r11, r11
    3cf4:	68 94       	set
    3cf6:	a2 f8       	bld	r10, 2
    3cf8:	ac 0e       	add	r10, r28
    3cfa:	bd 1e       	adc	r11, r29
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3cfc:	0f b6       	in	r0, 0x3f	; 63
    3cfe:	f8 94       	cli
    3d00:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    3d02:	f8 01       	movw	r30, r16
    3d04:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    3d06:	88 23       	and	r24, r24
    3d08:	89 f0       	breq	.+34     	; 0x3d2c <xQueueSemaphoreTake+0x80>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    3d0a:	81 50       	subi	r24, 0x01	; 1
    3d0c:	82 8f       	std	Z+26, r24	; 0x1a
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3d0e:	80 85       	ldd	r24, Z+8	; 0x08
    3d10:	88 23       	and	r24, r24
    3d12:	41 f0       	breq	.+16     	; 0x3d24 <xQueueSemaphoreTake+0x78>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3d14:	c8 01       	movw	r24, r16
    3d16:	08 96       	adiw	r24, 0x08	; 8
    3d18:	0e 94 ef 25 	call	0x4bde	; 0x4bde <xTaskRemoveFromEventList>
    3d1c:	88 23       	and	r24, r24
    3d1e:	11 f0       	breq	.+4      	; 0x3d24 <xQueueSemaphoreTake+0x78>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    3d20:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3d24:	0f 90       	pop	r0
    3d26:	0f be       	out	0x3f, r0	; 63
    3d28:	81 e0       	ldi	r24, 0x01	; 1
    3d2a:	4e c0       	rjmp	.+156    	; 0x3dc8 <xQueueSemaphoreTake+0x11c>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3d2c:	8c 81       	ldd	r24, Y+4	; 0x04
    3d2e:	9d 81       	ldd	r25, Y+5	; 0x05
    3d30:	89 2b       	or	r24, r25
    3d32:	21 f4       	brne	.+8      	; 0x3d3c <xQueueSemaphoreTake+0x90>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    3d34:	0f 90       	pop	r0
    3d36:	0f be       	out	0x3f, r0	; 63
    3d38:	80 e0       	ldi	r24, 0x00	; 0
    3d3a:	46 c0       	rjmp	.+140    	; 0x3dc8 <xQueueSemaphoreTake+0x11c>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    3d3c:	ff 20       	and	r15, r15
    3d3e:	21 f4       	brne	.+8      	; 0x3d48 <xQueueSemaphoreTake+0x9c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3d40:	c6 01       	movw	r24, r12
    3d42:	0e 94 55 27 	call	0x4eaa	; 0x4eaa <vTaskInternalSetTimeOutState>
    3d46:	fe 2c       	mov	r15, r14
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3d48:	0f 90       	pop	r0
    3d4a:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    3d4c:	0e 94 81 25 	call	0x4b02	; 0x4b02 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3d50:	0f b6       	in	r0, 0x3f	; 63
    3d52:	f8 94       	cli
    3d54:	0f 92       	push	r0
    3d56:	f8 01       	movw	r30, r16
    3d58:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d5a:	8f 3f       	cpi	r24, 0xFF	; 255
    3d5c:	09 f4       	brne	.+2      	; 0x3d60 <xQueueSemaphoreTake+0xb4>
    3d5e:	15 8e       	std	Z+29, r1	; 0x1d
    3d60:	f8 01       	movw	r30, r16
    3d62:	86 8d       	ldd	r24, Z+30	; 0x1e
    3d64:	8f 3f       	cpi	r24, 0xFF	; 255
    3d66:	09 f4       	brne	.+2      	; 0x3d6a <xQueueSemaphoreTake+0xbe>
    3d68:	16 8e       	std	Z+30, r1	; 0x1e
    3d6a:	0f 90       	pop	r0
    3d6c:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3d6e:	c6 01       	movw	r24, r12
    3d70:	b5 01       	movw	r22, r10
    3d72:	0e 94 60 27 	call	0x4ec0	; 0x4ec0 <xTaskCheckForTimeOut>
    3d76:	88 23       	and	r24, r24
    3d78:	d9 f4       	brne	.+54     	; 0x3db0 <xQueueSemaphoreTake+0x104>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3d7a:	c8 01       	movw	r24, r16
    3d7c:	0e 94 22 1c 	call	0x3844	; 0x3844 <prvIsQueueEmpty>
    3d80:	88 23       	and	r24, r24
    3d82:	81 f0       	breq	.+32     	; 0x3da4 <xQueueSemaphoreTake+0xf8>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3d84:	6c 81       	ldd	r22, Y+4	; 0x04
    3d86:	7d 81       	ldd	r23, Y+5	; 0x05
    3d88:	c4 01       	movw	r24, r8
    3d8a:	0e 94 33 2f 	call	0x5e66	; 0x5e66 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    3d8e:	c8 01       	movw	r24, r16
    3d90:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    3d94:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>
    3d98:	88 23       	and	r24, r24
    3d9a:	09 f0       	breq	.+2      	; 0x3d9e <xQueueSemaphoreTake+0xf2>
    3d9c:	af cf       	rjmp	.-162    	; 0x3cfc <xQueueSemaphoreTake+0x50>
                {
                    portYIELD_WITHIN_API();
    3d9e:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
    3da2:	ac cf       	rjmp	.-168    	; 0x3cfc <xQueueSemaphoreTake+0x50>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    3da4:	c8 01       	movw	r24, r16
    3da6:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3daa:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>
    3dae:	a6 cf       	rjmp	.-180    	; 0x3cfc <xQueueSemaphoreTake+0x50>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    3db0:	c8 01       	movw	r24, r16
    3db2:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3db6:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3dba:	c8 01       	movw	r24, r16
    3dbc:	0e 94 22 1c 	call	0x3844	; 0x3844 <prvIsQueueEmpty>
    3dc0:	88 23       	and	r24, r24
    3dc2:	09 f4       	brne	.+2      	; 0x3dc6 <xQueueSemaphoreTake+0x11a>
    3dc4:	9b cf       	rjmp	.-202    	; 0x3cfc <xQueueSemaphoreTake+0x50>
    3dc6:	80 e0       	ldi	r24, 0x00	; 0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    3dc8:	0f 90       	pop	r0
    3dca:	0f 90       	pop	r0
    3dcc:	0f 90       	pop	r0
    3dce:	0f 90       	pop	r0
    3dd0:	0f 90       	pop	r0
    3dd2:	cf 91       	pop	r28
    3dd4:	df 91       	pop	r29
    3dd6:	1f 91       	pop	r17
    3dd8:	0f 91       	pop	r16
    3dda:	ff 90       	pop	r15
    3ddc:	ef 90       	pop	r14
    3dde:	df 90       	pop	r13
    3de0:	cf 90       	pop	r12
    3de2:	bf 90       	pop	r11
    3de4:	af 90       	pop	r10
    3de6:	9f 90       	pop	r9
    3de8:	8f 90       	pop	r8
    3dea:	08 95       	ret

00003dec <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    3dec:	5f 92       	push	r5
    3dee:	6f 92       	push	r6
    3df0:	7f 92       	push	r7
    3df2:	8f 92       	push	r8
    3df4:	9f 92       	push	r9
    3df6:	af 92       	push	r10
    3df8:	bf 92       	push	r11
    3dfa:	cf 92       	push	r12
    3dfc:	df 92       	push	r13
    3dfe:	ef 92       	push	r14
    3e00:	ff 92       	push	r15
    3e02:	0f 93       	push	r16
    3e04:	1f 93       	push	r17
    3e06:	df 93       	push	r29
    3e08:	cf 93       	push	r28
    3e0a:	00 d0       	rcall	.+0      	; 0x3e0c <xQueueReceive+0x20>
    3e0c:	00 d0       	rcall	.+0      	; 0x3e0e <xQueueReceive+0x22>
    3e0e:	0f 92       	push	r0
    3e10:	cd b7       	in	r28, 0x3d	; 61
    3e12:	de b7       	in	r29, 0x3e	; 62
    3e14:	8c 01       	movw	r16, r24
    3e16:	3b 01       	movw	r6, r22
    3e18:	5d 83       	std	Y+5, r21	; 0x05
    3e1a:	4c 83       	std	Y+4, r20	; 0x04
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3e1c:	0f 2e       	mov	r0, r31
    3e1e:	f1 e1       	ldi	r31, 0x11	; 17
    3e20:	8f 2e       	mov	r8, r31
    3e22:	99 24       	eor	r9, r9
    3e24:	f0 2d       	mov	r31, r0
    3e26:	88 0e       	add	r8, r24
    3e28:	99 1e       	adc	r9, r25
    3e2a:	ee 24       	eor	r14, r14
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3e2c:	6e 01       	movw	r12, r28
    3e2e:	08 94       	sec
    3e30:	c1 1c       	adc	r12, r1
    3e32:	d1 1c       	adc	r13, r1
    3e34:	55 24       	eor	r5, r5
    3e36:	53 94       	inc	r5

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3e38:	aa 24       	eor	r10, r10
    3e3a:	bb 24       	eor	r11, r11
    3e3c:	68 94       	set
    3e3e:	a2 f8       	bld	r10, 2
    3e40:	ac 0e       	add	r10, r28
    3e42:	bd 1e       	adc	r11, r29
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3e44:	0f b6       	in	r0, 0x3f	; 63
    3e46:	f8 94       	cli
    3e48:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3e4a:	f8 01       	movw	r30, r16
    3e4c:	f2 8c       	ldd	r15, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3e4e:	ff 20       	and	r15, r15
    3e50:	b9 f0       	breq	.+46     	; 0x3e80 <xQueueReceive+0x94>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    3e52:	c8 01       	movw	r24, r16
    3e54:	b3 01       	movw	r22, r6
    3e56:	0e 94 43 1c 	call	0x3886	; 0x3886 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3e5a:	8f 2d       	mov	r24, r15
    3e5c:	81 50       	subi	r24, 0x01	; 1
    3e5e:	f8 01       	movw	r30, r16
    3e60:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3e62:	80 85       	ldd	r24, Z+8	; 0x08
    3e64:	88 23       	and	r24, r24
    3e66:	41 f0       	breq	.+16     	; 0x3e78 <xQueueReceive+0x8c>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3e68:	c8 01       	movw	r24, r16
    3e6a:	08 96       	adiw	r24, 0x08	; 8
    3e6c:	0e 94 ef 25 	call	0x4bde	; 0x4bde <xTaskRemoveFromEventList>
    3e70:	88 23       	and	r24, r24
    3e72:	11 f0       	breq	.+4      	; 0x3e78 <xQueueReceive+0x8c>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    3e74:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3e78:	0f 90       	pop	r0
    3e7a:	0f be       	out	0x3f, r0	; 63
    3e7c:	81 e0       	ldi	r24, 0x01	; 1
    3e7e:	4e c0       	rjmp	.+156    	; 0x3f1c <xQueueReceive+0x130>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3e80:	8c 81       	ldd	r24, Y+4	; 0x04
    3e82:	9d 81       	ldd	r25, Y+5	; 0x05
    3e84:	89 2b       	or	r24, r25
    3e86:	21 f4       	brne	.+8      	; 0x3e90 <xQueueReceive+0xa4>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3e88:	0f 90       	pop	r0
    3e8a:	0f be       	out	0x3f, r0	; 63
    3e8c:	80 e0       	ldi	r24, 0x00	; 0
    3e8e:	46 c0       	rjmp	.+140    	; 0x3f1c <xQueueReceive+0x130>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    3e90:	ee 20       	and	r14, r14
    3e92:	21 f4       	brne	.+8      	; 0x3e9c <xQueueReceive+0xb0>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3e94:	c6 01       	movw	r24, r12
    3e96:	0e 94 55 27 	call	0x4eaa	; 0x4eaa <vTaskInternalSetTimeOutState>
    3e9a:	e5 2c       	mov	r14, r5
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3e9c:	0f 90       	pop	r0
    3e9e:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    3ea0:	0e 94 81 25 	call	0x4b02	; 0x4b02 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3ea4:	0f b6       	in	r0, 0x3f	; 63
    3ea6:	f8 94       	cli
    3ea8:	0f 92       	push	r0
    3eaa:	f8 01       	movw	r30, r16
    3eac:	85 8d       	ldd	r24, Z+29	; 0x1d
    3eae:	8f 3f       	cpi	r24, 0xFF	; 255
    3eb0:	09 f4       	brne	.+2      	; 0x3eb4 <xQueueReceive+0xc8>
    3eb2:	15 8e       	std	Z+29, r1	; 0x1d
    3eb4:	f8 01       	movw	r30, r16
    3eb6:	86 8d       	ldd	r24, Z+30	; 0x1e
    3eb8:	8f 3f       	cpi	r24, 0xFF	; 255
    3eba:	09 f4       	brne	.+2      	; 0x3ebe <xQueueReceive+0xd2>
    3ebc:	16 8e       	std	Z+30, r1	; 0x1e
    3ebe:	0f 90       	pop	r0
    3ec0:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3ec2:	c6 01       	movw	r24, r12
    3ec4:	b5 01       	movw	r22, r10
    3ec6:	0e 94 60 27 	call	0x4ec0	; 0x4ec0 <xTaskCheckForTimeOut>
    3eca:	88 23       	and	r24, r24
    3ecc:	d9 f4       	brne	.+54     	; 0x3f04 <xQueueReceive+0x118>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3ece:	c8 01       	movw	r24, r16
    3ed0:	0e 94 22 1c 	call	0x3844	; 0x3844 <prvIsQueueEmpty>
    3ed4:	88 23       	and	r24, r24
    3ed6:	81 f0       	breq	.+32     	; 0x3ef8 <xQueueReceive+0x10c>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3ed8:	6c 81       	ldd	r22, Y+4	; 0x04
    3eda:	7d 81       	ldd	r23, Y+5	; 0x05
    3edc:	c4 01       	movw	r24, r8
    3ede:	0e 94 33 2f 	call	0x5e66	; 0x5e66 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    3ee2:	c8 01       	movw	r24, r16
    3ee4:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    3ee8:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>
    3eec:	88 23       	and	r24, r24
    3eee:	09 f0       	breq	.+2      	; 0x3ef2 <xQueueReceive+0x106>
    3ef0:	a9 cf       	rjmp	.-174    	; 0x3e44 <xQueueReceive+0x58>
                {
                    portYIELD_WITHIN_API();
    3ef2:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
    3ef6:	a6 cf       	rjmp	.-180    	; 0x3e44 <xQueueReceive+0x58>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    3ef8:	c8 01       	movw	r24, r16
    3efa:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3efe:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>
    3f02:	a0 cf       	rjmp	.-192    	; 0x3e44 <xQueueReceive+0x58>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    3f04:	c8 01       	movw	r24, r16
    3f06:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3f0a:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3f0e:	c8 01       	movw	r24, r16
    3f10:	0e 94 22 1c 	call	0x3844	; 0x3844 <prvIsQueueEmpty>
    3f14:	88 23       	and	r24, r24
    3f16:	09 f4       	brne	.+2      	; 0x3f1a <xQueueReceive+0x12e>
    3f18:	95 cf       	rjmp	.-214    	; 0x3e44 <xQueueReceive+0x58>
    3f1a:	80 e0       	ldi	r24, 0x00	; 0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    3f1c:	0f 90       	pop	r0
    3f1e:	0f 90       	pop	r0
    3f20:	0f 90       	pop	r0
    3f22:	0f 90       	pop	r0
    3f24:	0f 90       	pop	r0
    3f26:	cf 91       	pop	r28
    3f28:	df 91       	pop	r29
    3f2a:	1f 91       	pop	r17
    3f2c:	0f 91       	pop	r16
    3f2e:	ff 90       	pop	r15
    3f30:	ef 90       	pop	r14
    3f32:	df 90       	pop	r13
    3f34:	cf 90       	pop	r12
    3f36:	bf 90       	pop	r11
    3f38:	af 90       	pop	r10
    3f3a:	9f 90       	pop	r9
    3f3c:	8f 90       	pop	r8
    3f3e:	7f 90       	pop	r7
    3f40:	6f 90       	pop	r6
    3f42:	5f 90       	pop	r5
    3f44:	08 95       	ret

00003f46 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    3f46:	5f 92       	push	r5
    3f48:	6f 92       	push	r6
    3f4a:	7f 92       	push	r7
    3f4c:	8f 92       	push	r8
    3f4e:	9f 92       	push	r9
    3f50:	af 92       	push	r10
    3f52:	bf 92       	push	r11
    3f54:	cf 92       	push	r12
    3f56:	df 92       	push	r13
    3f58:	ef 92       	push	r14
    3f5a:	ff 92       	push	r15
    3f5c:	0f 93       	push	r16
    3f5e:	1f 93       	push	r17
    3f60:	df 93       	push	r29
    3f62:	cf 93       	push	r28
    3f64:	00 d0       	rcall	.+0      	; 0x3f66 <xQueueGenericSend+0x20>
    3f66:	00 d0       	rcall	.+0      	; 0x3f68 <xQueueGenericSend+0x22>
    3f68:	0f 92       	push	r0
    3f6a:	cd b7       	in	r28, 0x3d	; 61
    3f6c:	de b7       	in	r29, 0x3e	; 62
    3f6e:	8c 01       	movw	r16, r24
    3f70:	3b 01       	movw	r6, r22
    3f72:	5d 83       	std	Y+5, r21	; 0x05
    3f74:	4c 83       	std	Y+4, r20	; 0x04
    3f76:	e2 2e       	mov	r14, r18
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3f78:	aa 24       	eor	r10, r10
    3f7a:	bb 24       	eor	r11, r11
    3f7c:	68 94       	set
    3f7e:	a3 f8       	bld	r10, 3
    3f80:	a8 0e       	add	r10, r24
    3f82:	b9 1e       	adc	r11, r25
    3f84:	ff 24       	eor	r15, r15
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3f86:	6e 01       	movw	r12, r28
    3f88:	08 94       	sec
    3f8a:	c1 1c       	adc	r12, r1
    3f8c:	d1 1c       	adc	r13, r1
    3f8e:	55 24       	eor	r5, r5
    3f90:	53 94       	inc	r5

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3f92:	88 24       	eor	r8, r8
    3f94:	99 24       	eor	r9, r9
    3f96:	68 94       	set
    3f98:	82 f8       	bld	r8, 2
    3f9a:	8c 0e       	add	r8, r28
    3f9c:	9d 1e       	adc	r9, r29
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3f9e:	0f b6       	in	r0, 0x3f	; 63
    3fa0:	f8 94       	cli
    3fa2:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3fa4:	f8 01       	movw	r30, r16
    3fa6:	92 8d       	ldd	r25, Z+26	; 0x1a
    3fa8:	83 8d       	ldd	r24, Z+27	; 0x1b
    3faa:	98 17       	cp	r25, r24
    3fac:	18 f0       	brcs	.+6      	; 0x3fb4 <xQueueGenericSend+0x6e>
    3fae:	f2 e0       	ldi	r31, 0x02	; 2
    3fb0:	ef 16       	cp	r14, r31
    3fb2:	d9 f4       	brne	.+54     	; 0x3fea <xQueueGenericSend+0xa4>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3fb4:	c8 01       	movw	r24, r16
    3fb6:	b3 01       	movw	r22, r6
    3fb8:	4e 2d       	mov	r20, r14
    3fba:	0e 94 76 1c 	call	0x38ec	; 0x38ec <prvCopyDataToQueue>
    3fbe:	98 2f       	mov	r25, r24

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3fc0:	f8 01       	movw	r30, r16
    3fc2:	81 89       	ldd	r24, Z+17	; 0x11
    3fc4:	88 23       	and	r24, r24
    3fc6:	49 f0       	breq	.+18     	; 0x3fda <xQueueGenericSend+0x94>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3fc8:	c8 01       	movw	r24, r16
    3fca:	41 96       	adiw	r24, 0x11	; 17
    3fcc:	0e 94 ef 25 	call	0x4bde	; 0x4bde <xTaskRemoveFromEventList>
    3fd0:	88 23       	and	r24, r24
    3fd2:	39 f0       	breq	.+14     	; 0x3fe2 <xQueueGenericSend+0x9c>
                        {
                            /* The unblocked task has a priority higher than
                             * our own so yield immediately.  Yes it is ok to do
                             * this from within the critical section - the kernel
                             * takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
    3fd4:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
    3fd8:	04 c0       	rjmp	.+8      	; 0x3fe2 <xQueueGenericSend+0x9c>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
    3fda:	99 23       	and	r25, r25
    3fdc:	11 f0       	breq	.+4      	; 0x3fe2 <xQueueGenericSend+0x9c>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
    3fde:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    3fe2:	0f 90       	pop	r0
    3fe4:	0f be       	out	0x3f, r0	; 63
    3fe6:	81 e0       	ldi	r24, 0x01	; 1
    3fe8:	4e c0       	rjmp	.+156    	; 0x4086 <xQueueGenericSend+0x140>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3fea:	8c 81       	ldd	r24, Y+4	; 0x04
    3fec:	9d 81       	ldd	r25, Y+5	; 0x05
    3fee:	89 2b       	or	r24, r25
    3ff0:	21 f4       	brne	.+8      	; 0x3ffa <xQueueGenericSend+0xb4>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3ff2:	0f 90       	pop	r0
    3ff4:	0f be       	out	0x3f, r0	; 63
    3ff6:	80 e0       	ldi	r24, 0x00	; 0
    3ff8:	46 c0       	rjmp	.+140    	; 0x4086 <xQueueGenericSend+0x140>
                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
                }
                else if( xEntryTimeSet == pdFALSE )
    3ffa:	ff 20       	and	r15, r15
    3ffc:	21 f4       	brne	.+8      	; 0x4006 <xQueueGenericSend+0xc0>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3ffe:	c6 01       	movw	r24, r12
    4000:	0e 94 55 27 	call	0x4eaa	; 0x4eaa <vTaskInternalSetTimeOutState>
    4004:	f5 2c       	mov	r15, r5
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    4006:	0f 90       	pop	r0
    4008:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    400a:	0e 94 81 25 	call	0x4b02	; 0x4b02 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    400e:	0f b6       	in	r0, 0x3f	; 63
    4010:	f8 94       	cli
    4012:	0f 92       	push	r0
    4014:	f8 01       	movw	r30, r16
    4016:	85 8d       	ldd	r24, Z+29	; 0x1d
    4018:	8f 3f       	cpi	r24, 0xFF	; 255
    401a:	09 f4       	brne	.+2      	; 0x401e <xQueueGenericSend+0xd8>
    401c:	15 8e       	std	Z+29, r1	; 0x1d
    401e:	f8 01       	movw	r30, r16
    4020:	86 8d       	ldd	r24, Z+30	; 0x1e
    4022:	8f 3f       	cpi	r24, 0xFF	; 255
    4024:	09 f4       	brne	.+2      	; 0x4028 <xQueueGenericSend+0xe2>
    4026:	16 8e       	std	Z+30, r1	; 0x1e
    4028:	0f 90       	pop	r0
    402a:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    402c:	c6 01       	movw	r24, r12
    402e:	b4 01       	movw	r22, r8
    4030:	0e 94 60 27 	call	0x4ec0	; 0x4ec0 <xTaskCheckForTimeOut>
    4034:	88 23       	and	r24, r24
    4036:	09 f5       	brne	.+66     	; 0x407a <xQueueGenericSend+0x134>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    4038:	0f b6       	in	r0, 0x3f	; 63
    403a:	f8 94       	cli
    403c:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    403e:	f8 01       	movw	r30, r16
    4040:	92 8d       	ldd	r25, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    4042:	0f 90       	pop	r0
    4044:	0f be       	out	0x3f, r0	; 63
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    4046:	f8 01       	movw	r30, r16
    4048:	83 8d       	ldd	r24, Z+27	; 0x1b
    404a:	98 17       	cp	r25, r24
    404c:	81 f4       	brne	.+32     	; 0x406e <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    404e:	6c 81       	ldd	r22, Y+4	; 0x04
    4050:	7d 81       	ldd	r23, Y+5	; 0x05
    4052:	c5 01       	movw	r24, r10
    4054:	0e 94 33 2f 	call	0x5e66	; 0x5e66 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    4058:	c8 01       	movw	r24, r16
    405a:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    405e:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>
    4062:	88 23       	and	r24, r24
    4064:	09 f0       	breq	.+2      	; 0x4068 <xQueueGenericSend+0x122>
    4066:	9b cf       	rjmp	.-202    	; 0x3f9e <xQueueGenericSend+0x58>
                {
                    portYIELD_WITHIN_API();
    4068:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
    406c:	98 cf       	rjmp	.-208    	; 0x3f9e <xQueueGenericSend+0x58>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    406e:	c8 01       	movw	r24, r16
    4070:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    4074:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>
    4078:	92 cf       	rjmp	.-220    	; 0x3f9e <xQueueGenericSend+0x58>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    407a:	c8 01       	movw	r24, r16
    407c:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    4080:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>
    4084:	80 e0       	ldi	r24, 0x00	; 0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
    4086:	0f 90       	pop	r0
    4088:	0f 90       	pop	r0
    408a:	0f 90       	pop	r0
    408c:	0f 90       	pop	r0
    408e:	0f 90       	pop	r0
    4090:	cf 91       	pop	r28
    4092:	df 91       	pop	r29
    4094:	1f 91       	pop	r17
    4096:	0f 91       	pop	r16
    4098:	ff 90       	pop	r15
    409a:	ef 90       	pop	r14
    409c:	df 90       	pop	r13
    409e:	cf 90       	pop	r12
    40a0:	bf 90       	pop	r11
    40a2:	af 90       	pop	r10
    40a4:	9f 90       	pop	r9
    40a6:	8f 90       	pop	r8
    40a8:	7f 90       	pop	r7
    40aa:	6f 90       	pop	r6
    40ac:	5f 90       	pop	r5
    40ae:	08 95       	ret

000040b0 <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    40b0:	cf 93       	push	r28
    40b2:	df 93       	push	r29
    40b4:	ec 01       	movw	r28, r24
    40b6:	e6 2f       	mov	r30, r22
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    40b8:	00 97       	sbiw	r24, 0x00	; 0
    40ba:	09 f4       	brne	.+2      	; 0x40be <xQueueGenericReset+0xe>
    40bc:	4f c0       	rjmp	.+158    	; 0x415c <xQueueGenericReset+0xac>
    40be:	2b 8d       	ldd	r18, Y+27	; 0x1b
    40c0:	22 23       	and	r18, r18
    40c2:	09 f4       	brne	.+2      	; 0x40c6 <xQueueGenericReset+0x16>
    40c4:	4b c0       	rjmp	.+150    	; 0x415c <xQueueGenericReset+0xac>
    40c6:	3c 8d       	ldd	r19, Y+28	; 0x1c
    40c8:	8f ef       	ldi	r24, 0xFF	; 255
    40ca:	9f e7       	ldi	r25, 0x7F	; 127
    40cc:	62 2f       	mov	r22, r18
    40ce:	70 e0       	ldi	r23, 0x00	; 0
    40d0:	0e 94 52 31 	call	0x62a4	; 0x62a4 <__udivmodhi4>
    40d4:	83 2f       	mov	r24, r19
    40d6:	90 e0       	ldi	r25, 0x00	; 0
    40d8:	68 17       	cp	r22, r24
    40da:	79 07       	cpc	r23, r25
    40dc:	08 f4       	brcc	.+2      	; 0x40e0 <xQueueGenericReset+0x30>
    40de:	3e c0       	rjmp	.+124    	; 0x415c <xQueueGenericReset+0xac>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    40e0:	0f b6       	in	r0, 0x3f	; 63
    40e2:	f8 94       	cli
    40e4:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    40e6:	32 9f       	mul	r19, r18
    40e8:	c0 01       	movw	r24, r0
    40ea:	11 24       	eor	r1, r1
    40ec:	48 81       	ld	r20, Y
    40ee:	59 81       	ldd	r21, Y+1	; 0x01
    40f0:	84 0f       	add	r24, r20
    40f2:	95 1f       	adc	r25, r21
    40f4:	9d 83       	std	Y+5, r25	; 0x05
    40f6:	8c 83       	std	Y+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    40f8:	1a 8e       	std	Y+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    40fa:	5b 83       	std	Y+3, r21	; 0x03
    40fc:	4a 83       	std	Y+2, r20	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    40fe:	2b 8d       	ldd	r18, Y+27	; 0x1b
    4100:	30 e0       	ldi	r19, 0x00	; 0
    4102:	21 50       	subi	r18, 0x01	; 1
    4104:	30 40       	sbci	r19, 0x00	; 0
    4106:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4108:	90 e0       	ldi	r25, 0x00	; 0
    410a:	bc 01       	movw	r22, r24
    410c:	26 9f       	mul	r18, r22
    410e:	c0 01       	movw	r24, r0
    4110:	27 9f       	mul	r18, r23
    4112:	90 0d       	add	r25, r0
    4114:	36 9f       	mul	r19, r22
    4116:	90 0d       	add	r25, r0
    4118:	11 24       	eor	r1, r1
    411a:	48 0f       	add	r20, r24
    411c:	59 1f       	adc	r21, r25
    411e:	5f 83       	std	Y+7, r21	; 0x07
    4120:	4e 83       	std	Y+6, r20	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    4122:	8f ef       	ldi	r24, 0xFF	; 255
    4124:	8d 8f       	std	Y+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    4126:	8e 8f       	std	Y+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    4128:	ee 23       	and	r30, r30
    412a:	61 f4       	brne	.+24     	; 0x4144 <xQueueGenericReset+0x94>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    412c:	88 85       	ldd	r24, Y+8	; 0x08
    412e:	88 23       	and	r24, r24
    4130:	89 f0       	breq	.+34     	; 0x4154 <xQueueGenericReset+0xa4>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4132:	ce 01       	movw	r24, r28
    4134:	08 96       	adiw	r24, 0x08	; 8
    4136:	0e 94 ef 25 	call	0x4bde	; 0x4bde <xTaskRemoveFromEventList>
    413a:	88 23       	and	r24, r24
    413c:	59 f0       	breq	.+22     	; 0x4154 <xQueueGenericReset+0xa4>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    413e:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
    4142:	08 c0       	rjmp	.+16     	; 0x4154 <xQueueGenericReset+0xa4>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    4144:	ce 01       	movw	r24, r28
    4146:	08 96       	adiw	r24, 0x08	; 8
    4148:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    414c:	ce 01       	movw	r24, r28
    414e:	41 96       	adiw	r24, 0x11	; 17
    4150:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    4154:	0f 90       	pop	r0
    4156:	0f be       	out	0x3f, r0	; 63
    4158:	81 e0       	ldi	r24, 0x01	; 1
    415a:	01 c0       	rjmp	.+2      	; 0x415e <xQueueGenericReset+0xae>
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    415c:	80 e0       	ldi	r24, 0x00	; 0
    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
}
    415e:	df 91       	pop	r29
    4160:	cf 91       	pop	r28
    4162:	08 95       	ret

00004164 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    4164:	0f 93       	push	r16
    4166:	1f 93       	push	r17
    4168:	cf 93       	push	r28
    416a:	df 93       	push	r29
    416c:	18 2f       	mov	r17, r24
    416e:	06 2f       	mov	r16, r22
        Queue_t * pxNewQueue = NULL;
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    4170:	88 23       	and	r24, r24
    4172:	41 f1       	breq	.+80     	; 0x41c4 <xQueueGenericCreate+0x60>
    4174:	8f ef       	ldi	r24, 0xFF	; 255
    4176:	9f e7       	ldi	r25, 0x7F	; 127
    4178:	61 2f       	mov	r22, r17
    417a:	70 e0       	ldi	r23, 0x00	; 0
    417c:	0e 94 52 31 	call	0x62a4	; 0x62a4 <__udivmodhi4>
    4180:	80 2f       	mov	r24, r16
    4182:	90 e0       	ldi	r25, 0x00	; 0
    4184:	68 17       	cp	r22, r24
    4186:	79 07       	cpc	r23, r25
    4188:	e8 f0       	brcs	.+58     	; 0x41c4 <xQueueGenericCreate+0x60>
    418a:	01 9f       	mul	r16, r17
    418c:	c0 01       	movw	r24, r0
    418e:	11 24       	eor	r1, r1
    4190:	2f e7       	ldi	r18, 0x7F	; 127
    4192:	81 3e       	cpi	r24, 0xE1	; 225
    4194:	92 07       	cpc	r25, r18
    4196:	b0 f4       	brcc	.+44     	; 0x41c4 <xQueueGenericCreate+0x60>
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    4198:	4f 96       	adiw	r24, 0x1f	; 31
    419a:	0e 94 7f 18 	call	0x30fe	; 0x30fe <pvPortMalloc>
    419e:	ec 01       	movw	r28, r24

            if( pxNewQueue != NULL )
    41a0:	20 97       	sbiw	r28, 0x00	; 0
    41a2:	91 f0       	breq	.+36     	; 0x41c8 <xQueueGenericCreate+0x64>
{
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    41a4:	00 23       	and	r16, r16
    41a6:	19 f4       	brne	.+6      	; 0x41ae <xQueueGenericCreate+0x4a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    41a8:	d9 83       	std	Y+1, r29	; 0x01
    41aa:	c8 83       	st	Y, r28
    41ac:	04 c0       	rjmp	.+8      	; 0x41b6 <xQueueGenericCreate+0x52>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    41ae:	ce 01       	movw	r24, r28
    41b0:	4f 96       	adiw	r24, 0x1f	; 31
    41b2:	99 83       	std	Y+1, r25	; 0x01
    41b4:	88 83       	st	Y, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    41b6:	1b 8f       	std	Y+27, r17	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    41b8:	0c 8f       	std	Y+28, r16	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    41ba:	ce 01       	movw	r24, r28
    41bc:	61 e0       	ldi	r22, 0x01	; 1
    41be:	0e 94 58 20 	call	0x40b0	; 0x40b0 <xQueueGenericReset>
    41c2:	02 c0       	rjmp	.+4      	; 0x41c8 <xQueueGenericCreate+0x64>
    41c4:	c0 e0       	ldi	r28, 0x00	; 0
    41c6:	d0 e0       	ldi	r29, 0x00	; 0
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
    41c8:	8c 2f       	mov	r24, r28
    41ca:	9d 2f       	mov	r25, r29
    41cc:	df 91       	pop	r29
    41ce:	cf 91       	pop	r28
    41d0:	1f 91       	pop	r17
    41d2:	0f 91       	pop	r16
    41d4:	08 95       	ret

000041d6 <xStreamBufferSetTriggerLevel>:
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
    41d6:	fc 01       	movw	r30, r24
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
    41d8:	61 15       	cp	r22, r1
    41da:	71 05       	cpc	r23, r1
    41dc:	11 f4       	brne	.+4      	; 0x41e2 <xStreamBufferSetTriggerLevel+0xc>
    41de:	61 e0       	ldi	r22, 0x01	; 1
    41e0:	70 e0       	ldi	r23, 0x00	; 0
        xTriggerLevel = ( size_t ) 1;
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
    41e2:	84 81       	ldd	r24, Z+4	; 0x04
    41e4:	95 81       	ldd	r25, Z+5	; 0x05
    41e6:	68 17       	cp	r22, r24
    41e8:	79 07       	cpc	r23, r25
    41ea:	10 f0       	brcs	.+4      	; 0x41f0 <xStreamBufferSetTriggerLevel+0x1a>
    41ec:	80 e0       	ldi	r24, 0x00	; 0
    41ee:	08 95       	ret
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    41f0:	77 83       	std	Z+7, r23	; 0x07
    41f2:	66 83       	std	Z+6, r22	; 0x06
    41f4:	81 e0       	ldi	r24, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    41f6:	08 95       	ret

000041f8 <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    41f8:	fc 01       	movw	r30, r24
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    41fa:	a4 81       	ldd	r26, Z+4	; 0x04
    41fc:	b5 81       	ldd	r27, Z+5	; 0x05
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
    41fe:	20 81       	ld	r18, Z
    4200:	31 81       	ldd	r19, Z+1	; 0x01
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    4202:	40 81       	ld	r20, Z
    4204:	51 81       	ldd	r21, Z+1	; 0x01
        xSpace -= pxStreamBuffer->xHead;
    4206:	62 81       	ldd	r22, Z+2	; 0x02
    4208:	73 81       	ldd	r23, Z+3	; 0x03
    } while( xOriginalTail != pxStreamBuffer->xTail );
    420a:	80 81       	ld	r24, Z
    420c:	91 81       	ldd	r25, Z+1	; 0x01
    420e:	82 17       	cp	r24, r18
    4210:	93 07       	cpc	r25, r19
    4212:	a9 f7       	brne	.-22     	; 0x41fe <xStreamBufferSpacesAvailable+0x6>
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    4214:	cd 01       	movw	r24, r26
    4216:	84 0f       	add	r24, r20
    4218:	95 1f       	adc	r25, r21
        xSpace -= pxStreamBuffer->xHead;
    421a:	01 97       	sbiw	r24, 0x01	; 1
    } while( xOriginalTail != pxStreamBuffer->xTail );

    xSpace -= ( size_t ) 1;
    421c:	9c 01       	movw	r18, r24
    421e:	26 1b       	sub	r18, r22
    4220:	37 0b       	sbc	r19, r23

    if( xSpace >= pxStreamBuffer->xLength )
    4222:	2a 17       	cp	r18, r26
    4224:	3b 07       	cpc	r19, r27
    4226:	10 f0       	brcs	.+4      	; 0x422c <xStreamBufferSpacesAvailable+0x34>
    {
        xSpace -= pxStreamBuffer->xLength;
    4228:	2a 1b       	sub	r18, r26
    422a:	3b 0b       	sbc	r19, r27
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
}
    422c:	82 2f       	mov	r24, r18
    422e:	93 2f       	mov	r25, r19
    4230:	08 95       	ret

00004232 <xStreamBufferIsEmpty>:
    return xCount;
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    4232:	fc 01       	movw	r30, r24
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
    4234:	20 81       	ld	r18, Z
    4236:	31 81       	ldd	r19, Z+1	; 0x01

    if( pxStreamBuffer->xHead == xTail )
    4238:	82 81       	ldd	r24, Z+2	; 0x02
    423a:	93 81       	ldd	r25, Z+3	; 0x03
    423c:	40 e0       	ldi	r20, 0x00	; 0
    423e:	82 17       	cp	r24, r18
    4240:	93 07       	cpc	r25, r19
    4242:	09 f4       	brne	.+2      	; 0x4246 <xStreamBufferIsEmpty+0x14>
    4244:	41 e0       	ldi	r20, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    4246:	84 2f       	mov	r24, r20
    4248:	08 95       	ret

0000424a <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    424a:	cf 93       	push	r28
    424c:	df 93       	push	r29
    424e:	fc 01       	movw	r30, r24

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4250:	86 85       	ldd	r24, Z+14	; 0x0e
    4252:	80 fd       	sbrc	r24, 0
    4254:	03 c0       	rjmp	.+6      	; 0x425c <xStreamBufferIsFull+0x12>
    4256:	c0 e0       	ldi	r28, 0x00	; 0
    4258:	d0 e0       	ldi	r29, 0x00	; 0
    425a:	02 c0       	rjmp	.+4      	; 0x4260 <xStreamBufferIsFull+0x16>
    425c:	c2 e0       	ldi	r28, 0x02	; 2
    425e:	d0 e0       	ldi	r29, 0x00	; 0
    {
        xBytesToStoreMessageLength = 0;
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    4260:	cf 01       	movw	r24, r30
    4262:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <xStreamBufferSpacesAvailable>
    4266:	20 e0       	ldi	r18, 0x00	; 0
    4268:	c8 17       	cp	r28, r24
    426a:	d9 07       	cpc	r29, r25
    426c:	08 f0       	brcs	.+2      	; 0x4270 <xStreamBufferIsFull+0x26>
    426e:	21 e0       	ldi	r18, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    4270:	82 2f       	mov	r24, r18
    4272:	df 91       	pop	r29
    4274:	cf 91       	pop	r28
    4276:	08 95       	ret

00004278 <prvBytesInBuffer>:
    return xTail;
}
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    4278:	fc 01       	movw	r30, r24
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    427a:	44 81       	ldd	r20, Z+4	; 0x04
    427c:	55 81       	ldd	r21, Z+5	; 0x05
    427e:	82 81       	ldd	r24, Z+2	; 0x02
    4280:	93 81       	ldd	r25, Z+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    4282:	20 81       	ld	r18, Z
    4284:	31 81       	ldd	r19, Z+1	; 0x01
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    4286:	84 0f       	add	r24, r20
    4288:	95 1f       	adc	r25, r21
    xCount -= pxStreamBuffer->xTail;
    428a:	bc 01       	movw	r22, r24
    428c:	62 1b       	sub	r22, r18
    428e:	73 0b       	sbc	r23, r19
    4290:	9b 01       	movw	r18, r22

    if( xCount >= pxStreamBuffer->xLength )
    4292:	64 17       	cp	r22, r20
    4294:	75 07       	cpc	r23, r21
    4296:	10 f0       	brcs	.+4      	; 0x429c <prvBytesInBuffer+0x24>
    {
        xCount -= pxStreamBuffer->xLength;
    4298:	24 1b       	sub	r18, r20
    429a:	35 0b       	sbc	r19, r21
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
}
    429c:	82 2f       	mov	r24, r18
    429e:	93 2f       	mov	r25, r19
    42a0:	08 95       	ret

000042a2 <xStreamBufferBytesAvailable>:
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
    42a2:	0e 94 3c 21 	call	0x4278	; 0x4278 <prvBytesInBuffer>
    return xReturn;
}
    42a6:	08 95       	ret

000042a8 <xStreamBufferReceiveCompletedFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
    42a8:	cf 92       	push	r12
    42aa:	df 92       	push	r13
    42ac:	ef 92       	push	r14
    42ae:	ff 92       	push	r15
    42b0:	0f 93       	push	r16
    42b2:	cf 93       	push	r28
    42b4:	df 93       	push	r29
    42b6:	ec 01       	movw	r28, r24
    42b8:	6b 01       	movw	r12, r22

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    42ba:	8a 85       	ldd	r24, Y+10	; 0x0a
    42bc:	9b 85       	ldd	r25, Y+11	; 0x0b
    42be:	89 2b       	or	r24, r25
    42c0:	11 f4       	brne	.+4      	; 0x42c6 <xStreamBufferReceiveCompletedFromISR+0x1e>
    42c2:	80 e0       	ldi	r24, 0x00	; 0
    42c4:	0f c0       	rjmp	.+30     	; 0x42e4 <xStreamBufferReceiveCompletedFromISR+0x3c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    42c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    42c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    42ca:	60 e0       	ldi	r22, 0x00	; 0
    42cc:	20 e0       	ldi	r18, 0x00	; 0
    42ce:	30 e0       	ldi	r19, 0x00	; 0
    42d0:	40 e0       	ldi	r20, 0x00	; 0
    42d2:	50 e0       	ldi	r21, 0x00	; 0
    42d4:	00 e0       	ldi	r16, 0x00	; 0
    42d6:	ee 24       	eor	r14, r14
    42d8:	ff 24       	eor	r15, r15
    42da:	0e 94 ea 28 	call	0x51d4	; 0x51d4 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    42de:	1b 86       	std	Y+11, r1	; 0x0b
    42e0:	1a 86       	std	Y+10, r1	; 0x0a
    42e2:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    42e4:	df 91       	pop	r29
    42e6:	cf 91       	pop	r28
    42e8:	0f 91       	pop	r16
    42ea:	ff 90       	pop	r15
    42ec:	ef 90       	pop	r14
    42ee:	df 90       	pop	r13
    42f0:	cf 90       	pop	r12
    42f2:	08 95       	ret

000042f4 <xStreamBufferSendCompletedFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
    42f4:	cf 92       	push	r12
    42f6:	df 92       	push	r13
    42f8:	ef 92       	push	r14
    42fa:	ff 92       	push	r15
    42fc:	0f 93       	push	r16
    42fe:	cf 93       	push	r28
    4300:	df 93       	push	r29
    4302:	ec 01       	movw	r28, r24
    4304:	6b 01       	movw	r12, r22

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    4306:	88 85       	ldd	r24, Y+8	; 0x08
    4308:	99 85       	ldd	r25, Y+9	; 0x09
    430a:	89 2b       	or	r24, r25
    430c:	11 f4       	brne	.+4      	; 0x4312 <xStreamBufferSendCompletedFromISR+0x1e>
    430e:	80 e0       	ldi	r24, 0x00	; 0
    4310:	0f c0       	rjmp	.+30     	; 0x4330 <xStreamBufferSendCompletedFromISR+0x3c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    4312:	88 85       	ldd	r24, Y+8	; 0x08
    4314:	99 85       	ldd	r25, Y+9	; 0x09
    4316:	60 e0       	ldi	r22, 0x00	; 0
    4318:	20 e0       	ldi	r18, 0x00	; 0
    431a:	30 e0       	ldi	r19, 0x00	; 0
    431c:	40 e0       	ldi	r20, 0x00	; 0
    431e:	50 e0       	ldi	r21, 0x00	; 0
    4320:	00 e0       	ldi	r16, 0x00	; 0
    4322:	ee 24       	eor	r14, r14
    4324:	ff 24       	eor	r15, r15
    4326:	0e 94 ea 28 	call	0x51d4	; 0x51d4 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    432a:	19 86       	std	Y+9, r1	; 0x09
    432c:	18 86       	std	Y+8, r1	; 0x08
    432e:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    4330:	df 91       	pop	r29
    4332:	cf 91       	pop	r28
    4334:	0f 91       	pop	r16
    4336:	ff 90       	pop	r15
    4338:	ef 90       	pop	r14
    433a:	df 90       	pop	r13
    433c:	cf 90       	pop	r12
    433e:	08 95       	ret

00004340 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
    4340:	af 92       	push	r10
    4342:	bf 92       	push	r11
    4344:	cf 92       	push	r12
    4346:	df 92       	push	r13
    4348:	ef 92       	push	r14
    434a:	ff 92       	push	r15
    434c:	0f 93       	push	r16
    434e:	1f 93       	push	r17
    4350:	cf 93       	push	r28
    4352:	df 93       	push	r29
    4354:	6c 01       	movw	r12, r24
    4356:	8b 01       	movw	r16, r22
    4358:	7a 01       	movw	r14, r20
    435a:	59 01       	movw	r10, r18
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
    435c:	dc 01       	movw	r26, r24
    435e:	14 96       	adiw	r26, 0x04	; 4
    4360:	8d 91       	ld	r24, X+
    4362:	9c 91       	ld	r25, X
    4364:	15 97       	sbiw	r26, 0x05	; 5
    4366:	ec 01       	movw	r28, r24
    4368:	c2 1b       	sub	r28, r18
    436a:	d3 0b       	sbc	r29, r19
    436c:	4c 17       	cp	r20, r28
    436e:	5d 07       	cpc	r21, r29
    4370:	08 f4       	brcc	.+2      	; 0x4374 <prvReadBytesFromBuffer+0x34>
    4372:	ea 01       	movw	r28, r20

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4374:	f6 01       	movw	r30, r12
    4376:	24 85       	ldd	r18, Z+12	; 0x0c
    4378:	35 85       	ldd	r19, Z+13	; 0x0d
    437a:	2a 0d       	add	r18, r10
    437c:	3b 1d       	adc	r19, r11
    437e:	80 2f       	mov	r24, r16
    4380:	91 2f       	mov	r25, r17
    4382:	62 2f       	mov	r22, r18
    4384:	73 2f       	mov	r23, r19
    4386:	4c 2f       	mov	r20, r28
    4388:	5d 2f       	mov	r21, r29
    438a:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
    438e:	ce 15       	cp	r28, r14
    4390:	df 05       	cpc	r29, r15
    4392:	90 f4       	brcc	.+36     	; 0x43b8 <prvReadBytesFromBuffer+0x78>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4394:	98 01       	movw	r18, r16
    4396:	2c 0f       	add	r18, r28
    4398:	3d 1f       	adc	r19, r29
    439a:	f7 01       	movw	r30, r14
    439c:	ec 1b       	sub	r30, r28
    439e:	fd 0b       	sbc	r31, r29
    43a0:	d6 01       	movw	r26, r12
    43a2:	1c 96       	adiw	r26, 0x0c	; 12
    43a4:	6c 91       	ld	r22, X
    43a6:	1c 97       	sbiw	r26, 0x0c	; 12
    43a8:	1d 96       	adiw	r26, 0x0d	; 13
    43aa:	7c 91       	ld	r23, X
    43ac:	82 2f       	mov	r24, r18
    43ae:	93 2f       	mov	r25, r19
    43b0:	4e 2f       	mov	r20, r30
    43b2:	5f 2f       	mov	r21, r31
    43b4:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
    43b8:	95 01       	movw	r18, r10
    43ba:	2e 0d       	add	r18, r14
    43bc:	3f 1d       	adc	r19, r15

    if( xTail >= pxStreamBuffer->xLength )
    43be:	f6 01       	movw	r30, r12
    43c0:	84 81       	ldd	r24, Z+4	; 0x04
    43c2:	95 81       	ldd	r25, Z+5	; 0x05
    43c4:	28 17       	cp	r18, r24
    43c6:	39 07       	cpc	r19, r25
    43c8:	10 f0       	brcs	.+4      	; 0x43ce <prvReadBytesFromBuffer+0x8e>
    {
        xTail -= pxStreamBuffer->xLength;
    43ca:	28 1b       	sub	r18, r24
    43cc:	39 0b       	sbc	r19, r25
    }

    return xTail;
}
    43ce:	82 2f       	mov	r24, r18
    43d0:	93 2f       	mov	r25, r19
    43d2:	df 91       	pop	r29
    43d4:	cf 91       	pop	r28
    43d6:	1f 91       	pop	r17
    43d8:	0f 91       	pop	r16
    43da:	ff 90       	pop	r15
    43dc:	ef 90       	pop	r14
    43de:	df 90       	pop	r13
    43e0:	cf 90       	pop	r12
    43e2:	bf 90       	pop	r11
    43e4:	af 90       	pop	r10
    43e6:	08 95       	ret

000043e8 <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
    43e8:	af 92       	push	r10
    43ea:	bf 92       	push	r11
    43ec:	cf 92       	push	r12
    43ee:	df 92       	push	r13
    43f0:	ef 92       	push	r14
    43f2:	ff 92       	push	r15
    43f4:	0f 93       	push	r16
    43f6:	1f 93       	push	r17
    43f8:	df 93       	push	r29
    43fa:	cf 93       	push	r28
    43fc:	00 d0       	rcall	.+0      	; 0x43fe <prvReadMessageFromBuffer+0x16>
    43fe:	cd b7       	in	r28, 0x3d	; 61
    4400:	de b7       	in	r29, 0x3e	; 62
    4402:	7c 01       	movw	r14, r24
    4404:	5b 01       	movw	r10, r22
    4406:	6a 01       	movw	r12, r20
    4408:	89 01       	movw	r16, r18
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
    440a:	fc 01       	movw	r30, r24
    440c:	20 81       	ld	r18, Z
    440e:	31 81       	ldd	r19, Z+1	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4410:	86 85       	ldd	r24, Z+14	; 0x0e
    4412:	80 fd       	sbrc	r24, 0
    4414:	02 c0       	rjmp	.+4      	; 0x441a <prvReadMessageFromBuffer+0x32>
    4416:	ca 01       	movw	r24, r20
    4418:	13 c0       	rjmp	.+38     	; 0x4440 <prvReadMessageFromBuffer+0x58>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
    441a:	c7 01       	movw	r24, r14
    441c:	be 01       	movw	r22, r28
    441e:	6f 5f       	subi	r22, 0xFF	; 255
    4420:	7f 4f       	sbci	r23, 0xFF	; 255
    4422:	42 e0       	ldi	r20, 0x02	; 2
    4424:	50 e0       	ldi	r21, 0x00	; 0
    4426:	0e 94 a0 21 	call	0x4340	; 0x4340 <prvReadBytesFromBuffer>
    442a:	9c 01       	movw	r18, r24
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    442c:	89 81       	ldd	r24, Y+1	; 0x01
    442e:	9a 81       	ldd	r25, Y+2	; 0x02
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
    4430:	c8 16       	cp	r12, r24
    4432:	d9 06       	cpc	r13, r25
    4434:	18 f4       	brcc	.+6      	; 0x443c <prvReadMessageFromBuffer+0x54>
    4436:	00 e0       	ldi	r16, 0x00	; 0
    4438:	10 e0       	ldi	r17, 0x00	; 0
    443a:	11 c0       	rjmp	.+34     	; 0x445e <prvReadMessageFromBuffer+0x76>
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
        xNextMessageLength = ( size_t ) xTempNextMessageLength;

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
    443c:	02 50       	subi	r16, 0x02	; 2
    443e:	10 40       	sbci	r17, 0x00	; 0
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
    4440:	80 17       	cp	r24, r16
    4442:	91 07       	cpc	r25, r17
    4444:	08 f4       	brcc	.+2      	; 0x4448 <prvReadMessageFromBuffer+0x60>
    4446:	8c 01       	movw	r16, r24

    if( xCount != ( size_t ) 0 )
    4448:	01 15       	cp	r16, r1
    444a:	11 05       	cpc	r17, r1
    444c:	41 f0       	breq	.+16     	; 0x445e <prvReadMessageFromBuffer+0x76>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    444e:	c7 01       	movw	r24, r14
    4450:	b5 01       	movw	r22, r10
    4452:	a8 01       	movw	r20, r16
    4454:	0e 94 a0 21 	call	0x4340	; 0x4340 <prvReadBytesFromBuffer>
    4458:	f7 01       	movw	r30, r14
    445a:	91 83       	std	Z+1, r25	; 0x01
    445c:	80 83       	st	Z, r24
    }

    return xCount;
}
    445e:	80 2f       	mov	r24, r16
    4460:	91 2f       	mov	r25, r17
    4462:	0f 90       	pop	r0
    4464:	0f 90       	pop	r0
    4466:	cf 91       	pop	r28
    4468:	df 91       	pop	r29
    446a:	1f 91       	pop	r17
    446c:	0f 91       	pop	r16
    446e:	ff 90       	pop	r15
    4470:	ef 90       	pop	r14
    4472:	df 90       	pop	r13
    4474:	cf 90       	pop	r12
    4476:	bf 90       	pop	r11
    4478:	af 90       	pop	r10
    447a:	08 95       	ret

0000447c <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
    447c:	af 92       	push	r10
    447e:	bf 92       	push	r11
    4480:	cf 92       	push	r12
    4482:	df 92       	push	r13
    4484:	ef 92       	push	r14
    4486:	ff 92       	push	r15
    4488:	0f 93       	push	r16
    448a:	1f 93       	push	r17
    448c:	cf 93       	push	r28
    448e:	df 93       	push	r29
    4490:	5c 01       	movw	r10, r24
    4492:	7b 01       	movw	r14, r22
    4494:	8a 01       	movw	r16, r20
    4496:	69 01       	movw	r12, r18
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4498:	fc 01       	movw	r30, r24
    449a:	86 85       	ldd	r24, Z+14	; 0x0e
    449c:	80 fd       	sbrc	r24, 0
    449e:	03 c0       	rjmp	.+6      	; 0x44a6 <xStreamBufferReceiveFromISR+0x2a>
    44a0:	c0 e0       	ldi	r28, 0x00	; 0
    44a2:	d0 e0       	ldi	r29, 0x00	; 0
    44a4:	02 c0       	rjmp	.+4      	; 0x44aa <xStreamBufferReceiveFromISR+0x2e>
    44a6:	c2 e0       	ldi	r28, 0x02	; 2
    44a8:	d0 e0       	ldi	r29, 0x00	; 0
    else
    {
        xBytesToStoreMessageLength = 0;
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    44aa:	c5 01       	movw	r24, r10
    44ac:	0e 94 3c 21 	call	0x4278	; 0x4278 <prvBytesInBuffer>
    44b0:	9c 01       	movw	r18, r24
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    44b2:	c8 17       	cp	r28, r24
    44b4:	d9 07       	cpc	r29, r25
    44b6:	18 f0       	brcs	.+6      	; 0x44be <xStreamBufferReceiveFromISR+0x42>
    44b8:	c0 e0       	ldi	r28, 0x00	; 0
    44ba:	d0 e0       	ldi	r29, 0x00	; 0
    44bc:	1c c0       	rjmp	.+56     	; 0x44f6 <xStreamBufferReceiveFromISR+0x7a>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    44be:	c5 01       	movw	r24, r10
    44c0:	b7 01       	movw	r22, r14
    44c2:	a8 01       	movw	r20, r16
    44c4:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <prvReadMessageFromBuffer>
    44c8:	ec 01       	movw	r28, r24

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    44ca:	00 97       	sbiw	r24, 0x00	; 0
    44cc:	a1 f0       	breq	.+40     	; 0x44f6 <xStreamBufferReceiveFromISR+0x7a>
        {
            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    44ce:	f5 01       	movw	r30, r10
    44d0:	82 85       	ldd	r24, Z+10	; 0x0a
    44d2:	93 85       	ldd	r25, Z+11	; 0x0b
    44d4:	89 2b       	or	r24, r25
    44d6:	79 f0       	breq	.+30     	; 0x44f6 <xStreamBufferReceiveFromISR+0x7a>
    44d8:	82 85       	ldd	r24, Z+10	; 0x0a
    44da:	93 85       	ldd	r25, Z+11	; 0x0b
    44dc:	60 e0       	ldi	r22, 0x00	; 0
    44de:	20 e0       	ldi	r18, 0x00	; 0
    44e0:	30 e0       	ldi	r19, 0x00	; 0
    44e2:	40 e0       	ldi	r20, 0x00	; 0
    44e4:	50 e0       	ldi	r21, 0x00	; 0
    44e6:	00 e0       	ldi	r16, 0x00	; 0
    44e8:	ee 24       	eor	r14, r14
    44ea:	ff 24       	eor	r15, r15
    44ec:	0e 94 ea 28 	call	0x51d4	; 0x51d4 <xTaskGenericNotifyFromISR>
    44f0:	f5 01       	movw	r30, r10
    44f2:	13 86       	std	Z+11, r1	; 0x0b
    44f4:	12 86       	std	Z+10, r1	; 0x0a
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
}
    44f6:	8c 2f       	mov	r24, r28
    44f8:	9d 2f       	mov	r25, r29
    44fa:	df 91       	pop	r29
    44fc:	cf 91       	pop	r28
    44fe:	1f 91       	pop	r17
    4500:	0f 91       	pop	r16
    4502:	ff 90       	pop	r15
    4504:	ef 90       	pop	r14
    4506:	df 90       	pop	r13
    4508:	cf 90       	pop	r12
    450a:	bf 90       	pop	r11
    450c:	af 90       	pop	r10
    450e:	08 95       	ret

00004510 <xStreamBufferNextMessageLengthBytes>:
    return xReceivedLength;
}
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    4510:	0f 93       	push	r16
    4512:	1f 93       	push	r17
    4514:	df 93       	push	r29
    4516:	cf 93       	push	r28
    4518:	00 d0       	rcall	.+0      	; 0x451a <xStreamBufferNextMessageLengthBytes+0xa>
    451a:	cd b7       	in	r28, 0x3d	; 61
    451c:	de b7       	in	r29, 0x3e	; 62
    451e:	8c 01       	movw	r16, r24
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4520:	fc 01       	movw	r30, r24
    4522:	86 85       	ldd	r24, Z+14	; 0x0e
    4524:	80 ff       	sbrs	r24, 0
    4526:	13 c0       	rjmp	.+38     	; 0x454e <xStreamBufferNextMessageLengthBytes+0x3e>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    4528:	c8 01       	movw	r24, r16
    452a:	0e 94 3c 21 	call	0x4278	; 0x4278 <prvBytesInBuffer>

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    452e:	03 97       	sbiw	r24, 0x03	; 3
    4530:	70 f0       	brcs	.+28     	; 0x454e <xStreamBufferNextMessageLengthBytes+0x3e>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
    4532:	f8 01       	movw	r30, r16
    4534:	20 81       	ld	r18, Z
    4536:	31 81       	ldd	r19, Z+1	; 0x01
    4538:	c8 01       	movw	r24, r16
    453a:	be 01       	movw	r22, r28
    453c:	6f 5f       	subi	r22, 0xFF	; 255
    453e:	7f 4f       	sbci	r23, 0xFF	; 255
    4540:	42 e0       	ldi	r20, 0x02	; 2
    4542:	50 e0       	ldi	r21, 0x00	; 0
    4544:	0e 94 a0 21 	call	0x4340	; 0x4340 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
    4548:	29 81       	ldd	r18, Y+1	; 0x01
    454a:	3a 81       	ldd	r19, Y+2	; 0x02
    454c:	02 c0       	rjmp	.+4      	; 0x4552 <xStreamBufferNextMessageLengthBytes+0x42>
    454e:	20 e0       	ldi	r18, 0x00	; 0
    4550:	30 e0       	ldi	r19, 0x00	; 0
    {
        xReturn = 0;
    }

    return xReturn;
}
    4552:	82 2f       	mov	r24, r18
    4554:	93 2f       	mov	r25, r19
    4556:	0f 90       	pop	r0
    4558:	0f 90       	pop	r0
    455a:	cf 91       	pop	r28
    455c:	df 91       	pop	r29
    455e:	1f 91       	pop	r17
    4560:	0f 91       	pop	r16
    4562:	08 95       	ret

00004564 <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
    4564:	af 92       	push	r10
    4566:	bf 92       	push	r11
    4568:	cf 92       	push	r12
    456a:	df 92       	push	r13
    456c:	ef 92       	push	r14
    456e:	ff 92       	push	r15
    4570:	0f 93       	push	r16
    4572:	1f 93       	push	r17
    4574:	cf 93       	push	r28
    4576:	df 93       	push	r29
    4578:	6c 01       	movw	r12, r24
    457a:	7b 01       	movw	r14, r22
    457c:	8a 01       	movw	r16, r20
    457e:	59 01       	movw	r10, r18
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
    4580:	dc 01       	movw	r26, r24
    4582:	14 96       	adiw	r26, 0x04	; 4
    4584:	8d 91       	ld	r24, X+
    4586:	9c 91       	ld	r25, X
    4588:	15 97       	sbiw	r26, 0x05	; 5
    458a:	ec 01       	movw	r28, r24
    458c:	c2 1b       	sub	r28, r18
    458e:	d3 0b       	sbc	r29, r19
    4590:	4c 17       	cp	r20, r28
    4592:	5d 07       	cpc	r21, r29
    4594:	08 f4       	brcc	.+2      	; 0x4598 <prvWriteBytesToBuffer+0x34>
    4596:	ea 01       	movw	r28, r20

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4598:	f6 01       	movw	r30, r12
    459a:	24 85       	ldd	r18, Z+12	; 0x0c
    459c:	35 85       	ldd	r19, Z+13	; 0x0d
    459e:	2a 0d       	add	r18, r10
    45a0:	3b 1d       	adc	r19, r11
    45a2:	82 2f       	mov	r24, r18
    45a4:	93 2f       	mov	r25, r19
    45a6:	6e 2d       	mov	r22, r14
    45a8:	7f 2d       	mov	r23, r15
    45aa:	4c 2f       	mov	r20, r28
    45ac:	5d 2f       	mov	r21, r29
    45ae:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
    45b2:	c0 17       	cp	r28, r16
    45b4:	d1 07       	cpc	r29, r17
    45b6:	90 f4       	brcc	.+36     	; 0x45dc <prvWriteBytesToBuffer+0x78>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    45b8:	f8 01       	movw	r30, r16
    45ba:	ec 1b       	sub	r30, r28
    45bc:	fd 0b       	sbc	r31, r29
    45be:	97 01       	movw	r18, r14
    45c0:	2c 0f       	add	r18, r28
    45c2:	3d 1f       	adc	r19, r29
    45c4:	d6 01       	movw	r26, r12
    45c6:	1c 96       	adiw	r26, 0x0c	; 12
    45c8:	8c 91       	ld	r24, X
    45ca:	1c 97       	sbiw	r26, 0x0c	; 12
    45cc:	1d 96       	adiw	r26, 0x0d	; 13
    45ce:	9c 91       	ld	r25, X
    45d0:	62 2f       	mov	r22, r18
    45d2:	73 2f       	mov	r23, r19
    45d4:	4e 2f       	mov	r20, r30
    45d6:	5f 2f       	mov	r21, r31
    45d8:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
    45dc:	95 01       	movw	r18, r10
    45de:	20 0f       	add	r18, r16
    45e0:	31 1f       	adc	r19, r17

    if( xHead >= pxStreamBuffer->xLength )
    45e2:	f6 01       	movw	r30, r12
    45e4:	84 81       	ldd	r24, Z+4	; 0x04
    45e6:	95 81       	ldd	r25, Z+5	; 0x05
    45e8:	28 17       	cp	r18, r24
    45ea:	39 07       	cpc	r19, r25
    45ec:	10 f0       	brcs	.+4      	; 0x45f2 <prvWriteBytesToBuffer+0x8e>
    {
        xHead -= pxStreamBuffer->xLength;
    45ee:	28 1b       	sub	r18, r24
    45f0:	39 0b       	sbc	r19, r25
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
}
    45f2:	82 2f       	mov	r24, r18
    45f4:	93 2f       	mov	r25, r19
    45f6:	df 91       	pop	r29
    45f8:	cf 91       	pop	r28
    45fa:	1f 91       	pop	r17
    45fc:	0f 91       	pop	r16
    45fe:	ff 90       	pop	r15
    4600:	ef 90       	pop	r14
    4602:	df 90       	pop	r13
    4604:	cf 90       	pop	r12
    4606:	bf 90       	pop	r11
    4608:	af 90       	pop	r10
    460a:	08 95       	ret

0000460c <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
    460c:	af 92       	push	r10
    460e:	bf 92       	push	r11
    4610:	cf 92       	push	r12
    4612:	df 92       	push	r13
    4614:	ef 92       	push	r14
    4616:	ff 92       	push	r15
    4618:	0f 93       	push	r16
    461a:	1f 93       	push	r17
    461c:	df 93       	push	r29
    461e:	cf 93       	push	r28
    4620:	00 d0       	rcall	.+0      	; 0x4622 <prvWriteMessageToBuffer+0x16>
    4622:	cd b7       	in	r28, 0x3d	; 61
    4624:	de b7       	in	r29, 0x3e	; 62
    4626:	6c 01       	movw	r12, r24
    4628:	5b 01       	movw	r10, r22
    462a:	7a 01       	movw	r14, r20
    size_t xNextHead = pxStreamBuffer->xHead;
    462c:	dc 01       	movw	r26, r24
    462e:	12 96       	adiw	r26, 0x02	; 2
    4630:	ed 91       	ld	r30, X+
    4632:	fc 91       	ld	r31, X
    4634:	13 97       	sbiw	r26, 0x03	; 3
    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4636:	1e 96       	adiw	r26, 0x0e	; 14
    4638:	8c 91       	ld	r24, X
    463a:	80 ff       	sbrs	r24, 0
    463c:	13 c0       	rjmp	.+38     	; 0x4664 <prvWriteMessageToBuffer+0x58>
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;

        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */
        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );

        if( xSpace >= xRequiredSpace )
    463e:	20 17       	cp	r18, r16
    4640:	31 07       	cpc	r19, r17
    4642:	18 f4       	brcc	.+6      	; 0x464a <prvWriteMessageToBuffer+0x3e>
    4644:	ee 24       	eor	r14, r14
    4646:	ff 24       	eor	r15, r15
    4648:	1d c0       	rjmp	.+58     	; 0x4684 <prvWriteMessageToBuffer+0x78>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        /* Convert xDataLengthBytes to the message length type. */
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
    464a:	5a 83       	std	Y+2, r21	; 0x02
    464c:	49 83       	std	Y+1, r20	; 0x01
        if( xSpace >= xRequiredSpace )
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
    464e:	c6 01       	movw	r24, r12
    4650:	be 01       	movw	r22, r28
    4652:	6f 5f       	subi	r22, 0xFF	; 255
    4654:	7f 4f       	sbci	r23, 0xFF	; 255
    4656:	42 e0       	ldi	r20, 0x02	; 2
    4658:	50 e0       	ldi	r21, 0x00	; 0
    465a:	9f 01       	movw	r18, r30
    465c:	0e 94 b2 22 	call	0x4564	; 0x4564 <prvWriteBytesToBuffer>
    4660:	fc 01       	movw	r30, r24
    4662:	04 c0       	rjmp	.+8      	; 0x466c <prvWriteMessageToBuffer+0x60>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    4664:	24 17       	cp	r18, r20
    4666:	35 07       	cpc	r19, r21
    4668:	08 f4       	brcc	.+2      	; 0x466c <prvWriteMessageToBuffer+0x60>
    466a:	79 01       	movw	r14, r18
    }

    if( xDataLengthBytes != ( size_t ) 0 )
    466c:	e1 14       	cp	r14, r1
    466e:	f1 04       	cpc	r15, r1
    4670:	49 f0       	breq	.+18     	; 0x4684 <prvWriteMessageToBuffer+0x78>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
    4672:	c6 01       	movw	r24, r12
    4674:	b5 01       	movw	r22, r10
    4676:	a7 01       	movw	r20, r14
    4678:	9f 01       	movw	r18, r30
    467a:	0e 94 b2 22 	call	0x4564	; 0x4564 <prvWriteBytesToBuffer>
    467e:	f6 01       	movw	r30, r12
    4680:	93 83       	std	Z+3, r25	; 0x03
    4682:	82 83       	std	Z+2, r24	; 0x02
    }

    return xDataLengthBytes;
}
    4684:	8e 2d       	mov	r24, r14
    4686:	9f 2d       	mov	r25, r15
    4688:	0f 90       	pop	r0
    468a:	0f 90       	pop	r0
    468c:	cf 91       	pop	r28
    468e:	df 91       	pop	r29
    4690:	1f 91       	pop	r17
    4692:	0f 91       	pop	r16
    4694:	ff 90       	pop	r15
    4696:	ef 90       	pop	r14
    4698:	df 90       	pop	r13
    469a:	cf 90       	pop	r12
    469c:	bf 90       	pop	r11
    469e:	af 90       	pop	r10
    46a0:	08 95       	ret

000046a2 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    46a2:	af 92       	push	r10
    46a4:	bf 92       	push	r11
    46a6:	cf 92       	push	r12
    46a8:	df 92       	push	r13
    46aa:	ef 92       	push	r14
    46ac:	ff 92       	push	r15
    46ae:	0f 93       	push	r16
    46b0:	1f 93       	push	r17
    46b2:	cf 93       	push	r28
    46b4:	df 93       	push	r29
    46b6:	5c 01       	movw	r10, r24
    46b8:	7b 01       	movw	r14, r22
    46ba:	ea 01       	movw	r28, r20
    46bc:	69 01       	movw	r12, r18

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    46be:	fc 01       	movw	r30, r24
    46c0:	86 85       	ldd	r24, Z+14	; 0x0e
    46c2:	80 fd       	sbrc	r24, 0
    46c4:	02 c0       	rjmp	.+4      	; 0x46ca <xStreamBufferSendFromISR+0x28>
    46c6:	8a 01       	movw	r16, r20
    46c8:	03 c0       	rjmp	.+6      	; 0x46d0 <xStreamBufferSendFromISR+0x2e>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    46ca:	8a 01       	movw	r16, r20
    46cc:	0e 5f       	subi	r16, 0xFE	; 254
    46ce:	1f 4f       	sbci	r17, 0xFF	; 255
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    46d0:	c5 01       	movw	r24, r10
    46d2:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <xStreamBufferSpacesAvailable>
    46d6:	9c 01       	movw	r18, r24
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    46d8:	c5 01       	movw	r24, r10
    46da:	b7 01       	movw	r22, r14
    46dc:	ae 01       	movw	r20, r28
    46de:	0e 94 06 23 	call	0x460c	; 0x460c <prvWriteMessageToBuffer>
    46e2:	ec 01       	movw	r28, r24

    if( xReturn > ( size_t ) 0 )
    46e4:	00 97       	sbiw	r24, 0x00	; 0
    46e6:	e1 f0       	breq	.+56     	; 0x4720 <xStreamBufferSendFromISR+0x7e>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    46e8:	c5 01       	movw	r24, r10
    46ea:	0e 94 3c 21 	call	0x4278	; 0x4278 <prvBytesInBuffer>
    46ee:	f5 01       	movw	r30, r10
    46f0:	26 81       	ldd	r18, Z+6	; 0x06
    46f2:	37 81       	ldd	r19, Z+7	; 0x07
    46f4:	82 17       	cp	r24, r18
    46f6:	93 07       	cpc	r25, r19
    46f8:	98 f0       	brcs	.+38     	; 0x4720 <xStreamBufferSendFromISR+0x7e>
        {
            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    46fa:	80 85       	ldd	r24, Z+8	; 0x08
    46fc:	91 85       	ldd	r25, Z+9	; 0x09
    46fe:	89 2b       	or	r24, r25
    4700:	79 f0       	breq	.+30     	; 0x4720 <xStreamBufferSendFromISR+0x7e>
    4702:	80 85       	ldd	r24, Z+8	; 0x08
    4704:	91 85       	ldd	r25, Z+9	; 0x09
    4706:	60 e0       	ldi	r22, 0x00	; 0
    4708:	20 e0       	ldi	r18, 0x00	; 0
    470a:	30 e0       	ldi	r19, 0x00	; 0
    470c:	40 e0       	ldi	r20, 0x00	; 0
    470e:	50 e0       	ldi	r21, 0x00	; 0
    4710:	00 e0       	ldi	r16, 0x00	; 0
    4712:	ee 24       	eor	r14, r14
    4714:	ff 24       	eor	r15, r15
    4716:	0e 94 ea 28 	call	0x51d4	; 0x51d4 <xTaskGenericNotifyFromISR>
    471a:	f5 01       	movw	r30, r10
    471c:	11 86       	std	Z+9, r1	; 0x09
    471e:	10 86       	std	Z+8, r1	; 0x08
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
}
    4720:	8c 2f       	mov	r24, r28
    4722:	9d 2f       	mov	r25, r29
    4724:	df 91       	pop	r29
    4726:	cf 91       	pop	r28
    4728:	1f 91       	pop	r17
    472a:	0f 91       	pop	r16
    472c:	ff 90       	pop	r15
    472e:	ef 90       	pop	r14
    4730:	df 90       	pop	r13
    4732:	cf 90       	pop	r12
    4734:	bf 90       	pop	r11
    4736:	af 90       	pop	r10
    4738:	08 95       	ret

0000473a <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
    473a:	4f 92       	push	r4
    473c:	5f 92       	push	r5
    473e:	6f 92       	push	r6
    4740:	7f 92       	push	r7
    4742:	8f 92       	push	r8
    4744:	9f 92       	push	r9
    4746:	af 92       	push	r10
    4748:	bf 92       	push	r11
    474a:	cf 92       	push	r12
    474c:	df 92       	push	r13
    474e:	ef 92       	push	r14
    4750:	ff 92       	push	r15
    4752:	0f 93       	push	r16
    4754:	1f 93       	push	r17
    4756:	cf 93       	push	r28
    4758:	df 93       	push	r29
    475a:	5c 01       	movw	r10, r24
    475c:	3b 01       	movw	r6, r22
    475e:	2a 01       	movw	r4, r20
    4760:	69 01       	movw	r12, r18
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4762:	fc 01       	movw	r30, r24
    4764:	86 85       	ldd	r24, Z+14	; 0x0e
    4766:	80 fd       	sbrc	r24, 0
    4768:	03 c0       	rjmp	.+6      	; 0x4770 <xStreamBufferReceive+0x36>
    476a:	88 24       	eor	r8, r8
    476c:	99 24       	eor	r9, r9
    476e:	04 c0       	rjmp	.+8      	; 0x4778 <xStreamBufferReceive+0x3e>
    4770:	88 24       	eor	r8, r8
    4772:	99 24       	eor	r9, r9
    4774:	68 94       	set
    4776:	81 f8       	bld	r8, 1
    else
    {
        xBytesToStoreMessageLength = 0;
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    4778:	c1 14       	cp	r12, r1
    477a:	d1 04       	cpc	r13, r1
    477c:	71 f1       	breq	.+92     	; 0x47da <xStreamBufferReceive+0xa0>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
    477e:	0f b6       	in	r0, 0x3f	; 63
    4780:	f8 94       	cli
    4782:	0f 92       	push	r0
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    4784:	c5 01       	movw	r24, r10
    4786:	0e 94 3c 21 	call	0x4278	; 0x4278 <prvBytesInBuffer>
    478a:	ec 01       	movw	r28, r24
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
    478c:	88 16       	cp	r8, r24
    478e:	99 06       	cpc	r9, r25
    4790:	50 f0       	brcs	.+20     	; 0x47a6 <xStreamBufferReceive+0x6c>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
    4792:	80 e0       	ldi	r24, 0x00	; 0
    4794:	90 e0       	ldi	r25, 0x00	; 0
    4796:	60 e0       	ldi	r22, 0x00	; 0
    4798:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    479c:	0e 94 cb 28 	call	0x5196	; 0x5196 <xTaskGetCurrentTaskHandle>
    47a0:	f5 01       	movw	r30, r10
    47a2:	91 87       	std	Z+9, r25	; 0x09
    47a4:	80 87       	std	Z+8, r24	; 0x08
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    47a6:	0f 90       	pop	r0
    47a8:	0f be       	out	0x3f, r0	; 63

        if( xBytesAvailable <= xBytesToStoreMessageLength )
    47aa:	8c 16       	cp	r8, r28
    47ac:	9d 06       	cpc	r9, r29
    47ae:	f8 f0       	brcs	.+62     	; 0x47ee <xStreamBufferReceive+0xb4>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    47b0:	80 e0       	ldi	r24, 0x00	; 0
    47b2:	40 e0       	ldi	r20, 0x00	; 0
    47b4:	50 e0       	ldi	r21, 0x00	; 0
    47b6:	60 e0       	ldi	r22, 0x00	; 0
    47b8:	70 e0       	ldi	r23, 0x00	; 0
    47ba:	00 e0       	ldi	r16, 0x00	; 0
    47bc:	10 e0       	ldi	r17, 0x00	; 0
    47be:	20 e0       	ldi	r18, 0x00	; 0
    47c0:	30 e0       	ldi	r19, 0x00	; 0
    47c2:	ee 24       	eor	r14, r14
    47c4:	ff 24       	eor	r15, r15
    47c6:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
    47ca:	f5 01       	movw	r30, r10
    47cc:	11 86       	std	Z+9, r1	; 0x09
    47ce:	10 86       	std	Z+8, r1	; 0x08

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    47d0:	c5 01       	movw	r24, r10
    47d2:	0e 94 3c 21 	call	0x4278	; 0x4278 <prvBytesInBuffer>
    47d6:	ec 01       	movw	r28, r24
    47d8:	04 c0       	rjmp	.+8      	; 0x47e2 <xStreamBufferReceive+0xa8>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    47da:	c5 01       	movw	r24, r10
    47dc:	0e 94 3c 21 	call	0x4278	; 0x4278 <prvBytesInBuffer>
    47e0:	ec 01       	movw	r28, r24
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    47e2:	8c 16       	cp	r8, r28
    47e4:	9d 06       	cpc	r9, r29
    47e6:	18 f0       	brcs	.+6      	; 0x47ee <xStreamBufferReceive+0xb4>
    47e8:	c0 e0       	ldi	r28, 0x00	; 0
    47ea:	d0 e0       	ldi	r29, 0x00	; 0
    47ec:	21 c0       	rjmp	.+66     	; 0x4830 <xStreamBufferReceive+0xf6>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    47ee:	c5 01       	movw	r24, r10
    47f0:	b3 01       	movw	r22, r6
    47f2:	a2 01       	movw	r20, r4
    47f4:	9e 01       	movw	r18, r28
    47f6:	0e 94 f4 21 	call	0x43e8	; 0x43e8 <prvReadMessageFromBuffer>
    47fa:	ec 01       	movw	r28, r24

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    47fc:	00 97       	sbiw	r24, 0x00	; 0
    47fe:	c1 f0       	breq	.+48     	; 0x4830 <xStreamBufferReceive+0xf6>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            prvRECEIVE_COMPLETED( xStreamBuffer );
    4800:	0e 94 81 25 	call	0x4b02	; 0x4b02 <vTaskSuspendAll>
    4804:	f5 01       	movw	r30, r10
    4806:	82 85       	ldd	r24, Z+10	; 0x0a
    4808:	93 85       	ldd	r25, Z+11	; 0x0b
    480a:	89 2b       	or	r24, r25
    480c:	79 f0       	breq	.+30     	; 0x482c <xStreamBufferReceive+0xf2>
    480e:	82 85       	ldd	r24, Z+10	; 0x0a
    4810:	93 85       	ldd	r25, Z+11	; 0x0b
    4812:	60 e0       	ldi	r22, 0x00	; 0
    4814:	20 e0       	ldi	r18, 0x00	; 0
    4816:	30 e0       	ldi	r19, 0x00	; 0
    4818:	40 e0       	ldi	r20, 0x00	; 0
    481a:	50 e0       	ldi	r21, 0x00	; 0
    481c:	00 e0       	ldi	r16, 0x00	; 0
    481e:	ee 24       	eor	r14, r14
    4820:	ff 24       	eor	r15, r15
    4822:	0e 94 38 2b 	call	0x5670	; 0x5670 <xTaskGenericNotify>
    4826:	f5 01       	movw	r30, r10
    4828:	13 86       	std	Z+11, r1	; 0x0b
    482a:	12 86       	std	Z+10, r1	; 0x0a
    482c:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
}
    4830:	8c 2f       	mov	r24, r28
    4832:	9d 2f       	mov	r25, r29
    4834:	df 91       	pop	r29
    4836:	cf 91       	pop	r28
    4838:	1f 91       	pop	r17
    483a:	0f 91       	pop	r16
    483c:	ff 90       	pop	r15
    483e:	ef 90       	pop	r14
    4840:	df 90       	pop	r13
    4842:	cf 90       	pop	r12
    4844:	bf 90       	pop	r11
    4846:	af 90       	pop	r10
    4848:	9f 90       	pop	r9
    484a:	8f 90       	pop	r8
    484c:	7f 90       	pop	r7
    484e:	6f 90       	pop	r6
    4850:	5f 90       	pop	r5
    4852:	4f 90       	pop	r4
    4854:	08 95       	ret

00004856 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
    4856:	2f 92       	push	r2
    4858:	3f 92       	push	r3
    485a:	4f 92       	push	r4
    485c:	5f 92       	push	r5
    485e:	6f 92       	push	r6
    4860:	7f 92       	push	r7
    4862:	8f 92       	push	r8
    4864:	9f 92       	push	r9
    4866:	af 92       	push	r10
    4868:	bf 92       	push	r11
    486a:	cf 92       	push	r12
    486c:	df 92       	push	r13
    486e:	ef 92       	push	r14
    4870:	ff 92       	push	r15
    4872:	0f 93       	push	r16
    4874:	1f 93       	push	r17
    4876:	df 93       	push	r29
    4878:	cf 93       	push	r28
    487a:	cd b7       	in	r28, 0x3d	; 61
    487c:	de b7       	in	r29, 0x3e	; 62
    487e:	27 97       	sbiw	r28, 0x07	; 7
    4880:	0f b6       	in	r0, 0x3f	; 63
    4882:	f8 94       	cli
    4884:	de bf       	out	0x3e, r29	; 62
    4886:	0f be       	out	0x3f, r0	; 63
    4888:	cd bf       	out	0x3d, r28	; 61
    488a:	5c 01       	movw	r10, r24
    488c:	7f 83       	std	Y+7, r23	; 0x07
    488e:	6e 83       	std	Y+6, r22	; 0x06
    4890:	2a 01       	movw	r4, r20
    4892:	3d 83       	std	Y+5, r19	; 0x05
    4894:	2c 83       	std	Y+4, r18	; 0x04
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
    4896:	fc 01       	movw	r30, r24
    4898:	84 81       	ldd	r24, Z+4	; 0x04
    489a:	95 81       	ldd	r25, Z+5	; 0x05
    489c:	9c 01       	movw	r18, r24
    489e:	21 50       	subi	r18, 0x01	; 1
    48a0:	30 40       	sbci	r19, 0x00	; 0

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    48a2:	86 85       	ldd	r24, Z+14	; 0x0e
    48a4:	80 ff       	sbrs	r24, 0
    48a6:	0c c0       	rjmp	.+24     	; 0x48c0 <xStreamBufferSend+0x6a>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    48a8:	66 24       	eor	r6, r6
    48aa:	77 24       	eor	r7, r7
    48ac:	68 94       	set
    48ae:	61 f8       	bld	r6, 1
    48b0:	64 0e       	add	r6, r20
    48b2:	75 1e       	adc	r7, r21
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
    48b4:	26 15       	cp	r18, r6
    48b6:	37 05       	cpc	r19, r7
    48b8:	40 f4       	brcc	.+16     	; 0x48ca <xStreamBufferSend+0x74>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
    48ba:	1d 82       	std	Y+5, r1	; 0x05
    48bc:	1c 82       	std	Y+4, r1	; 0x04
    48be:	48 c0       	rjmp	.+144    	; 0x4950 <xStreamBufferSend+0xfa>
    48c0:	3a 01       	movw	r6, r20
    48c2:	24 17       	cp	r18, r20
    48c4:	35 07       	cpc	r19, r21
    48c6:	08 f4       	brcc	.+2      	; 0x48ca <xStreamBufferSend+0x74>
    48c8:	39 01       	movw	r6, r18
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    48ca:	8c 81       	ldd	r24, Y+4	; 0x04
    48cc:	9d 81       	ldd	r25, Y+5	; 0x05
    48ce:	89 2b       	or	r24, r25
    48d0:	09 f4       	brne	.+2      	; 0x48d4 <xStreamBufferSend+0x7e>
    48d2:	3e c0       	rjmp	.+124    	; 0x4950 <xStreamBufferSend+0xfa>
    {
        vTaskSetTimeOutState( &xTimeOut );
    48d4:	ce 01       	movw	r24, r28
    48d6:	01 96       	adiw	r24, 0x01	; 1
    48d8:	0e 94 45 27 	call	0x4e8a	; 0x4e8a <vTaskSetTimeOutState>
            taskEXIT_CRITICAL();

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
            pxStreamBuffer->xTaskWaitingToSend = NULL;
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    48dc:	1e 01       	movw	r2, r28
    48de:	08 94       	sec
    48e0:	21 1c       	adc	r2, r1
    48e2:	31 1c       	adc	r3, r1

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
    48e4:	0f b6       	in	r0, 0x3f	; 63
    48e6:	f8 94       	cli
    48e8:	0f 92       	push	r0
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    48ea:	c5 01       	movw	r24, r10
    48ec:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <xStreamBufferSpacesAvailable>
    48f0:	4c 01       	movw	r8, r24

                if( xSpace < xRequiredSpace )
    48f2:	86 15       	cp	r24, r6
    48f4:	97 05       	cpc	r25, r7
    48f6:	40 f5       	brcc	.+80     	; 0x4948 <xStreamBufferSend+0xf2>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
    48f8:	80 e0       	ldi	r24, 0x00	; 0
    48fa:	90 e0       	ldi	r25, 0x00	; 0
    48fc:	60 e0       	ldi	r22, 0x00	; 0
    48fe:	0e 94 d4 2a 	call	0x55a8	; 0x55a8 <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    4902:	0e 94 cb 28 	call	0x5196	; 0x5196 <xTaskGetCurrentTaskHandle>
    4906:	f5 01       	movw	r30, r10
    4908:	93 87       	std	Z+11, r25	; 0x0b
    490a:	82 87       	std	Z+10, r24	; 0x0a
                {
                    taskEXIT_CRITICAL();
                    break;
                }
            }
            taskEXIT_CRITICAL();
    490c:	0f 90       	pop	r0
    490e:	0f be       	out	0x3f, r0	; 63

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    4910:	cc 80       	ldd	r12, Y+4	; 0x04
    4912:	dd 80       	ldd	r13, Y+5	; 0x05
    4914:	80 e0       	ldi	r24, 0x00	; 0
    4916:	40 e0       	ldi	r20, 0x00	; 0
    4918:	50 e0       	ldi	r21, 0x00	; 0
    491a:	60 e0       	ldi	r22, 0x00	; 0
    491c:	70 e0       	ldi	r23, 0x00	; 0
    491e:	00 e0       	ldi	r16, 0x00	; 0
    4920:	10 e0       	ldi	r17, 0x00	; 0
    4922:	20 e0       	ldi	r18, 0x00	; 0
    4924:	30 e0       	ldi	r19, 0x00	; 0
    4926:	ee 24       	eor	r14, r14
    4928:	ff 24       	eor	r15, r15
    492a:	0e 94 61 2d 	call	0x5ac2	; 0x5ac2 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
    492e:	f5 01       	movw	r30, r10
    4930:	13 86       	std	Z+11, r1	; 0x0b
    4932:	12 86       	std	Z+10, r1	; 0x0a
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    4934:	c1 01       	movw	r24, r2
    4936:	be 01       	movw	r22, r28
    4938:	6c 5f       	subi	r22, 0xFC	; 252
    493a:	7f 4f       	sbci	r23, 0xFF	; 255
    493c:	0e 94 60 27 	call	0x4ec0	; 0x4ec0 <xTaskCheckForTimeOut>
    4940:	88 23       	and	r24, r24
    4942:	81 f2       	breq	.-96     	; 0x48e4 <xStreamBufferSend+0x8e>
    4944:	c4 01       	movw	r24, r8
    4946:	02 c0       	rjmp	.+4      	; 0x494c <xStreamBufferSend+0xf6>
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
                }
                else
                {
                    taskEXIT_CRITICAL();
    4948:	0f 90       	pop	r0
    494a:	0f be       	out	0x3f, r0	; 63
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
    494c:	89 2b       	or	r24, r25
    494e:	21 f4       	brne	.+8      	; 0x4958 <xStreamBufferSend+0x102>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    4950:	c5 01       	movw	r24, r10
    4952:	0e 94 fc 20 	call	0x41f8	; 0x41f8 <xStreamBufferSpacesAvailable>
    4956:	4c 01       	movw	r8, r24
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    4958:	c5 01       	movw	r24, r10
    495a:	6e 81       	ldd	r22, Y+6	; 0x06
    495c:	7f 81       	ldd	r23, Y+7	; 0x07
    495e:	a2 01       	movw	r20, r4
    4960:	94 01       	movw	r18, r8
    4962:	83 01       	movw	r16, r6
    4964:	0e 94 06 23 	call	0x460c	; 0x460c <prvWriteMessageToBuffer>
    4968:	6c 01       	movw	r12, r24

    if( xReturn > ( size_t ) 0 )
    496a:	00 97       	sbiw	r24, 0x00	; 0
    496c:	09 f1       	breq	.+66     	; 0x49b0 <xStreamBufferSend+0x15a>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    496e:	c5 01       	movw	r24, r10
    4970:	0e 94 3c 21 	call	0x4278	; 0x4278 <prvBytesInBuffer>
    4974:	f5 01       	movw	r30, r10
    4976:	26 81       	ldd	r18, Z+6	; 0x06
    4978:	37 81       	ldd	r19, Z+7	; 0x07
    497a:	82 17       	cp	r24, r18
    497c:	93 07       	cpc	r25, r19
    497e:	c0 f0       	brcs	.+48     	; 0x49b0 <xStreamBufferSend+0x15a>
        {
            prvSEND_COMPLETED( pxStreamBuffer );
    4980:	0e 94 81 25 	call	0x4b02	; 0x4b02 <vTaskSuspendAll>
    4984:	f5 01       	movw	r30, r10
    4986:	80 85       	ldd	r24, Z+8	; 0x08
    4988:	91 85       	ldd	r25, Z+9	; 0x09
    498a:	89 2b       	or	r24, r25
    498c:	79 f0       	breq	.+30     	; 0x49ac <xStreamBufferSend+0x156>
    498e:	80 85       	ldd	r24, Z+8	; 0x08
    4990:	91 85       	ldd	r25, Z+9	; 0x09
    4992:	60 e0       	ldi	r22, 0x00	; 0
    4994:	20 e0       	ldi	r18, 0x00	; 0
    4996:	30 e0       	ldi	r19, 0x00	; 0
    4998:	40 e0       	ldi	r20, 0x00	; 0
    499a:	50 e0       	ldi	r21, 0x00	; 0
    499c:	00 e0       	ldi	r16, 0x00	; 0
    499e:	ee 24       	eor	r14, r14
    49a0:	ff 24       	eor	r15, r15
    49a2:	0e 94 38 2b 	call	0x5670	; 0x5670 <xTaskGenericNotify>
    49a6:	f5 01       	movw	r30, r10
    49a8:	11 86       	std	Z+9, r1	; 0x09
    49aa:	10 86       	std	Z+8, r1	; 0x08
    49ac:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
}
    49b0:	8c 2d       	mov	r24, r12
    49b2:	9d 2d       	mov	r25, r13
    49b4:	27 96       	adiw	r28, 0x07	; 7
    49b6:	0f b6       	in	r0, 0x3f	; 63
    49b8:	f8 94       	cli
    49ba:	de bf       	out	0x3e, r29	; 62
    49bc:	0f be       	out	0x3f, r0	; 63
    49be:	cd bf       	out	0x3d, r28	; 61
    49c0:	cf 91       	pop	r28
    49c2:	df 91       	pop	r29
    49c4:	1f 91       	pop	r17
    49c6:	0f 91       	pop	r16
    49c8:	ff 90       	pop	r15
    49ca:	ef 90       	pop	r14
    49cc:	df 90       	pop	r13
    49ce:	cf 90       	pop	r12
    49d0:	bf 90       	pop	r11
    49d2:	af 90       	pop	r10
    49d4:	9f 90       	pop	r9
    49d6:	8f 90       	pop	r8
    49d8:	7f 90       	pop	r7
    49da:	6f 90       	pop	r6
    49dc:	5f 90       	pop	r5
    49de:	4f 90       	pop	r4
    49e0:	3f 90       	pop	r3
    49e2:	2f 90       	pop	r2
    49e4:	08 95       	ret

000049e6 <prvInitialiseNewStreamBuffer>:
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags,
                                          StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
{
    49e6:	0f 93       	push	r16
    49e8:	fc 01       	movw	r30, r24
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    49ea:	8f e0       	ldi	r24, 0x0F	; 15
    49ec:	df 01       	movw	r26, r30
    49ee:	1d 92       	st	X+, r1
    49f0:	8a 95       	dec	r24
    49f2:	e9 f7       	brne	.-6      	; 0x49ee <prvInitialiseNewStreamBuffer+0x8>
    pxStreamBuffer->pucBuffer = pucBuffer;
    49f4:	75 87       	std	Z+13, r23	; 0x0d
    49f6:	64 87       	std	Z+12, r22	; 0x0c
    pxStreamBuffer->xLength = xBufferSizeBytes;
    49f8:	55 83       	std	Z+5, r21	; 0x05
    49fa:	44 83       	std	Z+4, r20	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    49fc:	37 83       	std	Z+7, r19	; 0x07
    49fe:	26 83       	std	Z+6, r18	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    4a00:	06 87       	std	Z+14, r16	; 0x0e
    {
        ( void ) pxSendCompletedCallback;
        ( void ) pxReceiveCompletedCallback;
    }
    #endif
}
    4a02:	0f 91       	pop	r16
    4a04:	08 95       	ret

00004a06 <xStreamBufferReset>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    4a06:	cf 92       	push	r12
    4a08:	df 92       	push	r13
    4a0a:	ef 92       	push	r14
    4a0c:	ff 92       	push	r15
    4a0e:	0f 93       	push	r16
    4a10:	fc 01       	movw	r30, r24
        uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
    }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
    4a12:	0f b6       	in	r0, 0x3f	; 63
    4a14:	f8 94       	cli
    4a16:	0f 92       	push	r0
    {
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
    4a18:	80 85       	ldd	r24, Z+8	; 0x08
    4a1a:	91 85       	ldd	r25, Z+9	; 0x09
    4a1c:	89 2b       	or	r24, r25
    4a1e:	a1 f4       	brne	.+40     	; 0x4a48 <xStreamBufferReset+0x42>
    4a20:	82 85       	ldd	r24, Z+10	; 0x0a
    4a22:	93 85       	ldd	r25, Z+11	; 0x0b
    4a24:	89 2b       	or	r24, r25
    4a26:	81 f4       	brne	.+32     	; 0x4a48 <xStreamBufferReset+0x42>
                pxSendCallback = pxStreamBuffer->pxSendCompletedCallback;
                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;
            }
            #endif

            prvInitialiseNewStreamBuffer( pxStreamBuffer,
    4a28:	64 85       	ldd	r22, Z+12	; 0x0c
    4a2a:	75 85       	ldd	r23, Z+13	; 0x0d
    4a2c:	44 81       	ldd	r20, Z+4	; 0x04
    4a2e:	55 81       	ldd	r21, Z+5	; 0x05
    4a30:	26 81       	ldd	r18, Z+6	; 0x06
    4a32:	37 81       	ldd	r19, Z+7	; 0x07
    4a34:	cf 01       	movw	r24, r30
    4a36:	06 85       	ldd	r16, Z+14	; 0x0e
    4a38:	ee 24       	eor	r14, r14
    4a3a:	ff 24       	eor	r15, r15
    4a3c:	cc 24       	eor	r12, r12
    4a3e:	dd 24       	eor	r13, r13
    4a40:	0e 94 f3 24 	call	0x49e6	; 0x49e6 <prvInitialiseNewStreamBuffer>
    4a44:	81 e0       	ldi	r24, 0x01	; 1
    4a46:	01 c0       	rjmp	.+2      	; 0x4a4a <xStreamBufferReset+0x44>
    4a48:	80 e0       	ldi	r24, 0x00	; 0
            traceSTREAM_BUFFER_RESET( xStreamBuffer );

            xReturn = pdPASS;
        }
    }
    taskEXIT_CRITICAL();
    4a4a:	0f 90       	pop	r0
    4a4c:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    4a4e:	0f 91       	pop	r16
    4a50:	ff 90       	pop	r15
    4a52:	ef 90       	pop	r14
    4a54:	df 90       	pop	r13
    4a56:	cf 90       	pop	r12
    4a58:	08 95       	ret

00004a5a <vStreamBufferDelete>:
    }
#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    4a5a:	fc 01       	movw	r30, r24

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    4a5c:	86 85       	ldd	r24, Z+14	; 0x0e
    4a5e:	81 fd       	sbrc	r24, 1
    4a60:	04 c0       	rjmp	.+8      	; 0x4a6a <vStreamBufferDelete+0x10>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
        {
            /* Both the structure and the buffer were allocated using a single call
            * to pvPortMalloc(), hence only one call to vPortFree() is required. */
            vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    4a62:	cf 01       	movw	r24, r30
    4a64:	0e 94 6e 18 	call	0x30dc	; 0x30dc <vPortFree>
    4a68:	08 95       	ret
    }
    else
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    4a6a:	8f e0       	ldi	r24, 0x0F	; 15
    4a6c:	df 01       	movw	r26, r30
    4a6e:	1d 92       	st	X+, r1
    4a70:	8a 95       	dec	r24
    4a72:	e9 f7       	brne	.-6      	; 0x4a6e <vStreamBufferDelete+0x14>
    4a74:	08 95       	ret

00004a76 <xStreamBufferGenericCreate>:
    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer,
                                                     StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                     StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
    {
    4a76:	7f 92       	push	r7
    4a78:	8f 92       	push	r8
    4a7a:	9f 92       	push	r9
    4a7c:	af 92       	push	r10
    4a7e:	bf 92       	push	r11
    4a80:	cf 92       	push	r12
    4a82:	df 92       	push	r13
    4a84:	ef 92       	push	r14
    4a86:	ff 92       	push	r15
    4a88:	0f 93       	push	r16
    4a8a:	1f 93       	push	r17
    4a8c:	cf 93       	push	r28
    4a8e:	df 93       	push	r29
    4a90:	7c 01       	movw	r14, r24
    4a92:	6b 01       	movw	r12, r22
    4a94:	74 2e       	mov	r7, r20
    4a96:	59 01       	movw	r10, r18
    4a98:	48 01       	movw	r8, r16

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
    4a9a:	61 15       	cp	r22, r1
    4a9c:	71 05       	cpc	r23, r1
    4a9e:	19 f4       	brne	.+6      	; 0x4aa6 <xStreamBufferGenericCreate+0x30>
    4aa0:	cc 24       	eor	r12, r12
    4aa2:	dd 24       	eor	r13, r13
    4aa4:	c3 94       	inc	r12
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
    4aa6:	c7 01       	movw	r24, r14
    4aa8:	40 96       	adiw	r24, 0x10	; 16
    4aaa:	e8 16       	cp	r14, r24
    4aac:	f9 06       	cpc	r15, r25
    4aae:	18 f0       	brcs	.+6      	; 0x4ab6 <xStreamBufferGenericCreate+0x40>
    4ab0:	c0 e0       	ldi	r28, 0x00	; 0
    4ab2:	d0 e0       	ldi	r29, 0x00	; 0
    4ab4:	16 c0       	rjmp	.+44     	; 0x4ae2 <xStreamBufferGenericCreate+0x6c>
        {
            xBufferSizeBytes++;
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    4ab6:	0e 94 7f 18 	call	0x30fe	; 0x30fe <pvPortMalloc>
    4aba:	ec 01       	movw	r28, r24
        else
        {
            pucAllocatedMemory = NULL;
        }

        if( pucAllocatedMemory != NULL )
    4abc:	20 97       	sbiw	r28, 0x00	; 0
    4abe:	89 f0       	breq	.+34     	; 0x4ae2 <xStreamBufferGenericCreate+0x6c>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    4ac0:	be 01       	movw	r22, r28
    4ac2:	61 5f       	subi	r22, 0xF1	; 241
    4ac4:	7f 4f       	sbci	r23, 0xFF	; 255
    4ac6:	a7 01       	movw	r20, r14
    4ac8:	4f 5f       	subi	r20, 0xFF	; 255
    4aca:	5f 4f       	sbci	r21, 0xFF	; 255
    4acc:	00 e0       	ldi	r16, 0x00	; 0
    4ace:	81 e0       	ldi	r24, 0x01	; 1
    4ad0:	78 16       	cp	r7, r24
    4ad2:	09 f4       	brne	.+2      	; 0x4ad6 <xStreamBufferGenericCreate+0x60>
    4ad4:	01 e0       	ldi	r16, 0x01	; 1
    4ad6:	ce 01       	movw	r24, r28
    4ad8:	96 01       	movw	r18, r12
    4ada:	75 01       	movw	r14, r10
    4adc:	64 01       	movw	r12, r8
    4ade:	0e 94 f3 24 	call	0x49e6	; 0x49e6 <prvInitialiseNewStreamBuffer>
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    }
    4ae2:	8c 2f       	mov	r24, r28
    4ae4:	9d 2f       	mov	r25, r29
    4ae6:	df 91       	pop	r29
    4ae8:	cf 91       	pop	r28
    4aea:	1f 91       	pop	r17
    4aec:	0f 91       	pop	r16
    4aee:	ff 90       	pop	r15
    4af0:	ef 90       	pop	r14
    4af2:	df 90       	pop	r13
    4af4:	cf 90       	pop	r12
    4af6:	bf 90       	pop	r11
    4af8:	af 90       	pop	r10
    4afa:	9f 90       	pop	r9
    4afc:	8f 90       	pop	r8
    4afe:	7f 90       	pop	r7
    4b00:	08 95       	ret

00004b02 <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    4b02:	80 91 c3 07 	lds	r24, 0x07C3
    4b06:	8f 5f       	subi	r24, 0xFF	; 255
    4b08:	80 93 c3 07 	sts	0x07C3, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    4b0c:	08 95       	ret

00004b0e <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    4b0e:	0f b6       	in	r0, 0x3f	; 63
    4b10:	f8 94       	cli
    4b12:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    4b14:	20 91 c6 07 	lds	r18, 0x07C6
    4b18:	30 91 c7 07 	lds	r19, 0x07C7
    }
    portTICK_TYPE_EXIT_CRITICAL();
    4b1c:	0f 90       	pop	r0
    4b1e:	0f be       	out	0x3f, r0	; 63

    return xTicks;
}
    4b20:	82 2f       	mov	r24, r18
    4b22:	93 2f       	mov	r25, r19
    4b24:	08 95       	ret

00004b26 <xTaskGetTickCountFromISR>:
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    {
        xReturn = xTickCount;
    4b26:	20 91 c6 07 	lds	r18, 0x07C6
    4b2a:	30 91 c7 07 	lds	r19, 0x07C7
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    4b2e:	82 2f       	mov	r24, r18
    4b30:	93 2f       	mov	r25, r19
    4b32:	08 95       	ret

00004b34 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    4b34:	80 91 cd 07 	lds	r24, 0x07CD
}
    4b38:	08 95       	ret

00004b3a <pcTaskGetName>:
{
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4b3a:	00 97       	sbiw	r24, 0x00	; 0
    4b3c:	21 f4       	brne	.+8      	; 0x4b46 <pcTaskGetName+0xc>
    4b3e:	80 91 c1 07 	lds	r24, 0x07C1
    4b42:	90 91 c2 07 	lds	r25, 0x07C2
    4b46:	9c 01       	movw	r18, r24
    4b48:	27 5e       	subi	r18, 0xE7	; 231
    4b4a:	3f 4f       	sbci	r19, 0xFF	; 255
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
}
    4b4c:	82 2f       	mov	r24, r18
    4b4e:	93 2f       	mov	r25, r19
    4b50:	08 95       	ret

00004b52 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4b52:	80 91 c3 07 	lds	r24, 0x07C3
    4b56:	88 23       	and	r24, r24
    4b58:	21 f0       	breq	.+8      	; 0x4b62 <vTaskSwitchContext+0x10>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    4b5a:	81 e0       	ldi	r24, 0x01	; 1
    4b5c:	80 93 c5 07 	sts	0x07C5, r24
    4b60:	08 95       	ret
    }
    else
    {
        xYieldPending = pdFALSE;
    4b62:	10 92 c5 07 	sts	0x07C5, r1
        }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4b66:	20 91 c4 07 	lds	r18, 0x07C4
    4b6a:	89 e0       	ldi	r24, 0x09	; 9
    4b6c:	28 9f       	mul	r18, r24
    4b6e:	c0 01       	movw	r24, r0
    4b70:	11 24       	eor	r1, r1
    4b72:	dc 01       	movw	r26, r24
    4b74:	ad 52       	subi	r26, 0x2D	; 45
    4b76:	b8 4f       	sbci	r27, 0xF8	; 248
    4b78:	8c 91       	ld	r24, X
    4b7a:	88 23       	and	r24, r24
    4b7c:	69 f4       	brne	.+26     	; 0x4b98 <vTaskSwitchContext+0x46>
    4b7e:	39 e0       	ldi	r19, 0x09	; 9
    4b80:	43 ed       	ldi	r20, 0xD3	; 211
    4b82:	57 e0       	ldi	r21, 0x07	; 7
    4b84:	21 50       	subi	r18, 0x01	; 1
    4b86:	23 9f       	mul	r18, r19
    4b88:	c0 01       	movw	r24, r0
    4b8a:	11 24       	eor	r1, r1
    4b8c:	da 01       	movw	r26, r20
    4b8e:	a8 0f       	add	r26, r24
    4b90:	b9 1f       	adc	r27, r25
    4b92:	8c 91       	ld	r24, X
    4b94:	88 23       	and	r24, r24
    4b96:	b1 f3       	breq	.-20     	; 0x4b84 <vTaskSwitchContext+0x32>
    4b98:	11 96       	adiw	r26, 0x01	; 1
    4b9a:	ed 91       	ld	r30, X+
    4b9c:	fc 91       	ld	r31, X
    4b9e:	12 97       	sbiw	r26, 0x02	; 2
    4ba0:	02 80       	ldd	r0, Z+2	; 0x02
    4ba2:	f3 81       	ldd	r31, Z+3	; 0x03
    4ba4:	e0 2d       	mov	r30, r0
    4ba6:	12 96       	adiw	r26, 0x02	; 2
    4ba8:	fc 93       	st	X, r31
    4baa:	ee 93       	st	-X, r30
    4bac:	11 97       	sbiw	r26, 0x01	; 1
    4bae:	cd 01       	movw	r24, r26
    4bb0:	03 96       	adiw	r24, 0x03	; 3
    4bb2:	e8 17       	cp	r30, r24
    4bb4:	f9 07       	cpc	r31, r25
    4bb6:	31 f4       	brne	.+12     	; 0x4bc4 <vTaskSwitchContext+0x72>
    4bb8:	82 81       	ldd	r24, Z+2	; 0x02
    4bba:	93 81       	ldd	r25, Z+3	; 0x03
    4bbc:	12 96       	adiw	r26, 0x02	; 2
    4bbe:	9c 93       	st	X, r25
    4bc0:	8e 93       	st	-X, r24
    4bc2:	11 97       	sbiw	r26, 0x01	; 1
    4bc4:	11 96       	adiw	r26, 0x01	; 1
    4bc6:	ed 91       	ld	r30, X+
    4bc8:	fc 91       	ld	r31, X
    4bca:	12 97       	sbiw	r26, 0x02	; 2
    4bcc:	86 81       	ldd	r24, Z+6	; 0x06
    4bce:	97 81       	ldd	r25, Z+7	; 0x07
    4bd0:	90 93 c2 07 	sts	0x07C2, r25
    4bd4:	80 93 c1 07 	sts	0x07C1, r24
    4bd8:	20 93 c4 07 	sts	0x07C4, r18
    4bdc:	08 95       	ret

00004bde <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4bde:	cf 93       	push	r28
    4be0:	df 93       	push	r29
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4be2:	dc 01       	movw	r26, r24
    4be4:	15 96       	adiw	r26, 0x05	; 5
    4be6:	ed 91       	ld	r30, X+
    4be8:	fc 91       	ld	r31, X
    4bea:	16 97       	sbiw	r26, 0x06	; 6
    4bec:	c6 81       	ldd	r28, Z+6	; 0x06
    4bee:	d7 81       	ldd	r29, Z+7	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    4bf0:	2c 89       	ldd	r18, Y+20	; 0x14
    4bf2:	3d 89       	ldd	r19, Y+21	; 0x15
    4bf4:	ae 85       	ldd	r26, Y+14	; 0x0e
    4bf6:	bf 85       	ldd	r27, Y+15	; 0x0f
    4bf8:	88 89       	ldd	r24, Y+16	; 0x10
    4bfa:	99 89       	ldd	r25, Y+17	; 0x11
    4bfc:	15 96       	adiw	r26, 0x05	; 5
    4bfe:	9c 93       	st	X, r25
    4c00:	8e 93       	st	-X, r24
    4c02:	14 97       	sbiw	r26, 0x04	; 4
    4c04:	e8 89       	ldd	r30, Y+16	; 0x10
    4c06:	f9 89       	ldd	r31, Y+17	; 0x11
    4c08:	b3 83       	std	Z+3, r27	; 0x03
    4c0a:	a2 83       	std	Z+2, r26	; 0x02
    4c0c:	ae 01       	movw	r20, r28
    4c0e:	44 5f       	subi	r20, 0xF4	; 244
    4c10:	5f 4f       	sbci	r21, 0xFF	; 255
    4c12:	f9 01       	movw	r30, r18
    4c14:	81 81       	ldd	r24, Z+1	; 0x01
    4c16:	92 81       	ldd	r25, Z+2	; 0x02
    4c18:	84 17       	cp	r24, r20
    4c1a:	95 07       	cpc	r25, r21
    4c1c:	21 f4       	brne	.+8      	; 0x4c26 <xTaskRemoveFromEventList+0x48>
    4c1e:	88 89       	ldd	r24, Y+16	; 0x10
    4c20:	99 89       	ldd	r25, Y+17	; 0x11
    4c22:	92 83       	std	Z+2, r25	; 0x02
    4c24:	81 83       	std	Z+1, r24	; 0x01
    4c26:	1d 8a       	std	Y+21, r1	; 0x15
    4c28:	1c 8a       	std	Y+20, r1	; 0x14
    4c2a:	d9 01       	movw	r26, r18
    4c2c:	8c 91       	ld	r24, X
    4c2e:	81 50       	subi	r24, 0x01	; 1
    4c30:	8c 93       	st	X, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4c32:	80 91 c3 07 	lds	r24, 0x07C3
    4c36:	88 23       	and	r24, r24
    4c38:	09 f0       	breq	.+2      	; 0x4c3c <xTaskRemoveFromEventList+0x5e>
    4c3a:	59 c0       	rjmp	.+178    	; 0x4cee <xTaskRemoveFromEventList+0x110>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4c3c:	2a 85       	ldd	r18, Y+10	; 0x0a
    4c3e:	3b 85       	ldd	r19, Y+11	; 0x0b
    4c40:	ac 81       	ldd	r26, Y+4	; 0x04
    4c42:	bd 81       	ldd	r27, Y+5	; 0x05
    4c44:	8e 81       	ldd	r24, Y+6	; 0x06
    4c46:	9f 81       	ldd	r25, Y+7	; 0x07
    4c48:	15 96       	adiw	r26, 0x05	; 5
    4c4a:	9c 93       	st	X, r25
    4c4c:	8e 93       	st	-X, r24
    4c4e:	14 97       	sbiw	r26, 0x04	; 4
    4c50:	ee 81       	ldd	r30, Y+6	; 0x06
    4c52:	ff 81       	ldd	r31, Y+7	; 0x07
    4c54:	b3 83       	std	Z+3, r27	; 0x03
    4c56:	a2 83       	std	Z+2, r26	; 0x02
    4c58:	be 01       	movw	r22, r28
    4c5a:	6e 5f       	subi	r22, 0xFE	; 254
    4c5c:	7f 4f       	sbci	r23, 0xFF	; 255
    4c5e:	f9 01       	movw	r30, r18
    4c60:	81 81       	ldd	r24, Z+1	; 0x01
    4c62:	92 81       	ldd	r25, Z+2	; 0x02
    4c64:	86 17       	cp	r24, r22
    4c66:	97 07       	cpc	r25, r23
    4c68:	21 f4       	brne	.+8      	; 0x4c72 <xTaskRemoveFromEventList+0x94>
    4c6a:	8e 81       	ldd	r24, Y+6	; 0x06
    4c6c:	9f 81       	ldd	r25, Y+7	; 0x07
    4c6e:	92 83       	std	Z+2, r25	; 0x02
    4c70:	81 83       	std	Z+1, r24	; 0x01
    4c72:	1b 86       	std	Y+11, r1	; 0x0b
    4c74:	1a 86       	std	Y+10, r1	; 0x0a
    4c76:	d9 01       	movw	r26, r18
    4c78:	8c 91       	ld	r24, X
    4c7a:	81 50       	subi	r24, 0x01	; 1
    4c7c:	8c 93       	st	X, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    4c7e:	2e 89       	ldd	r18, Y+22	; 0x16
    4c80:	80 91 c4 07 	lds	r24, 0x07C4
    4c84:	82 17       	cp	r24, r18
    4c86:	10 f4       	brcc	.+4      	; 0x4c8c <xTaskRemoveFromEventList+0xae>
    4c88:	20 93 c4 07 	sts	0x07C4, r18
    4c8c:	30 e0       	ldi	r19, 0x00	; 0
    4c8e:	c9 01       	movw	r24, r18
    4c90:	88 0f       	add	r24, r24
    4c92:	99 1f       	adc	r25, r25
    4c94:	88 0f       	add	r24, r24
    4c96:	99 1f       	adc	r25, r25
    4c98:	88 0f       	add	r24, r24
    4c9a:	99 1f       	adc	r25, r25
    4c9c:	82 0f       	add	r24, r18
    4c9e:	93 1f       	adc	r25, r19
    4ca0:	43 ed       	ldi	r20, 0xD3	; 211
    4ca2:	57 e0       	ldi	r21, 0x07	; 7
    4ca4:	fa 01       	movw	r30, r20
    4ca6:	e8 0f       	add	r30, r24
    4ca8:	f9 1f       	adc	r31, r25
    4caa:	a1 81       	ldd	r26, Z+1	; 0x01
    4cac:	b2 81       	ldd	r27, Z+2	; 0x02
    4cae:	bd 83       	std	Y+5, r27	; 0x05
    4cb0:	ac 83       	std	Y+4, r26	; 0x04
    4cb2:	14 96       	adiw	r26, 0x04	; 4
    4cb4:	8d 91       	ld	r24, X+
    4cb6:	9c 91       	ld	r25, X
    4cb8:	15 97       	sbiw	r26, 0x05	; 5
    4cba:	9f 83       	std	Y+7, r25	; 0x07
    4cbc:	8e 83       	std	Y+6, r24	; 0x06
    4cbe:	14 96       	adiw	r26, 0x04	; 4
    4cc0:	ed 91       	ld	r30, X+
    4cc2:	fc 91       	ld	r31, X
    4cc4:	15 97       	sbiw	r26, 0x05	; 5
    4cc6:	73 83       	std	Z+3, r23	; 0x03
    4cc8:	62 83       	std	Z+2, r22	; 0x02
    4cca:	15 96       	adiw	r26, 0x05	; 5
    4ccc:	7c 93       	st	X, r23
    4cce:	6e 93       	st	-X, r22
    4cd0:	14 97       	sbiw	r26, 0x04	; 4
    4cd2:	8e 89       	ldd	r24, Y+22	; 0x16
    4cd4:	29 e0       	ldi	r18, 0x09	; 9
    4cd6:	82 9f       	mul	r24, r18
    4cd8:	c0 01       	movw	r24, r0
    4cda:	11 24       	eor	r1, r1
    4cdc:	48 0f       	add	r20, r24
    4cde:	59 1f       	adc	r21, r25
    4ce0:	5b 87       	std	Y+11, r21	; 0x0b
    4ce2:	4a 87       	std	Y+10, r20	; 0x0a
    4ce4:	fa 01       	movw	r30, r20
    4ce6:	80 81       	ld	r24, Z
    4ce8:	8f 5f       	subi	r24, 0xFF	; 255
    4cea:	80 83       	st	Z, r24
    4cec:	1f c0       	rjmp	.+62     	; 0x4d2c <xTaskRemoveFromEventList+0x14e>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4cee:	2e e0       	ldi	r18, 0x0E	; 14
    4cf0:	38 e0       	ldi	r19, 0x08	; 8
    4cf2:	f9 01       	movw	r30, r18
    4cf4:	a0 81       	ld	r26, Z
    4cf6:	b1 81       	ldd	r27, Z+1	; 0x01
    4cf8:	bf 87       	std	Y+15, r27	; 0x0f
    4cfa:	ae 87       	std	Y+14, r26	; 0x0e
    4cfc:	14 96       	adiw	r26, 0x04	; 4
    4cfe:	8d 91       	ld	r24, X+
    4d00:	9c 91       	ld	r25, X
    4d02:	15 97       	sbiw	r26, 0x05	; 5
    4d04:	99 8b       	std	Y+17, r25	; 0x11
    4d06:	88 8b       	std	Y+16, r24	; 0x10
    4d08:	14 96       	adiw	r26, 0x04	; 4
    4d0a:	ed 91       	ld	r30, X+
    4d0c:	fc 91       	ld	r31, X
    4d0e:	15 97       	sbiw	r26, 0x05	; 5
    4d10:	53 83       	std	Z+3, r21	; 0x03
    4d12:	42 83       	std	Z+2, r20	; 0x02
    4d14:	15 96       	adiw	r26, 0x05	; 5
    4d16:	5c 93       	st	X, r21
    4d18:	4e 93       	st	-X, r20
    4d1a:	14 97       	sbiw	r26, 0x04	; 4
    4d1c:	21 50       	subi	r18, 0x01	; 1
    4d1e:	30 40       	sbci	r19, 0x00	; 0
    4d20:	3d 8b       	std	Y+21, r19	; 0x15
    4d22:	2c 8b       	std	Y+20, r18	; 0x14
    4d24:	d9 01       	movw	r26, r18
    4d26:	8c 91       	ld	r24, X
    4d28:	8f 5f       	subi	r24, 0xFF	; 255
    4d2a:	8c 93       	st	X, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4d2c:	e0 91 c1 07 	lds	r30, 0x07C1
    4d30:	f0 91 c2 07 	lds	r31, 0x07C2
    4d34:	9e 89       	ldd	r25, Y+22	; 0x16
    4d36:	86 89       	ldd	r24, Z+22	; 0x16
    4d38:	89 17       	cp	r24, r25
    4d3a:	10 f0       	brcs	.+4      	; 0x4d40 <xTaskRemoveFromEventList+0x162>
    4d3c:	80 e0       	ldi	r24, 0x00	; 0
    4d3e:	03 c0       	rjmp	.+6      	; 0x4d46 <xTaskRemoveFromEventList+0x168>
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    4d40:	81 e0       	ldi	r24, 0x01	; 1
    4d42:	80 93 c5 07 	sts	0x07C5, r24
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    4d46:	df 91       	pop	r29
    4d48:	cf 91       	pop	r28
    4d4a:	08 95       	ret

00004d4c <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    4d4c:	0f 93       	push	r16
    4d4e:	1f 93       	push	r17
    4d50:	cf 93       	push	r28
    4d52:	df 93       	push	r29
    4d54:	ec 01       	movw	r28, r24
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4d56:	70 68       	ori	r23, 0x80	; 128
    4d58:	79 83       	std	Y+1, r23	; 0x01
    4d5a:	68 83       	st	Y, r22

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4d5c:	6e 81       	ldd	r22, Y+6	; 0x06
    4d5e:	7f 81       	ldd	r23, Y+7	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    4d60:	28 85       	ldd	r18, Y+8	; 0x08
    4d62:	39 85       	ldd	r19, Y+9	; 0x09
    4d64:	aa 81       	ldd	r26, Y+2	; 0x02
    4d66:	bb 81       	ldd	r27, Y+3	; 0x03
    4d68:	8c 81       	ldd	r24, Y+4	; 0x04
    4d6a:	9d 81       	ldd	r25, Y+5	; 0x05
    4d6c:	15 96       	adiw	r26, 0x05	; 5
    4d6e:	9c 93       	st	X, r25
    4d70:	8e 93       	st	-X, r24
    4d72:	14 97       	sbiw	r26, 0x04	; 4
    4d74:	ec 81       	ldd	r30, Y+4	; 0x04
    4d76:	fd 81       	ldd	r31, Y+5	; 0x05
    4d78:	b3 83       	std	Z+3, r27	; 0x03
    4d7a:	a2 83       	std	Z+2, r26	; 0x02
    4d7c:	d9 01       	movw	r26, r18
    4d7e:	11 96       	adiw	r26, 0x01	; 1
    4d80:	ed 91       	ld	r30, X+
    4d82:	fc 91       	ld	r31, X
    4d84:	12 97       	sbiw	r26, 0x02	; 2
    4d86:	ec 17       	cp	r30, r28
    4d88:	fd 07       	cpc	r31, r29
    4d8a:	31 f4       	brne	.+12     	; 0x4d98 <vTaskRemoveFromUnorderedEventList+0x4c>
    4d8c:	84 81       	ldd	r24, Z+4	; 0x04
    4d8e:	95 81       	ldd	r25, Z+5	; 0x05
    4d90:	12 96       	adiw	r26, 0x02	; 2
    4d92:	9c 93       	st	X, r25
    4d94:	8e 93       	st	-X, r24
    4d96:	11 97       	sbiw	r26, 0x01	; 1
    4d98:	19 86       	std	Y+9, r1	; 0x09
    4d9a:	18 86       	std	Y+8, r1	; 0x08
    4d9c:	f9 01       	movw	r30, r18
    4d9e:	80 81       	ld	r24, Z
    4da0:	81 50       	subi	r24, 0x01	; 1
    4da2:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4da4:	db 01       	movw	r26, r22
    4da6:	1a 96       	adiw	r26, 0x0a	; 10
    4da8:	cd 91       	ld	r28, X+
    4daa:	dc 91       	ld	r29, X
    4dac:	1b 97       	sbiw	r26, 0x0b	; 11
    4dae:	14 96       	adiw	r26, 0x04	; 4
    4db0:	0d 90       	ld	r0, X+
    4db2:	bc 91       	ld	r27, X
    4db4:	a0 2d       	mov	r26, r0
    4db6:	fb 01       	movw	r30, r22
    4db8:	86 81       	ldd	r24, Z+6	; 0x06
    4dba:	97 81       	ldd	r25, Z+7	; 0x07
    4dbc:	15 96       	adiw	r26, 0x05	; 5
    4dbe:	9c 93       	st	X, r25
    4dc0:	8e 93       	st	-X, r24
    4dc2:	14 97       	sbiw	r26, 0x04	; 4
    4dc4:	86 81       	ldd	r24, Z+6	; 0x06
    4dc6:	97 81       	ldd	r25, Z+7	; 0x07
    4dc8:	fc 01       	movw	r30, r24
    4dca:	b3 83       	std	Z+3, r27	; 0x03
    4dcc:	a2 83       	std	Z+2, r26	; 0x02
    4dce:	8b 01       	movw	r16, r22
    4dd0:	0e 5f       	subi	r16, 0xFE	; 254
    4dd2:	1f 4f       	sbci	r17, 0xFF	; 255
    4dd4:	89 81       	ldd	r24, Y+1	; 0x01
    4dd6:	9a 81       	ldd	r25, Y+2	; 0x02
    4dd8:	80 17       	cp	r24, r16
    4dda:	91 07       	cpc	r25, r17
    4ddc:	11 f4       	brne	.+4      	; 0x4de2 <vTaskRemoveFromUnorderedEventList+0x96>
    4dde:	fa 83       	std	Y+2, r31	; 0x02
    4de0:	e9 83       	std	Y+1, r30	; 0x01
    4de2:	fb 01       	movw	r30, r22
    4de4:	13 86       	std	Z+11, r1	; 0x0b
    4de6:	12 86       	std	Z+10, r1	; 0x0a
    4de8:	88 81       	ld	r24, Y
    4dea:	81 50       	subi	r24, 0x01	; 1
    4dec:	88 83       	st	Y, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    4dee:	26 89       	ldd	r18, Z+22	; 0x16
    4df0:	80 91 c4 07 	lds	r24, 0x07C4
    4df4:	82 17       	cp	r24, r18
    4df6:	10 f4       	brcc	.+4      	; 0x4dfc <vTaskRemoveFromUnorderedEventList+0xb0>
    4df8:	20 93 c4 07 	sts	0x07C4, r18
    4dfc:	30 e0       	ldi	r19, 0x00	; 0
    4dfe:	c9 01       	movw	r24, r18
    4e00:	88 0f       	add	r24, r24
    4e02:	99 1f       	adc	r25, r25
    4e04:	88 0f       	add	r24, r24
    4e06:	99 1f       	adc	r25, r25
    4e08:	88 0f       	add	r24, r24
    4e0a:	99 1f       	adc	r25, r25
    4e0c:	82 0f       	add	r24, r18
    4e0e:	93 1f       	adc	r25, r19
    4e10:	43 ed       	ldi	r20, 0xD3	; 211
    4e12:	57 e0       	ldi	r21, 0x07	; 7
    4e14:	fa 01       	movw	r30, r20
    4e16:	e8 0f       	add	r30, r24
    4e18:	f9 1f       	adc	r31, r25
    4e1a:	a1 81       	ldd	r26, Z+1	; 0x01
    4e1c:	b2 81       	ldd	r27, Z+2	; 0x02
    4e1e:	fb 01       	movw	r30, r22
    4e20:	b5 83       	std	Z+5, r27	; 0x05
    4e22:	a4 83       	std	Z+4, r26	; 0x04
    4e24:	14 96       	adiw	r26, 0x04	; 4
    4e26:	8d 91       	ld	r24, X+
    4e28:	9c 91       	ld	r25, X
    4e2a:	15 97       	sbiw	r26, 0x05	; 5
    4e2c:	97 83       	std	Z+7, r25	; 0x07
    4e2e:	86 83       	std	Z+6, r24	; 0x06
    4e30:	14 96       	adiw	r26, 0x04	; 4
    4e32:	ed 91       	ld	r30, X+
    4e34:	fc 91       	ld	r31, X
    4e36:	15 97       	sbiw	r26, 0x05	; 5
    4e38:	13 83       	std	Z+3, r17	; 0x03
    4e3a:	02 83       	std	Z+2, r16	; 0x02
    4e3c:	15 96       	adiw	r26, 0x05	; 5
    4e3e:	1c 93       	st	X, r17
    4e40:	0e 93       	st	-X, r16
    4e42:	14 97       	sbiw	r26, 0x04	; 4
    4e44:	db 01       	movw	r26, r22
    4e46:	56 96       	adiw	r26, 0x16	; 22
    4e48:	8c 91       	ld	r24, X
    4e4a:	56 97       	sbiw	r26, 0x16	; 22
    4e4c:	29 e0       	ldi	r18, 0x09	; 9
    4e4e:	82 9f       	mul	r24, r18
    4e50:	c0 01       	movw	r24, r0
    4e52:	11 24       	eor	r1, r1
    4e54:	48 0f       	add	r20, r24
    4e56:	59 1f       	adc	r21, r25
    4e58:	1b 96       	adiw	r26, 0x0b	; 11
    4e5a:	5c 93       	st	X, r21
    4e5c:	4e 93       	st	-X, r20
    4e5e:	1a 97       	sbiw	r26, 0x0a	; 10
    4e60:	fa 01       	movw	r30, r20
    4e62:	80 81       	ld	r24, Z
    4e64:	8f 5f       	subi	r24, 0xFF	; 255
    4e66:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4e68:	e0 91 c1 07 	lds	r30, 0x07C1
    4e6c:	f0 91 c2 07 	lds	r31, 0x07C2
    4e70:	56 96       	adiw	r26, 0x16	; 22
    4e72:	9c 91       	ld	r25, X
    4e74:	86 89       	ldd	r24, Z+22	; 0x16
    4e76:	89 17       	cp	r24, r25
    4e78:	18 f4       	brcc	.+6      	; 0x4e80 <vTaskRemoveFromUnorderedEventList+0x134>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    4e7a:	81 e0       	ldi	r24, 0x01	; 1
    4e7c:	80 93 c5 07 	sts	0x07C5, r24
    }
}
    4e80:	df 91       	pop	r29
    4e82:	cf 91       	pop	r28
    4e84:	1f 91       	pop	r17
    4e86:	0f 91       	pop	r16
    4e88:	08 95       	ret

00004e8a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4e8a:	fc 01       	movw	r30, r24
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    4e8c:	0f b6       	in	r0, 0x3f	; 63
    4e8e:	f8 94       	cli
    4e90:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    4e92:	80 91 ca 07 	lds	r24, 0x07CA
    4e96:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    4e98:	80 91 c6 07 	lds	r24, 0x07C6
    4e9c:	90 91 c7 07 	lds	r25, 0x07C7
    4ea0:	92 83       	std	Z+2, r25	; 0x02
    4ea2:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    4ea4:	0f 90       	pop	r0
    4ea6:	0f be       	out	0x3f, r0	; 63
}
    4ea8:	08 95       	ret

00004eaa <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4eaa:	fc 01       	movw	r30, r24
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4eac:	80 91 ca 07 	lds	r24, 0x07CA
    4eb0:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    4eb2:	80 91 c6 07 	lds	r24, 0x07C6
    4eb6:	90 91 c7 07 	lds	r25, 0x07C7
    4eba:	92 83       	std	Z+2, r25	; 0x02
    4ebc:	81 83       	std	Z+1, r24	; 0x01
}
    4ebe:	08 95       	ret

00004ec0 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    4ec0:	fc 01       	movw	r30, r24
    4ec2:	db 01       	movw	r26, r22
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    4ec4:	0f b6       	in	r0, 0x3f	; 63
    4ec6:	f8 94       	cli
    4ec8:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    4eca:	40 91 c6 07 	lds	r20, 0x07C6
    4ece:	50 91 c7 07 	lds	r21, 0x07C7
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4ed2:	21 81       	ldd	r18, Z+1	; 0x01
    4ed4:	32 81       	ldd	r19, Z+2	; 0x02
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4ed6:	90 91 ca 07 	lds	r25, 0x07CA
    4eda:	80 81       	ld	r24, Z
    4edc:	89 17       	cp	r24, r25
    4ede:	39 f0       	breq	.+14     	; 0x4eee <xTaskCheckForTimeOut+0x2e>
    4ee0:	42 17       	cp	r20, r18
    4ee2:	53 07       	cpc	r21, r19
    4ee4:	20 f0       	brcs	.+8      	; 0x4eee <xTaskCheckForTimeOut+0x2e>
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
    4ee6:	1d 92       	st	X+, r1
    4ee8:	1c 92       	st	X, r1
    4eea:	81 e0       	ldi	r24, 0x01	; 1
    4eec:	16 c0       	rjmp	.+44     	; 0x4f1a <xTaskCheckForTimeOut+0x5a>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4eee:	ca 01       	movw	r24, r20
    4ef0:	82 1b       	sub	r24, r18
    4ef2:	93 0b       	sbc	r25, r19
    4ef4:	9c 01       	movw	r18, r24
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4ef6:	8d 91       	ld	r24, X+
    4ef8:	9c 91       	ld	r25, X
    4efa:	11 97       	sbiw	r26, 0x01	; 1
    4efc:	28 17       	cp	r18, r24
    4efe:	39 07       	cpc	r19, r25
    4f00:	48 f4       	brcc	.+18     	; 0x4f14 <xTaskCheckForTimeOut+0x54>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    4f02:	82 1b       	sub	r24, r18
    4f04:	93 0b       	sbc	r25, r19
    4f06:	8d 93       	st	X+, r24
    4f08:	9c 93       	st	X, r25
            vTaskInternalSetTimeOutState( pxTimeOut );
    4f0a:	cf 01       	movw	r24, r30
    4f0c:	0e 94 55 27 	call	0x4eaa	; 0x4eaa <vTaskInternalSetTimeOutState>
    4f10:	80 e0       	ldi	r24, 0x00	; 0
    4f12:	03 c0       	rjmp	.+6      	; 0x4f1a <xTaskCheckForTimeOut+0x5a>
            xReturn = pdFALSE;
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    4f14:	1d 92       	st	X+, r1
    4f16:	1c 92       	st	X, r1
    4f18:	81 e0       	ldi	r24, 0x01	; 1
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
    4f1a:	0f 90       	pop	r0
    4f1c:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    4f1e:	08 95       	ret

00004f20 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
    4f20:	81 e0       	ldi	r24, 0x01	; 1
    4f22:	80 93 c5 07 	sts	0x07C5, r24
}
    4f26:	08 95       	ret

00004f28 <prvResetNextTaskUnblockTime>:
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4f28:	e0 91 09 08 	lds	r30, 0x0809
    4f2c:	f0 91 0a 08 	lds	r31, 0x080A
    4f30:	80 81       	ld	r24, Z
    4f32:	88 23       	and	r24, r24
    4f34:	39 f4       	brne	.+14     	; 0x4f44 <prvResetNextTaskUnblockTime+0x1c>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    4f36:	8f ef       	ldi	r24, 0xFF	; 255
    4f38:	9f ef       	ldi	r25, 0xFF	; 255
    4f3a:	90 93 c9 07 	sts	0x07C9, r25
    4f3e:	80 93 c8 07 	sts	0x07C8, r24
    4f42:	08 95       	ret
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4f44:	e0 91 09 08 	lds	r30, 0x0809
    4f48:	f0 91 0a 08 	lds	r31, 0x080A
    4f4c:	05 80       	ldd	r0, Z+5	; 0x05
    4f4e:	f6 81       	ldd	r31, Z+6	; 0x06
    4f50:	e0 2d       	mov	r30, r0
    4f52:	80 81       	ld	r24, Z
    4f54:	91 81       	ldd	r25, Z+1	; 0x01
    4f56:	90 93 c9 07 	sts	0x07C9, r25
    4f5a:	80 93 c8 07 	sts	0x07C8, r24
    4f5e:	08 95       	ret

00004f60 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4f60:	bf 92       	push	r11
    4f62:	cf 92       	push	r12
    4f64:	df 92       	push	r13
    4f66:	ef 92       	push	r14
    4f68:	ff 92       	push	r15
    4f6a:	0f 93       	push	r16
    4f6c:	1f 93       	push	r17
    4f6e:	cf 93       	push	r28
    4f70:	df 93       	push	r29
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4f72:	80 91 c3 07 	lds	r24, 0x07C3
    4f76:	88 23       	and	r24, r24
    4f78:	09 f0       	breq	.+2      	; 0x4f7c <xTaskIncrementTick+0x1c>
    4f7a:	f8 c0       	rjmp	.+496    	; 0x516c <xTaskIncrementTick+0x20c>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4f7c:	80 91 c6 07 	lds	r24, 0x07C6
    4f80:	90 91 c7 07 	lds	r25, 0x07C7
    4f84:	8c 01       	movw	r16, r24
    4f86:	0f 5f       	subi	r16, 0xFF	; 255
    4f88:	1f 4f       	sbci	r17, 0xFF	; 255

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    4f8a:	10 93 c7 07 	sts	0x07C7, r17
    4f8e:	00 93 c6 07 	sts	0x07C6, r16

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4f92:	01 15       	cp	r16, r1
    4f94:	11 05       	cpc	r17, r1
    4f96:	b9 f4       	brne	.+46     	; 0x4fc6 <xTaskIncrementTick+0x66>
        {
            taskSWITCH_DELAYED_LISTS();
    4f98:	80 91 09 08 	lds	r24, 0x0809
    4f9c:	90 91 0a 08 	lds	r25, 0x080A
    4fa0:	20 91 0b 08 	lds	r18, 0x080B
    4fa4:	30 91 0c 08 	lds	r19, 0x080C
    4fa8:	30 93 0a 08 	sts	0x080A, r19
    4fac:	20 93 09 08 	sts	0x0809, r18
    4fb0:	90 93 0c 08 	sts	0x080C, r25
    4fb4:	80 93 0b 08 	sts	0x080B, r24
    4fb8:	80 91 ca 07 	lds	r24, 0x07CA
    4fbc:	8f 5f       	subi	r24, 0xFF	; 255
    4fbe:	80 93 ca 07 	sts	0x07CA, r24
    4fc2:	0e 94 94 27 	call	0x4f28	; 0x4f28 <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    4fc6:	80 91 c8 07 	lds	r24, 0x07C8
    4fca:	90 91 c9 07 	lds	r25, 0x07C9
    4fce:	08 17       	cp	r16, r24
    4fd0:	19 07       	cpc	r17, r25
    4fd2:	08 f4       	brcc	.+2      	; 0x4fd6 <xTaskIncrementTick+0x76>
    4fd4:	b3 c0       	rjmp	.+358    	; 0x513c <xTaskIncrementTick+0x1dc>
    4fd6:	dd 24       	eor	r13, r13
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    4fd8:	0f 2e       	mov	r0, r31
    4fda:	f3 ed       	ldi	r31, 0xD3	; 211
    4fdc:	ef 2e       	mov	r14, r31
    4fde:	f7 e0       	ldi	r31, 0x07	; 7
    4fe0:	ff 2e       	mov	r15, r31
    4fe2:	f0 2d       	mov	r31, r0
    4fe4:	0f 2e       	mov	r0, r31
    4fe6:	f9 e0       	ldi	r31, 0x09	; 9
    4fe8:	cf 2e       	mov	r12, r31
    4fea:	f0 2d       	mov	r31, r0
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4fec:	bb 24       	eor	r11, r11
    4fee:	b3 94       	inc	r11
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4ff0:	e0 91 09 08 	lds	r30, 0x0809
    4ff4:	f0 91 0a 08 	lds	r31, 0x080A
    4ff8:	80 81       	ld	r24, Z
    4ffa:	88 23       	and	r24, r24
    4ffc:	39 f4       	brne	.+14     	; 0x500c <xTaskIncrementTick+0xac>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4ffe:	8f ef       	ldi	r24, 0xFF	; 255
    5000:	9f ef       	ldi	r25, 0xFF	; 255
    5002:	90 93 c9 07 	sts	0x07C9, r25
    5006:	80 93 c8 07 	sts	0x07C8, r24
    500a:	99 c0       	rjmp	.+306    	; 0x513e <xTaskIncrementTick+0x1de>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    500c:	e0 91 09 08 	lds	r30, 0x0809
    5010:	f0 91 0a 08 	lds	r31, 0x080A
    5014:	05 80       	ldd	r0, Z+5	; 0x05
    5016:	f6 81       	ldd	r31, Z+6	; 0x06
    5018:	e0 2d       	mov	r30, r0
    501a:	c6 81       	ldd	r28, Z+6	; 0x06
    501c:	d7 81       	ldd	r29, Z+7	; 0x07
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    501e:	8a 81       	ldd	r24, Y+2	; 0x02
    5020:	9b 81       	ldd	r25, Y+3	; 0x03

                    if( xConstTickCount < xItemValue )
    5022:	08 17       	cp	r16, r24
    5024:	19 07       	cpc	r17, r25
    5026:	28 f4       	brcc	.+10     	; 0x5032 <xTaskIncrementTick+0xd2>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    5028:	90 93 c9 07 	sts	0x07C9, r25
    502c:	80 93 c8 07 	sts	0x07C8, r24
    5030:	86 c0       	rjmp	.+268    	; 0x513e <xTaskIncrementTick+0x1de>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5032:	2a 85       	ldd	r18, Y+10	; 0x0a
    5034:	3b 85       	ldd	r19, Y+11	; 0x0b
    5036:	ac 81       	ldd	r26, Y+4	; 0x04
    5038:	bd 81       	ldd	r27, Y+5	; 0x05
    503a:	8e 81       	ldd	r24, Y+6	; 0x06
    503c:	9f 81       	ldd	r25, Y+7	; 0x07
    503e:	15 96       	adiw	r26, 0x05	; 5
    5040:	9c 93       	st	X, r25
    5042:	8e 93       	st	-X, r24
    5044:	14 97       	sbiw	r26, 0x04	; 4
    5046:	ee 81       	ldd	r30, Y+6	; 0x06
    5048:	ff 81       	ldd	r31, Y+7	; 0x07
    504a:	b3 83       	std	Z+3, r27	; 0x03
    504c:	a2 83       	std	Z+2, r26	; 0x02
    504e:	be 01       	movw	r22, r28
    5050:	6e 5f       	subi	r22, 0xFE	; 254
    5052:	7f 4f       	sbci	r23, 0xFF	; 255
    5054:	f9 01       	movw	r30, r18
    5056:	81 81       	ldd	r24, Z+1	; 0x01
    5058:	92 81       	ldd	r25, Z+2	; 0x02
    505a:	86 17       	cp	r24, r22
    505c:	97 07       	cpc	r25, r23
    505e:	21 f4       	brne	.+8      	; 0x5068 <xTaskIncrementTick+0x108>
    5060:	8e 81       	ldd	r24, Y+6	; 0x06
    5062:	9f 81       	ldd	r25, Y+7	; 0x07
    5064:	92 83       	std	Z+2, r25	; 0x02
    5066:	81 83       	std	Z+1, r24	; 0x01
    5068:	1b 86       	std	Y+11, r1	; 0x0b
    506a:	1a 86       	std	Y+10, r1	; 0x0a
    506c:	f9 01       	movw	r30, r18
    506e:	80 81       	ld	r24, Z
    5070:	81 50       	subi	r24, 0x01	; 1
    5072:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5074:	4c 89       	ldd	r20, Y+20	; 0x14
    5076:	5d 89       	ldd	r21, Y+21	; 0x15
    5078:	41 15       	cp	r20, r1
    507a:	51 05       	cpc	r21, r1
    507c:	f9 f0       	breq	.+62     	; 0x50bc <xTaskIncrementTick+0x15c>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    507e:	ae 85       	ldd	r26, Y+14	; 0x0e
    5080:	bf 85       	ldd	r27, Y+15	; 0x0f
    5082:	88 89       	ldd	r24, Y+16	; 0x10
    5084:	99 89       	ldd	r25, Y+17	; 0x11
    5086:	15 96       	adiw	r26, 0x05	; 5
    5088:	9c 93       	st	X, r25
    508a:	8e 93       	st	-X, r24
    508c:	14 97       	sbiw	r26, 0x04	; 4
    508e:	e8 89       	ldd	r30, Y+16	; 0x10
    5090:	f9 89       	ldd	r31, Y+17	; 0x11
    5092:	b3 83       	std	Z+3, r27	; 0x03
    5094:	a2 83       	std	Z+2, r26	; 0x02
    5096:	9e 01       	movw	r18, r28
    5098:	24 5f       	subi	r18, 0xF4	; 244
    509a:	3f 4f       	sbci	r19, 0xFF	; 255
    509c:	fa 01       	movw	r30, r20
    509e:	81 81       	ldd	r24, Z+1	; 0x01
    50a0:	92 81       	ldd	r25, Z+2	; 0x02
    50a2:	82 17       	cp	r24, r18
    50a4:	93 07       	cpc	r25, r19
    50a6:	21 f4       	brne	.+8      	; 0x50b0 <xTaskIncrementTick+0x150>
    50a8:	88 89       	ldd	r24, Y+16	; 0x10
    50aa:	99 89       	ldd	r25, Y+17	; 0x11
    50ac:	92 83       	std	Z+2, r25	; 0x02
    50ae:	81 83       	std	Z+1, r24	; 0x01
    50b0:	1d 8a       	std	Y+21, r1	; 0x15
    50b2:	1c 8a       	std	Y+20, r1	; 0x14
    50b4:	fa 01       	movw	r30, r20
    50b6:	80 81       	ld	r24, Z
    50b8:	81 50       	subi	r24, 0x01	; 1
    50ba:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    50bc:	9e 89       	ldd	r25, Y+22	; 0x16
    50be:	80 91 c4 07 	lds	r24, 0x07C4
    50c2:	89 17       	cp	r24, r25
    50c4:	10 f4       	brcc	.+4      	; 0x50ca <xTaskIncrementTick+0x16a>
    50c6:	90 93 c4 07 	sts	0x07C4, r25
    50ca:	2e 89       	ldd	r18, Y+22	; 0x16
    50cc:	30 e0       	ldi	r19, 0x00	; 0
    50ce:	c9 01       	movw	r24, r18
    50d0:	88 0f       	add	r24, r24
    50d2:	99 1f       	adc	r25, r25
    50d4:	88 0f       	add	r24, r24
    50d6:	99 1f       	adc	r25, r25
    50d8:	88 0f       	add	r24, r24
    50da:	99 1f       	adc	r25, r25
    50dc:	82 0f       	add	r24, r18
    50de:	93 1f       	adc	r25, r19
    50e0:	f7 01       	movw	r30, r14
    50e2:	e8 0f       	add	r30, r24
    50e4:	f9 1f       	adc	r31, r25
    50e6:	a1 81       	ldd	r26, Z+1	; 0x01
    50e8:	b2 81       	ldd	r27, Z+2	; 0x02
    50ea:	bd 83       	std	Y+5, r27	; 0x05
    50ec:	ac 83       	std	Y+4, r26	; 0x04
    50ee:	14 96       	adiw	r26, 0x04	; 4
    50f0:	8d 91       	ld	r24, X+
    50f2:	9c 91       	ld	r25, X
    50f4:	15 97       	sbiw	r26, 0x05	; 5
    50f6:	9f 83       	std	Y+7, r25	; 0x07
    50f8:	8e 83       	std	Y+6, r24	; 0x06
    50fa:	14 96       	adiw	r26, 0x04	; 4
    50fc:	ed 91       	ld	r30, X+
    50fe:	fc 91       	ld	r31, X
    5100:	15 97       	sbiw	r26, 0x05	; 5
    5102:	73 83       	std	Z+3, r23	; 0x03
    5104:	62 83       	std	Z+2, r22	; 0x02
    5106:	15 96       	adiw	r26, 0x05	; 5
    5108:	7c 93       	st	X, r23
    510a:	6e 93       	st	-X, r22
    510c:	14 97       	sbiw	r26, 0x04	; 4
    510e:	8e 89       	ldd	r24, Y+22	; 0x16
    5110:	8c 9d       	mul	r24, r12
    5112:	c0 01       	movw	r24, r0
    5114:	11 24       	eor	r1, r1
    5116:	f7 01       	movw	r30, r14
    5118:	e8 0f       	add	r30, r24
    511a:	f9 1f       	adc	r31, r25
    511c:	fb 87       	std	Y+11, r31	; 0x0b
    511e:	ea 87       	std	Y+10, r30	; 0x0a
    5120:	80 81       	ld	r24, Z
    5122:	8f 5f       	subi	r24, 0xFF	; 255
    5124:	80 83       	st	Z, r24
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5126:	e0 91 c1 07 	lds	r30, 0x07C1
    512a:	f0 91 c2 07 	lds	r31, 0x07C2
    512e:	9e 89       	ldd	r25, Y+22	; 0x16
    5130:	86 89       	ldd	r24, Z+22	; 0x16
    5132:	89 17       	cp	r24, r25
    5134:	08 f0       	brcs	.+2      	; 0x5138 <xTaskIncrementTick+0x1d8>
    5136:	5c cf       	rjmp	.-328    	; 0x4ff0 <xTaskIncrementTick+0x90>
    5138:	db 2c       	mov	r13, r11
    513a:	5a cf       	rjmp	.-332    	; 0x4ff0 <xTaskIncrementTick+0x90>
    513c:	dd 24       	eor	r13, r13
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    513e:	e0 91 c1 07 	lds	r30, 0x07C1
    5142:	f0 91 c2 07 	lds	r31, 0x07C2
    5146:	e6 89       	ldd	r30, Z+22	; 0x16
    5148:	89 e0       	ldi	r24, 0x09	; 9
    514a:	e8 9f       	mul	r30, r24
    514c:	f0 01       	movw	r30, r0
    514e:	11 24       	eor	r1, r1
    5150:	ed 52       	subi	r30, 0x2D	; 45
    5152:	f8 4f       	sbci	r31, 0xF8	; 248
    5154:	80 81       	ld	r24, Z
    5156:	82 30       	cpi	r24, 0x02	; 2
    5158:	10 f0       	brcs	.+4      	; 0x515e <xTaskIncrementTick+0x1fe>
    515a:	dd 24       	eor	r13, r13
    515c:	d3 94       	inc	r13
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
    515e:	80 91 c5 07 	lds	r24, 0x07C5
    5162:	88 23       	and	r24, r24
    5164:	69 f0       	breq	.+26     	; 0x5180 <xTaskIncrementTick+0x220>
    5166:	dd 24       	eor	r13, r13
    5168:	d3 94       	inc	r13
    516a:	0a c0       	rjmp	.+20     	; 0x5180 <xTaskIncrementTick+0x220>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    516c:	80 91 cb 07 	lds	r24, 0x07CB
    5170:	90 91 cc 07 	lds	r25, 0x07CC
    5174:	01 96       	adiw	r24, 0x01	; 1
    5176:	90 93 cc 07 	sts	0x07CC, r25
    517a:	80 93 cb 07 	sts	0x07CB, r24
    517e:	dd 24       	eor	r13, r13
        }
        #endif
    }

    return xSwitchRequired;
}
    5180:	8d 2d       	mov	r24, r13
    5182:	df 91       	pop	r29
    5184:	cf 91       	pop	r28
    5186:	1f 91       	pop	r17
    5188:	0f 91       	pop	r16
    518a:	ff 90       	pop	r15
    518c:	ef 90       	pop	r14
    518e:	df 90       	pop	r13
    5190:	cf 90       	pop	r12
    5192:	bf 90       	pop	r11
    5194:	08 95       	ret

00005196 <xTaskGetCurrentTaskHandle>:
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    5196:	20 91 c1 07 	lds	r18, 0x07C1
    519a:	30 91 c2 07 	lds	r19, 0x07C2

        return xReturn;
    }
    519e:	82 2f       	mov	r24, r18
    51a0:	93 2f       	mov	r25, r19
    51a2:	08 95       	ret

000051a4 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    51a4:	e0 91 c1 07 	lds	r30, 0x07C1
    51a8:	f0 91 c2 07 	lds	r31, 0x07C2
    51ac:	84 85       	ldd	r24, Z+12	; 0x0c
    51ae:	95 85       	ldd	r25, Z+13	; 0x0d

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    51b0:	a0 91 c1 07 	lds	r26, 0x07C1
    51b4:	b0 91 c2 07 	lds	r27, 0x07C2
    51b8:	e0 91 c1 07 	lds	r30, 0x07C1
    51bc:	f0 91 c2 07 	lds	r31, 0x07C2
    51c0:	46 89       	ldd	r20, Z+22	; 0x16
    51c2:	24 e0       	ldi	r18, 0x04	; 4
    51c4:	30 e0       	ldi	r19, 0x00	; 0
    51c6:	24 1b       	sub	r18, r20
    51c8:	31 09       	sbc	r19, r1
    51ca:	1d 96       	adiw	r26, 0x0d	; 13
    51cc:	3c 93       	st	X, r19
    51ce:	2e 93       	st	-X, r18
    51d0:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
}
    51d2:	08 95       	ret

000051d4 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    51d4:	af 92       	push	r10
    51d6:	bf 92       	push	r11
    51d8:	cf 92       	push	r12
    51da:	df 92       	push	r13
    51dc:	ef 92       	push	r14
    51de:	ff 92       	push	r15
    51e0:	0f 93       	push	r16
    51e2:	1f 93       	push	r17
    51e4:	cf 93       	push	r28
    51e6:	df 93       	push	r29
    51e8:	5c 01       	movw	r10, r24
    51ea:	e7 01       	movw	r28, r14
    51ec:	76 01       	movw	r14, r12

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( pulPreviousNotificationValue != NULL )
    51ee:	20 97       	sbiw	r28, 0x00	; 0
    51f0:	91 f0       	breq	.+36     	; 0x5216 <xTaskGenericNotifyFromISR+0x42>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    51f2:	86 2f       	mov	r24, r22
    51f4:	90 e0       	ldi	r25, 0x00	; 0
    51f6:	88 0f       	add	r24, r24
    51f8:	99 1f       	adc	r25, r25
    51fa:	88 0f       	add	r24, r24
    51fc:	99 1f       	adc	r25, r25
    51fe:	f5 01       	movw	r30, r10
    5200:	e8 0f       	add	r30, r24
    5202:	f9 1f       	adc	r31, r25
    5204:	b1 96       	adiw	r30, 0x21	; 33
    5206:	80 81       	ld	r24, Z
    5208:	91 81       	ldd	r25, Z+1	; 0x01
    520a:	a2 81       	ldd	r26, Z+2	; 0x02
    520c:	b3 81       	ldd	r27, Z+3	; 0x03
    520e:	88 83       	st	Y, r24
    5210:	99 83       	std	Y+1, r25	; 0x01
    5212:	aa 83       	std	Y+2, r26	; 0x02
    5214:	bb 83       	std	Y+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5216:	70 e0       	ldi	r23, 0x00	; 0
    5218:	f5 01       	movw	r30, r10
    521a:	e6 0f       	add	r30, r22
    521c:	f7 1f       	adc	r31, r23
    521e:	b5 96       	adiw	r30, 0x25	; 37
    5220:	10 81       	ld	r17, Z
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    5222:	82 e0       	ldi	r24, 0x02	; 2
    5224:	80 83       	st	Z, r24

            switch( eAction )
    5226:	02 30       	cpi	r16, 0x02	; 2
    5228:	11 f1       	breq	.+68     	; 0x526e <xTaskGenericNotifyFromISR+0x9a>
    522a:	03 30       	cpi	r16, 0x03	; 3
    522c:	20 f4       	brcc	.+8      	; 0x5236 <xTaskGenericNotifyFromISR+0x62>
    522e:	01 30       	cpi	r16, 0x01	; 1
    5230:	09 f0       	breq	.+2      	; 0x5234 <xTaskGenericNotifyFromISR+0x60>
    5232:	51 c0       	rjmp	.+162    	; 0x52d6 <xTaskGenericNotifyFromISR+0x102>
    5234:	06 c0       	rjmp	.+12     	; 0x5242 <xTaskGenericNotifyFromISR+0x6e>
    5236:	03 30       	cpi	r16, 0x03	; 3
    5238:	79 f1       	breq	.+94     	; 0x5298 <xTaskGenericNotifyFromISR+0xc4>
    523a:	04 30       	cpi	r16, 0x04	; 4
    523c:	09 f0       	breq	.+2      	; 0x5240 <xTaskGenericNotifyFromISR+0x6c>
    523e:	4b c0       	rjmp	.+150    	; 0x52d6 <xTaskGenericNotifyFromISR+0x102>
    5240:	39 c0       	rjmp	.+114    	; 0x52b4 <xTaskGenericNotifyFromISR+0xe0>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    5242:	cb 01       	movw	r24, r22
    5244:	88 0f       	add	r24, r24
    5246:	99 1f       	adc	r25, r25
    5248:	88 0f       	add	r24, r24
    524a:	99 1f       	adc	r25, r25
    524c:	f5 01       	movw	r30, r10
    524e:	e8 0f       	add	r30, r24
    5250:	f9 1f       	adc	r31, r25
    5252:	b1 96       	adiw	r30, 0x21	; 33
    5254:	80 81       	ld	r24, Z
    5256:	91 81       	ldd	r25, Z+1	; 0x01
    5258:	a2 81       	ldd	r26, Z+2	; 0x02
    525a:	b3 81       	ldd	r27, Z+3	; 0x03
    525c:	82 2b       	or	r24, r18
    525e:	93 2b       	or	r25, r19
    5260:	a4 2b       	or	r26, r20
    5262:	b5 2b       	or	r27, r21
    5264:	80 83       	st	Z, r24
    5266:	91 83       	std	Z+1, r25	; 0x01
    5268:	a2 83       	std	Z+2, r26	; 0x02
    526a:	b3 83       	std	Z+3, r27	; 0x03
    526c:	34 c0       	rjmp	.+104    	; 0x52d6 <xTaskGenericNotifyFromISR+0x102>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    526e:	cb 01       	movw	r24, r22
    5270:	88 0f       	add	r24, r24
    5272:	99 1f       	adc	r25, r25
    5274:	88 0f       	add	r24, r24
    5276:	99 1f       	adc	r25, r25
    5278:	f5 01       	movw	r30, r10
    527a:	e8 0f       	add	r30, r24
    527c:	f9 1f       	adc	r31, r25
    527e:	b1 96       	adiw	r30, 0x21	; 33
    5280:	80 81       	ld	r24, Z
    5282:	91 81       	ldd	r25, Z+1	; 0x01
    5284:	a2 81       	ldd	r26, Z+2	; 0x02
    5286:	b3 81       	ldd	r27, Z+3	; 0x03
    5288:	01 96       	adiw	r24, 0x01	; 1
    528a:	a1 1d       	adc	r26, r1
    528c:	b1 1d       	adc	r27, r1
    528e:	80 83       	st	Z, r24
    5290:	91 83       	std	Z+1, r25	; 0x01
    5292:	a2 83       	std	Z+2, r26	; 0x02
    5294:	b3 83       	std	Z+3, r27	; 0x03
    5296:	1f c0       	rjmp	.+62     	; 0x52d6 <xTaskGenericNotifyFromISR+0x102>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5298:	cb 01       	movw	r24, r22
    529a:	88 0f       	add	r24, r24
    529c:	99 1f       	adc	r25, r25
    529e:	88 0f       	add	r24, r24
    52a0:	99 1f       	adc	r25, r25
    52a2:	f5 01       	movw	r30, r10
    52a4:	e8 0f       	add	r30, r24
    52a6:	f9 1f       	adc	r31, r25
    52a8:	b1 96       	adiw	r30, 0x21	; 33
    52aa:	20 83       	st	Z, r18
    52ac:	31 83       	std	Z+1, r19	; 0x01
    52ae:	42 83       	std	Z+2, r20	; 0x02
    52b0:	53 83       	std	Z+3, r21	; 0x03
    52b2:	11 c0       	rjmp	.+34     	; 0x52d6 <xTaskGenericNotifyFromISR+0x102>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    52b4:	12 30       	cpi	r17, 0x02	; 2
    52b6:	11 f4       	brne	.+4      	; 0x52bc <xTaskGenericNotifyFromISR+0xe8>
    52b8:	80 e0       	ldi	r24, 0x00	; 0
    52ba:	b2 c0       	rjmp	.+356    	; 0x5420 <xTaskGenericNotifyFromISR+0x24c>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    52bc:	cb 01       	movw	r24, r22
    52be:	88 0f       	add	r24, r24
    52c0:	99 1f       	adc	r25, r25
    52c2:	88 0f       	add	r24, r24
    52c4:	99 1f       	adc	r25, r25
    52c6:	f5 01       	movw	r30, r10
    52c8:	e8 0f       	add	r30, r24
    52ca:	f9 1f       	adc	r31, r25
    52cc:	b1 96       	adiw	r30, 0x21	; 33
    52ce:	20 83       	st	Z, r18
    52d0:	31 83       	std	Z+1, r19	; 0x01
    52d2:	42 83       	std	Z+2, r20	; 0x02
    52d4:	53 83       	std	Z+3, r21	; 0x03

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    52d6:	11 30       	cpi	r17, 0x01	; 1
    52d8:	09 f0       	breq	.+2      	; 0x52dc <xTaskGenericNotifyFromISR+0x108>
    52da:	a1 c0       	rjmp	.+322    	; 0x541e <xTaskGenericNotifyFromISR+0x24a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    52dc:	80 91 c3 07 	lds	r24, 0x07C3
    52e0:	88 23       	and	r24, r24
    52e2:	09 f0       	breq	.+2      	; 0x52e6 <xTaskGenericNotifyFromISR+0x112>
    52e4:	63 c0       	rjmp	.+198    	; 0x53ac <xTaskGenericNotifyFromISR+0x1d8>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    52e6:	d5 01       	movw	r26, r10
    52e8:	1a 96       	adiw	r26, 0x0a	; 10
    52ea:	cd 91       	ld	r28, X+
    52ec:	dc 91       	ld	r29, X
    52ee:	1b 97       	sbiw	r26, 0x0b	; 11
    52f0:	14 96       	adiw	r26, 0x04	; 4
    52f2:	0d 90       	ld	r0, X+
    52f4:	bc 91       	ld	r27, X
    52f6:	a0 2d       	mov	r26, r0
    52f8:	f5 01       	movw	r30, r10
    52fa:	86 81       	ldd	r24, Z+6	; 0x06
    52fc:	97 81       	ldd	r25, Z+7	; 0x07
    52fe:	15 96       	adiw	r26, 0x05	; 5
    5300:	9c 93       	st	X, r25
    5302:	8e 93       	st	-X, r24
    5304:	14 97       	sbiw	r26, 0x04	; 4
    5306:	86 81       	ldd	r24, Z+6	; 0x06
    5308:	97 81       	ldd	r25, Z+7	; 0x07
    530a:	fc 01       	movw	r30, r24
    530c:	b3 83       	std	Z+3, r27	; 0x03
    530e:	a2 83       	std	Z+2, r26	; 0x02
    5310:	b5 01       	movw	r22, r10
    5312:	6e 5f       	subi	r22, 0xFE	; 254
    5314:	7f 4f       	sbci	r23, 0xFF	; 255
    5316:	89 81       	ldd	r24, Y+1	; 0x01
    5318:	9a 81       	ldd	r25, Y+2	; 0x02
    531a:	86 17       	cp	r24, r22
    531c:	97 07       	cpc	r25, r23
    531e:	11 f4       	brne	.+4      	; 0x5324 <xTaskGenericNotifyFromISR+0x150>
    5320:	fa 83       	std	Y+2, r31	; 0x02
    5322:	e9 83       	std	Y+1, r30	; 0x01
    5324:	f5 01       	movw	r30, r10
    5326:	13 86       	std	Z+11, r1	; 0x0b
    5328:	12 86       	std	Z+10, r1	; 0x0a
    532a:	88 81       	ld	r24, Y
    532c:	81 50       	subi	r24, 0x01	; 1
    532e:	88 83       	st	Y, r24
                    prvAddTaskToReadyList( pxTCB );
    5330:	26 89       	ldd	r18, Z+22	; 0x16
    5332:	80 91 c4 07 	lds	r24, 0x07C4
    5336:	82 17       	cp	r24, r18
    5338:	10 f4       	brcc	.+4      	; 0x533e <xTaskGenericNotifyFromISR+0x16a>
    533a:	20 93 c4 07 	sts	0x07C4, r18
    533e:	30 e0       	ldi	r19, 0x00	; 0
    5340:	c9 01       	movw	r24, r18
    5342:	88 0f       	add	r24, r24
    5344:	99 1f       	adc	r25, r25
    5346:	88 0f       	add	r24, r24
    5348:	99 1f       	adc	r25, r25
    534a:	88 0f       	add	r24, r24
    534c:	99 1f       	adc	r25, r25
    534e:	82 0f       	add	r24, r18
    5350:	93 1f       	adc	r25, r19
    5352:	43 ed       	ldi	r20, 0xD3	; 211
    5354:	57 e0       	ldi	r21, 0x07	; 7
    5356:	fa 01       	movw	r30, r20
    5358:	e8 0f       	add	r30, r24
    535a:	f9 1f       	adc	r31, r25
    535c:	a1 81       	ldd	r26, Z+1	; 0x01
    535e:	b2 81       	ldd	r27, Z+2	; 0x02
    5360:	f5 01       	movw	r30, r10
    5362:	b5 83       	std	Z+5, r27	; 0x05
    5364:	a4 83       	std	Z+4, r26	; 0x04
    5366:	14 96       	adiw	r26, 0x04	; 4
    5368:	8d 91       	ld	r24, X+
    536a:	9c 91       	ld	r25, X
    536c:	15 97       	sbiw	r26, 0x05	; 5
    536e:	97 83       	std	Z+7, r25	; 0x07
    5370:	86 83       	std	Z+6, r24	; 0x06
    5372:	14 96       	adiw	r26, 0x04	; 4
    5374:	ed 91       	ld	r30, X+
    5376:	fc 91       	ld	r31, X
    5378:	15 97       	sbiw	r26, 0x05	; 5
    537a:	73 83       	std	Z+3, r23	; 0x03
    537c:	62 83       	std	Z+2, r22	; 0x02
    537e:	15 96       	adiw	r26, 0x05	; 5
    5380:	7c 93       	st	X, r23
    5382:	6e 93       	st	-X, r22
    5384:	14 97       	sbiw	r26, 0x04	; 4
    5386:	d5 01       	movw	r26, r10
    5388:	56 96       	adiw	r26, 0x16	; 22
    538a:	8c 91       	ld	r24, X
    538c:	56 97       	sbiw	r26, 0x16	; 22
    538e:	29 e0       	ldi	r18, 0x09	; 9
    5390:	82 9f       	mul	r24, r18
    5392:	c0 01       	movw	r24, r0
    5394:	11 24       	eor	r1, r1
    5396:	48 0f       	add	r20, r24
    5398:	59 1f       	adc	r21, r25
    539a:	1b 96       	adiw	r26, 0x0b	; 11
    539c:	5c 93       	st	X, r21
    539e:	4e 93       	st	-X, r20
    53a0:	1a 97       	sbiw	r26, 0x0a	; 10
    53a2:	fa 01       	movw	r30, r20
    53a4:	80 81       	ld	r24, Z
    53a6:	8f 5f       	subi	r24, 0xFF	; 255
    53a8:	80 83       	st	Z, r24
    53aa:	25 c0       	rjmp	.+74     	; 0x53f6 <xTaskGenericNotifyFromISR+0x222>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    53ac:	2e e0       	ldi	r18, 0x0E	; 14
    53ae:	38 e0       	ldi	r19, 0x08	; 8
    53b0:	f9 01       	movw	r30, r18
    53b2:	a0 81       	ld	r26, Z
    53b4:	b1 81       	ldd	r27, Z+1	; 0x01
    53b6:	f5 01       	movw	r30, r10
    53b8:	b7 87       	std	Z+15, r27	; 0x0f
    53ba:	a6 87       	std	Z+14, r26	; 0x0e
    53bc:	14 96       	adiw	r26, 0x04	; 4
    53be:	8d 91       	ld	r24, X+
    53c0:	9c 91       	ld	r25, X
    53c2:	15 97       	sbiw	r26, 0x05	; 5
    53c4:	91 8b       	std	Z+17, r25	; 0x11
    53c6:	80 8b       	std	Z+16, r24	; 0x10
    53c8:	c5 01       	movw	r24, r10
    53ca:	0c 96       	adiw	r24, 0x0c	; 12
    53cc:	14 96       	adiw	r26, 0x04	; 4
    53ce:	ed 91       	ld	r30, X+
    53d0:	fc 91       	ld	r31, X
    53d2:	15 97       	sbiw	r26, 0x05	; 5
    53d4:	93 83       	std	Z+3, r25	; 0x03
    53d6:	82 83       	std	Z+2, r24	; 0x02
    53d8:	15 96       	adiw	r26, 0x05	; 5
    53da:	9c 93       	st	X, r25
    53dc:	8e 93       	st	-X, r24
    53de:	14 97       	sbiw	r26, 0x04	; 4
    53e0:	21 50       	subi	r18, 0x01	; 1
    53e2:	30 40       	sbci	r19, 0x00	; 0
    53e4:	d5 01       	movw	r26, r10
    53e6:	55 96       	adiw	r26, 0x15	; 21
    53e8:	3c 93       	st	X, r19
    53ea:	2e 93       	st	-X, r18
    53ec:	54 97       	sbiw	r26, 0x14	; 20
    53ee:	f9 01       	movw	r30, r18
    53f0:	80 81       	ld	r24, Z
    53f2:	8f 5f       	subi	r24, 0xFF	; 255
    53f4:	80 83       	st	Z, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    53f6:	e0 91 c1 07 	lds	r30, 0x07C1
    53fa:	f0 91 c2 07 	lds	r31, 0x07C2
    53fe:	d5 01       	movw	r26, r10
    5400:	56 96       	adiw	r26, 0x16	; 22
    5402:	9c 91       	ld	r25, X
    5404:	86 89       	ldd	r24, Z+22	; 0x16
    5406:	89 17       	cp	r24, r25
    5408:	50 f4       	brcc	.+20     	; 0x541e <xTaskGenericNotifyFromISR+0x24a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    540a:	e1 14       	cp	r14, r1
    540c:	f1 04       	cpc	r15, r1
    540e:	19 f0       	breq	.+6      	; 0x5416 <xTaskGenericNotifyFromISR+0x242>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5410:	81 e0       	ldi	r24, 0x01	; 1
    5412:	f7 01       	movw	r30, r14
    5414:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5416:	81 e0       	ldi	r24, 0x01	; 1
    5418:	80 93 c5 07 	sts	0x07C5, r24
    541c:	01 c0       	rjmp	.+2      	; 0x5420 <xTaskGenericNotifyFromISR+0x24c>
    541e:	81 e0       	ldi	r24, 0x01	; 1
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    }
    5420:	df 91       	pop	r29
    5422:	cf 91       	pop	r28
    5424:	1f 91       	pop	r17
    5426:	0f 91       	pop	r16
    5428:	ff 90       	pop	r15
    542a:	ef 90       	pop	r14
    542c:	df 90       	pop	r13
    542e:	cf 90       	pop	r12
    5430:	bf 90       	pop	r11
    5432:	af 90       	pop	r10
    5434:	08 95       	ret

00005436 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    5436:	0f 93       	push	r16
    5438:	1f 93       	push	r17
    543a:	cf 93       	push	r28
    543c:	df 93       	push	r29
    543e:	ec 01       	movw	r28, r24
    5440:	8a 01       	movw	r16, r20

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5442:	70 e0       	ldi	r23, 0x00	; 0
    5444:	fc 01       	movw	r30, r24
    5446:	e6 0f       	add	r30, r22
    5448:	f7 1f       	adc	r31, r23
    544a:	b5 96       	adiw	r30, 0x25	; 37
    544c:	20 81       	ld	r18, Z
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    544e:	82 e0       	ldi	r24, 0x02	; 2
    5450:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5452:	66 0f       	add	r22, r22
    5454:	77 1f       	adc	r23, r23
    5456:	66 0f       	add	r22, r22
    5458:	77 1f       	adc	r23, r23
    545a:	fe 01       	movw	r30, r28
    545c:	e6 0f       	add	r30, r22
    545e:	f7 1f       	adc	r31, r23
    5460:	b1 96       	adiw	r30, 0x21	; 33
    5462:	80 81       	ld	r24, Z
    5464:	91 81       	ldd	r25, Z+1	; 0x01
    5466:	a2 81       	ldd	r26, Z+2	; 0x02
    5468:	b3 81       	ldd	r27, Z+3	; 0x03
    546a:	01 96       	adiw	r24, 0x01	; 1
    546c:	a1 1d       	adc	r26, r1
    546e:	b1 1d       	adc	r27, r1
    5470:	80 83       	st	Z, r24
    5472:	91 83       	std	Z+1, r25	; 0x01
    5474:	a2 83       	std	Z+2, r26	; 0x02
    5476:	b3 83       	std	Z+3, r27	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5478:	21 30       	cpi	r18, 0x01	; 1
    547a:	09 f0       	breq	.+2      	; 0x547e <vTaskGenericNotifyGiveFromISR+0x48>
    547c:	90 c0       	rjmp	.+288    	; 0x559e <vTaskGenericNotifyGiveFromISR+0x168>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    547e:	80 91 c3 07 	lds	r24, 0x07C3
    5482:	88 23       	and	r24, r24
    5484:	09 f0       	breq	.+2      	; 0x5488 <vTaskGenericNotifyGiveFromISR+0x52>
    5486:	59 c0       	rjmp	.+178    	; 0x553a <vTaskGenericNotifyGiveFromISR+0x104>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5488:	2a 85       	ldd	r18, Y+10	; 0x0a
    548a:	3b 85       	ldd	r19, Y+11	; 0x0b
    548c:	ac 81       	ldd	r26, Y+4	; 0x04
    548e:	bd 81       	ldd	r27, Y+5	; 0x05
    5490:	8e 81       	ldd	r24, Y+6	; 0x06
    5492:	9f 81       	ldd	r25, Y+7	; 0x07
    5494:	15 96       	adiw	r26, 0x05	; 5
    5496:	9c 93       	st	X, r25
    5498:	8e 93       	st	-X, r24
    549a:	14 97       	sbiw	r26, 0x04	; 4
    549c:	ee 81       	ldd	r30, Y+6	; 0x06
    549e:	ff 81       	ldd	r31, Y+7	; 0x07
    54a0:	b3 83       	std	Z+3, r27	; 0x03
    54a2:	a2 83       	std	Z+2, r26	; 0x02
    54a4:	be 01       	movw	r22, r28
    54a6:	6e 5f       	subi	r22, 0xFE	; 254
    54a8:	7f 4f       	sbci	r23, 0xFF	; 255
    54aa:	f9 01       	movw	r30, r18
    54ac:	81 81       	ldd	r24, Z+1	; 0x01
    54ae:	92 81       	ldd	r25, Z+2	; 0x02
    54b0:	86 17       	cp	r24, r22
    54b2:	97 07       	cpc	r25, r23
    54b4:	21 f4       	brne	.+8      	; 0x54be <vTaskGenericNotifyGiveFromISR+0x88>
    54b6:	8e 81       	ldd	r24, Y+6	; 0x06
    54b8:	9f 81       	ldd	r25, Y+7	; 0x07
    54ba:	92 83       	std	Z+2, r25	; 0x02
    54bc:	81 83       	std	Z+1, r24	; 0x01
    54be:	1b 86       	std	Y+11, r1	; 0x0b
    54c0:	1a 86       	std	Y+10, r1	; 0x0a
    54c2:	f9 01       	movw	r30, r18
    54c4:	80 81       	ld	r24, Z
    54c6:	81 50       	subi	r24, 0x01	; 1
    54c8:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    54ca:	2e 89       	ldd	r18, Y+22	; 0x16
    54cc:	80 91 c4 07 	lds	r24, 0x07C4
    54d0:	82 17       	cp	r24, r18
    54d2:	10 f4       	brcc	.+4      	; 0x54d8 <vTaskGenericNotifyGiveFromISR+0xa2>
    54d4:	20 93 c4 07 	sts	0x07C4, r18
    54d8:	30 e0       	ldi	r19, 0x00	; 0
    54da:	c9 01       	movw	r24, r18
    54dc:	88 0f       	add	r24, r24
    54de:	99 1f       	adc	r25, r25
    54e0:	88 0f       	add	r24, r24
    54e2:	99 1f       	adc	r25, r25
    54e4:	88 0f       	add	r24, r24
    54e6:	99 1f       	adc	r25, r25
    54e8:	82 0f       	add	r24, r18
    54ea:	93 1f       	adc	r25, r19
    54ec:	43 ed       	ldi	r20, 0xD3	; 211
    54ee:	57 e0       	ldi	r21, 0x07	; 7
    54f0:	fa 01       	movw	r30, r20
    54f2:	e8 0f       	add	r30, r24
    54f4:	f9 1f       	adc	r31, r25
    54f6:	a1 81       	ldd	r26, Z+1	; 0x01
    54f8:	b2 81       	ldd	r27, Z+2	; 0x02
    54fa:	bd 83       	std	Y+5, r27	; 0x05
    54fc:	ac 83       	std	Y+4, r26	; 0x04
    54fe:	14 96       	adiw	r26, 0x04	; 4
    5500:	8d 91       	ld	r24, X+
    5502:	9c 91       	ld	r25, X
    5504:	15 97       	sbiw	r26, 0x05	; 5
    5506:	9f 83       	std	Y+7, r25	; 0x07
    5508:	8e 83       	std	Y+6, r24	; 0x06
    550a:	14 96       	adiw	r26, 0x04	; 4
    550c:	ed 91       	ld	r30, X+
    550e:	fc 91       	ld	r31, X
    5510:	15 97       	sbiw	r26, 0x05	; 5
    5512:	73 83       	std	Z+3, r23	; 0x03
    5514:	62 83       	std	Z+2, r22	; 0x02
    5516:	15 96       	adiw	r26, 0x05	; 5
    5518:	7c 93       	st	X, r23
    551a:	6e 93       	st	-X, r22
    551c:	14 97       	sbiw	r26, 0x04	; 4
    551e:	8e 89       	ldd	r24, Y+22	; 0x16
    5520:	29 e0       	ldi	r18, 0x09	; 9
    5522:	82 9f       	mul	r24, r18
    5524:	c0 01       	movw	r24, r0
    5526:	11 24       	eor	r1, r1
    5528:	48 0f       	add	r20, r24
    552a:	59 1f       	adc	r21, r25
    552c:	5b 87       	std	Y+11, r21	; 0x0b
    552e:	4a 87       	std	Y+10, r20	; 0x0a
    5530:	fa 01       	movw	r30, r20
    5532:	80 81       	ld	r24, Z
    5534:	8f 5f       	subi	r24, 0xFF	; 255
    5536:	80 83       	st	Z, r24
    5538:	21 c0       	rjmp	.+66     	; 0x557c <vTaskGenericNotifyGiveFromISR+0x146>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    553a:	2e e0       	ldi	r18, 0x0E	; 14
    553c:	38 e0       	ldi	r19, 0x08	; 8
    553e:	f9 01       	movw	r30, r18
    5540:	a0 81       	ld	r26, Z
    5542:	b1 81       	ldd	r27, Z+1	; 0x01
    5544:	bf 87       	std	Y+15, r27	; 0x0f
    5546:	ae 87       	std	Y+14, r26	; 0x0e
    5548:	14 96       	adiw	r26, 0x04	; 4
    554a:	8d 91       	ld	r24, X+
    554c:	9c 91       	ld	r25, X
    554e:	15 97       	sbiw	r26, 0x05	; 5
    5550:	99 8b       	std	Y+17, r25	; 0x11
    5552:	88 8b       	std	Y+16, r24	; 0x10
    5554:	ce 01       	movw	r24, r28
    5556:	0c 96       	adiw	r24, 0x0c	; 12
    5558:	14 96       	adiw	r26, 0x04	; 4
    555a:	ed 91       	ld	r30, X+
    555c:	fc 91       	ld	r31, X
    555e:	15 97       	sbiw	r26, 0x05	; 5
    5560:	93 83       	std	Z+3, r25	; 0x03
    5562:	82 83       	std	Z+2, r24	; 0x02
    5564:	15 96       	adiw	r26, 0x05	; 5
    5566:	9c 93       	st	X, r25
    5568:	8e 93       	st	-X, r24
    556a:	14 97       	sbiw	r26, 0x04	; 4
    556c:	21 50       	subi	r18, 0x01	; 1
    556e:	30 40       	sbci	r19, 0x00	; 0
    5570:	3d 8b       	std	Y+21, r19	; 0x15
    5572:	2c 8b       	std	Y+20, r18	; 0x14
    5574:	f9 01       	movw	r30, r18
    5576:	80 81       	ld	r24, Z
    5578:	8f 5f       	subi	r24, 0xFF	; 255
    557a:	80 83       	st	Z, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    557c:	e0 91 c1 07 	lds	r30, 0x07C1
    5580:	f0 91 c2 07 	lds	r31, 0x07C2
    5584:	9e 89       	ldd	r25, Y+22	; 0x16
    5586:	86 89       	ldd	r24, Z+22	; 0x16
    5588:	89 17       	cp	r24, r25
    558a:	48 f4       	brcc	.+18     	; 0x559e <vTaskGenericNotifyGiveFromISR+0x168>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    558c:	01 15       	cp	r16, r1
    558e:	11 05       	cpc	r17, r1
    5590:	19 f0       	breq	.+6      	; 0x5598 <vTaskGenericNotifyGiveFromISR+0x162>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5592:	81 e0       	ldi	r24, 0x01	; 1
    5594:	f8 01       	movw	r30, r16
    5596:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    5598:	81 e0       	ldi	r24, 0x01	; 1
    559a:	80 93 c5 07 	sts	0x07C5, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    559e:	df 91       	pop	r29
    55a0:	cf 91       	pop	r28
    55a2:	1f 91       	pop	r17
    55a4:	0f 91       	pop	r16
    55a6:	08 95       	ret

000055a8 <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    55a8:	26 2f       	mov	r18, r22

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    55aa:	00 97       	sbiw	r24, 0x00	; 0
    55ac:	11 f0       	breq	.+4      	; 0x55b2 <xTaskGenericNotifyStateClear+0xa>
    55ae:	bc 01       	movw	r22, r24
    55b0:	04 c0       	rjmp	.+8      	; 0x55ba <xTaskGenericNotifyStateClear+0x12>
    55b2:	60 91 c1 07 	lds	r22, 0x07C1
    55b6:	70 91 c2 07 	lds	r23, 0x07C2

        taskENTER_CRITICAL();
    55ba:	0f b6       	in	r0, 0x3f	; 63
    55bc:	f8 94       	cli
    55be:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    55c0:	30 e0       	ldi	r19, 0x00	; 0
    55c2:	fb 01       	movw	r30, r22
    55c4:	e2 0f       	add	r30, r18
    55c6:	f3 1f       	adc	r31, r19
    55c8:	b5 96       	adiw	r30, 0x25	; 37
    55ca:	80 81       	ld	r24, Z
    55cc:	82 30       	cpi	r24, 0x02	; 2
    55ce:	11 f0       	breq	.+4      	; 0x55d4 <xTaskGenericNotifyStateClear+0x2c>
    55d0:	80 e0       	ldi	r24, 0x00	; 0
    55d2:	06 c0       	rjmp	.+12     	; 0x55e0 <xTaskGenericNotifyStateClear+0x38>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    55d4:	fb 01       	movw	r30, r22
    55d6:	e2 0f       	add	r30, r18
    55d8:	f3 1f       	adc	r31, r19
    55da:	b5 96       	adiw	r30, 0x25	; 37
    55dc:	10 82       	st	Z, r1
    55de:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                xReturn = pdFAIL;
            }
        }
        taskEXIT_CRITICAL();
    55e0:	0f 90       	pop	r0
    55e2:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    55e4:	08 95       	ret

000055e6 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    55e6:	af 92       	push	r10
    55e8:	bf 92       	push	r11
    55ea:	cf 92       	push	r12
    55ec:	df 92       	push	r13
    55ee:	ef 92       	push	r14
    55f0:	ff 92       	push	r15
    55f2:	0f 93       	push	r16
    55f4:	1f 93       	push	r17
    55f6:	e6 2f       	mov	r30, r22
    55f8:	59 01       	movw	r10, r18
    55fa:	6a 01       	movw	r12, r20
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    55fc:	00 97       	sbiw	r24, 0x00	; 0
    55fe:	11 f0       	breq	.+4      	; 0x5604 <ulTaskGenericNotifyValueClear+0x1e>
    5600:	bc 01       	movw	r22, r24
    5602:	04 c0       	rjmp	.+8      	; 0x560c <ulTaskGenericNotifyValueClear+0x26>
    5604:	60 91 c1 07 	lds	r22, 0x07C1
    5608:	70 91 c2 07 	lds	r23, 0x07C2

        taskENTER_CRITICAL();
    560c:	0f b6       	in	r0, 0x3f	; 63
    560e:	f8 94       	cli
    5610:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    5612:	8e 2f       	mov	r24, r30
    5614:	90 e0       	ldi	r25, 0x00	; 0
    5616:	88 0f       	add	r24, r24
    5618:	99 1f       	adc	r25, r25
    561a:	88 0f       	add	r24, r24
    561c:	99 1f       	adc	r25, r25
    561e:	fb 01       	movw	r30, r22
    5620:	e8 0f       	add	r30, r24
    5622:	f9 1f       	adc	r31, r25
    5624:	b1 96       	adiw	r30, 0x21	; 33
    5626:	20 81       	ld	r18, Z
    5628:	31 81       	ldd	r19, Z+1	; 0x01
    562a:	42 81       	ldd	r20, Z+2	; 0x02
    562c:	53 81       	ldd	r21, Z+3	; 0x03
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    562e:	e0 80       	ld	r14, Z
    5630:	f1 80       	ldd	r15, Z+1	; 0x01
    5632:	02 81       	ldd	r16, Z+2	; 0x02
    5634:	13 81       	ldd	r17, Z+3	; 0x03
    5636:	d6 01       	movw	r26, r12
    5638:	c5 01       	movw	r24, r10
    563a:	80 95       	com	r24
    563c:	90 95       	com	r25
    563e:	a0 95       	com	r26
    5640:	b0 95       	com	r27
    5642:	8e 21       	and	r24, r14
    5644:	9f 21       	and	r25, r15
    5646:	a0 23       	and	r26, r16
    5648:	b1 23       	and	r27, r17
    564a:	80 83       	st	Z, r24
    564c:	91 83       	std	Z+1, r25	; 0x01
    564e:	a2 83       	std	Z+2, r26	; 0x02
    5650:	b3 83       	std	Z+3, r27	; 0x03
        }
        taskEXIT_CRITICAL();
    5652:	0f 90       	pop	r0
    5654:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    5656:	62 2f       	mov	r22, r18
    5658:	73 2f       	mov	r23, r19
    565a:	84 2f       	mov	r24, r20
    565c:	95 2f       	mov	r25, r21
    565e:	1f 91       	pop	r17
    5660:	0f 91       	pop	r16
    5662:	ff 90       	pop	r15
    5664:	ef 90       	pop	r14
    5666:	df 90       	pop	r13
    5668:	cf 90       	pop	r12
    566a:	bf 90       	pop	r11
    566c:	af 90       	pop	r10
    566e:	08 95       	ret

00005670 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    5670:	ef 92       	push	r14
    5672:	ff 92       	push	r15
    5674:	0f 93       	push	r16
    5676:	1f 93       	push	r17
    5678:	cf 93       	push	r28
    567a:	df 93       	push	r29
    567c:	ec 01       	movw	r28, r24

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;

        taskENTER_CRITICAL();
    567e:	0f b6       	in	r0, 0x3f	; 63
    5680:	f8 94       	cli
    5682:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    5684:	e1 14       	cp	r14, r1
    5686:	f1 04       	cpc	r15, r1
    5688:	99 f0       	breq	.+38     	; 0x56b0 <xTaskGenericNotify+0x40>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    568a:	86 2f       	mov	r24, r22
    568c:	90 e0       	ldi	r25, 0x00	; 0
    568e:	88 0f       	add	r24, r24
    5690:	99 1f       	adc	r25, r25
    5692:	88 0f       	add	r24, r24
    5694:	99 1f       	adc	r25, r25
    5696:	fe 01       	movw	r30, r28
    5698:	e8 0f       	add	r30, r24
    569a:	f9 1f       	adc	r31, r25
    569c:	b1 96       	adiw	r30, 0x21	; 33
    569e:	80 81       	ld	r24, Z
    56a0:	91 81       	ldd	r25, Z+1	; 0x01
    56a2:	a2 81       	ldd	r26, Z+2	; 0x02
    56a4:	b3 81       	ldd	r27, Z+3	; 0x03
    56a6:	f7 01       	movw	r30, r14
    56a8:	80 83       	st	Z, r24
    56aa:	91 83       	std	Z+1, r25	; 0x01
    56ac:	a2 83       	std	Z+2, r26	; 0x02
    56ae:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    56b0:	70 e0       	ldi	r23, 0x00	; 0
    56b2:	fe 01       	movw	r30, r28
    56b4:	e6 0f       	add	r30, r22
    56b6:	f7 1f       	adc	r31, r23
    56b8:	b5 96       	adiw	r30, 0x25	; 37
    56ba:	10 81       	ld	r17, Z

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    56bc:	82 e0       	ldi	r24, 0x02	; 2
    56be:	80 83       	st	Z, r24

            switch( eAction )
    56c0:	02 30       	cpi	r16, 0x02	; 2
    56c2:	11 f1       	breq	.+68     	; 0x5708 <xTaskGenericNotify+0x98>
    56c4:	03 30       	cpi	r16, 0x03	; 3
    56c6:	20 f4       	brcc	.+8      	; 0x56d0 <xTaskGenericNotify+0x60>
    56c8:	01 30       	cpi	r16, 0x01	; 1
    56ca:	09 f0       	breq	.+2      	; 0x56ce <xTaskGenericNotify+0x5e>
    56cc:	51 c0       	rjmp	.+162    	; 0x5770 <xTaskGenericNotify+0x100>
    56ce:	06 c0       	rjmp	.+12     	; 0x56dc <xTaskGenericNotify+0x6c>
    56d0:	03 30       	cpi	r16, 0x03	; 3
    56d2:	79 f1       	breq	.+94     	; 0x5732 <xTaskGenericNotify+0xc2>
    56d4:	04 30       	cpi	r16, 0x04	; 4
    56d6:	09 f0       	breq	.+2      	; 0x56da <xTaskGenericNotify+0x6a>
    56d8:	4b c0       	rjmp	.+150    	; 0x5770 <xTaskGenericNotify+0x100>
    56da:	39 c0       	rjmp	.+114    	; 0x574e <xTaskGenericNotify+0xde>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    56dc:	cb 01       	movw	r24, r22
    56de:	88 0f       	add	r24, r24
    56e0:	99 1f       	adc	r25, r25
    56e2:	88 0f       	add	r24, r24
    56e4:	99 1f       	adc	r25, r25
    56e6:	fe 01       	movw	r30, r28
    56e8:	e8 0f       	add	r30, r24
    56ea:	f9 1f       	adc	r31, r25
    56ec:	b1 96       	adiw	r30, 0x21	; 33
    56ee:	80 81       	ld	r24, Z
    56f0:	91 81       	ldd	r25, Z+1	; 0x01
    56f2:	a2 81       	ldd	r26, Z+2	; 0x02
    56f4:	b3 81       	ldd	r27, Z+3	; 0x03
    56f6:	82 2b       	or	r24, r18
    56f8:	93 2b       	or	r25, r19
    56fa:	a4 2b       	or	r26, r20
    56fc:	b5 2b       	or	r27, r21
    56fe:	80 83       	st	Z, r24
    5700:	91 83       	std	Z+1, r25	; 0x01
    5702:	a2 83       	std	Z+2, r26	; 0x02
    5704:	b3 83       	std	Z+3, r27	; 0x03
    5706:	34 c0       	rjmp	.+104    	; 0x5770 <xTaskGenericNotify+0x100>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5708:	cb 01       	movw	r24, r22
    570a:	88 0f       	add	r24, r24
    570c:	99 1f       	adc	r25, r25
    570e:	88 0f       	add	r24, r24
    5710:	99 1f       	adc	r25, r25
    5712:	fe 01       	movw	r30, r28
    5714:	e8 0f       	add	r30, r24
    5716:	f9 1f       	adc	r31, r25
    5718:	b1 96       	adiw	r30, 0x21	; 33
    571a:	80 81       	ld	r24, Z
    571c:	91 81       	ldd	r25, Z+1	; 0x01
    571e:	a2 81       	ldd	r26, Z+2	; 0x02
    5720:	b3 81       	ldd	r27, Z+3	; 0x03
    5722:	01 96       	adiw	r24, 0x01	; 1
    5724:	a1 1d       	adc	r26, r1
    5726:	b1 1d       	adc	r27, r1
    5728:	80 83       	st	Z, r24
    572a:	91 83       	std	Z+1, r25	; 0x01
    572c:	a2 83       	std	Z+2, r26	; 0x02
    572e:	b3 83       	std	Z+3, r27	; 0x03
    5730:	1f c0       	rjmp	.+62     	; 0x5770 <xTaskGenericNotify+0x100>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5732:	cb 01       	movw	r24, r22
    5734:	88 0f       	add	r24, r24
    5736:	99 1f       	adc	r25, r25
    5738:	88 0f       	add	r24, r24
    573a:	99 1f       	adc	r25, r25
    573c:	fe 01       	movw	r30, r28
    573e:	e8 0f       	add	r30, r24
    5740:	f9 1f       	adc	r31, r25
    5742:	b1 96       	adiw	r30, 0x21	; 33
    5744:	20 83       	st	Z, r18
    5746:	31 83       	std	Z+1, r19	; 0x01
    5748:	42 83       	std	Z+2, r20	; 0x02
    574a:	53 83       	std	Z+3, r21	; 0x03
    574c:	11 c0       	rjmp	.+34     	; 0x5770 <xTaskGenericNotify+0x100>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    574e:	12 30       	cpi	r17, 0x02	; 2
    5750:	11 f4       	brne	.+4      	; 0x5756 <xTaskGenericNotify+0xe6>
    5752:	80 e0       	ldi	r24, 0x00	; 0
    5754:	76 c0       	rjmp	.+236    	; 0x5842 <xTaskGenericNotify+0x1d2>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    5756:	cb 01       	movw	r24, r22
    5758:	88 0f       	add	r24, r24
    575a:	99 1f       	adc	r25, r25
    575c:	88 0f       	add	r24, r24
    575e:	99 1f       	adc	r25, r25
    5760:	fe 01       	movw	r30, r28
    5762:	e8 0f       	add	r30, r24
    5764:	f9 1f       	adc	r31, r25
    5766:	b1 96       	adiw	r30, 0x21	; 33
    5768:	20 83       	st	Z, r18
    576a:	31 83       	std	Z+1, r19	; 0x01
    576c:	42 83       	std	Z+2, r20	; 0x02
    576e:	53 83       	std	Z+3, r21	; 0x03

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5770:	11 30       	cpi	r17, 0x01	; 1
    5772:	09 f0       	breq	.+2      	; 0x5776 <xTaskGenericNotify+0x106>
    5774:	65 c0       	rjmp	.+202    	; 0x5840 <xTaskGenericNotify+0x1d0>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5776:	2a 85       	ldd	r18, Y+10	; 0x0a
    5778:	3b 85       	ldd	r19, Y+11	; 0x0b
    577a:	ac 81       	ldd	r26, Y+4	; 0x04
    577c:	bd 81       	ldd	r27, Y+5	; 0x05
    577e:	8e 81       	ldd	r24, Y+6	; 0x06
    5780:	9f 81       	ldd	r25, Y+7	; 0x07
    5782:	15 96       	adiw	r26, 0x05	; 5
    5784:	9c 93       	st	X, r25
    5786:	8e 93       	st	-X, r24
    5788:	14 97       	sbiw	r26, 0x04	; 4
    578a:	ee 81       	ldd	r30, Y+6	; 0x06
    578c:	ff 81       	ldd	r31, Y+7	; 0x07
    578e:	b3 83       	std	Z+3, r27	; 0x03
    5790:	a2 83       	std	Z+2, r26	; 0x02
    5792:	be 01       	movw	r22, r28
    5794:	6e 5f       	subi	r22, 0xFE	; 254
    5796:	7f 4f       	sbci	r23, 0xFF	; 255
    5798:	f9 01       	movw	r30, r18
    579a:	81 81       	ldd	r24, Z+1	; 0x01
    579c:	92 81       	ldd	r25, Z+2	; 0x02
    579e:	86 17       	cp	r24, r22
    57a0:	97 07       	cpc	r25, r23
    57a2:	21 f4       	brne	.+8      	; 0x57ac <xTaskGenericNotify+0x13c>
    57a4:	8e 81       	ldd	r24, Y+6	; 0x06
    57a6:	9f 81       	ldd	r25, Y+7	; 0x07
    57a8:	92 83       	std	Z+2, r25	; 0x02
    57aa:	81 83       	std	Z+1, r24	; 0x01
    57ac:	1b 86       	std	Y+11, r1	; 0x0b
    57ae:	1a 86       	std	Y+10, r1	; 0x0a
    57b0:	f9 01       	movw	r30, r18
    57b2:	80 81       	ld	r24, Z
    57b4:	81 50       	subi	r24, 0x01	; 1
    57b6:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    57b8:	9e 89       	ldd	r25, Y+22	; 0x16
    57ba:	80 91 c4 07 	lds	r24, 0x07C4
    57be:	89 17       	cp	r24, r25
    57c0:	10 f4       	brcc	.+4      	; 0x57c6 <xTaskGenericNotify+0x156>
    57c2:	90 93 c4 07 	sts	0x07C4, r25
    57c6:	8e 89       	ldd	r24, Y+22	; 0x16
    57c8:	90 e0       	ldi	r25, 0x00	; 0
    57ca:	9c 01       	movw	r18, r24
    57cc:	22 0f       	add	r18, r18
    57ce:	33 1f       	adc	r19, r19
    57d0:	22 0f       	add	r18, r18
    57d2:	33 1f       	adc	r19, r19
    57d4:	22 0f       	add	r18, r18
    57d6:	33 1f       	adc	r19, r19
    57d8:	28 0f       	add	r18, r24
    57da:	39 1f       	adc	r19, r25
    57dc:	43 ed       	ldi	r20, 0xD3	; 211
    57de:	57 e0       	ldi	r21, 0x07	; 7
    57e0:	fa 01       	movw	r30, r20
    57e2:	e2 0f       	add	r30, r18
    57e4:	f3 1f       	adc	r31, r19
    57e6:	a1 81       	ldd	r26, Z+1	; 0x01
    57e8:	b2 81       	ldd	r27, Z+2	; 0x02
    57ea:	bd 83       	std	Y+5, r27	; 0x05
    57ec:	ac 83       	std	Y+4, r26	; 0x04
    57ee:	14 96       	adiw	r26, 0x04	; 4
    57f0:	8d 91       	ld	r24, X+
    57f2:	9c 91       	ld	r25, X
    57f4:	15 97       	sbiw	r26, 0x05	; 5
    57f6:	9f 83       	std	Y+7, r25	; 0x07
    57f8:	8e 83       	std	Y+6, r24	; 0x06
    57fa:	14 96       	adiw	r26, 0x04	; 4
    57fc:	ed 91       	ld	r30, X+
    57fe:	fc 91       	ld	r31, X
    5800:	15 97       	sbiw	r26, 0x05	; 5
    5802:	73 83       	std	Z+3, r23	; 0x03
    5804:	62 83       	std	Z+2, r22	; 0x02
    5806:	15 96       	adiw	r26, 0x05	; 5
    5808:	7c 93       	st	X, r23
    580a:	6e 93       	st	-X, r22
    580c:	14 97       	sbiw	r26, 0x04	; 4
    580e:	8e 89       	ldd	r24, Y+22	; 0x16
    5810:	29 e0       	ldi	r18, 0x09	; 9
    5812:	82 9f       	mul	r24, r18
    5814:	c0 01       	movw	r24, r0
    5816:	11 24       	eor	r1, r1
    5818:	48 0f       	add	r20, r24
    581a:	59 1f       	adc	r21, r25
    581c:	5b 87       	std	Y+11, r21	; 0x0b
    581e:	4a 87       	std	Y+10, r20	; 0x0a
    5820:	fa 01       	movw	r30, r20
    5822:	80 81       	ld	r24, Z
    5824:	8f 5f       	subi	r24, 0xFF	; 255
    5826:	80 83       	st	Z, r24
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5828:	e0 91 c1 07 	lds	r30, 0x07C1
    582c:	f0 91 c2 07 	lds	r31, 0x07C2
    5830:	9e 89       	ldd	r25, Y+22	; 0x16
    5832:	86 89       	ldd	r24, Z+22	; 0x16
    5834:	89 17       	cp	r24, r25
    5836:	20 f4       	brcc	.+8      	; 0x5840 <xTaskGenericNotify+0x1d0>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    5838:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
    583c:	81 e0       	ldi	r24, 0x01	; 1
    583e:	01 c0       	rjmp	.+2      	; 0x5842 <xTaskGenericNotify+0x1d2>
    5840:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5842:	0f 90       	pop	r0
    5844:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    5846:	df 91       	pop	r29
    5848:	cf 91       	pop	r28
    584a:	1f 91       	pop	r17
    584c:	0f 91       	pop	r16
    584e:	ff 90       	pop	r15
    5850:	ef 90       	pop	r14
    5852:	08 95       	ret

00005854 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    5854:	ef 92       	push	r14
    5856:	ff 92       	push	r15
    5858:	0f 93       	push	r16
    585a:	1f 93       	push	r17
    585c:	cf 93       	push	r28
    585e:	df 93       	push	r29
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    5860:	0f b6       	in	r0, 0x3f	; 63
    5862:	f8 94       	cli
    5864:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    5866:	80 91 c3 07 	lds	r24, 0x07C3
    586a:	81 50       	subi	r24, 0x01	; 1
    586c:	80 93 c3 07 	sts	0x07C3, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5870:	80 91 c3 07 	lds	r24, 0x07C3
    5874:	88 23       	and	r24, r24
    5876:	09 f0       	breq	.+2      	; 0x587a <xTaskResumeAll+0x26>
    5878:	bd c0       	rjmp	.+378    	; 0x59f4 <xTaskResumeAll+0x1a0>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    587a:	80 91 cd 07 	lds	r24, 0x07CD
    587e:	88 23       	and	r24, r24
    5880:	09 f4       	brne	.+2      	; 0x5884 <xTaskResumeAll+0x30>
    5882:	b8 c0       	rjmp	.+368    	; 0x59f4 <xTaskResumeAll+0x1a0>
    5884:	c0 e0       	ldi	r28, 0x00	; 0
    5886:	d0 e0       	ldi	r29, 0x00	; 0
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    5888:	0d e0       	ldi	r16, 0x0D	; 13
    588a:	18 e0       	ldi	r17, 0x08	; 8
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
    588c:	63 ed       	ldi	r22, 0xD3	; 211
    588e:	77 e0       	ldi	r23, 0x07	; 7
    5890:	0f 2e       	mov	r0, r31
    5892:	f9 e0       	ldi	r31, 0x09	; 9
    5894:	ff 2e       	mov	r15, r31
    5896:	f0 2d       	mov	r31, r0

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
                    {
                        xYieldPending = pdTRUE;
    5898:	ee 24       	eor	r14, r14
    589a:	e3 94       	inc	r14
    589c:	87 c0       	rjmp	.+270    	; 0x59ac <xTaskResumeAll+0x158>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    589e:	e0 91 12 08 	lds	r30, 0x0812
    58a2:	f0 91 13 08 	lds	r31, 0x0813
    58a6:	c6 81       	ldd	r28, Z+6	; 0x06
    58a8:	d7 81       	ldd	r29, Z+7	; 0x07
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    58aa:	4c 89       	ldd	r20, Y+20	; 0x14
    58ac:	5d 89       	ldd	r21, Y+21	; 0x15
    58ae:	ae 85       	ldd	r26, Y+14	; 0x0e
    58b0:	bf 85       	ldd	r27, Y+15	; 0x0f
    58b2:	88 89       	ldd	r24, Y+16	; 0x10
    58b4:	99 89       	ldd	r25, Y+17	; 0x11
    58b6:	15 96       	adiw	r26, 0x05	; 5
    58b8:	9c 93       	st	X, r25
    58ba:	8e 93       	st	-X, r24
    58bc:	14 97       	sbiw	r26, 0x04	; 4
    58be:	e8 89       	ldd	r30, Y+16	; 0x10
    58c0:	f9 89       	ldd	r31, Y+17	; 0x11
    58c2:	b3 83       	std	Z+3, r27	; 0x03
    58c4:	a2 83       	std	Z+2, r26	; 0x02
    58c6:	9e 01       	movw	r18, r28
    58c8:	24 5f       	subi	r18, 0xF4	; 244
    58ca:	3f 4f       	sbci	r19, 0xFF	; 255
    58cc:	fa 01       	movw	r30, r20
    58ce:	81 81       	ldd	r24, Z+1	; 0x01
    58d0:	92 81       	ldd	r25, Z+2	; 0x02
    58d2:	82 17       	cp	r24, r18
    58d4:	93 07       	cpc	r25, r19
    58d6:	21 f4       	brne	.+8      	; 0x58e0 <xTaskResumeAll+0x8c>
    58d8:	88 89       	ldd	r24, Y+16	; 0x10
    58da:	99 89       	ldd	r25, Y+17	; 0x11
    58dc:	92 83       	std	Z+2, r25	; 0x02
    58de:	81 83       	std	Z+1, r24	; 0x01
    58e0:	1d 8a       	std	Y+21, r1	; 0x15
    58e2:	1c 8a       	std	Y+20, r1	; 0x14
    58e4:	fa 01       	movw	r30, r20
    58e6:	80 81       	ld	r24, Z
    58e8:	81 50       	subi	r24, 0x01	; 1
    58ea:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    58ec:	2a 85       	ldd	r18, Y+10	; 0x0a
    58ee:	3b 85       	ldd	r19, Y+11	; 0x0b
    58f0:	ac 81       	ldd	r26, Y+4	; 0x04
    58f2:	bd 81       	ldd	r27, Y+5	; 0x05
    58f4:	8e 81       	ldd	r24, Y+6	; 0x06
    58f6:	9f 81       	ldd	r25, Y+7	; 0x07
    58f8:	15 96       	adiw	r26, 0x05	; 5
    58fa:	9c 93       	st	X, r25
    58fc:	8e 93       	st	-X, r24
    58fe:	14 97       	sbiw	r26, 0x04	; 4
    5900:	ee 81       	ldd	r30, Y+6	; 0x06
    5902:	ff 81       	ldd	r31, Y+7	; 0x07
    5904:	b3 83       	std	Z+3, r27	; 0x03
    5906:	a2 83       	std	Z+2, r26	; 0x02
    5908:	ae 01       	movw	r20, r28
    590a:	4e 5f       	subi	r20, 0xFE	; 254
    590c:	5f 4f       	sbci	r21, 0xFF	; 255
    590e:	f9 01       	movw	r30, r18
    5910:	81 81       	ldd	r24, Z+1	; 0x01
    5912:	92 81       	ldd	r25, Z+2	; 0x02
    5914:	84 17       	cp	r24, r20
    5916:	95 07       	cpc	r25, r21
    5918:	21 f4       	brne	.+8      	; 0x5922 <xTaskResumeAll+0xce>
    591a:	8e 81       	ldd	r24, Y+6	; 0x06
    591c:	9f 81       	ldd	r25, Y+7	; 0x07
    591e:	92 83       	std	Z+2, r25	; 0x02
    5920:	81 83       	std	Z+1, r24	; 0x01
    5922:	1b 86       	std	Y+11, r1	; 0x0b
    5924:	1a 86       	std	Y+10, r1	; 0x0a
    5926:	f9 01       	movw	r30, r18
    5928:	80 81       	ld	r24, Z
    592a:	81 50       	subi	r24, 0x01	; 1
    592c:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    592e:	9e 89       	ldd	r25, Y+22	; 0x16
    5930:	80 91 c4 07 	lds	r24, 0x07C4
    5934:	89 17       	cp	r24, r25
    5936:	10 f4       	brcc	.+4      	; 0x593c <xTaskResumeAll+0xe8>
    5938:	90 93 c4 07 	sts	0x07C4, r25
    593c:	2e 89       	ldd	r18, Y+22	; 0x16
    593e:	30 e0       	ldi	r19, 0x00	; 0
    5940:	c9 01       	movw	r24, r18
    5942:	88 0f       	add	r24, r24
    5944:	99 1f       	adc	r25, r25
    5946:	88 0f       	add	r24, r24
    5948:	99 1f       	adc	r25, r25
    594a:	88 0f       	add	r24, r24
    594c:	99 1f       	adc	r25, r25
    594e:	82 0f       	add	r24, r18
    5950:	93 1f       	adc	r25, r19
    5952:	fb 01       	movw	r30, r22
    5954:	e8 0f       	add	r30, r24
    5956:	f9 1f       	adc	r31, r25
    5958:	a1 81       	ldd	r26, Z+1	; 0x01
    595a:	b2 81       	ldd	r27, Z+2	; 0x02
    595c:	bd 83       	std	Y+5, r27	; 0x05
    595e:	ac 83       	std	Y+4, r26	; 0x04
    5960:	14 96       	adiw	r26, 0x04	; 4
    5962:	8d 91       	ld	r24, X+
    5964:	9c 91       	ld	r25, X
    5966:	15 97       	sbiw	r26, 0x05	; 5
    5968:	9f 83       	std	Y+7, r25	; 0x07
    596a:	8e 83       	std	Y+6, r24	; 0x06
    596c:	14 96       	adiw	r26, 0x04	; 4
    596e:	ed 91       	ld	r30, X+
    5970:	fc 91       	ld	r31, X
    5972:	15 97       	sbiw	r26, 0x05	; 5
    5974:	53 83       	std	Z+3, r21	; 0x03
    5976:	42 83       	std	Z+2, r20	; 0x02
    5978:	15 96       	adiw	r26, 0x05	; 5
    597a:	5c 93       	st	X, r21
    597c:	4e 93       	st	-X, r20
    597e:	14 97       	sbiw	r26, 0x04	; 4
    5980:	8e 89       	ldd	r24, Y+22	; 0x16
    5982:	8f 9d       	mul	r24, r15
    5984:	c0 01       	movw	r24, r0
    5986:	11 24       	eor	r1, r1
    5988:	fb 01       	movw	r30, r22
    598a:	e8 0f       	add	r30, r24
    598c:	f9 1f       	adc	r31, r25
    598e:	fb 87       	std	Y+11, r31	; 0x0b
    5990:	ea 87       	std	Y+10, r30	; 0x0a
    5992:	80 81       	ld	r24, Z
    5994:	8f 5f       	subi	r24, 0xFF	; 255
    5996:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    5998:	e0 91 c1 07 	lds	r30, 0x07C1
    599c:	f0 91 c2 07 	lds	r31, 0x07C2
    59a0:	9e 89       	ldd	r25, Y+22	; 0x16
    59a2:	86 89       	ldd	r24, Z+22	; 0x16
    59a4:	98 17       	cp	r25, r24
    59a6:	10 f0       	brcs	.+4      	; 0x59ac <xTaskResumeAll+0x158>
                    {
                        xYieldPending = pdTRUE;
    59a8:	e0 92 c5 07 	sts	0x07C5, r14
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    59ac:	f8 01       	movw	r30, r16
    59ae:	80 81       	ld	r24, Z
    59b0:	88 23       	and	r24, r24
    59b2:	09 f0       	breq	.+2      	; 0x59b6 <xTaskResumeAll+0x162>
    59b4:	74 cf       	rjmp	.-280    	; 0x589e <xTaskResumeAll+0x4a>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    59b6:	cd 2b       	or	r28, r29
    59b8:	11 f0       	breq	.+4      	; 0x59be <xTaskResumeAll+0x16a>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    59ba:	0e 94 94 27 	call	0x4f28	; 0x4f28 <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    59be:	c0 91 cb 07 	lds	r28, 0x07CB
    59c2:	d0 91 cc 07 	lds	r29, 0x07CC

                    if( xPendedCounts > ( TickType_t ) 0U )
    59c6:	20 97       	sbiw	r28, 0x00	; 0
    59c8:	69 f0       	breq	.+26     	; 0x59e4 <xTaskResumeAll+0x190>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
    59ca:	11 e0       	ldi	r17, 0x01	; 1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    59cc:	0e 94 b0 27 	call	0x4f60	; 0x4f60 <xTaskIncrementTick>
    59d0:	88 23       	and	r24, r24
    59d2:	11 f0       	breq	.+4      	; 0x59d8 <xTaskResumeAll+0x184>
                            {
                                xYieldPending = pdTRUE;
    59d4:	10 93 c5 07 	sts	0x07C5, r17
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    59d8:	21 97       	sbiw	r28, 0x01	; 1
                        } while( xPendedCounts > ( TickType_t ) 0U );
    59da:	c1 f7       	brne	.-16     	; 0x59cc <xTaskResumeAll+0x178>

                        xPendedTicks = 0;
    59dc:	10 92 cc 07 	sts	0x07CC, r1
    59e0:	10 92 cb 07 	sts	0x07CB, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    59e4:	80 91 c5 07 	lds	r24, 0x07C5
    59e8:	88 23       	and	r24, r24
    59ea:	21 f0       	breq	.+8      	; 0x59f4 <xTaskResumeAll+0x1a0>
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    59ec:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
    59f0:	81 e0       	ldi	r24, 0x01	; 1
    59f2:	01 c0       	rjmp	.+2      	; 0x59f6 <xTaskResumeAll+0x1a2>
    59f4:	80 e0       	ldi	r24, 0x00	; 0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    59f6:	0f 90       	pop	r0
    59f8:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
}
    59fa:	df 91       	pop	r29
    59fc:	cf 91       	pop	r28
    59fe:	1f 91       	pop	r17
    5a00:	0f 91       	pop	r16
    5a02:	ff 90       	pop	r15
    5a04:	ef 90       	pop	r14
    5a06:	08 95       	ret

00005a08 <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    5a08:	0f 93       	push	r16
    5a0a:	1f 93       	push	r17
    5a0c:	8c 01       	movw	r16, r24
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    5a0e:	0e 94 81 25 	call	0x4b02	; 0x4b02 <vTaskSuspendAll>

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
    5a12:	0f b6       	in	r0, 0x3f	; 63
    5a14:	f8 94       	cli
    5a16:	0f 92       	push	r0
    {
        xPendedTicks += xTicksToCatchUp;
    5a18:	80 91 cb 07 	lds	r24, 0x07CB
    5a1c:	90 91 cc 07 	lds	r25, 0x07CC
    5a20:	08 0f       	add	r16, r24
    5a22:	19 1f       	adc	r17, r25
    5a24:	10 93 cc 07 	sts	0x07CC, r17
    5a28:	00 93 cb 07 	sts	0x07CB, r16
    }
    taskEXIT_CRITICAL();
    5a2c:	0f 90       	pop	r0
    5a2e:	0f be       	out	0x3f, r0	; 63
    xYieldOccurred = xTaskResumeAll();
    5a30:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>

    return xYieldOccurred;
}
    5a34:	1f 91       	pop	r17
    5a36:	0f 91       	pop	r16
    5a38:	08 95       	ret

00005a3a <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    5a3a:	ef 92       	push	r14
    5a3c:	ff 92       	push	r15
    5a3e:	0f 93       	push	r16
    5a40:	1f 93       	push	r17
    5a42:	7c 01       	movw	r14, r24
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    5a44:	00 91 c6 07 	lds	r16, 0x07C6
    5a48:	10 91 c7 07 	lds	r17, 0x07C7
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5a4c:	80 91 c1 07 	lds	r24, 0x07C1
    5a50:	90 91 c2 07 	lds	r25, 0x07C2
    5a54:	02 96       	adiw	r24, 0x02	; 2
    5a56:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
    {
        /* Calculate the time at which the task should be woken if the event
         * does not occur.  This may overflow but this doesn't matter, the kernel
         * will manage it correctly. */
        xTimeToWake = xConstTickCount + xTicksToWait;
    5a5a:	e0 0e       	add	r14, r16
    5a5c:	f1 1e       	adc	r15, r17

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    5a5e:	e0 91 c1 07 	lds	r30, 0x07C1
    5a62:	f0 91 c2 07 	lds	r31, 0x07C2
    5a66:	f3 82       	std	Z+3, r15	; 0x03
    5a68:	e2 82       	std	Z+2, r14	; 0x02

        if( xTimeToWake < xConstTickCount )
    5a6a:	e0 16       	cp	r14, r16
    5a6c:	f1 06       	cpc	r15, r17
    5a6e:	68 f4       	brcc	.+26     	; 0x5a8a <prvAddCurrentTaskToDelayedList+0x50>
        {
            /* Wake time has overflowed.  Place this item in the overflow list. */
            vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5a70:	80 91 0b 08 	lds	r24, 0x080B
    5a74:	90 91 0c 08 	lds	r25, 0x080C
    5a78:	60 91 c1 07 	lds	r22, 0x07C1
    5a7c:	70 91 c2 07 	lds	r23, 0x07C2
    5a80:	6e 5f       	subi	r22, 0xFE	; 254
    5a82:	7f 4f       	sbci	r23, 0xFF	; 255
    5a84:	0e 94 b2 1b 	call	0x3764	; 0x3764 <vListInsert>
    5a88:	17 c0       	rjmp	.+46     	; 0x5ab8 <prvAddCurrentTaskToDelayedList+0x7e>
        }
        else
        {
            /* The wake time has not overflowed, so the current block list is used. */
            vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5a8a:	80 91 09 08 	lds	r24, 0x0809
    5a8e:	90 91 0a 08 	lds	r25, 0x080A
    5a92:	60 91 c1 07 	lds	r22, 0x07C1
    5a96:	70 91 c2 07 	lds	r23, 0x07C2
    5a9a:	6e 5f       	subi	r22, 0xFE	; 254
    5a9c:	7f 4f       	sbci	r23, 0xFF	; 255
    5a9e:	0e 94 b2 1b 	call	0x3764	; 0x3764 <vListInsert>

            /* If the task entering the blocked state was placed at the head of the
             * list of blocked tasks then xNextTaskUnblockTime needs to be updated
             * too. */
            if( xTimeToWake < xNextTaskUnblockTime )
    5aa2:	80 91 c8 07 	lds	r24, 0x07C8
    5aa6:	90 91 c9 07 	lds	r25, 0x07C9
    5aaa:	e8 16       	cp	r14, r24
    5aac:	f9 06       	cpc	r15, r25
    5aae:	20 f4       	brcc	.+8      	; 0x5ab8 <prvAddCurrentTaskToDelayedList+0x7e>
            {
                xNextTaskUnblockTime = xTimeToWake;
    5ab0:	f0 92 c9 07 	sts	0x07C9, r15
    5ab4:	e0 92 c8 07 	sts	0x07C8, r14

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
    5ab8:	1f 91       	pop	r17
    5aba:	0f 91       	pop	r16
    5abc:	ff 90       	pop	r15
    5abe:	ef 90       	pop	r14
    5ac0:	08 95       	ret

00005ac2 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    5ac2:	4f 92       	push	r4
    5ac4:	5f 92       	push	r5
    5ac6:	6f 92       	push	r6
    5ac8:	7f 92       	push	r7
    5aca:	8f 92       	push	r8
    5acc:	9f 92       	push	r9
    5ace:	af 92       	push	r10
    5ad0:	bf 92       	push	r11
    5ad2:	cf 92       	push	r12
    5ad4:	df 92       	push	r13
    5ad6:	ef 92       	push	r14
    5ad8:	ff 92       	push	r15
    5ada:	0f 93       	push	r16
    5adc:	1f 93       	push	r17
    5ade:	cf 93       	push	r28
    5ae0:	df 93       	push	r29
    5ae2:	4a 01       	movw	r8, r20
    5ae4:	5b 01       	movw	r10, r22
    5ae6:	28 01       	movw	r4, r16
    5ae8:	39 01       	movw	r6, r18
    5aea:	e7 01       	movw	r28, r14
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    5aec:	0f b6       	in	r0, 0x3f	; 63
    5aee:	f8 94       	cli
    5af0:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5af2:	e0 91 c1 07 	lds	r30, 0x07C1
    5af6:	f0 91 c2 07 	lds	r31, 0x07C2
    5afa:	e8 2e       	mov	r14, r24
    5afc:	ff 24       	eor	r15, r15
    5afe:	ee 0d       	add	r30, r14
    5b00:	ff 1d       	adc	r31, r15
    5b02:	b5 96       	adiw	r30, 0x25	; 37
    5b04:	80 81       	ld	r24, Z
    5b06:	82 30       	cpi	r24, 0x02	; 2
    5b08:	81 f1       	breq	.+96     	; 0x5b6a <xTaskGenericNotifyWait+0xa8>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    5b0a:	e0 91 c1 07 	lds	r30, 0x07C1
    5b0e:	f0 91 c2 07 	lds	r31, 0x07C2
    5b12:	c7 01       	movw	r24, r14
    5b14:	88 0f       	add	r24, r24
    5b16:	99 1f       	adc	r25, r25
    5b18:	88 0f       	add	r24, r24
    5b1a:	99 1f       	adc	r25, r25
    5b1c:	e8 0f       	add	r30, r24
    5b1e:	f9 1f       	adc	r31, r25
    5b20:	b1 96       	adiw	r30, 0x21	; 33
    5b22:	20 81       	ld	r18, Z
    5b24:	31 81       	ldd	r19, Z+1	; 0x01
    5b26:	42 81       	ldd	r20, Z+2	; 0x02
    5b28:	53 81       	ldd	r21, Z+3	; 0x03
    5b2a:	d5 01       	movw	r26, r10
    5b2c:	c4 01       	movw	r24, r8
    5b2e:	80 95       	com	r24
    5b30:	90 95       	com	r25
    5b32:	a0 95       	com	r26
    5b34:	b0 95       	com	r27
    5b36:	82 23       	and	r24, r18
    5b38:	93 23       	and	r25, r19
    5b3a:	a4 23       	and	r26, r20
    5b3c:	b5 23       	and	r27, r21
    5b3e:	80 83       	st	Z, r24
    5b40:	91 83       	std	Z+1, r25	; 0x01
    5b42:	a2 83       	std	Z+2, r26	; 0x02
    5b44:	b3 83       	std	Z+3, r27	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    5b46:	e0 91 c1 07 	lds	r30, 0x07C1
    5b4a:	f0 91 c2 07 	lds	r31, 0x07C2
    5b4e:	ee 0d       	add	r30, r14
    5b50:	ff 1d       	adc	r31, r15
    5b52:	b5 96       	adiw	r30, 0x25	; 37
    5b54:	81 e0       	ldi	r24, 0x01	; 1
    5b56:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    5b58:	c1 14       	cp	r12, r1
    5b5a:	d1 04       	cpc	r13, r1
    5b5c:	31 f0       	breq	.+12     	; 0x5b6a <xTaskGenericNotifyWait+0xa8>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5b5e:	c6 01       	movw	r24, r12
    5b60:	61 e0       	ldi	r22, 0x01	; 1
    5b62:	0e 94 1d 2d 	call	0x5a3a	; 0x5a3a <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    5b66:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5b6a:	0f 90       	pop	r0
    5b6c:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    5b6e:	0f b6       	in	r0, 0x3f	; 63
    5b70:	f8 94       	cli
    5b72:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    5b74:	20 97       	sbiw	r28, 0x00	; 0
    5b76:	a1 f0       	breq	.+40     	; 0x5ba0 <xTaskGenericNotifyWait+0xde>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    5b78:	e0 91 c1 07 	lds	r30, 0x07C1
    5b7c:	f0 91 c2 07 	lds	r31, 0x07C2
    5b80:	c7 01       	movw	r24, r14
    5b82:	88 0f       	add	r24, r24
    5b84:	99 1f       	adc	r25, r25
    5b86:	88 0f       	add	r24, r24
    5b88:	99 1f       	adc	r25, r25
    5b8a:	e8 0f       	add	r30, r24
    5b8c:	f9 1f       	adc	r31, r25
    5b8e:	b1 96       	adiw	r30, 0x21	; 33
    5b90:	80 81       	ld	r24, Z
    5b92:	91 81       	ldd	r25, Z+1	; 0x01
    5b94:	a2 81       	ldd	r26, Z+2	; 0x02
    5b96:	b3 81       	ldd	r27, Z+3	; 0x03
    5b98:	88 83       	st	Y, r24
    5b9a:	99 83       	std	Y+1, r25	; 0x01
    5b9c:	aa 83       	std	Y+2, r26	; 0x02
    5b9e:	bb 83       	std	Y+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5ba0:	e0 91 c1 07 	lds	r30, 0x07C1
    5ba4:	f0 91 c2 07 	lds	r31, 0x07C2
    5ba8:	ee 0d       	add	r30, r14
    5baa:	ff 1d       	adc	r31, r15
    5bac:	b5 96       	adiw	r30, 0x25	; 37
    5bae:	80 81       	ld	r24, Z
    5bb0:	82 30       	cpi	r24, 0x02	; 2
    5bb2:	11 f0       	breq	.+4      	; 0x5bb8 <xTaskGenericNotifyWait+0xf6>
    5bb4:	80 e0       	ldi	r24, 0x00	; 0
    5bb6:	1f c0       	rjmp	.+62     	; 0x5bf6 <xTaskGenericNotifyWait+0x134>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    5bb8:	e0 91 c1 07 	lds	r30, 0x07C1
    5bbc:	f0 91 c2 07 	lds	r31, 0x07C2
    5bc0:	c7 01       	movw	r24, r14
    5bc2:	88 0f       	add	r24, r24
    5bc4:	99 1f       	adc	r25, r25
    5bc6:	88 0f       	add	r24, r24
    5bc8:	99 1f       	adc	r25, r25
    5bca:	e8 0f       	add	r30, r24
    5bcc:	f9 1f       	adc	r31, r25
    5bce:	b1 96       	adiw	r30, 0x21	; 33
    5bd0:	20 81       	ld	r18, Z
    5bd2:	31 81       	ldd	r19, Z+1	; 0x01
    5bd4:	42 81       	ldd	r20, Z+2	; 0x02
    5bd6:	53 81       	ldd	r21, Z+3	; 0x03
    5bd8:	d3 01       	movw	r26, r6
    5bda:	c2 01       	movw	r24, r4
    5bdc:	80 95       	com	r24
    5bde:	90 95       	com	r25
    5be0:	a0 95       	com	r26
    5be2:	b0 95       	com	r27
    5be4:	82 23       	and	r24, r18
    5be6:	93 23       	and	r25, r19
    5be8:	a4 23       	and	r26, r20
    5bea:	b5 23       	and	r27, r21
    5bec:	80 83       	st	Z, r24
    5bee:	91 83       	std	Z+1, r25	; 0x01
    5bf0:	a2 83       	std	Z+2, r26	; 0x02
    5bf2:	b3 83       	std	Z+3, r27	; 0x03
    5bf4:	81 e0       	ldi	r24, 0x01	; 1
                xReturn = pdTRUE;
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    5bf6:	e0 91 c1 07 	lds	r30, 0x07C1
    5bfa:	f0 91 c2 07 	lds	r31, 0x07C2
    5bfe:	ee 0d       	add	r30, r14
    5c00:	ff 1d       	adc	r31, r15
    5c02:	b5 96       	adiw	r30, 0x25	; 37
    5c04:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    5c06:	0f 90       	pop	r0
    5c08:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    5c0a:	df 91       	pop	r29
    5c0c:	cf 91       	pop	r28
    5c0e:	1f 91       	pop	r17
    5c10:	0f 91       	pop	r16
    5c12:	ff 90       	pop	r15
    5c14:	ef 90       	pop	r14
    5c16:	df 90       	pop	r13
    5c18:	cf 90       	pop	r12
    5c1a:	bf 90       	pop	r11
    5c1c:	af 90       	pop	r10
    5c1e:	9f 90       	pop	r9
    5c20:	8f 90       	pop	r8
    5c22:	7f 90       	pop	r7
    5c24:	6f 90       	pop	r6
    5c26:	5f 90       	pop	r5
    5c28:	4f 90       	pop	r4
    5c2a:	08 95       	ret

00005c2c <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    5c2c:	df 92       	push	r13
    5c2e:	ef 92       	push	r14
    5c30:	ff 92       	push	r15
    5c32:	0f 93       	push	r16
    5c34:	1f 93       	push	r17
    5c36:	cf 93       	push	r28
    5c38:	df 93       	push	r29
    5c3a:	d6 2e       	mov	r13, r22
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    5c3c:	0f b6       	in	r0, 0x3f	; 63
    5c3e:	f8 94       	cli
    5c40:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    5c42:	e0 91 c1 07 	lds	r30, 0x07C1
    5c46:	f0 91 c2 07 	lds	r31, 0x07C2
    5c4a:	c8 2f       	mov	r28, r24
    5c4c:	d0 e0       	ldi	r29, 0x00	; 0
    5c4e:	ce 01       	movw	r24, r28
    5c50:	88 0f       	add	r24, r24
    5c52:	99 1f       	adc	r25, r25
    5c54:	88 0f       	add	r24, r24
    5c56:	99 1f       	adc	r25, r25
    5c58:	e8 0f       	add	r30, r24
    5c5a:	f9 1f       	adc	r31, r25
    5c5c:	b1 96       	adiw	r30, 0x21	; 33
    5c5e:	80 81       	ld	r24, Z
    5c60:	91 81       	ldd	r25, Z+1	; 0x01
    5c62:	a2 81       	ldd	r26, Z+2	; 0x02
    5c64:	b3 81       	ldd	r27, Z+3	; 0x03
    5c66:	00 97       	sbiw	r24, 0x00	; 0
    5c68:	a1 05       	cpc	r26, r1
    5c6a:	b1 05       	cpc	r27, r1
    5c6c:	91 f4       	brne	.+36     	; 0x5c92 <ulTaskGenericNotifyTake+0x66>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    5c6e:	e0 91 c1 07 	lds	r30, 0x07C1
    5c72:	f0 91 c2 07 	lds	r31, 0x07C2
    5c76:	ec 0f       	add	r30, r28
    5c78:	fd 1f       	adc	r31, r29
    5c7a:	b5 96       	adiw	r30, 0x25	; 37
    5c7c:	81 e0       	ldi	r24, 0x01	; 1
    5c7e:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    5c80:	41 15       	cp	r20, r1
    5c82:	51 05       	cpc	r21, r1
    5c84:	31 f0       	breq	.+12     	; 0x5c92 <ulTaskGenericNotifyTake+0x66>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5c86:	ca 01       	movw	r24, r20
    5c88:	61 e0       	ldi	r22, 0x01	; 1
    5c8a:	0e 94 1d 2d 	call	0x5a3a	; 0x5a3a <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    5c8e:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5c92:	0f 90       	pop	r0
    5c94:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    5c96:	0f b6       	in	r0, 0x3f	; 63
    5c98:	f8 94       	cli
    5c9a:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    5c9c:	e0 91 c1 07 	lds	r30, 0x07C1
    5ca0:	f0 91 c2 07 	lds	r31, 0x07C2
    5ca4:	ce 01       	movw	r24, r28
    5ca6:	88 0f       	add	r24, r24
    5ca8:	99 1f       	adc	r25, r25
    5caa:	88 0f       	add	r24, r24
    5cac:	99 1f       	adc	r25, r25
    5cae:	e8 0f       	add	r30, r24
    5cb0:	f9 1f       	adc	r31, r25
    5cb2:	b1 96       	adiw	r30, 0x21	; 33
    5cb4:	e0 80       	ld	r14, Z
    5cb6:	f1 80       	ldd	r15, Z+1	; 0x01
    5cb8:	02 81       	ldd	r16, Z+2	; 0x02
    5cba:	13 81       	ldd	r17, Z+3	; 0x03

            if( ulReturn != 0UL )
    5cbc:	e1 14       	cp	r14, r1
    5cbe:	f1 04       	cpc	r15, r1
    5cc0:	01 05       	cpc	r16, r1
    5cc2:	11 05       	cpc	r17, r1
    5cc4:	49 f1       	breq	.+82     	; 0x5d18 <ulTaskGenericNotifyTake+0xec>
            {
                if( xClearCountOnExit != pdFALSE )
    5cc6:	dd 20       	and	r13, r13
    5cc8:	89 f0       	breq	.+34     	; 0x5cec <ulTaskGenericNotifyTake+0xc0>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    5cca:	e0 91 c1 07 	lds	r30, 0x07C1
    5cce:	f0 91 c2 07 	lds	r31, 0x07C2
    5cd2:	ce 01       	movw	r24, r28
    5cd4:	88 0f       	add	r24, r24
    5cd6:	99 1f       	adc	r25, r25
    5cd8:	88 0f       	add	r24, r24
    5cda:	99 1f       	adc	r25, r25
    5cdc:	e8 0f       	add	r30, r24
    5cde:	f9 1f       	adc	r31, r25
    5ce0:	b1 96       	adiw	r30, 0x21	; 33
    5ce2:	10 82       	st	Z, r1
    5ce4:	11 82       	std	Z+1, r1	; 0x01
    5ce6:	12 82       	std	Z+2, r1	; 0x02
    5ce8:	13 82       	std	Z+3, r1	; 0x03
    5cea:	16 c0       	rjmp	.+44     	; 0x5d18 <ulTaskGenericNotifyTake+0xec>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    5cec:	e0 91 c1 07 	lds	r30, 0x07C1
    5cf0:	f0 91 c2 07 	lds	r31, 0x07C2
    5cf4:	a8 01       	movw	r20, r16
    5cf6:	97 01       	movw	r18, r14
    5cf8:	21 50       	subi	r18, 0x01	; 1
    5cfa:	30 40       	sbci	r19, 0x00	; 0
    5cfc:	40 40       	sbci	r20, 0x00	; 0
    5cfe:	50 40       	sbci	r21, 0x00	; 0
    5d00:	ce 01       	movw	r24, r28
    5d02:	88 0f       	add	r24, r24
    5d04:	99 1f       	adc	r25, r25
    5d06:	88 0f       	add	r24, r24
    5d08:	99 1f       	adc	r25, r25
    5d0a:	e8 0f       	add	r30, r24
    5d0c:	f9 1f       	adc	r31, r25
    5d0e:	b1 96       	adiw	r30, 0x21	; 33
    5d10:	20 83       	st	Z, r18
    5d12:	31 83       	std	Z+1, r19	; 0x01
    5d14:	42 83       	std	Z+2, r20	; 0x02
    5d16:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    5d18:	e0 91 c1 07 	lds	r30, 0x07C1
    5d1c:	f0 91 c2 07 	lds	r31, 0x07C2
    5d20:	ec 0f       	add	r30, r28
    5d22:	fd 1f       	adc	r31, r29
    5d24:	b5 96       	adiw	r30, 0x25	; 37
    5d26:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    5d28:	0f 90       	pop	r0
    5d2a:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    5d2c:	6e 2d       	mov	r22, r14
    5d2e:	7f 2d       	mov	r23, r15
    5d30:	80 2f       	mov	r24, r16
    5d32:	91 2f       	mov	r25, r17
    5d34:	df 91       	pop	r29
    5d36:	cf 91       	pop	r28
    5d38:	1f 91       	pop	r17
    5d3a:	0f 91       	pop	r16
    5d3c:	ff 90       	pop	r15
    5d3e:	ef 90       	pop	r14
    5d40:	df 90       	pop	r13
    5d42:	08 95       	ret

00005d44 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    5d44:	0f 93       	push	r16
    5d46:	1f 93       	push	r17
    5d48:	8c 01       	movw	r16, r24
    5d4a:	ca 01       	movw	r24, r20
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5d4c:	e0 91 c1 07 	lds	r30, 0x07C1
    5d50:	f0 91 c2 07 	lds	r31, 0x07C2
    5d54:	70 68       	ori	r23, 0x80	; 128
    5d56:	75 87       	std	Z+13, r23	; 0x0d
    5d58:	64 87       	std	Z+12, r22	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5d5a:	f8 01       	movw	r30, r16
    5d5c:	a1 81       	ldd	r26, Z+1	; 0x01
    5d5e:	b2 81       	ldd	r27, Z+2	; 0x02
    5d60:	e0 91 c1 07 	lds	r30, 0x07C1
    5d64:	f0 91 c2 07 	lds	r31, 0x07C2
    5d68:	b7 87       	std	Z+15, r27	; 0x0f
    5d6a:	a6 87       	std	Z+14, r26	; 0x0e
    5d6c:	e0 91 c1 07 	lds	r30, 0x07C1
    5d70:	f0 91 c2 07 	lds	r31, 0x07C2
    5d74:	14 96       	adiw	r26, 0x04	; 4
    5d76:	2d 91       	ld	r18, X+
    5d78:	3c 91       	ld	r19, X
    5d7a:	15 97       	sbiw	r26, 0x05	; 5
    5d7c:	31 8b       	std	Z+17, r19	; 0x11
    5d7e:	20 8b       	std	Z+16, r18	; 0x10
    5d80:	20 91 c1 07 	lds	r18, 0x07C1
    5d84:	30 91 c2 07 	lds	r19, 0x07C2
    5d88:	14 96       	adiw	r26, 0x04	; 4
    5d8a:	ed 91       	ld	r30, X+
    5d8c:	fc 91       	ld	r31, X
    5d8e:	15 97       	sbiw	r26, 0x05	; 5
    5d90:	24 5f       	subi	r18, 0xF4	; 244
    5d92:	3f 4f       	sbci	r19, 0xFF	; 255
    5d94:	33 83       	std	Z+3, r19	; 0x03
    5d96:	22 83       	std	Z+2, r18	; 0x02
    5d98:	20 91 c1 07 	lds	r18, 0x07C1
    5d9c:	30 91 c2 07 	lds	r19, 0x07C2
    5da0:	24 5f       	subi	r18, 0xF4	; 244
    5da2:	3f 4f       	sbci	r19, 0xFF	; 255
    5da4:	15 96       	adiw	r26, 0x05	; 5
    5da6:	3c 93       	st	X, r19
    5da8:	2e 93       	st	-X, r18
    5daa:	14 97       	sbiw	r26, 0x04	; 4
    5dac:	e0 91 c1 07 	lds	r30, 0x07C1
    5db0:	f0 91 c2 07 	lds	r31, 0x07C2
    5db4:	15 8b       	std	Z+21, r17	; 0x15
    5db6:	04 8b       	std	Z+20, r16	; 0x14
    5db8:	f8 01       	movw	r30, r16
    5dba:	20 81       	ld	r18, Z
    5dbc:	2f 5f       	subi	r18, 0xFF	; 255
    5dbe:	20 83       	st	Z, r18

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5dc0:	61 e0       	ldi	r22, 0x01	; 1
    5dc2:	0e 94 1d 2d 	call	0x5a3a	; 0x5a3a <prvAddCurrentTaskToDelayedList>
}
    5dc6:	1f 91       	pop	r17
    5dc8:	0f 91       	pop	r16
    5dca:	08 95       	ret

00005dcc <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    5dcc:	cf 93       	push	r28
    5dce:	df 93       	push	r29
    5dd0:	ec 01       	movw	r28, r24
        BaseType_t xAlreadyYielded = pdFALSE;

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    5dd2:	00 97       	sbiw	r24, 0x00	; 0
    5dd4:	51 f0       	breq	.+20     	; 0x5dea <vTaskDelay+0x1e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    5dd6:	0e 94 81 25 	call	0x4b02	; 0x4b02 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    5dda:	ce 01       	movw	r24, r28
    5ddc:	60 e0       	ldi	r22, 0x00	; 0
    5dde:	0e 94 1d 2d 	call	0x5a3a	; 0x5a3a <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    5de2:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    5de6:	88 23       	and	r24, r24
    5de8:	11 f4       	brne	.+4      	; 0x5dee <vTaskDelay+0x22>
        {
            portYIELD_WITHIN_API();
    5dea:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    5dee:	df 91       	pop	r29
    5df0:	cf 91       	pop	r28
    5df2:	08 95       	ret

00005df4 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    5df4:	0f 93       	push	r16
    5df6:	1f 93       	push	r17
    5df8:	cf 93       	push	r28
    5dfa:	df 93       	push	r29
    5dfc:	ec 01       	movw	r28, r24
    5dfe:	8b 01       	movw	r16, r22

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    5e00:	0e 94 81 25 	call	0x4b02	; 0x4b02 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    5e04:	40 91 c6 07 	lds	r20, 0x07C6
    5e08:	50 91 c7 07 	lds	r21, 0x07C7

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    5e0c:	28 81       	ld	r18, Y
    5e0e:	39 81       	ldd	r19, Y+1	; 0x01
    5e10:	c8 01       	movw	r24, r16
    5e12:	82 0f       	add	r24, r18
    5e14:	93 1f       	adc	r25, r19

            if( xConstTickCount < *pxPreviousWakeTime )
    5e16:	42 17       	cp	r20, r18
    5e18:	53 07       	cpc	r21, r19
    5e1a:	38 f4       	brcc	.+14     	; 0x5e2a <xTaskDelayUntil+0x36>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    5e1c:	82 17       	cp	r24, r18
    5e1e:	93 07       	cpc	r25, r19
    5e20:	50 f4       	brcc	.+20     	; 0x5e36 <xTaskDelayUntil+0x42>
    5e22:	48 17       	cp	r20, r24
    5e24:	59 07       	cpc	r21, r25
    5e26:	b0 f0       	brcs	.+44     	; 0x5e54 <xTaskDelayUntil+0x60>
    5e28:	06 c0       	rjmp	.+12     	; 0x5e36 <xTaskDelayUntil+0x42>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    5e2a:	82 17       	cp	r24, r18
    5e2c:	93 07       	cpc	r25, r19
    5e2e:	90 f0       	brcs	.+36     	; 0x5e54 <xTaskDelayUntil+0x60>
    5e30:	48 17       	cp	r20, r24
    5e32:	59 07       	cpc	r21, r25
    5e34:	78 f0       	brcs	.+30     	; 0x5e54 <xTaskDelayUntil+0x60>
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    5e36:	99 83       	std	Y+1, r25	; 0x01
    5e38:	88 83       	st	Y, r24
    5e3a:	00 e0       	ldi	r16, 0x00	; 0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    5e3c:	0e 94 2a 2c 	call	0x5854	; 0x5854 <xTaskResumeAll>

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    5e40:	88 23       	and	r24, r24
    5e42:	11 f4       	brne	.+4      	; 0x5e48 <xTaskDelayUntil+0x54>
        {
            portYIELD_WITHIN_API();
    5e44:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    }
    5e48:	80 2f       	mov	r24, r16
    5e4a:	df 91       	pop	r29
    5e4c:	cf 91       	pop	r28
    5e4e:	1f 91       	pop	r17
    5e50:	0f 91       	pop	r16
    5e52:	08 95       	ret
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    5e54:	99 83       	std	Y+1, r25	; 0x01
    5e56:	88 83       	st	Y, r24
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    5e58:	84 1b       	sub	r24, r20
    5e5a:	95 0b       	sbc	r25, r21
    5e5c:	60 e0       	ldi	r22, 0x00	; 0
    5e5e:	0e 94 1d 2d 	call	0x5a3a	; 0x5a3a <prvAddCurrentTaskToDelayedList>
    5e62:	01 e0       	ldi	r16, 0x01	; 1
    5e64:	eb cf       	rjmp	.-42     	; 0x5e3c <xTaskDelayUntil+0x48>

00005e66 <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    5e66:	0f 93       	push	r16
    5e68:	1f 93       	push	r17
    5e6a:	8b 01       	movw	r16, r22
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5e6c:	60 91 c1 07 	lds	r22, 0x07C1
    5e70:	70 91 c2 07 	lds	r23, 0x07C2
    5e74:	64 5f       	subi	r22, 0xF4	; 244
    5e76:	7f 4f       	sbci	r23, 0xFF	; 255
    5e78:	0e 94 b2 1b 	call	0x3764	; 0x3764 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5e7c:	c8 01       	movw	r24, r16
    5e7e:	61 e0       	ldi	r22, 0x01	; 1
    5e80:	0e 94 1d 2d 	call	0x5a3a	; 0x5a3a <prvAddCurrentTaskToDelayedList>
}
    5e84:	1f 91       	pop	r17
    5e86:	0f 91       	pop	r16
    5e88:	08 95       	ret

00005e8a <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    5e8a:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    5e8c:	10 92 ce 07 	sts	0x07CE, r1
    vPortEndScheduler();
    5e90:	0e 94 fe 18 	call	0x31fc	; 0x31fc <vPortEndScheduler>
}
    5e94:	08 95       	ret

00005e96 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    5e96:	0f 93       	push	r16
    5e98:	1f 93       	push	r17
    5e9a:	8c 01       	movw	r16, r24

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
    5e9c:	fc 01       	movw	r30, r24
    5e9e:	87 89       	ldd	r24, Z+23	; 0x17
    5ea0:	90 8d       	ldd	r25, Z+24	; 0x18
    5ea2:	0e 94 6e 18 	call	0x30dc	; 0x30dc <vPortFree>
            vPortFree( pxTCB );
    5ea6:	c8 01       	movw	r24, r16
    5ea8:	0e 94 6e 18 	call	0x30dc	; 0x30dc <vPortFree>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    5eac:	1f 91       	pop	r17
    5eae:	0f 91       	pop	r16
    5eb0:	08 95       	ret

00005eb2 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5eb2:	0f 93       	push	r16
    5eb4:	1f 93       	push	r17
    5eb6:	cf 93       	push	r28
    5eb8:	df 93       	push	r29
             *
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains more than one task
             * then a task other than the idle task is ready to execute. */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    5eba:	c3 ed       	ldi	r28, 0xD3	; 211
    5ebc:	d7 e0       	ldi	r29, 0x07	; 7
    5ebe:	1c c0       	rjmp	.+56     	; 0x5ef8 <prvIdleTask+0x46>

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
        {
            taskENTER_CRITICAL();
    5ec0:	0f b6       	in	r0, 0x3f	; 63
    5ec2:	f8 94       	cli
    5ec4:	0f 92       	push	r0
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5ec6:	e0 91 1b 08 	lds	r30, 0x081B
    5eca:	f0 91 1c 08 	lds	r31, 0x081C
    5ece:	06 81       	ldd	r16, Z+6	; 0x06
    5ed0:	17 81       	ldd	r17, Z+7	; 0x07
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5ed2:	c8 01       	movw	r24, r16
    5ed4:	02 96       	adiw	r24, 0x02	; 2
    5ed6:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <uxListRemove>
                --uxCurrentNumberOfTasks;
    5eda:	80 91 cd 07 	lds	r24, 0x07CD
    5ede:	81 50       	subi	r24, 0x01	; 1
    5ee0:	80 93 cd 07 	sts	0x07CD, r24
                --uxDeletedTasksWaitingCleanUp;
    5ee4:	80 91 d1 07 	lds	r24, 0x07D1
    5ee8:	81 50       	subi	r24, 0x01	; 1
    5eea:	80 93 d1 07 	sts	0x07D1, r24
            }
            taskEXIT_CRITICAL();
    5eee:	0f 90       	pop	r0
    5ef0:	0f be       	out	0x3f, r0	; 63

            prvDeleteTCB( pxTCB );
    5ef2:	c8 01       	movw	r24, r16
    5ef4:	0e 94 4b 2f 	call	0x5e96	; 0x5e96 <prvDeleteTCB>
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    5ef8:	80 91 d1 07 	lds	r24, 0x07D1
    5efc:	88 23       	and	r24, r24
    5efe:	01 f7       	brne	.-64     	; 0x5ec0 <prvIdleTask+0xe>
             *
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains more than one task
             * then a task other than the idle task is ready to execute. */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    5f00:	88 81       	ld	r24, Y
    5f02:	82 30       	cpi	r24, 0x02	; 2
    5f04:	c8 f3       	brcs	.-14     	; 0x5ef8 <prvIdleTask+0x46>
            {
                taskYIELD();
    5f06:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
    5f0a:	f6 cf       	rjmp	.-20     	; 0x5ef8 <prvIdleTask+0x46>

00005f0c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    5f0c:	0f 93       	push	r16
    5f0e:	1f 93       	push	r17
    5f10:	cf 93       	push	r28
    5f12:	df 93       	push	r29
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    5f14:	0f b6       	in	r0, 0x3f	; 63
    5f16:	f8 94       	cli
    5f18:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    5f1a:	00 97       	sbiw	r24, 0x00	; 0
    5f1c:	11 f0       	breq	.+4      	; 0x5f22 <vTaskDelete+0x16>
    5f1e:	ec 01       	movw	r28, r24
    5f20:	04 c0       	rjmp	.+8      	; 0x5f2a <vTaskDelete+0x1e>
    5f22:	c0 91 c1 07 	lds	r28, 0x07C1
    5f26:	d0 91 c2 07 	lds	r29, 0x07C2

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5f2a:	8e 01       	movw	r16, r28
    5f2c:	0e 5f       	subi	r16, 0xFE	; 254
    5f2e:	1f 4f       	sbci	r17, 0xFF	; 255
    5f30:	c8 01       	movw	r24, r16
    5f32:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5f36:	8c 89       	ldd	r24, Y+20	; 0x14
    5f38:	9d 89       	ldd	r25, Y+21	; 0x15
    5f3a:	89 2b       	or	r24, r25
    5f3c:	21 f0       	breq	.+8      	; 0x5f46 <vTaskDelete+0x3a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5f3e:	ce 01       	movw	r24, r28
    5f40:	0c 96       	adiw	r24, 0x0c	; 12
    5f42:	0e 94 e4 1b 	call	0x37c8	; 0x37c8 <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    5f46:	80 91 d2 07 	lds	r24, 0x07D2
    5f4a:	8f 5f       	subi	r24, 0xFF	; 255
    5f4c:	80 93 d2 07 	sts	0x07D2, r24

            if( pxTCB == pxCurrentTCB )
    5f50:	80 91 c1 07 	lds	r24, 0x07C1
    5f54:	90 91 c2 07 	lds	r25, 0x07C2
    5f58:	c8 17       	cp	r28, r24
    5f5a:	d9 07       	cpc	r29, r25
    5f5c:	59 f4       	brne	.+22     	; 0x5f74 <vTaskDelete+0x68>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    5f5e:	86 e1       	ldi	r24, 0x16	; 22
    5f60:	98 e0       	ldi	r25, 0x08	; 8
    5f62:	b8 01       	movw	r22, r16
    5f64:	0e 94 93 1b 	call	0x3726	; 0x3726 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    5f68:	80 91 d1 07 	lds	r24, 0x07D1
    5f6c:	8f 5f       	subi	r24, 0xFF	; 255
    5f6e:	80 93 d1 07 	sts	0x07D1, r24
    5f72:	07 c0       	rjmp	.+14     	; 0x5f82 <vTaskDelete+0x76>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    5f74:	80 91 cd 07 	lds	r24, 0x07CD
    5f78:	81 50       	subi	r24, 0x01	; 1
    5f7a:	80 93 cd 07 	sts	0x07CD, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    5f7e:	0e 94 94 27 	call	0x4f28	; 0x4f28 <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    5f82:	0f 90       	pop	r0
    5f84:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    5f86:	80 91 c1 07 	lds	r24, 0x07C1
    5f8a:	90 91 c2 07 	lds	r25, 0x07C2
    5f8e:	c8 17       	cp	r28, r24
    5f90:	d9 07       	cpc	r29, r25
    5f92:	19 f0       	breq	.+6      	; 0x5f9a <vTaskDelete+0x8e>
        {
            prvDeleteTCB( pxTCB );
    5f94:	ce 01       	movw	r24, r28
    5f96:	0e 94 4b 2f 	call	0x5e96	; 0x5e96 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    5f9a:	80 91 ce 07 	lds	r24, 0x07CE
    5f9e:	88 23       	and	r24, r24
    5fa0:	49 f0       	breq	.+18     	; 0x5fb4 <vTaskDelete+0xa8>
        {
            if( pxTCB == pxCurrentTCB )
    5fa2:	80 91 c1 07 	lds	r24, 0x07C1
    5fa6:	90 91 c2 07 	lds	r25, 0x07C2
    5faa:	c8 17       	cp	r28, r24
    5fac:	d9 07       	cpc	r29, r25
    5fae:	11 f4       	brne	.+4      	; 0x5fb4 <vTaskDelete+0xa8>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    5fb0:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    5fb4:	df 91       	pop	r29
    5fb6:	cf 91       	pop	r28
    5fb8:	1f 91       	pop	r17
    5fba:	0f 91       	pop	r16
    5fbc:	08 95       	ret

00005fbe <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    5fbe:	4f 92       	push	r4
    5fc0:	5f 92       	push	r5
    5fc2:	6f 92       	push	r6
    5fc4:	7f 92       	push	r7
    5fc6:	8f 92       	push	r8
    5fc8:	9f 92       	push	r9
    5fca:	af 92       	push	r10
    5fcc:	bf 92       	push	r11
    5fce:	cf 92       	push	r12
    5fd0:	df 92       	push	r13
    5fd2:	ef 92       	push	r14
    5fd4:	ff 92       	push	r15
    5fd6:	0f 93       	push	r16
    5fd8:	1f 93       	push	r17
    5fda:	cf 93       	push	r28
    5fdc:	df 93       	push	r29
    5fde:	2c 01       	movw	r4, r24
    5fe0:	6b 01       	movw	r12, r22
    5fe2:	5a 01       	movw	r10, r20
    5fe4:	39 01       	movw	r6, r18
    5fe6:	47 01       	movw	r8, r14
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    5fe8:	ca 01       	movw	r24, r20
    5fea:	0e 94 7f 18 	call	0x30fe	; 0x30fe <pvPortMalloc>
    5fee:	7c 01       	movw	r14, r24

            if( pxStack != NULL )
    5ff0:	e1 14       	cp	r14, r1
    5ff2:	f1 04       	cpc	r15, r1
    5ff4:	11 f4       	brne	.+4      	; 0x5ffa <xTaskCreate+0x3c>
    5ff6:	8f ef       	ldi	r24, 0xFF	; 255
    5ff8:	f9 c0       	rjmp	.+498    	; 0x61ec <xTaskCreate+0x22e>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    5ffa:	86 e2       	ldi	r24, 0x26	; 38
    5ffc:	90 e0       	ldi	r25, 0x00	; 0
    5ffe:	0e 94 7f 18 	call	0x30fe	; 0x30fe <pvPortMalloc>
    6002:	ec 01       	movw	r28, r24

                if( pxNewTCB != NULL )
    6004:	20 97       	sbiw	r28, 0x00	; 0
    6006:	59 f0       	breq	.+22     	; 0x601e <xTaskCreate+0x60>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
    6008:	86 e2       	ldi	r24, 0x26	; 38
    600a:	fe 01       	movw	r30, r28
    600c:	11 92       	st	Z+, r1
    600e:	8a 95       	dec	r24
    6010:	e9 f7       	brne	.-6      	; 0x600c <xTaskCreate+0x4e>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
    6012:	f8 8e       	std	Y+24, r15	; 0x18
    6014:	ef 8a       	std	Y+23, r14	; 0x17
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    6016:	c1 14       	cp	r12, r1
    6018:	d1 04       	cpc	r13, r1
    601a:	31 f4       	brne	.+12     	; 0x6028 <xTaskCreate+0x6a>
    601c:	15 c0       	rjmp	.+42     	; 0x6048 <xTaskCreate+0x8a>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
    601e:	c7 01       	movw	r24, r14
    6020:	0e 94 6e 18 	call	0x30dc	; 0x30dc <vPortFree>
    6024:	8f ef       	ldi	r24, 0xFF	; 255
    6026:	e2 c0       	rjmp	.+452    	; 0x61ec <xTaskCreate+0x22e>
    6028:	f6 01       	movw	r30, r12
    602a:	de 01       	movw	r26, r28
    602c:	90 e0       	ldi	r25, 0x00	; 0
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    602e:	80 81       	ld	r24, Z
    6030:	59 96       	adiw	r26, 0x19	; 25
    6032:	8c 93       	st	X, r24
    6034:	59 97       	sbiw	r26, 0x19	; 25

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    6036:	80 81       	ld	r24, Z
    6038:	88 23       	and	r24, r24
    603a:	29 f0       	breq	.+10     	; 0x6046 <xTaskCreate+0x88>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    603c:	9f 5f       	subi	r25, 0xFF	; 255
    603e:	31 96       	adiw	r30, 0x01	; 1
    6040:	11 96       	adiw	r26, 0x01	; 1
    6042:	98 30       	cpi	r25, 0x08	; 8
    6044:	a1 f7       	brne	.-24     	; 0x602e <xTaskCreate+0x70>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    6046:	18 a2       	std	Y+32, r1	; 0x20
    6048:	04 30       	cpi	r16, 0x04	; 4
    604a:	08 f0       	brcs	.+2      	; 0x604e <xTaskCreate+0x90>
    604c:	03 e0       	ldi	r16, 0x03	; 3
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    604e:	0e 8b       	std	Y+22, r16	; 0x16
    {
        pxNewTCB->uxBasePriority = uxPriority;
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    6050:	cc 24       	eor	r12, r12
    6052:	dd 24       	eor	r13, r13
    6054:	68 94       	set
    6056:	c1 f8       	bld	r12, 1
    6058:	cc 0e       	add	r12, r28
    605a:	dd 1e       	adc	r13, r29
    605c:	c6 01       	movw	r24, r12
    605e:	0e 94 8f 1b 	call	0x371e	; 0x371e <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    6062:	ce 01       	movw	r24, r28
    6064:	0c 96       	adiw	r24, 0x0c	; 12
    6066:	0e 94 8f 1b 	call	0x371e	; 0x371e <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    606a:	d9 87       	std	Y+9, r29	; 0x09
    606c:	c8 87       	std	Y+8, r28	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    606e:	84 e0       	ldi	r24, 0x04	; 4
    6070:	90 e0       	ldi	r25, 0x00	; 0
    6072:	80 1b       	sub	r24, r16
    6074:	91 09       	sbc	r25, r1
    6076:	9d 87       	std	Y+13, r25	; 0x0d
    6078:	8c 87       	std	Y+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    607a:	db 8b       	std	Y+19, r29	; 0x13
    607c:	ca 8b       	std	Y+18, r28	; 0x12
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    607e:	c5 01       	movw	r24, r10
    6080:	01 97       	sbiw	r24, 0x01	; 1
    6082:	8e 0d       	add	r24, r14
    6084:	9f 1d       	adc	r25, r15
    6086:	b2 01       	movw	r22, r4
    6088:	a3 01       	movw	r20, r6
    608a:	0e 94 b5 18 	call	0x316a	; 0x316a <pxPortInitialiseStack>
    608e:	99 83       	std	Y+1, r25	; 0x01
    6090:	88 83       	st	Y, r24
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    6092:	81 14       	cp	r8, r1
    6094:	91 04       	cpc	r9, r1
    6096:	19 f0       	breq	.+6      	; 0x609e <xTaskCreate+0xe0>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    6098:	f4 01       	movw	r30, r8
    609a:	d1 83       	std	Z+1, r29	; 0x01
    609c:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    609e:	0f b6       	in	r0, 0x3f	; 63
    60a0:	f8 94       	cli
    60a2:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    60a4:	80 91 cd 07 	lds	r24, 0x07CD
    60a8:	8f 5f       	subi	r24, 0xFF	; 255
    60aa:	80 93 cd 07 	sts	0x07CD, r24

        if( pxCurrentTCB == NULL )
    60ae:	80 91 c1 07 	lds	r24, 0x07C1
    60b2:	90 91 c2 07 	lds	r25, 0x07C2
    60b6:	89 2b       	or	r24, r25
    60b8:	c9 f5       	brne	.+114    	; 0x612c <xTaskCreate+0x16e>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    60ba:	d0 93 c2 07 	sts	0x07C2, r29
    60be:	c0 93 c1 07 	sts	0x07C1, r28

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    60c2:	80 91 cd 07 	lds	r24, 0x07CD
    60c6:	81 30       	cpi	r24, 0x01	; 1
    60c8:	09 f0       	breq	.+2      	; 0x60cc <xTaskCreate+0x10e>
    60ca:	40 c0       	rjmp	.+128    	; 0x614c <xTaskCreate+0x18e>
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    60cc:	03 ed       	ldi	r16, 0xD3	; 211
    60ce:	17 e0       	ldi	r17, 0x07	; 7
    60d0:	c8 01       	movw	r24, r16
    60d2:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <vListInitialise>
    60d6:	c8 01       	movw	r24, r16
    60d8:	09 96       	adiw	r24, 0x09	; 9
    60da:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <vListInitialise>
    60de:	c8 01       	movw	r24, r16
    60e0:	42 96       	adiw	r24, 0x12	; 18
    60e2:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <vListInitialise>
    60e6:	c8 01       	movw	r24, r16
    60e8:	4b 96       	adiw	r24, 0x1b	; 27
    60ea:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <vListInitialise>
    }

    vListInitialise( &xDelayedTaskList1 );
    60ee:	0f 2e       	mov	r0, r31
    60f0:	f7 ef       	ldi	r31, 0xF7	; 247
    60f2:	ef 2e       	mov	r14, r31
    60f4:	f7 e0       	ldi	r31, 0x07	; 7
    60f6:	ff 2e       	mov	r15, r31
    60f8:	f0 2d       	mov	r31, r0
    60fa:	c7 01       	movw	r24, r14
    60fc:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    6100:	00 e0       	ldi	r16, 0x00	; 0
    6102:	18 e0       	ldi	r17, 0x08	; 8
    6104:	c8 01       	movw	r24, r16
    6106:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <vListInitialise>
    vListInitialise( &xPendingReadyList );
    610a:	8d e0       	ldi	r24, 0x0D	; 13
    610c:	98 e0       	ldi	r25, 0x08	; 8
    610e:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
    6112:	86 e1       	ldi	r24, 0x16	; 22
    6114:	98 e0       	ldi	r25, 0x08	; 8
    6116:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    611a:	f0 92 0a 08 	sts	0x080A, r15
    611e:	e0 92 09 08 	sts	0x0809, r14
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    6122:	10 93 0c 08 	sts	0x080C, r17
    6126:	00 93 0b 08 	sts	0x080B, r16
    612a:	10 c0       	rjmp	.+32     	; 0x614c <xTaskCreate+0x18e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    612c:	80 91 ce 07 	lds	r24, 0x07CE
    6130:	88 23       	and	r24, r24
    6132:	61 f4       	brne	.+24     	; 0x614c <xTaskCreate+0x18e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    6134:	e0 91 c1 07 	lds	r30, 0x07C1
    6138:	f0 91 c2 07 	lds	r31, 0x07C2
    613c:	96 89       	ldd	r25, Z+22	; 0x16
    613e:	8e 89       	ldd	r24, Y+22	; 0x16
    6140:	89 17       	cp	r24, r25
    6142:	20 f0       	brcs	.+8      	; 0x614c <xTaskCreate+0x18e>
                {
                    pxCurrentTCB = pxNewTCB;
    6144:	d0 93 c2 07 	sts	0x07C2, r29
    6148:	c0 93 c1 07 	sts	0x07C1, r28
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    614c:	80 91 d2 07 	lds	r24, 0x07D2
    6150:	8f 5f       	subi	r24, 0xFF	; 255
    6152:	80 93 d2 07 	sts	0x07D2, r24
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    6156:	9e 89       	ldd	r25, Y+22	; 0x16
    6158:	80 91 c4 07 	lds	r24, 0x07C4
    615c:	89 17       	cp	r24, r25
    615e:	10 f4       	brcc	.+4      	; 0x6164 <xTaskCreate+0x1a6>
    6160:	90 93 c4 07 	sts	0x07C4, r25
    6164:	8e 89       	ldd	r24, Y+22	; 0x16
    6166:	90 e0       	ldi	r25, 0x00	; 0
    6168:	9c 01       	movw	r18, r24
    616a:	22 0f       	add	r18, r18
    616c:	33 1f       	adc	r19, r19
    616e:	22 0f       	add	r18, r18
    6170:	33 1f       	adc	r19, r19
    6172:	22 0f       	add	r18, r18
    6174:	33 1f       	adc	r19, r19
    6176:	28 0f       	add	r18, r24
    6178:	39 1f       	adc	r19, r25
    617a:	43 ed       	ldi	r20, 0xD3	; 211
    617c:	57 e0       	ldi	r21, 0x07	; 7
    617e:	fa 01       	movw	r30, r20
    6180:	e2 0f       	add	r30, r18
    6182:	f3 1f       	adc	r31, r19
    6184:	a1 81       	ldd	r26, Z+1	; 0x01
    6186:	b2 81       	ldd	r27, Z+2	; 0x02
    6188:	bd 83       	std	Y+5, r27	; 0x05
    618a:	ac 83       	std	Y+4, r26	; 0x04
    618c:	14 96       	adiw	r26, 0x04	; 4
    618e:	8d 91       	ld	r24, X+
    6190:	9c 91       	ld	r25, X
    6192:	15 97       	sbiw	r26, 0x05	; 5
    6194:	9f 83       	std	Y+7, r25	; 0x07
    6196:	8e 83       	std	Y+6, r24	; 0x06
    6198:	14 96       	adiw	r26, 0x04	; 4
    619a:	ed 91       	ld	r30, X+
    619c:	fc 91       	ld	r31, X
    619e:	15 97       	sbiw	r26, 0x05	; 5
    61a0:	d3 82       	std	Z+3, r13	; 0x03
    61a2:	c2 82       	std	Z+2, r12	; 0x02
    61a4:	15 96       	adiw	r26, 0x05	; 5
    61a6:	dc 92       	st	X, r13
    61a8:	ce 92       	st	-X, r12
    61aa:	14 97       	sbiw	r26, 0x04	; 4
    61ac:	8e 89       	ldd	r24, Y+22	; 0x16
    61ae:	29 e0       	ldi	r18, 0x09	; 9
    61b0:	82 9f       	mul	r24, r18
    61b2:	c0 01       	movw	r24, r0
    61b4:	11 24       	eor	r1, r1
    61b6:	48 0f       	add	r20, r24
    61b8:	59 1f       	adc	r21, r25
    61ba:	5b 87       	std	Y+11, r21	; 0x0b
    61bc:	4a 87       	std	Y+10, r20	; 0x0a
    61be:	fa 01       	movw	r30, r20
    61c0:	80 81       	ld	r24, Z
    61c2:	8f 5f       	subi	r24, 0xFF	; 255
    61c4:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    61c6:	0f 90       	pop	r0
    61c8:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    61ca:	80 91 ce 07 	lds	r24, 0x07CE
    61ce:	88 23       	and	r24, r24
    61d0:	61 f0       	breq	.+24     	; 0x61ea <xTaskCreate+0x22c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    61d2:	e0 91 c1 07 	lds	r30, 0x07C1
    61d6:	f0 91 c2 07 	lds	r31, 0x07C2
    61da:	96 89       	ldd	r25, Z+22	; 0x16
    61dc:	8e 89       	ldd	r24, Y+22	; 0x16
    61de:	98 17       	cp	r25, r24
    61e0:	20 f4       	brcc	.+8      	; 0x61ea <xTaskCreate+0x22c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    61e2:	0e 94 96 19 	call	0x332c	; 0x332c <vPortYield>
    61e6:	81 e0       	ldi	r24, 0x01	; 1
    61e8:	01 c0       	rjmp	.+2      	; 0x61ec <xTaskCreate+0x22e>
    61ea:	81 e0       	ldi	r24, 0x01	; 1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
    61ec:	df 91       	pop	r29
    61ee:	cf 91       	pop	r28
    61f0:	1f 91       	pop	r17
    61f2:	0f 91       	pop	r16
    61f4:	ff 90       	pop	r15
    61f6:	ef 90       	pop	r14
    61f8:	df 90       	pop	r13
    61fa:	cf 90       	pop	r12
    61fc:	bf 90       	pop	r11
    61fe:	af 90       	pop	r10
    6200:	9f 90       	pop	r9
    6202:	8f 90       	pop	r8
    6204:	7f 90       	pop	r7
    6206:	6f 90       	pop	r6
    6208:	5f 90       	pop	r5
    620a:	4f 90       	pop	r4
    620c:	08 95       	ret

0000620e <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    620e:	ef 92       	push	r14
    6210:	ff 92       	push	r15
    6212:	0f 93       	push	r16
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
    6214:	89 e5       	ldi	r24, 0x59	; 89
    6216:	9f e2       	ldi	r25, 0x2F	; 47
    6218:	63 e6       	ldi	r22, 0x63	; 99
    621a:	70 e0       	ldi	r23, 0x00	; 0
    621c:	45 e5       	ldi	r20, 0x55	; 85
    621e:	50 e0       	ldi	r21, 0x00	; 0
    6220:	20 e0       	ldi	r18, 0x00	; 0
    6222:	30 e0       	ldi	r19, 0x00	; 0
    6224:	00 e0       	ldi	r16, 0x00	; 0
    6226:	0f 2e       	mov	r0, r31
    6228:	ff ec       	ldi	r31, 0xCF	; 207
    622a:	ef 2e       	mov	r14, r31
    622c:	f7 e0       	ldi	r31, 0x07	; 7
    622e:	ff 2e       	mov	r15, r31
    6230:	f0 2d       	mov	r31, r0
    6232:	0e 94 df 2f 	call	0x5fbe	; 0x5fbe <xTaskCreate>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    6236:	81 30       	cpi	r24, 0x01	; 1
    6238:	81 f4       	brne	.+32     	; 0x625a <vTaskStartScheduler+0x4c>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    623a:	f8 94       	cli
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
    623c:	8f ef       	ldi	r24, 0xFF	; 255
    623e:	9f ef       	ldi	r25, 0xFF	; 255
    6240:	90 93 c9 07 	sts	0x07C9, r25
    6244:	80 93 c8 07 	sts	0x07C8, r24
        xSchedulerRunning = pdTRUE;
    6248:	81 e0       	ldi	r24, 0x01	; 1
    624a:	80 93 ce 07 	sts	0x07CE, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    624e:	10 92 c7 07 	sts	0x07C7, r1
    6252:	10 92 c6 07 	sts	0x07C6, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
    6256:	0e 94 ff 18 	call	0x31fe	; 0x31fe <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    625a:	80 91 a1 01 	lds	r24, 0x01A1
}
    625e:	0f 91       	pop	r16
    6260:	ff 90       	pop	r15
    6262:	ef 90       	pop	r14
    6264:	08 95       	ret

00006266 <__mulsi3>:
    6266:	62 9f       	mul	r22, r18
    6268:	d0 01       	movw	r26, r0
    626a:	73 9f       	mul	r23, r19
    626c:	f0 01       	movw	r30, r0
    626e:	82 9f       	mul	r24, r18
    6270:	e0 0d       	add	r30, r0
    6272:	f1 1d       	adc	r31, r1
    6274:	64 9f       	mul	r22, r20
    6276:	e0 0d       	add	r30, r0
    6278:	f1 1d       	adc	r31, r1
    627a:	92 9f       	mul	r25, r18
    627c:	f0 0d       	add	r31, r0
    627e:	83 9f       	mul	r24, r19
    6280:	f0 0d       	add	r31, r0
    6282:	74 9f       	mul	r23, r20
    6284:	f0 0d       	add	r31, r0
    6286:	65 9f       	mul	r22, r21
    6288:	f0 0d       	add	r31, r0
    628a:	99 27       	eor	r25, r25
    628c:	72 9f       	mul	r23, r18
    628e:	b0 0d       	add	r27, r0
    6290:	e1 1d       	adc	r30, r1
    6292:	f9 1f       	adc	r31, r25
    6294:	63 9f       	mul	r22, r19
    6296:	b0 0d       	add	r27, r0
    6298:	e1 1d       	adc	r30, r1
    629a:	f9 1f       	adc	r31, r25
    629c:	bd 01       	movw	r22, r26
    629e:	cf 01       	movw	r24, r30
    62a0:	11 24       	eor	r1, r1
    62a2:	08 95       	ret

000062a4 <__udivmodhi4>:
    62a4:	aa 1b       	sub	r26, r26
    62a6:	bb 1b       	sub	r27, r27
    62a8:	51 e1       	ldi	r21, 0x11	; 17
    62aa:	07 c0       	rjmp	.+14     	; 0x62ba <__udivmodhi4_ep>

000062ac <__udivmodhi4_loop>:
    62ac:	aa 1f       	adc	r26, r26
    62ae:	bb 1f       	adc	r27, r27
    62b0:	a6 17       	cp	r26, r22
    62b2:	b7 07       	cpc	r27, r23
    62b4:	10 f0       	brcs	.+4      	; 0x62ba <__udivmodhi4_ep>
    62b6:	a6 1b       	sub	r26, r22
    62b8:	b7 0b       	sbc	r27, r23

000062ba <__udivmodhi4_ep>:
    62ba:	88 1f       	adc	r24, r24
    62bc:	99 1f       	adc	r25, r25
    62be:	5a 95       	dec	r21
    62c0:	a9 f7       	brne	.-22     	; 0x62ac <__udivmodhi4_loop>
    62c2:	80 95       	com	r24
    62c4:	90 95       	com	r25
    62c6:	bc 01       	movw	r22, r24
    62c8:	cd 01       	movw	r24, r26
    62ca:	08 95       	ret

000062cc <__udivmodsi4>:
    62cc:	a1 e2       	ldi	r26, 0x21	; 33
    62ce:	1a 2e       	mov	r1, r26
    62d0:	aa 1b       	sub	r26, r26
    62d2:	bb 1b       	sub	r27, r27
    62d4:	fd 01       	movw	r30, r26
    62d6:	0d c0       	rjmp	.+26     	; 0x62f2 <__udivmodsi4_ep>

000062d8 <__udivmodsi4_loop>:
    62d8:	aa 1f       	adc	r26, r26
    62da:	bb 1f       	adc	r27, r27
    62dc:	ee 1f       	adc	r30, r30
    62de:	ff 1f       	adc	r31, r31
    62e0:	a2 17       	cp	r26, r18
    62e2:	b3 07       	cpc	r27, r19
    62e4:	e4 07       	cpc	r30, r20
    62e6:	f5 07       	cpc	r31, r21
    62e8:	20 f0       	brcs	.+8      	; 0x62f2 <__udivmodsi4_ep>
    62ea:	a2 1b       	sub	r26, r18
    62ec:	b3 0b       	sbc	r27, r19
    62ee:	e4 0b       	sbc	r30, r20
    62f0:	f5 0b       	sbc	r31, r21

000062f2 <__udivmodsi4_ep>:
    62f2:	66 1f       	adc	r22, r22
    62f4:	77 1f       	adc	r23, r23
    62f6:	88 1f       	adc	r24, r24
    62f8:	99 1f       	adc	r25, r25
    62fa:	1a 94       	dec	r1
    62fc:	69 f7       	brne	.-38     	; 0x62d8 <__udivmodsi4_loop>
    62fe:	60 95       	com	r22
    6300:	70 95       	com	r23
    6302:	80 95       	com	r24
    6304:	90 95       	com	r25
    6306:	9b 01       	movw	r18, r22
    6308:	ac 01       	movw	r20, r24
    630a:	bd 01       	movw	r22, r26
    630c:	cf 01       	movw	r24, r30
    630e:	08 95       	ret

00006310 <__prologue_saves__>:
    6310:	2f 92       	push	r2
    6312:	3f 92       	push	r3
    6314:	4f 92       	push	r4
    6316:	5f 92       	push	r5
    6318:	6f 92       	push	r6
    631a:	7f 92       	push	r7
    631c:	8f 92       	push	r8
    631e:	9f 92       	push	r9
    6320:	af 92       	push	r10
    6322:	bf 92       	push	r11
    6324:	cf 92       	push	r12
    6326:	df 92       	push	r13
    6328:	ef 92       	push	r14
    632a:	ff 92       	push	r15
    632c:	0f 93       	push	r16
    632e:	1f 93       	push	r17
    6330:	cf 93       	push	r28
    6332:	df 93       	push	r29
    6334:	cd b7       	in	r28, 0x3d	; 61
    6336:	de b7       	in	r29, 0x3e	; 62
    6338:	ca 1b       	sub	r28, r26
    633a:	db 0b       	sbc	r29, r27
    633c:	0f b6       	in	r0, 0x3f	; 63
    633e:	f8 94       	cli
    6340:	de bf       	out	0x3e, r29	; 62
    6342:	0f be       	out	0x3f, r0	; 63
    6344:	cd bf       	out	0x3d, r28	; 61
    6346:	09 94       	ijmp

00006348 <__epilogue_restores__>:
    6348:	2a 88       	ldd	r2, Y+18	; 0x12
    634a:	39 88       	ldd	r3, Y+17	; 0x11
    634c:	48 88       	ldd	r4, Y+16	; 0x10
    634e:	5f 84       	ldd	r5, Y+15	; 0x0f
    6350:	6e 84       	ldd	r6, Y+14	; 0x0e
    6352:	7d 84       	ldd	r7, Y+13	; 0x0d
    6354:	8c 84       	ldd	r8, Y+12	; 0x0c
    6356:	9b 84       	ldd	r9, Y+11	; 0x0b
    6358:	aa 84       	ldd	r10, Y+10	; 0x0a
    635a:	b9 84       	ldd	r11, Y+9	; 0x09
    635c:	c8 84       	ldd	r12, Y+8	; 0x08
    635e:	df 80       	ldd	r13, Y+7	; 0x07
    6360:	ee 80       	ldd	r14, Y+6	; 0x06
    6362:	fd 80       	ldd	r15, Y+5	; 0x05
    6364:	0c 81       	ldd	r16, Y+4	; 0x04
    6366:	1b 81       	ldd	r17, Y+3	; 0x03
    6368:	aa 81       	ldd	r26, Y+2	; 0x02
    636a:	b9 81       	ldd	r27, Y+1	; 0x01
    636c:	ce 0f       	add	r28, r30
    636e:	d1 1d       	adc	r29, r1
    6370:	0f b6       	in	r0, 0x3f	; 63
    6372:	f8 94       	cli
    6374:	de bf       	out	0x3e, r29	; 62
    6376:	0f be       	out	0x3f, r0	; 63
    6378:	cd bf       	out	0x3d, r28	; 61
    637a:	ed 01       	movw	r28, r26
    637c:	08 95       	ret

0000637e <malloc>:
    637e:	cf 93       	push	r28
    6380:	df 93       	push	r29
    6382:	bc 01       	movw	r22, r24
    6384:	82 30       	cpi	r24, 0x02	; 2
    6386:	91 05       	cpc	r25, r1
    6388:	10 f4       	brcc	.+4      	; 0x638e <malloc+0x10>
    638a:	62 e0       	ldi	r22, 0x02	; 2
    638c:	70 e0       	ldi	r23, 0x00	; 0
    638e:	a0 91 59 08 	lds	r26, 0x0859
    6392:	b0 91 5a 08 	lds	r27, 0x085A
    6396:	ed 01       	movw	r28, r26
    6398:	e0 e0       	ldi	r30, 0x00	; 0
    639a:	f0 e0       	ldi	r31, 0x00	; 0
    639c:	40 e0       	ldi	r20, 0x00	; 0
    639e:	50 e0       	ldi	r21, 0x00	; 0
    63a0:	21 c0       	rjmp	.+66     	; 0x63e4 <malloc+0x66>
    63a2:	88 81       	ld	r24, Y
    63a4:	99 81       	ldd	r25, Y+1	; 0x01
    63a6:	86 17       	cp	r24, r22
    63a8:	97 07       	cpc	r25, r23
    63aa:	69 f4       	brne	.+26     	; 0x63c6 <malloc+0x48>
    63ac:	8a 81       	ldd	r24, Y+2	; 0x02
    63ae:	9b 81       	ldd	r25, Y+3	; 0x03
    63b0:	30 97       	sbiw	r30, 0x00	; 0
    63b2:	19 f0       	breq	.+6      	; 0x63ba <malloc+0x3c>
    63b4:	93 83       	std	Z+3, r25	; 0x03
    63b6:	82 83       	std	Z+2, r24	; 0x02
    63b8:	04 c0       	rjmp	.+8      	; 0x63c2 <malloc+0x44>
    63ba:	90 93 5a 08 	sts	0x085A, r25
    63be:	80 93 59 08 	sts	0x0859, r24
    63c2:	fe 01       	movw	r30, r28
    63c4:	34 c0       	rjmp	.+104    	; 0x642e <malloc+0xb0>
    63c6:	68 17       	cp	r22, r24
    63c8:	79 07       	cpc	r23, r25
    63ca:	38 f4       	brcc	.+14     	; 0x63da <malloc+0x5c>
    63cc:	41 15       	cp	r20, r1
    63ce:	51 05       	cpc	r21, r1
    63d0:	19 f0       	breq	.+6      	; 0x63d8 <malloc+0x5a>
    63d2:	84 17       	cp	r24, r20
    63d4:	95 07       	cpc	r25, r21
    63d6:	08 f4       	brcc	.+2      	; 0x63da <malloc+0x5c>
    63d8:	ac 01       	movw	r20, r24
    63da:	fe 01       	movw	r30, r28
    63dc:	8a 81       	ldd	r24, Y+2	; 0x02
    63de:	9b 81       	ldd	r25, Y+3	; 0x03
    63e0:	9c 01       	movw	r18, r24
    63e2:	e9 01       	movw	r28, r18
    63e4:	20 97       	sbiw	r28, 0x00	; 0
    63e6:	e9 f6       	brne	.-70     	; 0x63a2 <malloc+0x24>
    63e8:	41 15       	cp	r20, r1
    63ea:	51 05       	cpc	r21, r1
    63ec:	a9 f1       	breq	.+106    	; 0x6458 <malloc+0xda>
    63ee:	ca 01       	movw	r24, r20
    63f0:	86 1b       	sub	r24, r22
    63f2:	97 0b       	sbc	r25, r23
    63f4:	04 97       	sbiw	r24, 0x04	; 4
    63f6:	08 f4       	brcc	.+2      	; 0x63fa <malloc+0x7c>
    63f8:	ba 01       	movw	r22, r20
    63fa:	e0 e0       	ldi	r30, 0x00	; 0
    63fc:	f0 e0       	ldi	r31, 0x00	; 0
    63fe:	2a c0       	rjmp	.+84     	; 0x6454 <malloc+0xd6>
    6400:	8d 91       	ld	r24, X+
    6402:	9c 91       	ld	r25, X
    6404:	11 97       	sbiw	r26, 0x01	; 1
    6406:	84 17       	cp	r24, r20
    6408:	95 07       	cpc	r25, r21
    640a:	f9 f4       	brne	.+62     	; 0x644a <malloc+0xcc>
    640c:	64 17       	cp	r22, r20
    640e:	75 07       	cpc	r23, r21
    6410:	81 f4       	brne	.+32     	; 0x6432 <malloc+0xb4>
    6412:	12 96       	adiw	r26, 0x02	; 2
    6414:	8d 91       	ld	r24, X+
    6416:	9c 91       	ld	r25, X
    6418:	13 97       	sbiw	r26, 0x03	; 3
    641a:	30 97       	sbiw	r30, 0x00	; 0
    641c:	19 f0       	breq	.+6      	; 0x6424 <malloc+0xa6>
    641e:	93 83       	std	Z+3, r25	; 0x03
    6420:	82 83       	std	Z+2, r24	; 0x02
    6422:	04 c0       	rjmp	.+8      	; 0x642c <malloc+0xae>
    6424:	90 93 5a 08 	sts	0x085A, r25
    6428:	80 93 59 08 	sts	0x0859, r24
    642c:	fd 01       	movw	r30, r26
    642e:	32 96       	adiw	r30, 0x02	; 2
    6430:	4f c0       	rjmp	.+158    	; 0x64d0 <malloc+0x152>
    6432:	ca 01       	movw	r24, r20
    6434:	86 1b       	sub	r24, r22
    6436:	97 0b       	sbc	r25, r23
    6438:	fd 01       	movw	r30, r26
    643a:	e8 0f       	add	r30, r24
    643c:	f9 1f       	adc	r31, r25
    643e:	61 93       	st	Z+, r22
    6440:	71 93       	st	Z+, r23
    6442:	02 97       	sbiw	r24, 0x02	; 2
    6444:	8d 93       	st	X+, r24
    6446:	9c 93       	st	X, r25
    6448:	43 c0       	rjmp	.+134    	; 0x64d0 <malloc+0x152>
    644a:	fd 01       	movw	r30, r26
    644c:	82 81       	ldd	r24, Z+2	; 0x02
    644e:	93 81       	ldd	r25, Z+3	; 0x03
    6450:	9c 01       	movw	r18, r24
    6452:	d9 01       	movw	r26, r18
    6454:	10 97       	sbiw	r26, 0x00	; 0
    6456:	a1 f6       	brne	.-88     	; 0x6400 <malloc+0x82>
    6458:	80 91 57 08 	lds	r24, 0x0857
    645c:	90 91 58 08 	lds	r25, 0x0858
    6460:	89 2b       	or	r24, r25
    6462:	41 f4       	brne	.+16     	; 0x6474 <malloc+0xf6>
    6464:	80 91 72 01 	lds	r24, 0x0172
    6468:	90 91 73 01 	lds	r25, 0x0173
    646c:	90 93 58 08 	sts	0x0858, r25
    6470:	80 93 57 08 	sts	0x0857, r24
    6474:	40 91 74 01 	lds	r20, 0x0174
    6478:	50 91 75 01 	lds	r21, 0x0175
    647c:	41 15       	cp	r20, r1
    647e:	51 05       	cpc	r21, r1
    6480:	41 f4       	brne	.+16     	; 0x6492 <malloc+0x114>
    6482:	4d b7       	in	r20, 0x3d	; 61
    6484:	5e b7       	in	r21, 0x3e	; 62
    6486:	80 91 70 01 	lds	r24, 0x0170
    648a:	90 91 71 01 	lds	r25, 0x0171
    648e:	48 1b       	sub	r20, r24
    6490:	59 0b       	sbc	r21, r25
    6492:	20 91 57 08 	lds	r18, 0x0857
    6496:	30 91 58 08 	lds	r19, 0x0858
    649a:	24 17       	cp	r18, r20
    649c:	35 07       	cpc	r19, r21
    649e:	b0 f4       	brcc	.+44     	; 0x64cc <malloc+0x14e>
    64a0:	ca 01       	movw	r24, r20
    64a2:	82 1b       	sub	r24, r18
    64a4:	93 0b       	sbc	r25, r19
    64a6:	86 17       	cp	r24, r22
    64a8:	97 07       	cpc	r25, r23
    64aa:	80 f0       	brcs	.+32     	; 0x64cc <malloc+0x14e>
    64ac:	ab 01       	movw	r20, r22
    64ae:	4e 5f       	subi	r20, 0xFE	; 254
    64b0:	5f 4f       	sbci	r21, 0xFF	; 255
    64b2:	84 17       	cp	r24, r20
    64b4:	95 07       	cpc	r25, r21
    64b6:	50 f0       	brcs	.+20     	; 0x64cc <malloc+0x14e>
    64b8:	42 0f       	add	r20, r18
    64ba:	53 1f       	adc	r21, r19
    64bc:	50 93 58 08 	sts	0x0858, r21
    64c0:	40 93 57 08 	sts	0x0857, r20
    64c4:	f9 01       	movw	r30, r18
    64c6:	61 93       	st	Z+, r22
    64c8:	71 93       	st	Z+, r23
    64ca:	02 c0       	rjmp	.+4      	; 0x64d0 <malloc+0x152>
    64cc:	e0 e0       	ldi	r30, 0x00	; 0
    64ce:	f0 e0       	ldi	r31, 0x00	; 0
    64d0:	cf 01       	movw	r24, r30
    64d2:	df 91       	pop	r29
    64d4:	cf 91       	pop	r28
    64d6:	08 95       	ret

000064d8 <free>:
    64d8:	cf 93       	push	r28
    64da:	df 93       	push	r29
    64dc:	00 97       	sbiw	r24, 0x00	; 0
    64de:	09 f4       	brne	.+2      	; 0x64e2 <free+0xa>
    64e0:	50 c0       	rjmp	.+160    	; 0x6582 <free+0xaa>
    64e2:	ec 01       	movw	r28, r24
    64e4:	22 97       	sbiw	r28, 0x02	; 2
    64e6:	1b 82       	std	Y+3, r1	; 0x03
    64e8:	1a 82       	std	Y+2, r1	; 0x02
    64ea:	a0 91 59 08 	lds	r26, 0x0859
    64ee:	b0 91 5a 08 	lds	r27, 0x085A
    64f2:	10 97       	sbiw	r26, 0x00	; 0
    64f4:	09 f1       	breq	.+66     	; 0x6538 <free+0x60>
    64f6:	40 e0       	ldi	r20, 0x00	; 0
    64f8:	50 e0       	ldi	r21, 0x00	; 0
    64fa:	ac 17       	cp	r26, r28
    64fc:	bd 07       	cpc	r27, r29
    64fe:	08 f1       	brcs	.+66     	; 0x6542 <free+0x6a>
    6500:	bb 83       	std	Y+3, r27	; 0x03
    6502:	aa 83       	std	Y+2, r26	; 0x02
    6504:	fe 01       	movw	r30, r28
    6506:	21 91       	ld	r18, Z+
    6508:	31 91       	ld	r19, Z+
    650a:	e2 0f       	add	r30, r18
    650c:	f3 1f       	adc	r31, r19
    650e:	ae 17       	cp	r26, r30
    6510:	bf 07       	cpc	r27, r31
    6512:	79 f4       	brne	.+30     	; 0x6532 <free+0x5a>
    6514:	8d 91       	ld	r24, X+
    6516:	9c 91       	ld	r25, X
    6518:	11 97       	sbiw	r26, 0x01	; 1
    651a:	28 0f       	add	r18, r24
    651c:	39 1f       	adc	r19, r25
    651e:	2e 5f       	subi	r18, 0xFE	; 254
    6520:	3f 4f       	sbci	r19, 0xFF	; 255
    6522:	39 83       	std	Y+1, r19	; 0x01
    6524:	28 83       	st	Y, r18
    6526:	12 96       	adiw	r26, 0x02	; 2
    6528:	8d 91       	ld	r24, X+
    652a:	9c 91       	ld	r25, X
    652c:	13 97       	sbiw	r26, 0x03	; 3
    652e:	9b 83       	std	Y+3, r25	; 0x03
    6530:	8a 83       	std	Y+2, r24	; 0x02
    6532:	41 15       	cp	r20, r1
    6534:	51 05       	cpc	r21, r1
    6536:	71 f4       	brne	.+28     	; 0x6554 <free+0x7c>
    6538:	d0 93 5a 08 	sts	0x085A, r29
    653c:	c0 93 59 08 	sts	0x0859, r28
    6540:	20 c0       	rjmp	.+64     	; 0x6582 <free+0xaa>
    6542:	12 96       	adiw	r26, 0x02	; 2
    6544:	8d 91       	ld	r24, X+
    6546:	9c 91       	ld	r25, X
    6548:	13 97       	sbiw	r26, 0x03	; 3
    654a:	ad 01       	movw	r20, r26
    654c:	00 97       	sbiw	r24, 0x00	; 0
    654e:	11 f0       	breq	.+4      	; 0x6554 <free+0x7c>
    6550:	dc 01       	movw	r26, r24
    6552:	d3 cf       	rjmp	.-90     	; 0x64fa <free+0x22>
    6554:	fa 01       	movw	r30, r20
    6556:	d3 83       	std	Z+3, r29	; 0x03
    6558:	c2 83       	std	Z+2, r28	; 0x02
    655a:	21 91       	ld	r18, Z+
    655c:	31 91       	ld	r19, Z+
    655e:	e2 0f       	add	r30, r18
    6560:	f3 1f       	adc	r31, r19
    6562:	ce 17       	cp	r28, r30
    6564:	df 07       	cpc	r29, r31
    6566:	69 f4       	brne	.+26     	; 0x6582 <free+0xaa>
    6568:	88 81       	ld	r24, Y
    656a:	99 81       	ldd	r25, Y+1	; 0x01
    656c:	28 0f       	add	r18, r24
    656e:	39 1f       	adc	r19, r25
    6570:	2e 5f       	subi	r18, 0xFE	; 254
    6572:	3f 4f       	sbci	r19, 0xFF	; 255
    6574:	fa 01       	movw	r30, r20
    6576:	31 83       	std	Z+1, r19	; 0x01
    6578:	20 83       	st	Z, r18
    657a:	8a 81       	ldd	r24, Y+2	; 0x02
    657c:	9b 81       	ldd	r25, Y+3	; 0x03
    657e:	93 83       	std	Z+3, r25	; 0x03
    6580:	82 83       	std	Z+2, r24	; 0x02
    6582:	df 91       	pop	r29
    6584:	cf 91       	pop	r28
    6586:	08 95       	ret

00006588 <atoi>:
    6588:	fc 01       	movw	r30, r24
    658a:	88 27       	eor	r24, r24
    658c:	99 27       	eor	r25, r25
    658e:	e8 94       	clt
    6590:	21 91       	ld	r18, Z+
    6592:	20 32       	cpi	r18, 0x20	; 32
    6594:	e9 f3       	breq	.-6      	; 0x6590 <atoi+0x8>
    6596:	29 30       	cpi	r18, 0x09	; 9
    6598:	10 f0       	brcs	.+4      	; 0x659e <atoi+0x16>
    659a:	2e 30       	cpi	r18, 0x0E	; 14
    659c:	c8 f3       	brcs	.-14     	; 0x6590 <atoi+0x8>
    659e:	2b 32       	cpi	r18, 0x2B	; 43
    65a0:	41 f0       	breq	.+16     	; 0x65b2 <atoi+0x2a>
    65a2:	2d 32       	cpi	r18, 0x2D	; 45
    65a4:	39 f4       	brne	.+14     	; 0x65b4 <atoi+0x2c>
    65a6:	68 94       	set
    65a8:	04 c0       	rjmp	.+8      	; 0x65b2 <atoi+0x2a>
    65aa:	0e 94 eb 32 	call	0x65d6	; 0x65d6 <__mulhi_const_10>
    65ae:	82 0f       	add	r24, r18
    65b0:	91 1d       	adc	r25, r1
    65b2:	21 91       	ld	r18, Z+
    65b4:	20 53       	subi	r18, 0x30	; 48
    65b6:	2a 30       	cpi	r18, 0x0A	; 10
    65b8:	c0 f3       	brcs	.-16     	; 0x65aa <atoi+0x22>
    65ba:	1e f4       	brtc	.+6      	; 0x65c2 <atoi+0x3a>
    65bc:	90 95       	com	r25
    65be:	81 95       	neg	r24
    65c0:	9f 4f       	sbci	r25, 0xFF	; 255
    65c2:	08 95       	ret

000065c4 <memcpy>:
    65c4:	fb 01       	movw	r30, r22
    65c6:	dc 01       	movw	r26, r24
    65c8:	02 c0       	rjmp	.+4      	; 0x65ce <memcpy+0xa>
    65ca:	01 90       	ld	r0, Z+
    65cc:	0d 92       	st	X+, r0
    65ce:	41 50       	subi	r20, 0x01	; 1
    65d0:	50 40       	sbci	r21, 0x00	; 0
    65d2:	d8 f7       	brcc	.-10     	; 0x65ca <memcpy+0x6>
    65d4:	08 95       	ret

000065d6 <__mulhi_const_10>:
    65d6:	7a e0       	ldi	r23, 0x0A	; 10
    65d8:	97 9f       	mul	r25, r23
    65da:	90 2d       	mov	r25, r0
    65dc:	87 9f       	mul	r24, r23
    65de:	80 2d       	mov	r24, r0
    65e0:	91 0d       	add	r25, r1
    65e2:	11 24       	eor	r1, r1
    65e4:	08 95       	ret

000065e6 <snprintf>:
    65e6:	ae e0       	ldi	r26, 0x0E	; 14
    65e8:	b0 e0       	ldi	r27, 0x00	; 0
    65ea:	e9 ef       	ldi	r30, 0xF9	; 249
    65ec:	f2 e3       	ldi	r31, 0x32	; 50
    65ee:	0c 94 96 31 	jmp	0x632c	; 0x632c <__prologue_saves__+0x1c>
    65f2:	0d 89       	ldd	r16, Y+21	; 0x15
    65f4:	1e 89       	ldd	r17, Y+22	; 0x16
    65f6:	8f 89       	ldd	r24, Y+23	; 0x17
    65f8:	98 8d       	ldd	r25, Y+24	; 0x18
    65fa:	97 ff       	sbrs	r25, 7
    65fc:	02 c0       	rjmp	.+4      	; 0x6602 <snprintf+0x1c>
    65fe:	80 e0       	ldi	r24, 0x00	; 0
    6600:	90 e8       	ldi	r25, 0x80	; 128
    6602:	01 97       	sbiw	r24, 0x01	; 1
    6604:	9e 83       	std	Y+6, r25	; 0x06
    6606:	8d 83       	std	Y+5, r24	; 0x05
    6608:	1a 83       	std	Y+2, r17	; 0x02
    660a:	09 83       	std	Y+1, r16	; 0x01
    660c:	86 e0       	ldi	r24, 0x06	; 6
    660e:	8c 83       	std	Y+4, r24	; 0x04
    6610:	9e 01       	movw	r18, r28
    6612:	25 5e       	subi	r18, 0xE5	; 229
    6614:	3f 4f       	sbci	r19, 0xFF	; 255
    6616:	ce 01       	movw	r24, r28
    6618:	01 96       	adiw	r24, 0x01	; 1
    661a:	69 8d       	ldd	r22, Y+25	; 0x19
    661c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    661e:	a9 01       	movw	r20, r18
    6620:	0e 94 24 33 	call	0x6648	; 0x6648 <vfprintf>
    6624:	4d 81       	ldd	r20, Y+5	; 0x05
    6626:	5e 81       	ldd	r21, Y+6	; 0x06
    6628:	57 fd       	sbrc	r21, 7
    662a:	0a c0       	rjmp	.+20     	; 0x6640 <snprintf+0x5a>
    662c:	2f 81       	ldd	r18, Y+7	; 0x07
    662e:	38 85       	ldd	r19, Y+8	; 0x08
    6630:	42 17       	cp	r20, r18
    6632:	53 07       	cpc	r21, r19
    6634:	0c f4       	brge	.+2      	; 0x6638 <snprintf+0x52>
    6636:	9a 01       	movw	r18, r20
    6638:	02 0f       	add	r16, r18
    663a:	13 1f       	adc	r17, r19
    663c:	f8 01       	movw	r30, r16
    663e:	10 82       	st	Z, r1
    6640:	2e 96       	adiw	r28, 0x0e	; 14
    6642:	e4 e0       	ldi	r30, 0x04	; 4
    6644:	0c 94 b2 31 	jmp	0x6364	; 0x6364 <__epilogue_restores__+0x1c>

00006648 <vfprintf>:
    6648:	ab e0       	ldi	r26, 0x0B	; 11
    664a:	b0 e0       	ldi	r27, 0x00	; 0
    664c:	ea e2       	ldi	r30, 0x2A	; 42
    664e:	f3 e3       	ldi	r31, 0x33	; 51
    6650:	0c 94 88 31 	jmp	0x6310	; 0x6310 <__prologue_saves__>
    6654:	3c 01       	movw	r6, r24
    6656:	2b 01       	movw	r4, r22
    6658:	5a 01       	movw	r10, r20
    665a:	fc 01       	movw	r30, r24
    665c:	17 82       	std	Z+7, r1	; 0x07
    665e:	16 82       	std	Z+6, r1	; 0x06
    6660:	83 81       	ldd	r24, Z+3	; 0x03
    6662:	81 fd       	sbrc	r24, 1
    6664:	03 c0       	rjmp	.+6      	; 0x666c <vfprintf+0x24>
    6666:	6f ef       	ldi	r22, 0xFF	; 255
    6668:	7f ef       	ldi	r23, 0xFF	; 255
    666a:	c6 c1       	rjmp	.+908    	; 0x69f8 <vfprintf+0x3b0>
    666c:	9a e0       	ldi	r25, 0x0A	; 10
    666e:	89 2e       	mov	r8, r25
    6670:	1e 01       	movw	r2, r28
    6672:	08 94       	sec
    6674:	21 1c       	adc	r2, r1
    6676:	31 1c       	adc	r3, r1
    6678:	f3 01       	movw	r30, r6
    667a:	23 81       	ldd	r18, Z+3	; 0x03
    667c:	f2 01       	movw	r30, r4
    667e:	23 fd       	sbrc	r18, 3
    6680:	85 91       	lpm	r24, Z+
    6682:	23 ff       	sbrs	r18, 3
    6684:	81 91       	ld	r24, Z+
    6686:	2f 01       	movw	r4, r30
    6688:	88 23       	and	r24, r24
    668a:	09 f4       	brne	.+2      	; 0x668e <vfprintf+0x46>
    668c:	b2 c1       	rjmp	.+868    	; 0x69f2 <vfprintf+0x3aa>
    668e:	85 32       	cpi	r24, 0x25	; 37
    6690:	39 f4       	brne	.+14     	; 0x66a0 <vfprintf+0x58>
    6692:	23 fd       	sbrc	r18, 3
    6694:	85 91       	lpm	r24, Z+
    6696:	23 ff       	sbrs	r18, 3
    6698:	81 91       	ld	r24, Z+
    669a:	2f 01       	movw	r4, r30
    669c:	85 32       	cpi	r24, 0x25	; 37
    669e:	29 f4       	brne	.+10     	; 0x66aa <vfprintf+0x62>
    66a0:	90 e0       	ldi	r25, 0x00	; 0
    66a2:	b3 01       	movw	r22, r6
    66a4:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <fputc>
    66a8:	e7 cf       	rjmp	.-50     	; 0x6678 <vfprintf+0x30>
    66aa:	98 2f       	mov	r25, r24
    66ac:	ff 24       	eor	r15, r15
    66ae:	ee 24       	eor	r14, r14
    66b0:	99 24       	eor	r9, r9
    66b2:	ff e1       	ldi	r31, 0x1F	; 31
    66b4:	ff 15       	cp	r31, r15
    66b6:	d0 f0       	brcs	.+52     	; 0x66ec <vfprintf+0xa4>
    66b8:	9b 32       	cpi	r25, 0x2B	; 43
    66ba:	69 f0       	breq	.+26     	; 0x66d6 <vfprintf+0x8e>
    66bc:	9c 32       	cpi	r25, 0x2C	; 44
    66be:	28 f4       	brcc	.+10     	; 0x66ca <vfprintf+0x82>
    66c0:	90 32       	cpi	r25, 0x20	; 32
    66c2:	59 f0       	breq	.+22     	; 0x66da <vfprintf+0x92>
    66c4:	93 32       	cpi	r25, 0x23	; 35
    66c6:	91 f4       	brne	.+36     	; 0x66ec <vfprintf+0xa4>
    66c8:	0e c0       	rjmp	.+28     	; 0x66e6 <vfprintf+0x9e>
    66ca:	9d 32       	cpi	r25, 0x2D	; 45
    66cc:	49 f0       	breq	.+18     	; 0x66e0 <vfprintf+0x98>
    66ce:	90 33       	cpi	r25, 0x30	; 48
    66d0:	69 f4       	brne	.+26     	; 0x66ec <vfprintf+0xa4>
    66d2:	41 e0       	ldi	r20, 0x01	; 1
    66d4:	24 c0       	rjmp	.+72     	; 0x671e <vfprintf+0xd6>
    66d6:	52 e0       	ldi	r21, 0x02	; 2
    66d8:	f5 2a       	or	r15, r21
    66da:	84 e0       	ldi	r24, 0x04	; 4
    66dc:	f8 2a       	or	r15, r24
    66de:	28 c0       	rjmp	.+80     	; 0x6730 <vfprintf+0xe8>
    66e0:	98 e0       	ldi	r25, 0x08	; 8
    66e2:	f9 2a       	or	r15, r25
    66e4:	25 c0       	rjmp	.+74     	; 0x6730 <vfprintf+0xe8>
    66e6:	e0 e1       	ldi	r30, 0x10	; 16
    66e8:	fe 2a       	or	r15, r30
    66ea:	22 c0       	rjmp	.+68     	; 0x6730 <vfprintf+0xe8>
    66ec:	f7 fc       	sbrc	r15, 7
    66ee:	29 c0       	rjmp	.+82     	; 0x6742 <vfprintf+0xfa>
    66f0:	89 2f       	mov	r24, r25
    66f2:	80 53       	subi	r24, 0x30	; 48
    66f4:	8a 30       	cpi	r24, 0x0A	; 10
    66f6:	70 f4       	brcc	.+28     	; 0x6714 <vfprintf+0xcc>
    66f8:	f6 fe       	sbrs	r15, 6
    66fa:	05 c0       	rjmp	.+10     	; 0x6706 <vfprintf+0xbe>
    66fc:	98 9c       	mul	r9, r8
    66fe:	90 2c       	mov	r9, r0
    6700:	11 24       	eor	r1, r1
    6702:	98 0e       	add	r9, r24
    6704:	15 c0       	rjmp	.+42     	; 0x6730 <vfprintf+0xe8>
    6706:	e8 9c       	mul	r14, r8
    6708:	e0 2c       	mov	r14, r0
    670a:	11 24       	eor	r1, r1
    670c:	e8 0e       	add	r14, r24
    670e:	f0 e2       	ldi	r31, 0x20	; 32
    6710:	ff 2a       	or	r15, r31
    6712:	0e c0       	rjmp	.+28     	; 0x6730 <vfprintf+0xe8>
    6714:	9e 32       	cpi	r25, 0x2E	; 46
    6716:	29 f4       	brne	.+10     	; 0x6722 <vfprintf+0xda>
    6718:	f6 fc       	sbrc	r15, 6
    671a:	6b c1       	rjmp	.+726    	; 0x69f2 <vfprintf+0x3aa>
    671c:	40 e4       	ldi	r20, 0x40	; 64
    671e:	f4 2a       	or	r15, r20
    6720:	07 c0       	rjmp	.+14     	; 0x6730 <vfprintf+0xe8>
    6722:	9c 36       	cpi	r25, 0x6C	; 108
    6724:	19 f4       	brne	.+6      	; 0x672c <vfprintf+0xe4>
    6726:	50 e8       	ldi	r21, 0x80	; 128
    6728:	f5 2a       	or	r15, r21
    672a:	02 c0       	rjmp	.+4      	; 0x6730 <vfprintf+0xe8>
    672c:	98 36       	cpi	r25, 0x68	; 104
    672e:	49 f4       	brne	.+18     	; 0x6742 <vfprintf+0xfa>
    6730:	f2 01       	movw	r30, r4
    6732:	23 fd       	sbrc	r18, 3
    6734:	95 91       	lpm	r25, Z+
    6736:	23 ff       	sbrs	r18, 3
    6738:	91 91       	ld	r25, Z+
    673a:	2f 01       	movw	r4, r30
    673c:	99 23       	and	r25, r25
    673e:	09 f0       	breq	.+2      	; 0x6742 <vfprintf+0xfa>
    6740:	b8 cf       	rjmp	.-144    	; 0x66b2 <vfprintf+0x6a>
    6742:	89 2f       	mov	r24, r25
    6744:	85 54       	subi	r24, 0x45	; 69
    6746:	83 30       	cpi	r24, 0x03	; 3
    6748:	18 f0       	brcs	.+6      	; 0x6750 <vfprintf+0x108>
    674a:	80 52       	subi	r24, 0x20	; 32
    674c:	83 30       	cpi	r24, 0x03	; 3
    674e:	38 f4       	brcc	.+14     	; 0x675e <vfprintf+0x116>
    6750:	44 e0       	ldi	r20, 0x04	; 4
    6752:	50 e0       	ldi	r21, 0x00	; 0
    6754:	a4 0e       	add	r10, r20
    6756:	b5 1e       	adc	r11, r21
    6758:	5f e3       	ldi	r21, 0x3F	; 63
    675a:	59 83       	std	Y+1, r21	; 0x01
    675c:	0f c0       	rjmp	.+30     	; 0x677c <vfprintf+0x134>
    675e:	93 36       	cpi	r25, 0x63	; 99
    6760:	31 f0       	breq	.+12     	; 0x676e <vfprintf+0x126>
    6762:	93 37       	cpi	r25, 0x73	; 115
    6764:	79 f0       	breq	.+30     	; 0x6784 <vfprintf+0x13c>
    6766:	93 35       	cpi	r25, 0x53	; 83
    6768:	09 f0       	breq	.+2      	; 0x676c <vfprintf+0x124>
    676a:	56 c0       	rjmp	.+172    	; 0x6818 <vfprintf+0x1d0>
    676c:	20 c0       	rjmp	.+64     	; 0x67ae <vfprintf+0x166>
    676e:	f5 01       	movw	r30, r10
    6770:	80 81       	ld	r24, Z
    6772:	89 83       	std	Y+1, r24	; 0x01
    6774:	42 e0       	ldi	r20, 0x02	; 2
    6776:	50 e0       	ldi	r21, 0x00	; 0
    6778:	a4 0e       	add	r10, r20
    677a:	b5 1e       	adc	r11, r21
    677c:	61 01       	movw	r12, r2
    677e:	01 e0       	ldi	r16, 0x01	; 1
    6780:	10 e0       	ldi	r17, 0x00	; 0
    6782:	12 c0       	rjmp	.+36     	; 0x67a8 <vfprintf+0x160>
    6784:	f5 01       	movw	r30, r10
    6786:	c0 80       	ld	r12, Z
    6788:	d1 80       	ldd	r13, Z+1	; 0x01
    678a:	f6 fc       	sbrc	r15, 6
    678c:	03 c0       	rjmp	.+6      	; 0x6794 <vfprintf+0x14c>
    678e:	6f ef       	ldi	r22, 0xFF	; 255
    6790:	7f ef       	ldi	r23, 0xFF	; 255
    6792:	02 c0       	rjmp	.+4      	; 0x6798 <vfprintf+0x150>
    6794:	69 2d       	mov	r22, r9
    6796:	70 e0       	ldi	r23, 0x00	; 0
    6798:	42 e0       	ldi	r20, 0x02	; 2
    679a:	50 e0       	ldi	r21, 0x00	; 0
    679c:	a4 0e       	add	r10, r20
    679e:	b5 1e       	adc	r11, r21
    67a0:	c6 01       	movw	r24, r12
    67a2:	0e 94 0c 35 	call	0x6a18	; 0x6a18 <strnlen>
    67a6:	8c 01       	movw	r16, r24
    67a8:	5f e7       	ldi	r21, 0x7F	; 127
    67aa:	f5 22       	and	r15, r21
    67ac:	14 c0       	rjmp	.+40     	; 0x67d6 <vfprintf+0x18e>
    67ae:	f5 01       	movw	r30, r10
    67b0:	c0 80       	ld	r12, Z
    67b2:	d1 80       	ldd	r13, Z+1	; 0x01
    67b4:	f6 fc       	sbrc	r15, 6
    67b6:	03 c0       	rjmp	.+6      	; 0x67be <vfprintf+0x176>
    67b8:	6f ef       	ldi	r22, 0xFF	; 255
    67ba:	7f ef       	ldi	r23, 0xFF	; 255
    67bc:	02 c0       	rjmp	.+4      	; 0x67c2 <vfprintf+0x17a>
    67be:	69 2d       	mov	r22, r9
    67c0:	70 e0       	ldi	r23, 0x00	; 0
    67c2:	42 e0       	ldi	r20, 0x02	; 2
    67c4:	50 e0       	ldi	r21, 0x00	; 0
    67c6:	a4 0e       	add	r10, r20
    67c8:	b5 1e       	adc	r11, r21
    67ca:	c6 01       	movw	r24, r12
    67cc:	0e 94 01 35 	call	0x6a02	; 0x6a02 <strnlen_P>
    67d0:	8c 01       	movw	r16, r24
    67d2:	50 e8       	ldi	r21, 0x80	; 128
    67d4:	f5 2a       	or	r15, r21
    67d6:	f3 fe       	sbrs	r15, 3
    67d8:	07 c0       	rjmp	.+14     	; 0x67e8 <vfprintf+0x1a0>
    67da:	1a c0       	rjmp	.+52     	; 0x6810 <vfprintf+0x1c8>
    67dc:	80 e2       	ldi	r24, 0x20	; 32
    67de:	90 e0       	ldi	r25, 0x00	; 0
    67e0:	b3 01       	movw	r22, r6
    67e2:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <fputc>
    67e6:	ea 94       	dec	r14
    67e8:	8e 2d       	mov	r24, r14
    67ea:	90 e0       	ldi	r25, 0x00	; 0
    67ec:	08 17       	cp	r16, r24
    67ee:	19 07       	cpc	r17, r25
    67f0:	a8 f3       	brcs	.-22     	; 0x67dc <vfprintf+0x194>
    67f2:	0e c0       	rjmp	.+28     	; 0x6810 <vfprintf+0x1c8>
    67f4:	f6 01       	movw	r30, r12
    67f6:	f7 fc       	sbrc	r15, 7
    67f8:	85 91       	lpm	r24, Z+
    67fa:	f7 fe       	sbrs	r15, 7
    67fc:	81 91       	ld	r24, Z+
    67fe:	6f 01       	movw	r12, r30
    6800:	90 e0       	ldi	r25, 0x00	; 0
    6802:	b3 01       	movw	r22, r6
    6804:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <fputc>
    6808:	e1 10       	cpse	r14, r1
    680a:	ea 94       	dec	r14
    680c:	01 50       	subi	r16, 0x01	; 1
    680e:	10 40       	sbci	r17, 0x00	; 0
    6810:	01 15       	cp	r16, r1
    6812:	11 05       	cpc	r17, r1
    6814:	79 f7       	brne	.-34     	; 0x67f4 <vfprintf+0x1ac>
    6816:	ea c0       	rjmp	.+468    	; 0x69ec <vfprintf+0x3a4>
    6818:	94 36       	cpi	r25, 0x64	; 100
    681a:	11 f0       	breq	.+4      	; 0x6820 <vfprintf+0x1d8>
    681c:	99 36       	cpi	r25, 0x69	; 105
    681e:	69 f5       	brne	.+90     	; 0x687a <vfprintf+0x232>
    6820:	f7 fe       	sbrs	r15, 7
    6822:	08 c0       	rjmp	.+16     	; 0x6834 <vfprintf+0x1ec>
    6824:	f5 01       	movw	r30, r10
    6826:	20 81       	ld	r18, Z
    6828:	31 81       	ldd	r19, Z+1	; 0x01
    682a:	42 81       	ldd	r20, Z+2	; 0x02
    682c:	53 81       	ldd	r21, Z+3	; 0x03
    682e:	84 e0       	ldi	r24, 0x04	; 4
    6830:	90 e0       	ldi	r25, 0x00	; 0
    6832:	0a c0       	rjmp	.+20     	; 0x6848 <vfprintf+0x200>
    6834:	f5 01       	movw	r30, r10
    6836:	80 81       	ld	r24, Z
    6838:	91 81       	ldd	r25, Z+1	; 0x01
    683a:	9c 01       	movw	r18, r24
    683c:	44 27       	eor	r20, r20
    683e:	37 fd       	sbrc	r19, 7
    6840:	40 95       	com	r20
    6842:	54 2f       	mov	r21, r20
    6844:	82 e0       	ldi	r24, 0x02	; 2
    6846:	90 e0       	ldi	r25, 0x00	; 0
    6848:	a8 0e       	add	r10, r24
    684a:	b9 1e       	adc	r11, r25
    684c:	9f e6       	ldi	r25, 0x6F	; 111
    684e:	f9 22       	and	r15, r25
    6850:	57 ff       	sbrs	r21, 7
    6852:	09 c0       	rjmp	.+18     	; 0x6866 <vfprintf+0x21e>
    6854:	50 95       	com	r21
    6856:	40 95       	com	r20
    6858:	30 95       	com	r19
    685a:	21 95       	neg	r18
    685c:	3f 4f       	sbci	r19, 0xFF	; 255
    685e:	4f 4f       	sbci	r20, 0xFF	; 255
    6860:	5f 4f       	sbci	r21, 0xFF	; 255
    6862:	e0 e8       	ldi	r30, 0x80	; 128
    6864:	fe 2a       	or	r15, r30
    6866:	ca 01       	movw	r24, r20
    6868:	b9 01       	movw	r22, r18
    686a:	a1 01       	movw	r20, r2
    686c:	2a e0       	ldi	r18, 0x0A	; 10
    686e:	30 e0       	ldi	r19, 0x00	; 0
    6870:	0e 94 43 35 	call	0x6a86	; 0x6a86 <__ultoa_invert>
    6874:	d8 2e       	mov	r13, r24
    6876:	d2 18       	sub	r13, r2
    6878:	40 c0       	rjmp	.+128    	; 0x68fa <vfprintf+0x2b2>
    687a:	95 37       	cpi	r25, 0x75	; 117
    687c:	29 f4       	brne	.+10     	; 0x6888 <vfprintf+0x240>
    687e:	1f 2d       	mov	r17, r15
    6880:	1f 7e       	andi	r17, 0xEF	; 239
    6882:	2a e0       	ldi	r18, 0x0A	; 10
    6884:	30 e0       	ldi	r19, 0x00	; 0
    6886:	1d c0       	rjmp	.+58     	; 0x68c2 <vfprintf+0x27a>
    6888:	1f 2d       	mov	r17, r15
    688a:	19 7f       	andi	r17, 0xF9	; 249
    688c:	9f 36       	cpi	r25, 0x6F	; 111
    688e:	61 f0       	breq	.+24     	; 0x68a8 <vfprintf+0x260>
    6890:	90 37       	cpi	r25, 0x70	; 112
    6892:	20 f4       	brcc	.+8      	; 0x689c <vfprintf+0x254>
    6894:	98 35       	cpi	r25, 0x58	; 88
    6896:	09 f0       	breq	.+2      	; 0x689a <vfprintf+0x252>
    6898:	ac c0       	rjmp	.+344    	; 0x69f2 <vfprintf+0x3aa>
    689a:	0f c0       	rjmp	.+30     	; 0x68ba <vfprintf+0x272>
    689c:	90 37       	cpi	r25, 0x70	; 112
    689e:	39 f0       	breq	.+14     	; 0x68ae <vfprintf+0x266>
    68a0:	98 37       	cpi	r25, 0x78	; 120
    68a2:	09 f0       	breq	.+2      	; 0x68a6 <vfprintf+0x25e>
    68a4:	a6 c0       	rjmp	.+332    	; 0x69f2 <vfprintf+0x3aa>
    68a6:	04 c0       	rjmp	.+8      	; 0x68b0 <vfprintf+0x268>
    68a8:	28 e0       	ldi	r18, 0x08	; 8
    68aa:	30 e0       	ldi	r19, 0x00	; 0
    68ac:	0a c0       	rjmp	.+20     	; 0x68c2 <vfprintf+0x27a>
    68ae:	10 61       	ori	r17, 0x10	; 16
    68b0:	14 fd       	sbrc	r17, 4
    68b2:	14 60       	ori	r17, 0x04	; 4
    68b4:	20 e1       	ldi	r18, 0x10	; 16
    68b6:	30 e0       	ldi	r19, 0x00	; 0
    68b8:	04 c0       	rjmp	.+8      	; 0x68c2 <vfprintf+0x27a>
    68ba:	14 fd       	sbrc	r17, 4
    68bc:	16 60       	ori	r17, 0x06	; 6
    68be:	20 e1       	ldi	r18, 0x10	; 16
    68c0:	32 e0       	ldi	r19, 0x02	; 2
    68c2:	17 ff       	sbrs	r17, 7
    68c4:	08 c0       	rjmp	.+16     	; 0x68d6 <vfprintf+0x28e>
    68c6:	f5 01       	movw	r30, r10
    68c8:	60 81       	ld	r22, Z
    68ca:	71 81       	ldd	r23, Z+1	; 0x01
    68cc:	82 81       	ldd	r24, Z+2	; 0x02
    68ce:	93 81       	ldd	r25, Z+3	; 0x03
    68d0:	44 e0       	ldi	r20, 0x04	; 4
    68d2:	50 e0       	ldi	r21, 0x00	; 0
    68d4:	08 c0       	rjmp	.+16     	; 0x68e6 <vfprintf+0x29e>
    68d6:	f5 01       	movw	r30, r10
    68d8:	80 81       	ld	r24, Z
    68da:	91 81       	ldd	r25, Z+1	; 0x01
    68dc:	bc 01       	movw	r22, r24
    68de:	80 e0       	ldi	r24, 0x00	; 0
    68e0:	90 e0       	ldi	r25, 0x00	; 0
    68e2:	42 e0       	ldi	r20, 0x02	; 2
    68e4:	50 e0       	ldi	r21, 0x00	; 0
    68e6:	a4 0e       	add	r10, r20
    68e8:	b5 1e       	adc	r11, r21
    68ea:	a1 01       	movw	r20, r2
    68ec:	0e 94 43 35 	call	0x6a86	; 0x6a86 <__ultoa_invert>
    68f0:	d8 2e       	mov	r13, r24
    68f2:	d2 18       	sub	r13, r2
    68f4:	8f e7       	ldi	r24, 0x7F	; 127
    68f6:	f8 2e       	mov	r15, r24
    68f8:	f1 22       	and	r15, r17
    68fa:	f6 fe       	sbrs	r15, 6
    68fc:	0b c0       	rjmp	.+22     	; 0x6914 <vfprintf+0x2cc>
    68fe:	5e ef       	ldi	r21, 0xFE	; 254
    6900:	f5 22       	and	r15, r21
    6902:	d9 14       	cp	r13, r9
    6904:	38 f4       	brcc	.+14     	; 0x6914 <vfprintf+0x2cc>
    6906:	f4 fe       	sbrs	r15, 4
    6908:	07 c0       	rjmp	.+14     	; 0x6918 <vfprintf+0x2d0>
    690a:	f2 fc       	sbrc	r15, 2
    690c:	05 c0       	rjmp	.+10     	; 0x6918 <vfprintf+0x2d0>
    690e:	8f ee       	ldi	r24, 0xEF	; 239
    6910:	f8 22       	and	r15, r24
    6912:	02 c0       	rjmp	.+4      	; 0x6918 <vfprintf+0x2d0>
    6914:	1d 2d       	mov	r17, r13
    6916:	01 c0       	rjmp	.+2      	; 0x691a <vfprintf+0x2d2>
    6918:	19 2d       	mov	r17, r9
    691a:	f4 fe       	sbrs	r15, 4
    691c:	0d c0       	rjmp	.+26     	; 0x6938 <vfprintf+0x2f0>
    691e:	fe 01       	movw	r30, r28
    6920:	ed 0d       	add	r30, r13
    6922:	f1 1d       	adc	r31, r1
    6924:	80 81       	ld	r24, Z
    6926:	80 33       	cpi	r24, 0x30	; 48
    6928:	19 f4       	brne	.+6      	; 0x6930 <vfprintf+0x2e8>
    692a:	99 ee       	ldi	r25, 0xE9	; 233
    692c:	f9 22       	and	r15, r25
    692e:	08 c0       	rjmp	.+16     	; 0x6940 <vfprintf+0x2f8>
    6930:	1f 5f       	subi	r17, 0xFF	; 255
    6932:	f2 fe       	sbrs	r15, 2
    6934:	05 c0       	rjmp	.+10     	; 0x6940 <vfprintf+0x2f8>
    6936:	03 c0       	rjmp	.+6      	; 0x693e <vfprintf+0x2f6>
    6938:	8f 2d       	mov	r24, r15
    693a:	86 78       	andi	r24, 0x86	; 134
    693c:	09 f0       	breq	.+2      	; 0x6940 <vfprintf+0x2f8>
    693e:	1f 5f       	subi	r17, 0xFF	; 255
    6940:	0f 2d       	mov	r16, r15
    6942:	f3 fc       	sbrc	r15, 3
    6944:	14 c0       	rjmp	.+40     	; 0x696e <vfprintf+0x326>
    6946:	f0 fe       	sbrs	r15, 0
    6948:	0f c0       	rjmp	.+30     	; 0x6968 <vfprintf+0x320>
    694a:	1e 15       	cp	r17, r14
    694c:	10 f0       	brcs	.+4      	; 0x6952 <vfprintf+0x30a>
    694e:	9d 2c       	mov	r9, r13
    6950:	0b c0       	rjmp	.+22     	; 0x6968 <vfprintf+0x320>
    6952:	9d 2c       	mov	r9, r13
    6954:	9e 0c       	add	r9, r14
    6956:	91 1a       	sub	r9, r17
    6958:	1e 2d       	mov	r17, r14
    695a:	06 c0       	rjmp	.+12     	; 0x6968 <vfprintf+0x320>
    695c:	80 e2       	ldi	r24, 0x20	; 32
    695e:	90 e0       	ldi	r25, 0x00	; 0
    6960:	b3 01       	movw	r22, r6
    6962:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <fputc>
    6966:	1f 5f       	subi	r17, 0xFF	; 255
    6968:	1e 15       	cp	r17, r14
    696a:	c0 f3       	brcs	.-16     	; 0x695c <vfprintf+0x314>
    696c:	04 c0       	rjmp	.+8      	; 0x6976 <vfprintf+0x32e>
    696e:	1e 15       	cp	r17, r14
    6970:	10 f4       	brcc	.+4      	; 0x6976 <vfprintf+0x32e>
    6972:	e1 1a       	sub	r14, r17
    6974:	01 c0       	rjmp	.+2      	; 0x6978 <vfprintf+0x330>
    6976:	ee 24       	eor	r14, r14
    6978:	04 ff       	sbrs	r16, 4
    697a:	0f c0       	rjmp	.+30     	; 0x699a <vfprintf+0x352>
    697c:	80 e3       	ldi	r24, 0x30	; 48
    697e:	90 e0       	ldi	r25, 0x00	; 0
    6980:	b3 01       	movw	r22, r6
    6982:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <fputc>
    6986:	02 ff       	sbrs	r16, 2
    6988:	1d c0       	rjmp	.+58     	; 0x69c4 <vfprintf+0x37c>
    698a:	01 fd       	sbrc	r16, 1
    698c:	03 c0       	rjmp	.+6      	; 0x6994 <vfprintf+0x34c>
    698e:	88 e7       	ldi	r24, 0x78	; 120
    6990:	90 e0       	ldi	r25, 0x00	; 0
    6992:	0e c0       	rjmp	.+28     	; 0x69b0 <vfprintf+0x368>
    6994:	88 e5       	ldi	r24, 0x58	; 88
    6996:	90 e0       	ldi	r25, 0x00	; 0
    6998:	0b c0       	rjmp	.+22     	; 0x69b0 <vfprintf+0x368>
    699a:	80 2f       	mov	r24, r16
    699c:	86 78       	andi	r24, 0x86	; 134
    699e:	91 f0       	breq	.+36     	; 0x69c4 <vfprintf+0x37c>
    69a0:	01 ff       	sbrs	r16, 1
    69a2:	02 c0       	rjmp	.+4      	; 0x69a8 <vfprintf+0x360>
    69a4:	8b e2       	ldi	r24, 0x2B	; 43
    69a6:	01 c0       	rjmp	.+2      	; 0x69aa <vfprintf+0x362>
    69a8:	80 e2       	ldi	r24, 0x20	; 32
    69aa:	f7 fc       	sbrc	r15, 7
    69ac:	8d e2       	ldi	r24, 0x2D	; 45
    69ae:	90 e0       	ldi	r25, 0x00	; 0
    69b0:	b3 01       	movw	r22, r6
    69b2:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <fputc>
    69b6:	06 c0       	rjmp	.+12     	; 0x69c4 <vfprintf+0x37c>
    69b8:	80 e3       	ldi	r24, 0x30	; 48
    69ba:	90 e0       	ldi	r25, 0x00	; 0
    69bc:	b3 01       	movw	r22, r6
    69be:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <fputc>
    69c2:	9a 94       	dec	r9
    69c4:	d9 14       	cp	r13, r9
    69c6:	c0 f3       	brcs	.-16     	; 0x69b8 <vfprintf+0x370>
    69c8:	da 94       	dec	r13
    69ca:	f1 01       	movw	r30, r2
    69cc:	ed 0d       	add	r30, r13
    69ce:	f1 1d       	adc	r31, r1
    69d0:	80 81       	ld	r24, Z
    69d2:	90 e0       	ldi	r25, 0x00	; 0
    69d4:	b3 01       	movw	r22, r6
    69d6:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <fputc>
    69da:	dd 20       	and	r13, r13
    69dc:	a9 f7       	brne	.-22     	; 0x69c8 <vfprintf+0x380>
    69de:	06 c0       	rjmp	.+12     	; 0x69ec <vfprintf+0x3a4>
    69e0:	80 e2       	ldi	r24, 0x20	; 32
    69e2:	90 e0       	ldi	r25, 0x00	; 0
    69e4:	b3 01       	movw	r22, r6
    69e6:	0e 94 17 35 	call	0x6a2e	; 0x6a2e <fputc>
    69ea:	ea 94       	dec	r14
    69ec:	ee 20       	and	r14, r14
    69ee:	c1 f7       	brne	.-16     	; 0x69e0 <vfprintf+0x398>
    69f0:	43 ce       	rjmp	.-890    	; 0x6678 <vfprintf+0x30>
    69f2:	f3 01       	movw	r30, r6
    69f4:	66 81       	ldd	r22, Z+6	; 0x06
    69f6:	77 81       	ldd	r23, Z+7	; 0x07
    69f8:	cb 01       	movw	r24, r22
    69fa:	2b 96       	adiw	r28, 0x0b	; 11
    69fc:	e2 e1       	ldi	r30, 0x12	; 18
    69fe:	0c 94 a4 31 	jmp	0x6348	; 0x6348 <__epilogue_restores__>

00006a02 <strnlen_P>:
    6a02:	fc 01       	movw	r30, r24
    6a04:	05 90       	lpm	r0, Z+
    6a06:	61 50       	subi	r22, 0x01	; 1
    6a08:	70 40       	sbci	r23, 0x00	; 0
    6a0a:	01 10       	cpse	r0, r1
    6a0c:	d8 f7       	brcc	.-10     	; 0x6a04 <strnlen_P+0x2>
    6a0e:	80 95       	com	r24
    6a10:	90 95       	com	r25
    6a12:	8e 0f       	add	r24, r30
    6a14:	9f 1f       	adc	r25, r31
    6a16:	08 95       	ret

00006a18 <strnlen>:
    6a18:	fc 01       	movw	r30, r24
    6a1a:	61 50       	subi	r22, 0x01	; 1
    6a1c:	70 40       	sbci	r23, 0x00	; 0
    6a1e:	01 90       	ld	r0, Z+
    6a20:	01 10       	cpse	r0, r1
    6a22:	d8 f7       	brcc	.-10     	; 0x6a1a <strnlen+0x2>
    6a24:	80 95       	com	r24
    6a26:	90 95       	com	r25
    6a28:	8e 0f       	add	r24, r30
    6a2a:	9f 1f       	adc	r25, r31
    6a2c:	08 95       	ret

00006a2e <fputc>:
    6a2e:	0f 93       	push	r16
    6a30:	1f 93       	push	r17
    6a32:	cf 93       	push	r28
    6a34:	df 93       	push	r29
    6a36:	8c 01       	movw	r16, r24
    6a38:	eb 01       	movw	r28, r22
    6a3a:	8b 81       	ldd	r24, Y+3	; 0x03
    6a3c:	81 ff       	sbrs	r24, 1
    6a3e:	1b c0       	rjmp	.+54     	; 0x6a76 <fputc+0x48>
    6a40:	82 ff       	sbrs	r24, 2
    6a42:	0d c0       	rjmp	.+26     	; 0x6a5e <fputc+0x30>
    6a44:	2e 81       	ldd	r18, Y+6	; 0x06
    6a46:	3f 81       	ldd	r19, Y+7	; 0x07
    6a48:	8c 81       	ldd	r24, Y+4	; 0x04
    6a4a:	9d 81       	ldd	r25, Y+5	; 0x05
    6a4c:	28 17       	cp	r18, r24
    6a4e:	39 07       	cpc	r19, r25
    6a50:	64 f4       	brge	.+24     	; 0x6a6a <fputc+0x3c>
    6a52:	e8 81       	ld	r30, Y
    6a54:	f9 81       	ldd	r31, Y+1	; 0x01
    6a56:	01 93       	st	Z+, r16
    6a58:	f9 83       	std	Y+1, r31	; 0x01
    6a5a:	e8 83       	st	Y, r30
    6a5c:	06 c0       	rjmp	.+12     	; 0x6a6a <fputc+0x3c>
    6a5e:	e8 85       	ldd	r30, Y+8	; 0x08
    6a60:	f9 85       	ldd	r31, Y+9	; 0x09
    6a62:	80 2f       	mov	r24, r16
    6a64:	09 95       	icall
    6a66:	89 2b       	or	r24, r25
    6a68:	31 f4       	brne	.+12     	; 0x6a76 <fputc+0x48>
    6a6a:	8e 81       	ldd	r24, Y+6	; 0x06
    6a6c:	9f 81       	ldd	r25, Y+7	; 0x07
    6a6e:	01 96       	adiw	r24, 0x01	; 1
    6a70:	9f 83       	std	Y+7, r25	; 0x07
    6a72:	8e 83       	std	Y+6, r24	; 0x06
    6a74:	02 c0       	rjmp	.+4      	; 0x6a7a <fputc+0x4c>
    6a76:	0f ef       	ldi	r16, 0xFF	; 255
    6a78:	1f ef       	ldi	r17, 0xFF	; 255
    6a7a:	c8 01       	movw	r24, r16
    6a7c:	df 91       	pop	r29
    6a7e:	cf 91       	pop	r28
    6a80:	1f 91       	pop	r17
    6a82:	0f 91       	pop	r16
    6a84:	08 95       	ret

00006a86 <__ultoa_invert>:
    6a86:	fa 01       	movw	r30, r20
    6a88:	aa 27       	eor	r26, r26
    6a8a:	28 30       	cpi	r18, 0x08	; 8
    6a8c:	51 f1       	breq	.+84     	; 0x6ae2 <__ultoa_invert+0x5c>
    6a8e:	20 31       	cpi	r18, 0x10	; 16
    6a90:	81 f1       	breq	.+96     	; 0x6af2 <__ultoa_invert+0x6c>
    6a92:	e8 94       	clt
    6a94:	6f 93       	push	r22
    6a96:	6e 7f       	andi	r22, 0xFE	; 254
    6a98:	6e 5f       	subi	r22, 0xFE	; 254
    6a9a:	7f 4f       	sbci	r23, 0xFF	; 255
    6a9c:	8f 4f       	sbci	r24, 0xFF	; 255
    6a9e:	9f 4f       	sbci	r25, 0xFF	; 255
    6aa0:	af 4f       	sbci	r26, 0xFF	; 255
    6aa2:	b1 e0       	ldi	r27, 0x01	; 1
    6aa4:	3e d0       	rcall	.+124    	; 0x6b22 <__ultoa_invert+0x9c>
    6aa6:	b4 e0       	ldi	r27, 0x04	; 4
    6aa8:	3c d0       	rcall	.+120    	; 0x6b22 <__ultoa_invert+0x9c>
    6aaa:	67 0f       	add	r22, r23
    6aac:	78 1f       	adc	r23, r24
    6aae:	89 1f       	adc	r24, r25
    6ab0:	9a 1f       	adc	r25, r26
    6ab2:	a1 1d       	adc	r26, r1
    6ab4:	68 0f       	add	r22, r24
    6ab6:	79 1f       	adc	r23, r25
    6ab8:	8a 1f       	adc	r24, r26
    6aba:	91 1d       	adc	r25, r1
    6abc:	a1 1d       	adc	r26, r1
    6abe:	6a 0f       	add	r22, r26
    6ac0:	71 1d       	adc	r23, r1
    6ac2:	81 1d       	adc	r24, r1
    6ac4:	91 1d       	adc	r25, r1
    6ac6:	a1 1d       	adc	r26, r1
    6ac8:	20 d0       	rcall	.+64     	; 0x6b0a <__ultoa_invert+0x84>
    6aca:	09 f4       	brne	.+2      	; 0x6ace <__ultoa_invert+0x48>
    6acc:	68 94       	set
    6ace:	3f 91       	pop	r19
    6ad0:	2a e0       	ldi	r18, 0x0A	; 10
    6ad2:	26 9f       	mul	r18, r22
    6ad4:	11 24       	eor	r1, r1
    6ad6:	30 19       	sub	r19, r0
    6ad8:	30 5d       	subi	r19, 0xD0	; 208
    6ada:	31 93       	st	Z+, r19
    6adc:	de f6       	brtc	.-74     	; 0x6a94 <__ultoa_invert+0xe>
    6ade:	cf 01       	movw	r24, r30
    6ae0:	08 95       	ret
    6ae2:	46 2f       	mov	r20, r22
    6ae4:	47 70       	andi	r20, 0x07	; 7
    6ae6:	40 5d       	subi	r20, 0xD0	; 208
    6ae8:	41 93       	st	Z+, r20
    6aea:	b3 e0       	ldi	r27, 0x03	; 3
    6aec:	0f d0       	rcall	.+30     	; 0x6b0c <__ultoa_invert+0x86>
    6aee:	c9 f7       	brne	.-14     	; 0x6ae2 <__ultoa_invert+0x5c>
    6af0:	f6 cf       	rjmp	.-20     	; 0x6ade <__ultoa_invert+0x58>
    6af2:	46 2f       	mov	r20, r22
    6af4:	4f 70       	andi	r20, 0x0F	; 15
    6af6:	40 5d       	subi	r20, 0xD0	; 208
    6af8:	4a 33       	cpi	r20, 0x3A	; 58
    6afa:	18 f0       	brcs	.+6      	; 0x6b02 <__ultoa_invert+0x7c>
    6afc:	49 5d       	subi	r20, 0xD9	; 217
    6afe:	31 fd       	sbrc	r19, 1
    6b00:	40 52       	subi	r20, 0x20	; 32
    6b02:	41 93       	st	Z+, r20
    6b04:	02 d0       	rcall	.+4      	; 0x6b0a <__ultoa_invert+0x84>
    6b06:	a9 f7       	brne	.-22     	; 0x6af2 <__ultoa_invert+0x6c>
    6b08:	ea cf       	rjmp	.-44     	; 0x6ade <__ultoa_invert+0x58>
    6b0a:	b4 e0       	ldi	r27, 0x04	; 4
    6b0c:	a6 95       	lsr	r26
    6b0e:	97 95       	ror	r25
    6b10:	87 95       	ror	r24
    6b12:	77 95       	ror	r23
    6b14:	67 95       	ror	r22
    6b16:	ba 95       	dec	r27
    6b18:	c9 f7       	brne	.-14     	; 0x6b0c <__ultoa_invert+0x86>
    6b1a:	00 97       	sbiw	r24, 0x00	; 0
    6b1c:	61 05       	cpc	r22, r1
    6b1e:	71 05       	cpc	r23, r1
    6b20:	08 95       	ret
    6b22:	9b 01       	movw	r18, r22
    6b24:	ac 01       	movw	r20, r24
    6b26:	0a 2e       	mov	r0, r26
    6b28:	06 94       	lsr	r0
    6b2a:	57 95       	ror	r21
    6b2c:	47 95       	ror	r20
    6b2e:	37 95       	ror	r19
    6b30:	27 95       	ror	r18
    6b32:	ba 95       	dec	r27
    6b34:	c9 f7       	brne	.-14     	; 0x6b28 <__ultoa_invert+0xa2>
    6b36:	62 0f       	add	r22, r18
    6b38:	73 1f       	adc	r23, r19
    6b3a:	84 1f       	adc	r24, r20
    6b3c:	95 1f       	adc	r25, r21
    6b3e:	a0 1d       	adc	r26, r0
    6b40:	08 95       	ret

00006b42 <_exit>:
    6b42:	f8 94       	cli

00006b44 <__stop_program>:
    6b44:	ff cf       	rjmp	.-2      	; 0x6b44 <__stop_program>


AVR_DRIVERS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006ad8  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000152  00800060  00006ad8  00006b6c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006a1  008001b2  008001b2  00006cbe  2**0
                  ALLOC
  3 .stab         0000cd2c  00000000  00000000  00006cc0  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00007a07  00000000  00000000  000139ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001c0  00000000  00000000  0001b3f3  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000214  00000000  00000000  0001b5b3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002612  00000000  00000000  0001b7c7  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000014ce  00000000  00000000  0001ddd9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000130b  00000000  00000000  0001f2a7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001e0  00000000  00000000  000205b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000307  00000000  00000000  00020794  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000a1a  00000000  00000000  00020a9b  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  000214b5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 b8 0f 	jmp	0x1f70	; 0x1f70 <__vector_1>
       8:	0c 94 e1 0f 	jmp	0x1fc2	; 0x1fc2 <__vector_2>
       c:	0c 94 0a 10 	jmp	0x2014	; 0x2014 <__vector_3>
      10:	0c 94 d4 0a 	jmp	0x15a8	; 0x15a8 <__vector_4>
      14:	0c 94 9f 0a 	jmp	0x153e	; 0x153e <__vector_5>
      18:	0c 94 9e 0e 	jmp	0x1d3c	; 0x1d3c <__vector_6>
      1c:	0c 94 5c 19 	jmp	0x32b8	; 0x32b8 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 17 0c 	jmp	0x182e	; 0x182e <__vector_10>
      2c:	0c 94 de 0b 	jmp	0x17bc	; 0x17bc <__vector_11>
      30:	0c 94 8d 0c 	jmp	0x191a	; 0x191a <__vector_12>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 ed       	ldi	r30, 0xD8	; 216
      68:	fa e6       	ldi	r31, 0x6A	; 106
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 3b       	cpi	r26, 0xB2	; 178
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	18 e0       	ldi	r17, 0x08	; 8
      78:	a2 eb       	ldi	r26, 0xB2	; 178
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a3 35       	cpi	r26, 0x53	; 83
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 d3 17 	call	0x2fa6	; 0x2fa6 <main>
      8a:	0c 94 6a 35 	jmp	0x6ad4	; 0x6ad4 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 b3 04 	call	0x966	; 0x966 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 b3 04 	call	0x966	; 0x966 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 51 31 	jmp	0x62a2	; 0x62a2 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a8 e6       	ldi	r26, 0x68	; 104
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 6d 31 	jmp	0x62da	; 0x62da <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 5d 31 	jmp	0x62ba	; 0x62ba <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 79 31 	jmp	0x62f2	; 0x62f2 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 5d 31 	jmp	0x62ba	; 0x62ba <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 79 31 	jmp	0x62f2	; 0x62f2 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 51 31 	jmp	0x62a2	; 0x62a2 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	88 e6       	ldi	r24, 0x68	; 104
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 6d 31 	jmp	0x62da	; 0x62da <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 59 31 	jmp	0x62b2	; 0x62b2 <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	68 e6       	ldi	r22, 0x68	; 104
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 75 31 	jmp	0x62ea	; 0x62ea <__epilogue_restores__+0x10>

0000078a <__eqsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 5d 31 	jmp	0x62ba	; 0x62ba <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__eqsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__eqsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 1c 07 	call	0xe38	; 0xe38 <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__eqsf2+0x58>
     7e0:	81 e0       	ldi	r24, 0x01	; 1
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 79 31 	jmp	0x62f2	; 0x62f2 <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 5d 31 	jmp	0x62ba	; 0x62ba <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 1c 07 	call	0xe38	; 0xe38 <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 79 31 	jmp	0x62f2	; 0x62f2 <__epilogue_restores__+0x18>

0000084a <__lesf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 5d 31 	jmp	0x62ba	; 0x62ba <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 1c 07 	call	0xe38	; 0xe38 <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 79 31 	jmp	0x62f2	; 0x62f2 <__epilogue_restores__+0x18>

000008aa <__floatsisf>:
     8aa:	a8 e0       	ldi	r26, 0x08	; 8
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 5a 31 	jmp	0x62b4	; 0x62b4 <__prologue_saves__+0x12>
     8b6:	9b 01       	movw	r18, r22
     8b8:	ac 01       	movw	r20, r24
     8ba:	83 e0       	ldi	r24, 0x03	; 3
     8bc:	89 83       	std	Y+1, r24	; 0x01
     8be:	da 01       	movw	r26, r20
     8c0:	c9 01       	movw	r24, r18
     8c2:	88 27       	eor	r24, r24
     8c4:	b7 fd       	sbrc	r27, 7
     8c6:	83 95       	inc	r24
     8c8:	99 27       	eor	r25, r25
     8ca:	aa 27       	eor	r26, r26
     8cc:	bb 27       	eor	r27, r27
     8ce:	b8 2e       	mov	r11, r24
     8d0:	21 15       	cp	r18, r1
     8d2:	31 05       	cpc	r19, r1
     8d4:	41 05       	cpc	r20, r1
     8d6:	51 05       	cpc	r21, r1
     8d8:	19 f4       	brne	.+6      	; 0x8e0 <__floatsisf+0x36>
     8da:	82 e0       	ldi	r24, 0x02	; 2
     8dc:	89 83       	std	Y+1, r24	; 0x01
     8de:	3a c0       	rjmp	.+116    	; 0x954 <__floatsisf+0xaa>
     8e0:	88 23       	and	r24, r24
     8e2:	a9 f0       	breq	.+42     	; 0x90e <__floatsisf+0x64>
     8e4:	20 30       	cpi	r18, 0x00	; 0
     8e6:	80 e0       	ldi	r24, 0x00	; 0
     8e8:	38 07       	cpc	r19, r24
     8ea:	80 e0       	ldi	r24, 0x00	; 0
     8ec:	48 07       	cpc	r20, r24
     8ee:	80 e8       	ldi	r24, 0x80	; 128
     8f0:	58 07       	cpc	r21, r24
     8f2:	29 f4       	brne	.+10     	; 0x8fe <__floatsisf+0x54>
     8f4:	60 e0       	ldi	r22, 0x00	; 0
     8f6:	70 e0       	ldi	r23, 0x00	; 0
     8f8:	80 e0       	ldi	r24, 0x00	; 0
     8fa:	9f ec       	ldi	r25, 0xCF	; 207
     8fc:	30 c0       	rjmp	.+96     	; 0x95e <__floatsisf+0xb4>
     8fe:	ee 24       	eor	r14, r14
     900:	ff 24       	eor	r15, r15
     902:	87 01       	movw	r16, r14
     904:	e2 1a       	sub	r14, r18
     906:	f3 0a       	sbc	r15, r19
     908:	04 0b       	sbc	r16, r20
     90a:	15 0b       	sbc	r17, r21
     90c:	02 c0       	rjmp	.+4      	; 0x912 <__floatsisf+0x68>
     90e:	79 01       	movw	r14, r18
     910:	8a 01       	movw	r16, r20
     912:	8e e1       	ldi	r24, 0x1E	; 30
     914:	c8 2e       	mov	r12, r24
     916:	d1 2c       	mov	r13, r1
     918:	dc 82       	std	Y+4, r13	; 0x04
     91a:	cb 82       	std	Y+3, r12	; 0x03
     91c:	ed 82       	std	Y+5, r14	; 0x05
     91e:	fe 82       	std	Y+6, r15	; 0x06
     920:	0f 83       	std	Y+7, r16	; 0x07
     922:	18 87       	std	Y+8, r17	; 0x08
     924:	c8 01       	movw	r24, r16
     926:	b7 01       	movw	r22, r14
     928:	0e 94 80 05 	call	0xb00	; 0xb00 <__clzsi2>
     92c:	01 97       	sbiw	r24, 0x01	; 1
     92e:	18 16       	cp	r1, r24
     930:	19 06       	cpc	r1, r25
     932:	84 f4       	brge	.+32     	; 0x954 <__floatsisf+0xaa>
     934:	08 2e       	mov	r0, r24
     936:	04 c0       	rjmp	.+8      	; 0x940 <__floatsisf+0x96>
     938:	ee 0c       	add	r14, r14
     93a:	ff 1c       	adc	r15, r15
     93c:	00 1f       	adc	r16, r16
     93e:	11 1f       	adc	r17, r17
     940:	0a 94       	dec	r0
     942:	d2 f7       	brpl	.-12     	; 0x938 <__floatsisf+0x8e>
     944:	ed 82       	std	Y+5, r14	; 0x05
     946:	fe 82       	std	Y+6, r15	; 0x06
     948:	0f 83       	std	Y+7, r16	; 0x07
     94a:	18 87       	std	Y+8, r17	; 0x08
     94c:	c8 1a       	sub	r12, r24
     94e:	d9 0a       	sbc	r13, r25
     950:	dc 82       	std	Y+4, r13	; 0x04
     952:	cb 82       	std	Y+3, r12	; 0x03
     954:	ba 82       	std	Y+2, r11	; 0x02
     956:	ce 01       	movw	r24, r28
     958:	01 96       	adiw	r24, 0x01	; 1
     95a:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     95e:	28 96       	adiw	r28, 0x08	; 8
     960:	e9 e0       	ldi	r30, 0x09	; 9
     962:	0c 94 76 31 	jmp	0x62ec	; 0x62ec <__epilogue_restores__+0x12>

00000966 <__fixsfsi>:
     966:	ac e0       	ldi	r26, 0x0C	; 12
     968:	b0 e0       	ldi	r27, 0x00	; 0
     96a:	e9 eb       	ldi	r30, 0xB9	; 185
     96c:	f4 e0       	ldi	r31, 0x04	; 4
     96e:	0c 94 61 31 	jmp	0x62c2	; 0x62c2 <__prologue_saves__+0x20>
     972:	69 83       	std	Y+1, r22	; 0x01
     974:	7a 83       	std	Y+2, r23	; 0x02
     976:	8b 83       	std	Y+3, r24	; 0x03
     978:	9c 83       	std	Y+4, r25	; 0x04
     97a:	ce 01       	movw	r24, r28
     97c:	01 96       	adiw	r24, 0x01	; 1
     97e:	be 01       	movw	r22, r28
     980:	6b 5f       	subi	r22, 0xFB	; 251
     982:	7f 4f       	sbci	r23, 0xFF	; 255
     984:	0e 94 a4 06 	call	0xd48	; 0xd48 <__unpack_f>
     988:	8d 81       	ldd	r24, Y+5	; 0x05
     98a:	82 30       	cpi	r24, 0x02	; 2
     98c:	61 f1       	breq	.+88     	; 0x9e6 <__fixsfsi+0x80>
     98e:	82 30       	cpi	r24, 0x02	; 2
     990:	50 f1       	brcs	.+84     	; 0x9e6 <__fixsfsi+0x80>
     992:	84 30       	cpi	r24, 0x04	; 4
     994:	21 f4       	brne	.+8      	; 0x99e <__fixsfsi+0x38>
     996:	8e 81       	ldd	r24, Y+6	; 0x06
     998:	88 23       	and	r24, r24
     99a:	51 f1       	breq	.+84     	; 0x9f0 <__fixsfsi+0x8a>
     99c:	2e c0       	rjmp	.+92     	; 0x9fa <__fixsfsi+0x94>
     99e:	2f 81       	ldd	r18, Y+7	; 0x07
     9a0:	38 85       	ldd	r19, Y+8	; 0x08
     9a2:	37 fd       	sbrc	r19, 7
     9a4:	20 c0       	rjmp	.+64     	; 0x9e6 <__fixsfsi+0x80>
     9a6:	6e 81       	ldd	r22, Y+6	; 0x06
     9a8:	2f 31       	cpi	r18, 0x1F	; 31
     9aa:	31 05       	cpc	r19, r1
     9ac:	1c f0       	brlt	.+6      	; 0x9b4 <__fixsfsi+0x4e>
     9ae:	66 23       	and	r22, r22
     9b0:	f9 f0       	breq	.+62     	; 0x9f0 <__fixsfsi+0x8a>
     9b2:	23 c0       	rjmp	.+70     	; 0x9fa <__fixsfsi+0x94>
     9b4:	8e e1       	ldi	r24, 0x1E	; 30
     9b6:	90 e0       	ldi	r25, 0x00	; 0
     9b8:	82 1b       	sub	r24, r18
     9ba:	93 0b       	sbc	r25, r19
     9bc:	29 85       	ldd	r18, Y+9	; 0x09
     9be:	3a 85       	ldd	r19, Y+10	; 0x0a
     9c0:	4b 85       	ldd	r20, Y+11	; 0x0b
     9c2:	5c 85       	ldd	r21, Y+12	; 0x0c
     9c4:	04 c0       	rjmp	.+8      	; 0x9ce <__fixsfsi+0x68>
     9c6:	56 95       	lsr	r21
     9c8:	47 95       	ror	r20
     9ca:	37 95       	ror	r19
     9cc:	27 95       	ror	r18
     9ce:	8a 95       	dec	r24
     9d0:	d2 f7       	brpl	.-12     	; 0x9c6 <__fixsfsi+0x60>
     9d2:	66 23       	and	r22, r22
     9d4:	b1 f0       	breq	.+44     	; 0xa02 <__fixsfsi+0x9c>
     9d6:	50 95       	com	r21
     9d8:	40 95       	com	r20
     9da:	30 95       	com	r19
     9dc:	21 95       	neg	r18
     9de:	3f 4f       	sbci	r19, 0xFF	; 255
     9e0:	4f 4f       	sbci	r20, 0xFF	; 255
     9e2:	5f 4f       	sbci	r21, 0xFF	; 255
     9e4:	0e c0       	rjmp	.+28     	; 0xa02 <__fixsfsi+0x9c>
     9e6:	20 e0       	ldi	r18, 0x00	; 0
     9e8:	30 e0       	ldi	r19, 0x00	; 0
     9ea:	40 e0       	ldi	r20, 0x00	; 0
     9ec:	50 e0       	ldi	r21, 0x00	; 0
     9ee:	09 c0       	rjmp	.+18     	; 0xa02 <__fixsfsi+0x9c>
     9f0:	2f ef       	ldi	r18, 0xFF	; 255
     9f2:	3f ef       	ldi	r19, 0xFF	; 255
     9f4:	4f ef       	ldi	r20, 0xFF	; 255
     9f6:	5f e7       	ldi	r21, 0x7F	; 127
     9f8:	04 c0       	rjmp	.+8      	; 0xa02 <__fixsfsi+0x9c>
     9fa:	20 e0       	ldi	r18, 0x00	; 0
     9fc:	30 e0       	ldi	r19, 0x00	; 0
     9fe:	40 e0       	ldi	r20, 0x00	; 0
     a00:	50 e8       	ldi	r21, 0x80	; 128
     a02:	b9 01       	movw	r22, r18
     a04:	ca 01       	movw	r24, r20
     a06:	2c 96       	adiw	r28, 0x0c	; 12
     a08:	e2 e0       	ldi	r30, 0x02	; 2
     a0a:	0c 94 7d 31 	jmp	0x62fa	; 0x62fa <__epilogue_restores__+0x20>

00000a0e <__floatunsisf>:
     a0e:	a8 e0       	ldi	r26, 0x08	; 8
     a10:	b0 e0       	ldi	r27, 0x00	; 0
     a12:	ed e0       	ldi	r30, 0x0D	; 13
     a14:	f5 e0       	ldi	r31, 0x05	; 5
     a16:	0c 94 59 31 	jmp	0x62b2	; 0x62b2 <__prologue_saves__+0x10>
     a1a:	7b 01       	movw	r14, r22
     a1c:	8c 01       	movw	r16, r24
     a1e:	61 15       	cp	r22, r1
     a20:	71 05       	cpc	r23, r1
     a22:	81 05       	cpc	r24, r1
     a24:	91 05       	cpc	r25, r1
     a26:	19 f4       	brne	.+6      	; 0xa2e <__floatunsisf+0x20>
     a28:	82 e0       	ldi	r24, 0x02	; 2
     a2a:	89 83       	std	Y+1, r24	; 0x01
     a2c:	60 c0       	rjmp	.+192    	; 0xaee <__floatunsisf+0xe0>
     a2e:	83 e0       	ldi	r24, 0x03	; 3
     a30:	89 83       	std	Y+1, r24	; 0x01
     a32:	8e e1       	ldi	r24, 0x1E	; 30
     a34:	c8 2e       	mov	r12, r24
     a36:	d1 2c       	mov	r13, r1
     a38:	dc 82       	std	Y+4, r13	; 0x04
     a3a:	cb 82       	std	Y+3, r12	; 0x03
     a3c:	ed 82       	std	Y+5, r14	; 0x05
     a3e:	fe 82       	std	Y+6, r15	; 0x06
     a40:	0f 83       	std	Y+7, r16	; 0x07
     a42:	18 87       	std	Y+8, r17	; 0x08
     a44:	c8 01       	movw	r24, r16
     a46:	b7 01       	movw	r22, r14
     a48:	0e 94 80 05 	call	0xb00	; 0xb00 <__clzsi2>
     a4c:	fc 01       	movw	r30, r24
     a4e:	31 97       	sbiw	r30, 0x01	; 1
     a50:	f7 ff       	sbrs	r31, 7
     a52:	3b c0       	rjmp	.+118    	; 0xaca <__floatunsisf+0xbc>
     a54:	22 27       	eor	r18, r18
     a56:	33 27       	eor	r19, r19
     a58:	2e 1b       	sub	r18, r30
     a5a:	3f 0b       	sbc	r19, r31
     a5c:	57 01       	movw	r10, r14
     a5e:	68 01       	movw	r12, r16
     a60:	02 2e       	mov	r0, r18
     a62:	04 c0       	rjmp	.+8      	; 0xa6c <__floatunsisf+0x5e>
     a64:	d6 94       	lsr	r13
     a66:	c7 94       	ror	r12
     a68:	b7 94       	ror	r11
     a6a:	a7 94       	ror	r10
     a6c:	0a 94       	dec	r0
     a6e:	d2 f7       	brpl	.-12     	; 0xa64 <__floatunsisf+0x56>
     a70:	40 e0       	ldi	r20, 0x00	; 0
     a72:	50 e0       	ldi	r21, 0x00	; 0
     a74:	60 e0       	ldi	r22, 0x00	; 0
     a76:	70 e0       	ldi	r23, 0x00	; 0
     a78:	81 e0       	ldi	r24, 0x01	; 1
     a7a:	90 e0       	ldi	r25, 0x00	; 0
     a7c:	a0 e0       	ldi	r26, 0x00	; 0
     a7e:	b0 e0       	ldi	r27, 0x00	; 0
     a80:	04 c0       	rjmp	.+8      	; 0xa8a <__floatunsisf+0x7c>
     a82:	88 0f       	add	r24, r24
     a84:	99 1f       	adc	r25, r25
     a86:	aa 1f       	adc	r26, r26
     a88:	bb 1f       	adc	r27, r27
     a8a:	2a 95       	dec	r18
     a8c:	d2 f7       	brpl	.-12     	; 0xa82 <__floatunsisf+0x74>
     a8e:	01 97       	sbiw	r24, 0x01	; 1
     a90:	a1 09       	sbc	r26, r1
     a92:	b1 09       	sbc	r27, r1
     a94:	8e 21       	and	r24, r14
     a96:	9f 21       	and	r25, r15
     a98:	a0 23       	and	r26, r16
     a9a:	b1 23       	and	r27, r17
     a9c:	00 97       	sbiw	r24, 0x00	; 0
     a9e:	a1 05       	cpc	r26, r1
     aa0:	b1 05       	cpc	r27, r1
     aa2:	21 f0       	breq	.+8      	; 0xaac <__floatunsisf+0x9e>
     aa4:	41 e0       	ldi	r20, 0x01	; 1
     aa6:	50 e0       	ldi	r21, 0x00	; 0
     aa8:	60 e0       	ldi	r22, 0x00	; 0
     aaa:	70 e0       	ldi	r23, 0x00	; 0
     aac:	4a 29       	or	r20, r10
     aae:	5b 29       	or	r21, r11
     ab0:	6c 29       	or	r22, r12
     ab2:	7d 29       	or	r23, r13
     ab4:	4d 83       	std	Y+5, r20	; 0x05
     ab6:	5e 83       	std	Y+6, r21	; 0x06
     ab8:	6f 83       	std	Y+7, r22	; 0x07
     aba:	78 87       	std	Y+8, r23	; 0x08
     abc:	8e e1       	ldi	r24, 0x1E	; 30
     abe:	90 e0       	ldi	r25, 0x00	; 0
     ac0:	8e 1b       	sub	r24, r30
     ac2:	9f 0b       	sbc	r25, r31
     ac4:	9c 83       	std	Y+4, r25	; 0x04
     ac6:	8b 83       	std	Y+3, r24	; 0x03
     ac8:	12 c0       	rjmp	.+36     	; 0xaee <__floatunsisf+0xe0>
     aca:	30 97       	sbiw	r30, 0x00	; 0
     acc:	81 f0       	breq	.+32     	; 0xaee <__floatunsisf+0xe0>
     ace:	0e 2e       	mov	r0, r30
     ad0:	04 c0       	rjmp	.+8      	; 0xada <__floatunsisf+0xcc>
     ad2:	ee 0c       	add	r14, r14
     ad4:	ff 1c       	adc	r15, r15
     ad6:	00 1f       	adc	r16, r16
     ad8:	11 1f       	adc	r17, r17
     ada:	0a 94       	dec	r0
     adc:	d2 f7       	brpl	.-12     	; 0xad2 <__floatunsisf+0xc4>
     ade:	ed 82       	std	Y+5, r14	; 0x05
     ae0:	fe 82       	std	Y+6, r15	; 0x06
     ae2:	0f 83       	std	Y+7, r16	; 0x07
     ae4:	18 87       	std	Y+8, r17	; 0x08
     ae6:	ce 1a       	sub	r12, r30
     ae8:	df 0a       	sbc	r13, r31
     aea:	dc 82       	std	Y+4, r13	; 0x04
     aec:	cb 82       	std	Y+3, r12	; 0x03
     aee:	1a 82       	std	Y+2, r1	; 0x02
     af0:	ce 01       	movw	r24, r28
     af2:	01 96       	adiw	r24, 0x01	; 1
     af4:	0e 94 cf 05 	call	0xb9e	; 0xb9e <__pack_f>
     af8:	28 96       	adiw	r28, 0x08	; 8
     afa:	ea e0       	ldi	r30, 0x0A	; 10
     afc:	0c 94 75 31 	jmp	0x62ea	; 0x62ea <__epilogue_restores__+0x10>

00000b00 <__clzsi2>:
     b00:	ef 92       	push	r14
     b02:	ff 92       	push	r15
     b04:	0f 93       	push	r16
     b06:	1f 93       	push	r17
     b08:	7b 01       	movw	r14, r22
     b0a:	8c 01       	movw	r16, r24
     b0c:	80 e0       	ldi	r24, 0x00	; 0
     b0e:	e8 16       	cp	r14, r24
     b10:	80 e0       	ldi	r24, 0x00	; 0
     b12:	f8 06       	cpc	r15, r24
     b14:	81 e0       	ldi	r24, 0x01	; 1
     b16:	08 07       	cpc	r16, r24
     b18:	80 e0       	ldi	r24, 0x00	; 0
     b1a:	18 07       	cpc	r17, r24
     b1c:	88 f4       	brcc	.+34     	; 0xb40 <__clzsi2+0x40>
     b1e:	8f ef       	ldi	r24, 0xFF	; 255
     b20:	e8 16       	cp	r14, r24
     b22:	f1 04       	cpc	r15, r1
     b24:	01 05       	cpc	r16, r1
     b26:	11 05       	cpc	r17, r1
     b28:	31 f0       	breq	.+12     	; 0xb36 <__clzsi2+0x36>
     b2a:	28 f0       	brcs	.+10     	; 0xb36 <__clzsi2+0x36>
     b2c:	88 e0       	ldi	r24, 0x08	; 8
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	a0 e0       	ldi	r26, 0x00	; 0
     b32:	b0 e0       	ldi	r27, 0x00	; 0
     b34:	17 c0       	rjmp	.+46     	; 0xb64 <__clzsi2+0x64>
     b36:	80 e0       	ldi	r24, 0x00	; 0
     b38:	90 e0       	ldi	r25, 0x00	; 0
     b3a:	a0 e0       	ldi	r26, 0x00	; 0
     b3c:	b0 e0       	ldi	r27, 0x00	; 0
     b3e:	12 c0       	rjmp	.+36     	; 0xb64 <__clzsi2+0x64>
     b40:	80 e0       	ldi	r24, 0x00	; 0
     b42:	e8 16       	cp	r14, r24
     b44:	80 e0       	ldi	r24, 0x00	; 0
     b46:	f8 06       	cpc	r15, r24
     b48:	80 e0       	ldi	r24, 0x00	; 0
     b4a:	08 07       	cpc	r16, r24
     b4c:	81 e0       	ldi	r24, 0x01	; 1
     b4e:	18 07       	cpc	r17, r24
     b50:	28 f0       	brcs	.+10     	; 0xb5c <__clzsi2+0x5c>
     b52:	88 e1       	ldi	r24, 0x18	; 24
     b54:	90 e0       	ldi	r25, 0x00	; 0
     b56:	a0 e0       	ldi	r26, 0x00	; 0
     b58:	b0 e0       	ldi	r27, 0x00	; 0
     b5a:	04 c0       	rjmp	.+8      	; 0xb64 <__clzsi2+0x64>
     b5c:	80 e1       	ldi	r24, 0x10	; 16
     b5e:	90 e0       	ldi	r25, 0x00	; 0
     b60:	a0 e0       	ldi	r26, 0x00	; 0
     b62:	b0 e0       	ldi	r27, 0x00	; 0
     b64:	20 e2       	ldi	r18, 0x20	; 32
     b66:	30 e0       	ldi	r19, 0x00	; 0
     b68:	40 e0       	ldi	r20, 0x00	; 0
     b6a:	50 e0       	ldi	r21, 0x00	; 0
     b6c:	28 1b       	sub	r18, r24
     b6e:	39 0b       	sbc	r19, r25
     b70:	4a 0b       	sbc	r20, r26
     b72:	5b 0b       	sbc	r21, r27
     b74:	04 c0       	rjmp	.+8      	; 0xb7e <__clzsi2+0x7e>
     b76:	16 95       	lsr	r17
     b78:	07 95       	ror	r16
     b7a:	f7 94       	ror	r15
     b7c:	e7 94       	ror	r14
     b7e:	8a 95       	dec	r24
     b80:	d2 f7       	brpl	.-12     	; 0xb76 <__clzsi2+0x76>
     b82:	f7 01       	movw	r30, r14
     b84:	e0 59       	subi	r30, 0x90	; 144
     b86:	ff 4f       	sbci	r31, 0xFF	; 255
     b88:	80 81       	ld	r24, Z
     b8a:	28 1b       	sub	r18, r24
     b8c:	31 09       	sbc	r19, r1
     b8e:	41 09       	sbc	r20, r1
     b90:	51 09       	sbc	r21, r1
     b92:	c9 01       	movw	r24, r18
     b94:	1f 91       	pop	r17
     b96:	0f 91       	pop	r16
     b98:	ff 90       	pop	r15
     b9a:	ef 90       	pop	r14
     b9c:	08 95       	ret

00000b9e <__pack_f>:
     b9e:	df 92       	push	r13
     ba0:	ef 92       	push	r14
     ba2:	ff 92       	push	r15
     ba4:	0f 93       	push	r16
     ba6:	1f 93       	push	r17
     ba8:	fc 01       	movw	r30, r24
     baa:	e4 80       	ldd	r14, Z+4	; 0x04
     bac:	f5 80       	ldd	r15, Z+5	; 0x05
     bae:	06 81       	ldd	r16, Z+6	; 0x06
     bb0:	17 81       	ldd	r17, Z+7	; 0x07
     bb2:	d1 80       	ldd	r13, Z+1	; 0x01
     bb4:	80 81       	ld	r24, Z
     bb6:	82 30       	cpi	r24, 0x02	; 2
     bb8:	48 f4       	brcc	.+18     	; 0xbcc <__pack_f+0x2e>
     bba:	80 e0       	ldi	r24, 0x00	; 0
     bbc:	90 e0       	ldi	r25, 0x00	; 0
     bbe:	a0 e1       	ldi	r26, 0x10	; 16
     bc0:	b0 e0       	ldi	r27, 0x00	; 0
     bc2:	e8 2a       	or	r14, r24
     bc4:	f9 2a       	or	r15, r25
     bc6:	0a 2b       	or	r16, r26
     bc8:	1b 2b       	or	r17, r27
     bca:	a5 c0       	rjmp	.+330    	; 0xd16 <__pack_f+0x178>
     bcc:	84 30       	cpi	r24, 0x04	; 4
     bce:	09 f4       	brne	.+2      	; 0xbd2 <__pack_f+0x34>
     bd0:	9f c0       	rjmp	.+318    	; 0xd10 <__pack_f+0x172>
     bd2:	82 30       	cpi	r24, 0x02	; 2
     bd4:	21 f4       	brne	.+8      	; 0xbde <__pack_f+0x40>
     bd6:	ee 24       	eor	r14, r14
     bd8:	ff 24       	eor	r15, r15
     bda:	87 01       	movw	r16, r14
     bdc:	05 c0       	rjmp	.+10     	; 0xbe8 <__pack_f+0x4a>
     bde:	e1 14       	cp	r14, r1
     be0:	f1 04       	cpc	r15, r1
     be2:	01 05       	cpc	r16, r1
     be4:	11 05       	cpc	r17, r1
     be6:	19 f4       	brne	.+6      	; 0xbee <__pack_f+0x50>
     be8:	e0 e0       	ldi	r30, 0x00	; 0
     bea:	f0 e0       	ldi	r31, 0x00	; 0
     bec:	96 c0       	rjmp	.+300    	; 0xd1a <__pack_f+0x17c>
     bee:	62 81       	ldd	r22, Z+2	; 0x02
     bf0:	73 81       	ldd	r23, Z+3	; 0x03
     bf2:	9f ef       	ldi	r25, 0xFF	; 255
     bf4:	62 38       	cpi	r22, 0x82	; 130
     bf6:	79 07       	cpc	r23, r25
     bf8:	0c f0       	brlt	.+2      	; 0xbfc <__pack_f+0x5e>
     bfa:	5b c0       	rjmp	.+182    	; 0xcb2 <__pack_f+0x114>
     bfc:	22 e8       	ldi	r18, 0x82	; 130
     bfe:	3f ef       	ldi	r19, 0xFF	; 255
     c00:	26 1b       	sub	r18, r22
     c02:	37 0b       	sbc	r19, r23
     c04:	2a 31       	cpi	r18, 0x1A	; 26
     c06:	31 05       	cpc	r19, r1
     c08:	2c f0       	brlt	.+10     	; 0xc14 <__pack_f+0x76>
     c0a:	20 e0       	ldi	r18, 0x00	; 0
     c0c:	30 e0       	ldi	r19, 0x00	; 0
     c0e:	40 e0       	ldi	r20, 0x00	; 0
     c10:	50 e0       	ldi	r21, 0x00	; 0
     c12:	2a c0       	rjmp	.+84     	; 0xc68 <__pack_f+0xca>
     c14:	b8 01       	movw	r22, r16
     c16:	a7 01       	movw	r20, r14
     c18:	02 2e       	mov	r0, r18
     c1a:	04 c0       	rjmp	.+8      	; 0xc24 <__pack_f+0x86>
     c1c:	76 95       	lsr	r23
     c1e:	67 95       	ror	r22
     c20:	57 95       	ror	r21
     c22:	47 95       	ror	r20
     c24:	0a 94       	dec	r0
     c26:	d2 f7       	brpl	.-12     	; 0xc1c <__pack_f+0x7e>
     c28:	81 e0       	ldi	r24, 0x01	; 1
     c2a:	90 e0       	ldi	r25, 0x00	; 0
     c2c:	a0 e0       	ldi	r26, 0x00	; 0
     c2e:	b0 e0       	ldi	r27, 0x00	; 0
     c30:	04 c0       	rjmp	.+8      	; 0xc3a <__pack_f+0x9c>
     c32:	88 0f       	add	r24, r24
     c34:	99 1f       	adc	r25, r25
     c36:	aa 1f       	adc	r26, r26
     c38:	bb 1f       	adc	r27, r27
     c3a:	2a 95       	dec	r18
     c3c:	d2 f7       	brpl	.-12     	; 0xc32 <__pack_f+0x94>
     c3e:	01 97       	sbiw	r24, 0x01	; 1
     c40:	a1 09       	sbc	r26, r1
     c42:	b1 09       	sbc	r27, r1
     c44:	8e 21       	and	r24, r14
     c46:	9f 21       	and	r25, r15
     c48:	a0 23       	and	r26, r16
     c4a:	b1 23       	and	r27, r17
     c4c:	00 97       	sbiw	r24, 0x00	; 0
     c4e:	a1 05       	cpc	r26, r1
     c50:	b1 05       	cpc	r27, r1
     c52:	21 f0       	breq	.+8      	; 0xc5c <__pack_f+0xbe>
     c54:	81 e0       	ldi	r24, 0x01	; 1
     c56:	90 e0       	ldi	r25, 0x00	; 0
     c58:	a0 e0       	ldi	r26, 0x00	; 0
     c5a:	b0 e0       	ldi	r27, 0x00	; 0
     c5c:	9a 01       	movw	r18, r20
     c5e:	ab 01       	movw	r20, r22
     c60:	28 2b       	or	r18, r24
     c62:	39 2b       	or	r19, r25
     c64:	4a 2b       	or	r20, r26
     c66:	5b 2b       	or	r21, r27
     c68:	da 01       	movw	r26, r20
     c6a:	c9 01       	movw	r24, r18
     c6c:	8f 77       	andi	r24, 0x7F	; 127
     c6e:	90 70       	andi	r25, 0x00	; 0
     c70:	a0 70       	andi	r26, 0x00	; 0
     c72:	b0 70       	andi	r27, 0x00	; 0
     c74:	80 34       	cpi	r24, 0x40	; 64
     c76:	91 05       	cpc	r25, r1
     c78:	a1 05       	cpc	r26, r1
     c7a:	b1 05       	cpc	r27, r1
     c7c:	39 f4       	brne	.+14     	; 0xc8c <__pack_f+0xee>
     c7e:	27 ff       	sbrs	r18, 7
     c80:	09 c0       	rjmp	.+18     	; 0xc94 <__pack_f+0xf6>
     c82:	20 5c       	subi	r18, 0xC0	; 192
     c84:	3f 4f       	sbci	r19, 0xFF	; 255
     c86:	4f 4f       	sbci	r20, 0xFF	; 255
     c88:	5f 4f       	sbci	r21, 0xFF	; 255
     c8a:	04 c0       	rjmp	.+8      	; 0xc94 <__pack_f+0xf6>
     c8c:	21 5c       	subi	r18, 0xC1	; 193
     c8e:	3f 4f       	sbci	r19, 0xFF	; 255
     c90:	4f 4f       	sbci	r20, 0xFF	; 255
     c92:	5f 4f       	sbci	r21, 0xFF	; 255
     c94:	e0 e0       	ldi	r30, 0x00	; 0
     c96:	f0 e0       	ldi	r31, 0x00	; 0
     c98:	20 30       	cpi	r18, 0x00	; 0
     c9a:	a0 e0       	ldi	r26, 0x00	; 0
     c9c:	3a 07       	cpc	r19, r26
     c9e:	a0 e0       	ldi	r26, 0x00	; 0
     ca0:	4a 07       	cpc	r20, r26
     ca2:	a0 e4       	ldi	r26, 0x40	; 64
     ca4:	5a 07       	cpc	r21, r26
     ca6:	10 f0       	brcs	.+4      	; 0xcac <__pack_f+0x10e>
     ca8:	e1 e0       	ldi	r30, 0x01	; 1
     caa:	f0 e0       	ldi	r31, 0x00	; 0
     cac:	79 01       	movw	r14, r18
     cae:	8a 01       	movw	r16, r20
     cb0:	27 c0       	rjmp	.+78     	; 0xd00 <__pack_f+0x162>
     cb2:	60 38       	cpi	r22, 0x80	; 128
     cb4:	71 05       	cpc	r23, r1
     cb6:	64 f5       	brge	.+88     	; 0xd10 <__pack_f+0x172>
     cb8:	fb 01       	movw	r30, r22
     cba:	e1 58       	subi	r30, 0x81	; 129
     cbc:	ff 4f       	sbci	r31, 0xFF	; 255
     cbe:	d8 01       	movw	r26, r16
     cc0:	c7 01       	movw	r24, r14
     cc2:	8f 77       	andi	r24, 0x7F	; 127
     cc4:	90 70       	andi	r25, 0x00	; 0
     cc6:	a0 70       	andi	r26, 0x00	; 0
     cc8:	b0 70       	andi	r27, 0x00	; 0
     cca:	80 34       	cpi	r24, 0x40	; 64
     ccc:	91 05       	cpc	r25, r1
     cce:	a1 05       	cpc	r26, r1
     cd0:	b1 05       	cpc	r27, r1
     cd2:	39 f4       	brne	.+14     	; 0xce2 <__pack_f+0x144>
     cd4:	e7 fe       	sbrs	r14, 7
     cd6:	0d c0       	rjmp	.+26     	; 0xcf2 <__pack_f+0x154>
     cd8:	80 e4       	ldi	r24, 0x40	; 64
     cda:	90 e0       	ldi	r25, 0x00	; 0
     cdc:	a0 e0       	ldi	r26, 0x00	; 0
     cde:	b0 e0       	ldi	r27, 0x00	; 0
     ce0:	04 c0       	rjmp	.+8      	; 0xcea <__pack_f+0x14c>
     ce2:	8f e3       	ldi	r24, 0x3F	; 63
     ce4:	90 e0       	ldi	r25, 0x00	; 0
     ce6:	a0 e0       	ldi	r26, 0x00	; 0
     ce8:	b0 e0       	ldi	r27, 0x00	; 0
     cea:	e8 0e       	add	r14, r24
     cec:	f9 1e       	adc	r15, r25
     cee:	0a 1f       	adc	r16, r26
     cf0:	1b 1f       	adc	r17, r27
     cf2:	17 ff       	sbrs	r17, 7
     cf4:	05 c0       	rjmp	.+10     	; 0xd00 <__pack_f+0x162>
     cf6:	16 95       	lsr	r17
     cf8:	07 95       	ror	r16
     cfa:	f7 94       	ror	r15
     cfc:	e7 94       	ror	r14
     cfe:	31 96       	adiw	r30, 0x01	; 1
     d00:	87 e0       	ldi	r24, 0x07	; 7
     d02:	16 95       	lsr	r17
     d04:	07 95       	ror	r16
     d06:	f7 94       	ror	r15
     d08:	e7 94       	ror	r14
     d0a:	8a 95       	dec	r24
     d0c:	d1 f7       	brne	.-12     	; 0xd02 <__pack_f+0x164>
     d0e:	05 c0       	rjmp	.+10     	; 0xd1a <__pack_f+0x17c>
     d10:	ee 24       	eor	r14, r14
     d12:	ff 24       	eor	r15, r15
     d14:	87 01       	movw	r16, r14
     d16:	ef ef       	ldi	r30, 0xFF	; 255
     d18:	f0 e0       	ldi	r31, 0x00	; 0
     d1a:	6e 2f       	mov	r22, r30
     d1c:	67 95       	ror	r22
     d1e:	66 27       	eor	r22, r22
     d20:	67 95       	ror	r22
     d22:	90 2f       	mov	r25, r16
     d24:	9f 77       	andi	r25, 0x7F	; 127
     d26:	d7 94       	ror	r13
     d28:	dd 24       	eor	r13, r13
     d2a:	d7 94       	ror	r13
     d2c:	8e 2f       	mov	r24, r30
     d2e:	86 95       	lsr	r24
     d30:	49 2f       	mov	r20, r25
     d32:	46 2b       	or	r20, r22
     d34:	58 2f       	mov	r21, r24
     d36:	5d 29       	or	r21, r13
     d38:	b7 01       	movw	r22, r14
     d3a:	ca 01       	movw	r24, r20
     d3c:	1f 91       	pop	r17
     d3e:	0f 91       	pop	r16
     d40:	ff 90       	pop	r15
     d42:	ef 90       	pop	r14
     d44:	df 90       	pop	r13
     d46:	08 95       	ret

00000d48 <__unpack_f>:
     d48:	fc 01       	movw	r30, r24
     d4a:	db 01       	movw	r26, r22
     d4c:	40 81       	ld	r20, Z
     d4e:	51 81       	ldd	r21, Z+1	; 0x01
     d50:	22 81       	ldd	r18, Z+2	; 0x02
     d52:	62 2f       	mov	r22, r18
     d54:	6f 77       	andi	r22, 0x7F	; 127
     d56:	70 e0       	ldi	r23, 0x00	; 0
     d58:	22 1f       	adc	r18, r18
     d5a:	22 27       	eor	r18, r18
     d5c:	22 1f       	adc	r18, r18
     d5e:	93 81       	ldd	r25, Z+3	; 0x03
     d60:	89 2f       	mov	r24, r25
     d62:	88 0f       	add	r24, r24
     d64:	82 2b       	or	r24, r18
     d66:	28 2f       	mov	r18, r24
     d68:	30 e0       	ldi	r19, 0x00	; 0
     d6a:	99 1f       	adc	r25, r25
     d6c:	99 27       	eor	r25, r25
     d6e:	99 1f       	adc	r25, r25
     d70:	11 96       	adiw	r26, 0x01	; 1
     d72:	9c 93       	st	X, r25
     d74:	11 97       	sbiw	r26, 0x01	; 1
     d76:	21 15       	cp	r18, r1
     d78:	31 05       	cpc	r19, r1
     d7a:	a9 f5       	brne	.+106    	; 0xde6 <__unpack_f+0x9e>
     d7c:	41 15       	cp	r20, r1
     d7e:	51 05       	cpc	r21, r1
     d80:	61 05       	cpc	r22, r1
     d82:	71 05       	cpc	r23, r1
     d84:	11 f4       	brne	.+4      	; 0xd8a <__unpack_f+0x42>
     d86:	82 e0       	ldi	r24, 0x02	; 2
     d88:	37 c0       	rjmp	.+110    	; 0xdf8 <__unpack_f+0xb0>
     d8a:	82 e8       	ldi	r24, 0x82	; 130
     d8c:	9f ef       	ldi	r25, 0xFF	; 255
     d8e:	13 96       	adiw	r26, 0x03	; 3
     d90:	9c 93       	st	X, r25
     d92:	8e 93       	st	-X, r24
     d94:	12 97       	sbiw	r26, 0x02	; 2
     d96:	9a 01       	movw	r18, r20
     d98:	ab 01       	movw	r20, r22
     d9a:	67 e0       	ldi	r22, 0x07	; 7
     d9c:	22 0f       	add	r18, r18
     d9e:	33 1f       	adc	r19, r19
     da0:	44 1f       	adc	r20, r20
     da2:	55 1f       	adc	r21, r21
     da4:	6a 95       	dec	r22
     da6:	d1 f7       	brne	.-12     	; 0xd9c <__unpack_f+0x54>
     da8:	83 e0       	ldi	r24, 0x03	; 3
     daa:	8c 93       	st	X, r24
     dac:	0d c0       	rjmp	.+26     	; 0xdc8 <__unpack_f+0x80>
     dae:	22 0f       	add	r18, r18
     db0:	33 1f       	adc	r19, r19
     db2:	44 1f       	adc	r20, r20
     db4:	55 1f       	adc	r21, r21
     db6:	12 96       	adiw	r26, 0x02	; 2
     db8:	8d 91       	ld	r24, X+
     dba:	9c 91       	ld	r25, X
     dbc:	13 97       	sbiw	r26, 0x03	; 3
     dbe:	01 97       	sbiw	r24, 0x01	; 1
     dc0:	13 96       	adiw	r26, 0x03	; 3
     dc2:	9c 93       	st	X, r25
     dc4:	8e 93       	st	-X, r24
     dc6:	12 97       	sbiw	r26, 0x02	; 2
     dc8:	20 30       	cpi	r18, 0x00	; 0
     dca:	80 e0       	ldi	r24, 0x00	; 0
     dcc:	38 07       	cpc	r19, r24
     dce:	80 e0       	ldi	r24, 0x00	; 0
     dd0:	48 07       	cpc	r20, r24
     dd2:	80 e4       	ldi	r24, 0x40	; 64
     dd4:	58 07       	cpc	r21, r24
     dd6:	58 f3       	brcs	.-42     	; 0xdae <__unpack_f+0x66>
     dd8:	14 96       	adiw	r26, 0x04	; 4
     dda:	2d 93       	st	X+, r18
     ddc:	3d 93       	st	X+, r19
     dde:	4d 93       	st	X+, r20
     de0:	5c 93       	st	X, r21
     de2:	17 97       	sbiw	r26, 0x07	; 7
     de4:	08 95       	ret
     de6:	2f 3f       	cpi	r18, 0xFF	; 255
     de8:	31 05       	cpc	r19, r1
     dea:	79 f4       	brne	.+30     	; 0xe0a <__unpack_f+0xc2>
     dec:	41 15       	cp	r20, r1
     dee:	51 05       	cpc	r21, r1
     df0:	61 05       	cpc	r22, r1
     df2:	71 05       	cpc	r23, r1
     df4:	19 f4       	brne	.+6      	; 0xdfc <__unpack_f+0xb4>
     df6:	84 e0       	ldi	r24, 0x04	; 4
     df8:	8c 93       	st	X, r24
     dfa:	08 95       	ret
     dfc:	64 ff       	sbrs	r22, 4
     dfe:	03 c0       	rjmp	.+6      	; 0xe06 <__unpack_f+0xbe>
     e00:	81 e0       	ldi	r24, 0x01	; 1
     e02:	8c 93       	st	X, r24
     e04:	12 c0       	rjmp	.+36     	; 0xe2a <__unpack_f+0xe2>
     e06:	1c 92       	st	X, r1
     e08:	10 c0       	rjmp	.+32     	; 0xe2a <__unpack_f+0xe2>
     e0a:	2f 57       	subi	r18, 0x7F	; 127
     e0c:	30 40       	sbci	r19, 0x00	; 0
     e0e:	13 96       	adiw	r26, 0x03	; 3
     e10:	3c 93       	st	X, r19
     e12:	2e 93       	st	-X, r18
     e14:	12 97       	sbiw	r26, 0x02	; 2
     e16:	83 e0       	ldi	r24, 0x03	; 3
     e18:	8c 93       	st	X, r24
     e1a:	87 e0       	ldi	r24, 0x07	; 7
     e1c:	44 0f       	add	r20, r20
     e1e:	55 1f       	adc	r21, r21
     e20:	66 1f       	adc	r22, r22
     e22:	77 1f       	adc	r23, r23
     e24:	8a 95       	dec	r24
     e26:	d1 f7       	brne	.-12     	; 0xe1c <__unpack_f+0xd4>
     e28:	70 64       	ori	r23, 0x40	; 64
     e2a:	14 96       	adiw	r26, 0x04	; 4
     e2c:	4d 93       	st	X+, r20
     e2e:	5d 93       	st	X+, r21
     e30:	6d 93       	st	X+, r22
     e32:	7c 93       	st	X, r23
     e34:	17 97       	sbiw	r26, 0x07	; 7
     e36:	08 95       	ret

00000e38 <__fpcmp_parts_f>:
     e38:	1f 93       	push	r17
     e3a:	dc 01       	movw	r26, r24
     e3c:	fb 01       	movw	r30, r22
     e3e:	9c 91       	ld	r25, X
     e40:	92 30       	cpi	r25, 0x02	; 2
     e42:	08 f4       	brcc	.+2      	; 0xe46 <__fpcmp_parts_f+0xe>
     e44:	47 c0       	rjmp	.+142    	; 0xed4 <__fpcmp_parts_f+0x9c>
     e46:	80 81       	ld	r24, Z
     e48:	82 30       	cpi	r24, 0x02	; 2
     e4a:	08 f4       	brcc	.+2      	; 0xe4e <__fpcmp_parts_f+0x16>
     e4c:	43 c0       	rjmp	.+134    	; 0xed4 <__fpcmp_parts_f+0x9c>
     e4e:	94 30       	cpi	r25, 0x04	; 4
     e50:	51 f4       	brne	.+20     	; 0xe66 <__fpcmp_parts_f+0x2e>
     e52:	11 96       	adiw	r26, 0x01	; 1
     e54:	1c 91       	ld	r17, X
     e56:	84 30       	cpi	r24, 0x04	; 4
     e58:	99 f5       	brne	.+102    	; 0xec0 <__fpcmp_parts_f+0x88>
     e5a:	81 81       	ldd	r24, Z+1	; 0x01
     e5c:	68 2f       	mov	r22, r24
     e5e:	70 e0       	ldi	r23, 0x00	; 0
     e60:	61 1b       	sub	r22, r17
     e62:	71 09       	sbc	r23, r1
     e64:	3f c0       	rjmp	.+126    	; 0xee4 <__fpcmp_parts_f+0xac>
     e66:	84 30       	cpi	r24, 0x04	; 4
     e68:	21 f0       	breq	.+8      	; 0xe72 <__fpcmp_parts_f+0x3a>
     e6a:	92 30       	cpi	r25, 0x02	; 2
     e6c:	31 f4       	brne	.+12     	; 0xe7a <__fpcmp_parts_f+0x42>
     e6e:	82 30       	cpi	r24, 0x02	; 2
     e70:	b9 f1       	breq	.+110    	; 0xee0 <__fpcmp_parts_f+0xa8>
     e72:	81 81       	ldd	r24, Z+1	; 0x01
     e74:	88 23       	and	r24, r24
     e76:	89 f1       	breq	.+98     	; 0xeda <__fpcmp_parts_f+0xa2>
     e78:	2d c0       	rjmp	.+90     	; 0xed4 <__fpcmp_parts_f+0x9c>
     e7a:	11 96       	adiw	r26, 0x01	; 1
     e7c:	1c 91       	ld	r17, X
     e7e:	11 97       	sbiw	r26, 0x01	; 1
     e80:	82 30       	cpi	r24, 0x02	; 2
     e82:	f1 f0       	breq	.+60     	; 0xec0 <__fpcmp_parts_f+0x88>
     e84:	81 81       	ldd	r24, Z+1	; 0x01
     e86:	18 17       	cp	r17, r24
     e88:	d9 f4       	brne	.+54     	; 0xec0 <__fpcmp_parts_f+0x88>
     e8a:	12 96       	adiw	r26, 0x02	; 2
     e8c:	2d 91       	ld	r18, X+
     e8e:	3c 91       	ld	r19, X
     e90:	13 97       	sbiw	r26, 0x03	; 3
     e92:	82 81       	ldd	r24, Z+2	; 0x02
     e94:	93 81       	ldd	r25, Z+3	; 0x03
     e96:	82 17       	cp	r24, r18
     e98:	93 07       	cpc	r25, r19
     e9a:	94 f0       	brlt	.+36     	; 0xec0 <__fpcmp_parts_f+0x88>
     e9c:	28 17       	cp	r18, r24
     e9e:	39 07       	cpc	r19, r25
     ea0:	bc f0       	brlt	.+46     	; 0xed0 <__fpcmp_parts_f+0x98>
     ea2:	14 96       	adiw	r26, 0x04	; 4
     ea4:	8d 91       	ld	r24, X+
     ea6:	9d 91       	ld	r25, X+
     ea8:	0d 90       	ld	r0, X+
     eaa:	bc 91       	ld	r27, X
     eac:	a0 2d       	mov	r26, r0
     eae:	24 81       	ldd	r18, Z+4	; 0x04
     eb0:	35 81       	ldd	r19, Z+5	; 0x05
     eb2:	46 81       	ldd	r20, Z+6	; 0x06
     eb4:	57 81       	ldd	r21, Z+7	; 0x07
     eb6:	28 17       	cp	r18, r24
     eb8:	39 07       	cpc	r19, r25
     eba:	4a 07       	cpc	r20, r26
     ebc:	5b 07       	cpc	r21, r27
     ebe:	18 f4       	brcc	.+6      	; 0xec6 <__fpcmp_parts_f+0x8e>
     ec0:	11 23       	and	r17, r17
     ec2:	41 f0       	breq	.+16     	; 0xed4 <__fpcmp_parts_f+0x9c>
     ec4:	0a c0       	rjmp	.+20     	; 0xeda <__fpcmp_parts_f+0xa2>
     ec6:	82 17       	cp	r24, r18
     ec8:	93 07       	cpc	r25, r19
     eca:	a4 07       	cpc	r26, r20
     ecc:	b5 07       	cpc	r27, r21
     ece:	40 f4       	brcc	.+16     	; 0xee0 <__fpcmp_parts_f+0xa8>
     ed0:	11 23       	and	r17, r17
     ed2:	19 f0       	breq	.+6      	; 0xeda <__fpcmp_parts_f+0xa2>
     ed4:	61 e0       	ldi	r22, 0x01	; 1
     ed6:	70 e0       	ldi	r23, 0x00	; 0
     ed8:	05 c0       	rjmp	.+10     	; 0xee4 <__fpcmp_parts_f+0xac>
     eda:	6f ef       	ldi	r22, 0xFF	; 255
     edc:	7f ef       	ldi	r23, 0xFF	; 255
     ede:	02 c0       	rjmp	.+4      	; 0xee4 <__fpcmp_parts_f+0xac>
     ee0:	60 e0       	ldi	r22, 0x00	; 0
     ee2:	70 e0       	ldi	r23, 0x00	; 0
     ee4:	cb 01       	movw	r24, r22
     ee6:	1f 91       	pop	r17
     ee8:	08 95       	ret

00000eea <s_list_get_length>:
#include "linked_list.h"
#include "stdlib.h"
u32  s_list_get_length(struct node *list){
    u32 count =0;
    struct node *temp = list;
    while (temp != NULL)
     eea:	00 97       	sbiw	r24, 0x00	; 0
     eec:	29 f4       	brne	.+10     	; 0xef8 <s_list_get_length+0xe>
     eee:	20 e0       	ldi	r18, 0x00	; 0
     ef0:	30 e0       	ldi	r19, 0x00	; 0
     ef2:	40 e0       	ldi	r20, 0x00	; 0
     ef4:	50 e0       	ldi	r21, 0x00	; 0
     ef6:	0e c0       	rjmp	.+28     	; 0xf14 <s_list_get_length+0x2a>
     ef8:	fc 01       	movw	r30, r24
     efa:	20 e0       	ldi	r18, 0x00	; 0
     efc:	30 e0       	ldi	r19, 0x00	; 0
     efe:	40 e0       	ldi	r20, 0x00	; 0
     f00:	50 e0       	ldi	r21, 0x00	; 0
    {
        count ++;
     f02:	2f 5f       	subi	r18, 0xFF	; 255
     f04:	3f 4f       	sbci	r19, 0xFF	; 255
     f06:	4f 4f       	sbci	r20, 0xFF	; 255
     f08:	5f 4f       	sbci	r21, 0xFF	; 255
        temp = temp->node_link;
     f0a:	01 90       	ld	r0, Z+
     f0c:	f0 81       	ld	r31, Z
     f0e:	e0 2d       	mov	r30, r0
#include "linked_list.h"
#include "stdlib.h"
u32  s_list_get_length(struct node *list){
    u32 count =0;
    struct node *temp = list;
    while (temp != NULL)
     f10:	30 97       	sbiw	r30, 0x00	; 0
     f12:	b9 f7       	brne	.-18     	; 0xf02 <s_list_get_length+0x18>
    {
        count ++;
        temp = temp->node_link;
    }
    return count;
}
     f14:	62 2f       	mov	r22, r18
     f16:	73 2f       	mov	r23, r19
     f18:	84 2f       	mov	r24, r20
     f1a:	95 2f       	mov	r25, r21
     f1c:	08 95       	ret

00000f1e <s_list_insert_node_at_end>:
        temp_node->node_link = *list;
        *list = temp_node;
    }
}

void s_list_insert_node_at_end(struct node **list, void* data_ptr){
     f1e:	ef 92       	push	r14
     f20:	ff 92       	push	r15
     f22:	0f 93       	push	r16
     f24:	1f 93       	push	r17
     f26:	cf 93       	push	r28
     f28:	df 93       	push	r29
     f2a:	8c 01       	movw	r16, r24
     f2c:	7b 01       	movw	r14, r22
    struct node *last_node = *list;
     f2e:	fc 01       	movw	r30, r24
     f30:	c0 81       	ld	r28, Z
     f32:	d1 81       	ldd	r29, Z+1	; 0x01
    struct node *temp_node = (struct node *) malloc (sizeof(struct node));
     f34:	84 e0       	ldi	r24, 0x04	; 4
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	0e 94 88 31 	call	0x6310	; 0x6310 <malloc>
     f3c:	dc 01       	movw	r26, r24
    if(NULL == temp_node){}
     f3e:	10 97       	sbiw	r26, 0x00	; 0
     f40:	d1 f0       	breq	.+52     	; 0xf76 <s_list_insert_node_at_end+0x58>
    else{
        temp_node->node_data = data_ptr;
     f42:	13 96       	adiw	r26, 0x03	; 3
     f44:	fc 92       	st	X, r15
     f46:	ee 92       	st	-X, r14
     f48:	12 97       	sbiw	r26, 0x02	; 2
        temp_node->node_link = NULL;
     f4a:	11 96       	adiw	r26, 0x01	; 1
     f4c:	1c 92       	st	X, r1
     f4e:	1e 92       	st	-X, r1
        if(*list == NULL){
     f50:	f8 01       	movw	r30, r16
     f52:	80 81       	ld	r24, Z
     f54:	91 81       	ldd	r25, Z+1	; 0x01
     f56:	89 2b       	or	r24, r25
     f58:	19 f4       	brne	.+6      	; 0xf60 <s_list_insert_node_at_end+0x42>
            *list = temp_node;
     f5a:	b1 83       	std	Z+1, r27	; 0x01
     f5c:	a0 83       	st	Z, r26
     f5e:	0b c0       	rjmp	.+22     	; 0xf76 <s_list_insert_node_at_end+0x58>
        }
        else{
            while (NULL != (last_node->node_link)){
     f60:	8c 2f       	mov	r24, r28
     f62:	9d 2f       	mov	r25, r29
     f64:	09 90       	ld	r0, Y+
     f66:	d8 81       	ld	r29, Y
     f68:	c0 2d       	mov	r28, r0
     f6a:	20 97       	sbiw	r28, 0x00	; 0
     f6c:	c9 f7       	brne	.-14     	; 0xf60 <s_list_insert_node_at_end+0x42>
     f6e:	e8 2f       	mov	r30, r24
     f70:	f9 2f       	mov	r31, r25
                last_node = last_node->node_link;
            }
            last_node->node_link = temp_node;
     f72:	b1 83       	std	Z+1, r27	; 0x01
     f74:	a0 83       	st	Z, r26
        }
    }
}
     f76:	df 91       	pop	r29
     f78:	cf 91       	pop	r28
     f7a:	1f 91       	pop	r17
     f7c:	0f 91       	pop	r16
     f7e:	ff 90       	pop	r15
     f80:	ef 90       	pop	r14
     f82:	08 95       	ret

00000f84 <s_list_insert_node_after_pos>:

void s_list_insert_node_after_pos(struct node *list, u32 node_pos, void* data_ptr){
     f84:	8f 92       	push	r8
     f86:	9f 92       	push	r9
     f88:	af 92       	push	r10
     f8a:	bf 92       	push	r11
     f8c:	cf 92       	push	r12
     f8e:	df 92       	push	r13
     f90:	ef 92       	push	r14
     f92:	ff 92       	push	r15
     f94:	0f 93       	push	r16
     f96:	1f 93       	push	r17
     f98:	df 93       	push	r29
     f9a:	cf 93       	push	r28
     f9c:	00 d0       	rcall	.+0      	; 0xf9e <s_list_insert_node_after_pos+0x1a>
     f9e:	00 d0       	rcall	.+0      	; 0xfa0 <s_list_insert_node_after_pos+0x1c>
     fa0:	cd b7       	in	r28, 0x3d	; 61
     fa2:	de b7       	in	r29, 0x3e	; 62
     fa4:	9a 83       	std	Y+2, r25	; 0x02
     fa6:	89 83       	std	Y+1, r24	; 0x01
     fa8:	7a 01       	movw	r14, r20
     faa:	8b 01       	movw	r16, r22
     fac:	3c 83       	std	Y+4, r19	; 0x04
     fae:	2b 83       	std	Y+3, r18	; 0x03
    u32 count = s_list_get_length(list);
     fb0:	0e 94 75 07 	call	0xeea	; 0xeea <s_list_get_length>
     fb4:	4b 01       	movw	r8, r22
     fb6:	5c 01       	movw	r10, r24
    struct node *node_befor= list;
     fb8:	c9 80       	ldd	r12, Y+1	; 0x01
     fba:	da 80       	ldd	r13, Y+2	; 0x02
    struct node *node_after= list;
    struct node *tempnode= (struct node *)malloc (sizeof(struct node));
     fbc:	84 e0       	ldi	r24, 0x04	; 4
     fbe:	90 e0       	ldi	r25, 0x00	; 0
     fc0:	0e 94 88 31 	call	0x6310	; 0x6310 <malloc>
    if(node_pos > count){}
     fc4:	8e 14       	cp	r8, r14
     fc6:	9f 04       	cpc	r9, r15
     fc8:	a0 06       	cpc	r10, r16
     fca:	b1 06       	cpc	r11, r17
     fcc:	a0 f1       	brcs	.+104    	; 0x1036 <s_list_insert_node_after_pos+0xb2>
    else if(node_pos == count){
     fce:	8e 14       	cp	r8, r14
     fd0:	9f 04       	cpc	r9, r15
     fd2:	a0 06       	cpc	r10, r16
     fd4:	b1 06       	cpc	r11, r17
     fd6:	41 f4       	brne	.+16     	; 0xfe8 <s_list_insert_node_after_pos+0x64>
        s_list_insert_node_at_end(&list, &data_ptr);
     fd8:	ce 01       	movw	r24, r28
     fda:	01 96       	adiw	r24, 0x01	; 1
     fdc:	be 01       	movw	r22, r28
     fde:	6d 5f       	subi	r22, 0xFD	; 253
     fe0:	7f 4f       	sbci	r23, 0xFF	; 255
     fe2:	0e 94 8f 07 	call	0xf1e	; 0xf1e <s_list_insert_node_at_end>
     fe6:	27 c0       	rjmp	.+78     	; 0x1036 <s_list_insert_node_after_pos+0xb2>

void s_list_insert_node_after_pos(struct node *list, u32 node_pos, void* data_ptr){
    u32 count = s_list_get_length(list);
    struct node *node_befor= list;
    struct node *node_after= list;
    struct node *tempnode= (struct node *)malloc (sizeof(struct node));
     fe8:	28 2f       	mov	r18, r24
     fea:	39 2f       	mov	r19, r25
    if(node_pos > count){}
    else if(node_pos == count){
        s_list_insert_node_at_end(&list, &data_ptr);
    }
    else{
        if(tempnode == NULL){}
     fec:	21 15       	cp	r18, r1
     fee:	31 05       	cpc	r19, r1
     ff0:	11 f1       	breq	.+68     	; 0x1036 <s_list_insert_node_after_pos+0xb2>
        else{
            tempnode->node_data = data_ptr;
     ff2:	8b 81       	ldd	r24, Y+3	; 0x03
     ff4:	9c 81       	ldd	r25, Y+4	; 0x04
     ff6:	f9 01       	movw	r30, r18
     ff8:	93 83       	std	Z+3, r25	; 0x03
     ffa:	82 83       	std	Z+2, r24	; 0x02
            u32 node_cout = 1;
            while (node_cout <= node_pos) {
     ffc:	e1 14       	cp	r14, r1
     ffe:	f1 04       	cpc	r15, r1
    1000:	01 05       	cpc	r16, r1
    1002:	11 05       	cpc	r17, r1
    1004:	79 f0       	breq	.+30     	; 0x1024 <s_list_insert_node_after_pos+0xa0>
    1006:	81 e0       	ldi	r24, 0x01	; 1
    1008:	90 e0       	ldi	r25, 0x00	; 0
    100a:	a0 e0       	ldi	r26, 0x00	; 0
    100c:	b0 e0       	ldi	r27, 0x00	; 0
                node_cout ++;
    100e:	01 96       	adiw	r24, 0x01	; 1
    1010:	a1 1d       	adc	r26, r1
    1012:	b1 1d       	adc	r27, r1
                node_befor = node_befor->node_link;
    1014:	f6 01       	movw	r30, r12
    1016:	c0 80       	ld	r12, Z
    1018:	d1 80       	ldd	r13, Z+1	; 0x01
    else{
        if(tempnode == NULL){}
        else{
            tempnode->node_data = data_ptr;
            u32 node_cout = 1;
            while (node_cout <= node_pos) {
    101a:	e8 16       	cp	r14, r24
    101c:	f9 06       	cpc	r15, r25
    101e:	0a 07       	cpc	r16, r26
    1020:	1b 07       	cpc	r17, r27
    1022:	a8 f7       	brcc	.-22     	; 0x100e <s_list_insert_node_after_pos+0x8a>
                node_cout ++;
                node_befor = node_befor->node_link;
            }
            node_after = node_befor->node_link;
            tempnode->node_link = node_after;
    1024:	f6 01       	movw	r30, r12
    1026:	80 81       	ld	r24, Z
    1028:	91 81       	ldd	r25, Z+1	; 0x01
    102a:	f9 01       	movw	r30, r18
    102c:	91 83       	std	Z+1, r25	; 0x01
    102e:	80 83       	st	Z, r24
            node_befor->node_link = tempnode;
    1030:	f6 01       	movw	r30, r12
    1032:	31 83       	std	Z+1, r19	; 0x01
    1034:	20 83       	st	Z, r18
        }
    }
}
    1036:	0f 90       	pop	r0
    1038:	0f 90       	pop	r0
    103a:	0f 90       	pop	r0
    103c:	0f 90       	pop	r0
    103e:	cf 91       	pop	r28
    1040:	df 91       	pop	r29
    1042:	1f 91       	pop	r17
    1044:	0f 91       	pop	r16
    1046:	ff 90       	pop	r15
    1048:	ef 90       	pop	r14
    104a:	df 90       	pop	r13
    104c:	cf 90       	pop	r12
    104e:	bf 90       	pop	r11
    1050:	af 90       	pop	r10
    1052:	9f 90       	pop	r9
    1054:	8f 90       	pop	r8
    1056:	08 95       	ret

00001058 <s_list_insert_node_at_beg>:
        temp = temp->node_link;
    }
    return count;
}

void s_list_insert_node_at_beg(struct node **list, void* data_ptr){
    1058:	0f 93       	push	r16
    105a:	1f 93       	push	r17
    105c:	cf 93       	push	r28
    105e:	df 93       	push	r29
    1060:	ec 01       	movw	r28, r24
    1062:	8b 01       	movw	r16, r22
    struct node *temp_node = (struct node *) malloc (sizeof(struct node));
    1064:	84 e0       	ldi	r24, 0x04	; 4
    1066:	90 e0       	ldi	r25, 0x00	; 0
    1068:	0e 94 88 31 	call	0x6310	; 0x6310 <malloc>
    106c:	fc 01       	movw	r30, r24
    if(NULL == temp_node){    }
    106e:	30 97       	sbiw	r30, 0x00	; 0
    1070:	41 f0       	breq	.+16     	; 0x1082 <s_list_insert_node_at_beg+0x2a>
    else{
        temp_node->node_data = data_ptr;
    1072:	13 83       	std	Z+3, r17	; 0x03
    1074:	02 83       	std	Z+2, r16	; 0x02
        temp_node->node_link = *list;
    1076:	88 81       	ld	r24, Y
    1078:	99 81       	ldd	r25, Y+1	; 0x01
    107a:	91 83       	std	Z+1, r25	; 0x01
    107c:	80 83       	st	Z, r24
        *list = temp_node;
    107e:	f9 83       	std	Y+1, r31	; 0x01
    1080:	e8 83       	st	Y, r30
    }
}
    1082:	df 91       	pop	r29
    1084:	cf 91       	pop	r28
    1086:	1f 91       	pop	r17
    1088:	0f 91       	pop	r16
    108a:	08 95       	ret

0000108c <s_list_delete_node_at_pos>:
    *list = tempnode->node_link;
    tempnode->node_link = NULL;
    free(tempnode);
}

void s_list_delete_node_at_pos(struct node *list, u32 node_pos){
    108c:	8f 92       	push	r8
    108e:	9f 92       	push	r9
    1090:	af 92       	push	r10
    1092:	bf 92       	push	r11
    1094:	cf 92       	push	r12
    1096:	df 92       	push	r13
    1098:	ef 92       	push	r14
    109a:	ff 92       	push	r15
    109c:	0f 93       	push	r16
    109e:	1f 93       	push	r17
    10a0:	cf 93       	push	r28
    10a2:	df 93       	push	r29
    10a4:	98 2e       	mov	r9, r24
    10a6:	89 2e       	mov	r8, r25
    10a8:	5a 01       	movw	r10, r20
    10aa:	6b 01       	movw	r12, r22
    u32 count = s_list_get_length(list);
    10ac:	0e 94 75 07 	call	0xeea	; 0xeea <s_list_get_length>
    10b0:	7b 01       	movw	r14, r22
    10b2:	8c 01       	movw	r16, r24
    struct node *node_befor= list;
    struct node *node_after= list;
    struct node *tempnode= (struct node *)malloc (sizeof(struct node));
    10b4:	84 e0       	ldi	r24, 0x04	; 4
    10b6:	90 e0       	ldi	r25, 0x00	; 0
    10b8:	0e 94 88 31 	call	0x6310	; 0x6310 <malloc>
    if(node_pos > count){}
    10bc:	ea 14       	cp	r14, r10
    10be:	fb 04       	cpc	r15, r11
    10c0:	0c 05       	cpc	r16, r12
    10c2:	1d 05       	cpc	r17, r13
    10c4:	50 f1       	brcs	.+84     	; 0x111a <s_list_delete_node_at_pos+0x8e>
    else{
            u32 node_cout = 1;
            while (node_cout < node_pos-1) {
    10c6:	d6 01       	movw	r26, r12
    10c8:	c5 01       	movw	r24, r10
    10ca:	01 97       	sbiw	r24, 0x01	; 1
    10cc:	a1 09       	sbc	r26, r1
    10ce:	b1 09       	sbc	r27, r1
    10d0:	02 97       	sbiw	r24, 0x02	; 2
    10d2:	a1 05       	cpc	r26, r1
    10d4:	b1 05       	cpc	r27, r1
    10d6:	20 f4       	brcc	.+8      	; 0x10e0 <s_list_delete_node_at_pos+0x54>
    10d8:	29 2d       	mov	r18, r9
    10da:	38 2d       	mov	r19, r8
    10dc:	e9 01       	movw	r28, r18
    10de:	12 c0       	rjmp	.+36     	; 0x1104 <s_list_delete_node_at_pos+0x78>
    10e0:	29 2d       	mov	r18, r9
    10e2:	38 2d       	mov	r19, r8
    10e4:	e9 01       	movw	r28, r18
    10e6:	82 e0       	ldi	r24, 0x02	; 2
    10e8:	90 e0       	ldi	r25, 0x00	; 0
    10ea:	a0 e0       	ldi	r26, 0x00	; 0
    10ec:	b0 e0       	ldi	r27, 0x00	; 0
                node_cout ++;
                node_befor = node_befor->node_link;
    10ee:	09 90       	ld	r0, Y+
    10f0:	d8 81       	ld	r29, Y
    10f2:	c0 2d       	mov	r28, r0
    10f4:	01 96       	adiw	r24, 0x01	; 1
    10f6:	a1 1d       	adc	r26, r1
    10f8:	b1 1d       	adc	r27, r1
    struct node *node_after= list;
    struct node *tempnode= (struct node *)malloc (sizeof(struct node));
    if(node_pos > count){}
    else{
            u32 node_cout = 1;
            while (node_cout < node_pos-1) {
    10fa:	8a 15       	cp	r24, r10
    10fc:	9b 05       	cpc	r25, r11
    10fe:	ac 05       	cpc	r26, r12
    1100:	bd 05       	cpc	r27, r13
    1102:	a9 f7       	brne	.-22     	; 0x10ee <s_list_delete_node_at_pos+0x62>
                node_cout ++;
                node_befor = node_befor->node_link;
            }
            tempnode = node_befor->node_link;
    1104:	e8 81       	ld	r30, Y
    1106:	f9 81       	ldd	r31, Y+1	; 0x01
            node_after = tempnode->node_link;
            node_befor->node_link = node_after;
    1108:	80 81       	ld	r24, Z
    110a:	91 81       	ldd	r25, Z+1	; 0x01
    110c:	99 83       	std	Y+1, r25	; 0x01
    110e:	88 83       	st	Y, r24
            tempnode->node_link = NULL;
    1110:	11 82       	std	Z+1, r1	; 0x01
    1112:	10 82       	st	Z, r1
            free(tempnode);
    1114:	cf 01       	movw	r24, r30
    1116:	0e 94 35 32 	call	0x646a	; 0x646a <free>
        }
}
    111a:	df 91       	pop	r29
    111c:	cf 91       	pop	r28
    111e:	1f 91       	pop	r17
    1120:	0f 91       	pop	r16
    1122:	ff 90       	pop	r15
    1124:	ef 90       	pop	r14
    1126:	df 90       	pop	r13
    1128:	cf 90       	pop	r12
    112a:	bf 90       	pop	r11
    112c:	af 90       	pop	r10
    112e:	9f 90       	pop	r9
    1130:	8f 90       	pop	r8
    1132:	08 95       	ret

00001134 <s_list_delete_node_at_beg>:
            node_befor->node_link = tempnode;
        }
    }
}

void s_list_delete_node_at_beg(struct node **list){
    1134:	fc 01       	movw	r30, r24
    struct node *tempnode = *list;
    1136:	a0 81       	ld	r26, Z
    1138:	b1 81       	ldd	r27, Z+1	; 0x01
    *list = tempnode->node_link;
    113a:	8d 91       	ld	r24, X+
    113c:	9c 91       	ld	r25, X
    113e:	11 97       	sbiw	r26, 0x01	; 1
    1140:	91 83       	std	Z+1, r25	; 0x01
    1142:	80 83       	st	Z, r24
    tempnode->node_link = NULL;
    1144:	11 96       	adiw	r26, 0x01	; 1
    1146:	1c 92       	st	X, r1
    1148:	1e 92       	st	-X, r1
    free(tempnode);
    114a:	cd 01       	movw	r24, r26
    114c:	0e 94 35 32 	call	0x646a	; 0x646a <free>
}
    1150:	08 95       	ret

00001152 <WDT_void_Enable>:
#include "../../_MY_LIBS/BIT_MATH.h"

/* ----------------- Section : Software Interfaces Implementation -----------------*/
void WDT_void_Enable (u8 Copy_u8_Time)
{
	switch (Copy_u8_Time)
    1152:	84 30       	cpi	r24, 0x04	; 4
    1154:	d1 f1       	breq	.+116    	; 0x11ca <WDT_void_Enable+0x78>
    1156:	85 30       	cpi	r24, 0x05	; 5
    1158:	40 f4       	brcc	.+16     	; 0x116a <WDT_void_Enable+0x18>
    115a:	82 30       	cpi	r24, 0x02	; 2
    115c:	f1 f0       	breq	.+60     	; 0x119a <WDT_void_Enable+0x48>
    115e:	83 30       	cpi	r24, 0x03	; 3
    1160:	40 f5       	brcc	.+80     	; 0x11b2 <WDT_void_Enable+0x60>
    1162:	81 30       	cpi	r24, 0x01	; 1
    1164:	09 f0       	breq	.+2      	; 0x1168 <WDT_void_Enable+0x16>
    1166:	6c c0       	rjmp	.+216    	; 0x1240 <WDT_void_Enable+0xee>
    1168:	0c c0       	rjmp	.+24     	; 0x1182 <WDT_void_Enable+0x30>
    116a:	86 30       	cpi	r24, 0x06	; 6
    116c:	09 f4       	brne	.+2      	; 0x1170 <WDT_void_Enable+0x1e>
    116e:	45 c0       	rjmp	.+138    	; 0x11fa <WDT_void_Enable+0xa8>
    1170:	86 30       	cpi	r24, 0x06	; 6
    1172:	b8 f1       	brcs	.+110    	; 0x11e2 <WDT_void_Enable+0x90>
    1174:	87 30       	cpi	r24, 0x07	; 7
    1176:	09 f4       	brne	.+2      	; 0x117a <WDT_void_Enable+0x28>
    1178:	4c c0       	rjmp	.+152    	; 0x1212 <WDT_void_Enable+0xc0>
    117a:	88 30       	cpi	r24, 0x08	; 8
    117c:	09 f0       	breq	.+2      	; 0x1180 <WDT_void_Enable+0x2e>
    117e:	60 c0       	rjmp	.+192    	; 0x1240 <WDT_void_Enable+0xee>
    1180:	54 c0       	rjmp	.+168    	; 0x122a <WDT_void_Enable+0xd8>
	{
		case WDT_16_3_ms:
			CLR_BIT(_WDTCR, _WDP0);
    1182:	e1 e4       	ldi	r30, 0x41	; 65
    1184:	f0 e0       	ldi	r31, 0x00	; 0
    1186:	80 81       	ld	r24, Z
    1188:	8e 7f       	andi	r24, 0xFE	; 254
    118a:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP1);
    118c:	80 81       	ld	r24, Z
    118e:	8d 7f       	andi	r24, 0xFD	; 253
    1190:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP2);
    1192:	80 81       	ld	r24, Z
    1194:	8b 7f       	andi	r24, 0xFB	; 251
    1196:	80 83       	st	Z, r24
    1198:	53 c0       	rjmp	.+166    	; 0x1240 <WDT_void_Enable+0xee>
			break;
		case WDT_32_5_ms:
			SET_BIT(_WDTCR, _WDP0);
    119a:	e1 e4       	ldi	r30, 0x41	; 65
    119c:	f0 e0       	ldi	r31, 0x00	; 0
    119e:	80 81       	ld	r24, Z
    11a0:	81 60       	ori	r24, 0x01	; 1
    11a2:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP1);
    11a4:	80 81       	ld	r24, Z
    11a6:	8d 7f       	andi	r24, 0xFD	; 253
    11a8:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP2);
    11aa:	80 81       	ld	r24, Z
    11ac:	8b 7f       	andi	r24, 0xFB	; 251
    11ae:	80 83       	st	Z, r24
    11b0:	47 c0       	rjmp	.+142    	; 0x1240 <WDT_void_Enable+0xee>
			break;
		case WDT_65_0_ms:
			CLR_BIT(_WDTCR, _WDP0);
    11b2:	e1 e4       	ldi	r30, 0x41	; 65
    11b4:	f0 e0       	ldi	r31, 0x00	; 0
    11b6:	80 81       	ld	r24, Z
    11b8:	8e 7f       	andi	r24, 0xFE	; 254
    11ba:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP1);
    11bc:	80 81       	ld	r24, Z
    11be:	82 60       	ori	r24, 0x02	; 2
    11c0:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP2);
    11c2:	80 81       	ld	r24, Z
    11c4:	8b 7f       	andi	r24, 0xFB	; 251
    11c6:	80 83       	st	Z, r24
    11c8:	3b c0       	rjmp	.+118    	; 0x1240 <WDT_void_Enable+0xee>
			break;
		case WDT_0_13_ms:
			SET_BIT(_WDTCR, _WDP0);
    11ca:	e1 e4       	ldi	r30, 0x41	; 65
    11cc:	f0 e0       	ldi	r31, 0x00	; 0
    11ce:	80 81       	ld	r24, Z
    11d0:	81 60       	ori	r24, 0x01	; 1
    11d2:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP1);
    11d4:	80 81       	ld	r24, Z
    11d6:	82 60       	ori	r24, 0x02	; 2
    11d8:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP2);
    11da:	80 81       	ld	r24, Z
    11dc:	8b 7f       	andi	r24, 0xFB	; 251
    11de:	80 83       	st	Z, r24
    11e0:	2f c0       	rjmp	.+94     	; 0x1240 <WDT_void_Enable+0xee>
			break;
		case WDT_0_26_ms:
			CLR_BIT(_WDTCR, _WDP0);
    11e2:	e1 e4       	ldi	r30, 0x41	; 65
    11e4:	f0 e0       	ldi	r31, 0x00	; 0
    11e6:	80 81       	ld	r24, Z
    11e8:	8e 7f       	andi	r24, 0xFE	; 254
    11ea:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP1);
    11ec:	80 81       	ld	r24, Z
    11ee:	8d 7f       	andi	r24, 0xFD	; 253
    11f0:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP2);
    11f2:	80 81       	ld	r24, Z
    11f4:	84 60       	ori	r24, 0x04	; 4
    11f6:	80 83       	st	Z, r24
    11f8:	23 c0       	rjmp	.+70     	; 0x1240 <WDT_void_Enable+0xee>
			break;
		case WDT_0_52_ms:
			SET_BIT(_WDTCR, _WDP0);
    11fa:	e1 e4       	ldi	r30, 0x41	; 65
    11fc:	f0 e0       	ldi	r31, 0x00	; 0
    11fe:	80 81       	ld	r24, Z
    1200:	81 60       	ori	r24, 0x01	; 1
    1202:	80 83       	st	Z, r24
			CLR_BIT(_WDTCR, _WDP1);
    1204:	80 81       	ld	r24, Z
    1206:	8d 7f       	andi	r24, 0xFD	; 253
    1208:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP2);
    120a:	80 81       	ld	r24, Z
    120c:	84 60       	ori	r24, 0x04	; 4
    120e:	80 83       	st	Z, r24
    1210:	17 c0       	rjmp	.+46     	; 0x1240 <WDT_void_Enable+0xee>
			break;
		case WDT_01_0_ms:
			CLR_BIT(_WDTCR, _WDP0);
    1212:	e1 e4       	ldi	r30, 0x41	; 65
    1214:	f0 e0       	ldi	r31, 0x00	; 0
    1216:	80 81       	ld	r24, Z
    1218:	8e 7f       	andi	r24, 0xFE	; 254
    121a:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP1);
    121c:	80 81       	ld	r24, Z
    121e:	82 60       	ori	r24, 0x02	; 2
    1220:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP2);
    1222:	80 81       	ld	r24, Z
    1224:	84 60       	ori	r24, 0x04	; 4
    1226:	80 83       	st	Z, r24
    1228:	0b c0       	rjmp	.+22     	; 0x1240 <WDT_void_Enable+0xee>
			break;
		case WDT_02_1_ms:
			SET_BIT(_WDTCR, _WDP0);
    122a:	e1 e4       	ldi	r30, 0x41	; 65
    122c:	f0 e0       	ldi	r31, 0x00	; 0
    122e:	80 81       	ld	r24, Z
    1230:	81 60       	ori	r24, 0x01	; 1
    1232:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP1);
    1234:	80 81       	ld	r24, Z
    1236:	82 60       	ori	r24, 0x02	; 2
    1238:	80 83       	st	Z, r24
			SET_BIT(_WDTCR, _WDP2);
    123a:	80 81       	ld	r24, Z
    123c:	84 60       	ori	r24, 0x04	; 4
    123e:	80 83       	st	Z, r24
			break;
		default:
			break;
	}
	SET_BIT(_WDTCR, _WDE);
    1240:	e1 e4       	ldi	r30, 0x41	; 65
    1242:	f0 e0       	ldi	r31, 0x00	; 0
    1244:	80 81       	ld	r24, Z
    1246:	88 60       	ori	r24, 0x08	; 8
    1248:	80 83       	st	Z, r24
}
    124a:	08 95       	ret

0000124c <WDT_void_Disable>:

void WDT_void_Disable(void)
{
	_WDTCR = (1<<_WDTOE) | (1<<_WDE);
    124c:	e1 e4       	ldi	r30, 0x41	; 65
    124e:	f0 e0       	ldi	r31, 0x00	; 0
    1250:	88 e1       	ldi	r24, 0x18	; 24
    1252:	80 83       	st	Z, r24
	_WDTCR = 0x00;
    1254:	10 82       	st	Z, r1
}
    1256:	08 95       	ret

00001258 <UART_Init>:

/* ----------------- Section : Software Interfaces Implementation -----------------*/
void UART_Init()
{
	u16 rest = (1000000 /UART_BAUDRATE) - 1;
	_UBRRL = rest;
    1258:	87 e6       	ldi	r24, 0x67	; 103
    125a:	89 b9       	out	0x09, r24	; 9
	switch(UART_SPEED_MODE)
	{
	case ASY_NORMAL_SPEED:
		CLR_BIT(_UCSRA,1);
    125c:	eb e2       	ldi	r30, 0x2B	; 43
    125e:	f0 e0       	ldi	r31, 0x00	; 0
    1260:	80 81       	ld	r24, Z
    1262:	8d 7f       	andi	r24, 0xFD	; 253
    1264:	80 83       	st	Z, r24
	case SYN_MASTER_MODE:
		SET_BIT(_UCSRC, 6);
		break;
	}
	// ENABLE RX TX
	SET_BIT(_UCSRB,4);
    1266:	ea e2       	ldi	r30, 0x2A	; 42
    1268:	f0 e0       	ldi	r31, 0x00	; 0
    126a:	80 81       	ld	r24, Z
    126c:	80 61       	ori	r24, 0x10	; 16
    126e:	80 83       	st	Z, r24
	SET_BIT(_UCSRB,3);
    1270:	80 81       	ld	r24, Z
    1272:	88 60       	ori	r24, 0x08	; 8
    1274:	80 83       	st	Z, r24
}
    1276:	08 95       	ret

00001278 <UART_TransmitData>:

void UART_TransmitData(u8 data)
{
    1278:	98 2f       	mov	r25, r24
	while(!GET_BIT(_UCSRA,5));
    127a:	eb e2       	ldi	r30, 0x2B	; 43
    127c:	f0 e0       	ldi	r31, 0x00	; 0
    127e:	80 81       	ld	r24, Z
    1280:	85 ff       	sbrs	r24, 5
    1282:	fd cf       	rjmp	.-6      	; 0x127e <UART_TransmitData+0x6>
	_UDR = data;
    1284:	9c b9       	out	0x0c, r25	; 12
}
    1286:	08 95       	ret

00001288 <UART_ReceiveData>:

u8 UART_ReceiveData()
{
	while(!GET_BIT(_UCSRA,7));
    1288:	eb e2       	ldi	r30, 0x2B	; 43
    128a:	f0 e0       	ldi	r31, 0x00	; 0
    128c:	80 81       	ld	r24, Z
    128e:	88 23       	and	r24, r24
    1290:	ec f7       	brge	.-6      	; 0x128c <UART_ReceiveData+0x4>
	return _UDR;
    1292:	8c b1       	in	r24, 0x0c	; 12
}
    1294:	08 95       	ret

00001296 <UART_TransmitString>:
    int receivedNumber = atoi(rxBuffer);

    return receivedNumber;
}

void UART_TransmitString(const char* str) {
    1296:	cf 93       	push	r28
    1298:	df 93       	push	r29
    129a:	fc 01       	movw	r30, r24
    // Iterate over each character in the string until the null terminator is reached
    for (int i = 0; str[i] != '\0'; i++) {
    129c:	80 81       	ld	r24, Z
    129e:	88 23       	and	r24, r24
    12a0:	39 f0       	breq	.+14     	; 0x12b0 <UART_TransmitString+0x1a>
    12a2:	ef 01       	movw	r28, r30
        UART_TransmitData(str[i]); // Transmit each character
    12a4:	0e 94 3c 09 	call	0x1278	; 0x1278 <UART_TransmitData>
    return receivedNumber;
}

void UART_TransmitString(const char* str) {
    // Iterate over each character in the string until the null terminator is reached
    for (int i = 0; str[i] != '\0'; i++) {
    12a8:	89 81       	ldd	r24, Y+1	; 0x01
    12aa:	21 96       	adiw	r28, 0x01	; 1
    12ac:	88 23       	and	r24, r24
    12ae:	d1 f7       	brne	.-12     	; 0x12a4 <UART_TransmitString+0xe>
        UART_TransmitData(str[i]); // Transmit each character
    }
}
    12b0:	df 91       	pop	r29
    12b2:	cf 91       	pop	r28
    12b4:	08 95       	ret

000012b6 <UART_ReceiveNumber>:
}



// Function to receive a number over UART, terminated by '\r' (Enter key)
int UART_ReceiveNumber() {
    12b6:	ef 92       	push	r14
    12b8:	ff 92       	push	r15
    12ba:	0f 93       	push	r16
    12bc:	1f 93       	push	r17
    12be:	df 93       	push	r29
    12c0:	cf 93       	push	r28
    12c2:	cd b7       	in	r28, 0x3d	; 61
    12c4:	de b7       	in	r29, 0x3e	; 62
    12c6:	64 97       	sbiw	r28, 0x14	; 20
    12c8:	0f b6       	in	r0, 0x3f	; 63
    12ca:	f8 94       	cli
    12cc:	de bf       	out	0x3e, r29	; 62
    12ce:	0f be       	out	0x3f, r0	; 63
    12d0:	cd bf       	out	0x3d, r28	; 61
    12d2:	60 e0       	ldi	r22, 0x00	; 0
    12d4:	70 e0       	ldi	r23, 0x00	; 0
    char receivedChar;
    u8 endOfNumber = 0;

    // Read characters until Enter ('\r') is received
    while (!endOfNumber) {
        while (!GET_BIT(_UCSRA, 7));  // Wait for a character to be received
    12d6:	ab e2       	ldi	r26, 0x2B	; 43
    12d8:	b0 e0       	ldi	r27, 0x00	; 0
        receivedChar = _UDR;          // Read the received character
    12da:	2c e2       	ldi	r18, 0x2C	; 44
    12dc:	30 e0       	ldi	r19, 0x00	; 0
        if (receivedChar == '\r' || receivedChar == '\n') {
            // If Enter key is received, mark the end of the number
            endOfNumber = 1;
        } else {
            // Store the character in the buffer
            rxBuffer[rxIndex] = receivedChar;
    12de:	8e 01       	movw	r16, r28
    12e0:	0f 5f       	subi	r16, 0xFF	; 255
    12e2:	1f 4f       	sbci	r17, 0xFF	; 255
            rxIndex++;

            // Check if the buffer is full (adjust the buffer size as needed)
            if (rxIndex >= sizeof(rxBuffer)) {
    12e4:	0f 2e       	mov	r0, r31
    12e6:	f3 e1       	ldi	r31, 0x13	; 19
    12e8:	ef 2e       	mov	r14, r31
    12ea:	ff 24       	eor	r15, r15
    12ec:	f0 2d       	mov	r31, r0
    char receivedChar;
    u8 endOfNumber = 0;

    // Read characters until Enter ('\r') is received
    while (!endOfNumber) {
        while (!GET_BIT(_UCSRA, 7));  // Wait for a character to be received
    12ee:	8c 91       	ld	r24, X
    12f0:	88 23       	and	r24, r24
    12f2:	ec f7       	brge	.-6      	; 0x12ee <UART_ReceiveNumber+0x38>
        receivedChar = _UDR;          // Read the received character
    12f4:	f9 01       	movw	r30, r18
    12f6:	80 81       	ld	r24, Z

        if (receivedChar == '\r' || receivedChar == '\n') {
    12f8:	8d 30       	cpi	r24, 0x0D	; 13
    12fa:	79 f0       	breq	.+30     	; 0x131a <UART_ReceiveNumber+0x64>
    12fc:	8a 30       	cpi	r24, 0x0A	; 10
    12fe:	69 f0       	breq	.+26     	; 0x131a <UART_ReceiveNumber+0x64>
            // If Enter key is received, mark the end of the number
            endOfNumber = 1;
        } else {
            // Store the character in the buffer
            rxBuffer[rxIndex] = receivedChar;
            rxIndex++;
    1300:	ab 01       	movw	r20, r22
    1302:	4f 5f       	subi	r20, 0xFF	; 255
    1304:	5f 4f       	sbci	r21, 0xFF	; 255

            // Check if the buffer is full (adjust the buffer size as needed)
            if (rxIndex >= sizeof(rxBuffer)) {
    1306:	44 31       	cpi	r20, 0x14	; 20
    1308:	51 05       	cpc	r21, r1
    130a:	08 f0       	brcs	.+2      	; 0x130e <UART_ReceiveNumber+0x58>
    130c:	a7 01       	movw	r20, r14
        if (receivedChar == '\r' || receivedChar == '\n') {
            // If Enter key is received, mark the end of the number
            endOfNumber = 1;
        } else {
            // Store the character in the buffer
            rxBuffer[rxIndex] = receivedChar;
    130e:	f8 01       	movw	r30, r16
    1310:	e6 0f       	add	r30, r22
    1312:	f7 1f       	adc	r31, r23
    1314:	80 83       	st	Z, r24
    1316:	ba 01       	movw	r22, r20
    1318:	ea cf       	rjmp	.-44     	; 0x12ee <UART_ReceiveNumber+0x38>
            }
        }
    }

    // Null-terminate the string in the buffer
    rxBuffer[rxIndex] = '\0';
    131a:	ce 01       	movw	r24, r28
    131c:	01 96       	adiw	r24, 0x01	; 1
    131e:	fc 01       	movw	r30, r24
    1320:	e6 0f       	add	r30, r22
    1322:	f7 1f       	adc	r31, r23
    1324:	10 82       	st	Z, r1

    // Convert the received string to an integer
    int receivedNumber = atoi(rxBuffer);
    1326:	0e 94 8d 32 	call	0x651a	; 0x651a <atoi>

    return receivedNumber;
}
    132a:	64 96       	adiw	r28, 0x14	; 20
    132c:	0f b6       	in	r0, 0x3f	; 63
    132e:	f8 94       	cli
    1330:	de bf       	out	0x3e, r29	; 62
    1332:	0f be       	out	0x3f, r0	; 63
    1334:	cd bf       	out	0x3d, r28	; 61
    1336:	cf 91       	pop	r28
    1338:	df 91       	pop	r29
    133a:	1f 91       	pop	r17
    133c:	0f 91       	pop	r16
    133e:	ff 90       	pop	r15
    1340:	ef 90       	pop	r14
    1342:	08 95       	ret

00001344 <TWI_voidInitMaster>:

/* ----------------- Section : Software Interfaces Implementation -----------------*/

void TWI_voidInitMaster(u8 copy_u8MsterAddress)
{
	if ((copy_u8MsterAddress < 128) && (copy_u8MsterAddress > 0))
    1344:	18 16       	cp	r1, r24
    1346:	14 f4       	brge	.+4      	; 0x134c <TWI_voidInitMaster+0x8>
	{
		_TWAR = copy_u8MsterAddress <<1;
    1348:	88 0f       	add	r24, r24
    134a:	82 b9       	out	0x02, r24	; 2
	}
	/* Select SCL as 400KHz */
	_TWBR = 12;
    134c:	8c e0       	ldi	r24, 0x0C	; 12
    134e:	80 b9       	out	0x00, r24	; 0
	//Prescaler 1
	CLR_BIT(_TWSR, _TWPS0);
    1350:	e1 e2       	ldi	r30, 0x21	; 33
    1352:	f0 e0       	ldi	r31, 0x00	; 0
    1354:	80 81       	ld	r24, Z
    1356:	8e 7f       	andi	r24, 0xFE	; 254
    1358:	80 83       	st	Z, r24
	CLR_BIT(_TWSR, _TWPS1);
    135a:	80 81       	ld	r24, Z
    135c:	8d 7f       	andi	r24, 0xFD	; 253
    135e:	80 83       	st	Z, r24

	// Enable ACK, in order to generate status code
	SET_BIT(_TWCR, _TWEA);
    1360:	e6 e5       	ldi	r30, 0x56	; 86
    1362:	f0 e0       	ldi	r31, 0x00	; 0
    1364:	80 81       	ld	r24, Z
    1366:	80 64       	ori	r24, 0x40	; 64
    1368:	80 83       	st	Z, r24

	// Enable TWI
	SET_BIT(_TWCR, _TWEN);
    136a:	80 81       	ld	r24, Z
    136c:	84 60       	ori	r24, 0x04	; 4
    136e:	80 83       	st	Z, r24
}
    1370:	08 95       	ret

00001372 <TWI_voidSendStartCondition>:

void TWI_voidSendStartCondition(void)
{
	// Request Start condition
	SET_BIT(_TWCR, _TWSTA);
    1372:	e6 e5       	ldi	r30, 0x56	; 86
    1374:	f0 e0       	ldi	r31, 0x00	; 0
    1376:	80 81       	ld	r24, Z
    1378:	80 62       	ori	r24, 0x20	; 32
    137a:	80 83       	st	Z, r24
	// Send the start condition
	SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    137c:	80 81       	ld	r24, Z
    137e:	80 68       	ori	r24, 0x80	; 128
    1380:	80 83       	st	Z, r24
	while(0 == GET_BIT(_TWCR, _TWINT));
    1382:	80 81       	ld	r24, Z
    1384:	88 23       	and	r24, r24
    1386:	ec f7       	brge	.-6      	; 0x1382 <TWI_voidSendStartCondition+0x10>
	// Check ACK is Positive
	while(STATUS_VALUE != Start_Condition_ACK);
    1388:	e1 e2       	ldi	r30, 0x21	; 33
    138a:	f0 e0       	ldi	r31, 0x00	; 0
    138c:	80 81       	ld	r24, Z
    138e:	88 7f       	andi	r24, 0xF8	; 248
    1390:	88 30       	cpi	r24, 0x08	; 8
    1392:	e1 f7       	brne	.-8      	; 0x138c <TWI_voidSendStartCondition+0x1a>
}
    1394:	08 95       	ret

00001396 <TWI_voidSendStopCondition>:

void TWI_voidSendStopCondition(void)
{
	// Request STOP condition
	SET_BIT(_TWCR, _TWSTO);
    1396:	e6 e5       	ldi	r30, 0x56	; 86
    1398:	f0 e0       	ldi	r31, 0x00	; 0
    139a:	80 81       	ld	r24, Z
    139c:	80 61       	ori	r24, 0x10	; 16
    139e:	80 83       	st	Z, r24
	// Send the STOP condition
	SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    13a0:	80 81       	ld	r24, Z
    13a2:	80 68       	ori	r24, 0x80	; 128
    13a4:	80 83       	st	Z, r24
}
    13a6:	08 95       	ret

000013a8 <TWI_voidSendReapeatedStartCondition>:

void TWI_voidSendReapeatedStartCondition(void)
{
	// Request Reapeated Start condition
	SET_BIT(_TWCR, _TWSTA);
    13a8:	e6 e5       	ldi	r30, 0x56	; 86
    13aa:	f0 e0       	ldi	r31, 0x00	; 0
    13ac:	80 81       	ld	r24, Z
    13ae:	80 62       	ori	r24, 0x20	; 32
    13b0:	80 83       	st	Z, r24
	// Send the Reapeated start condition
	SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    13b2:	80 81       	ld	r24, Z
    13b4:	80 68       	ori	r24, 0x80	; 128
    13b6:	80 83       	st	Z, r24
	while(0 == GET_BIT(_TWCR, _TWINT));
    13b8:	80 81       	ld	r24, Z
    13ba:	88 23       	and	r24, r24
    13bc:	ec f7       	brge	.-6      	; 0x13b8 <TWI_voidSendReapeatedStartCondition+0x10>
	// Check ACK is Positive
	while(STATUS_VALUE != RepeatedStart_Condition_ACK);
    13be:	e1 e2       	ldi	r30, 0x21	; 33
    13c0:	f0 e0       	ldi	r31, 0x00	; 0
    13c2:	80 81       	ld	r24, Z
    13c4:	88 7f       	andi	r24, 0xF8	; 248
    13c6:	80 31       	cpi	r24, 0x10	; 16
    13c8:	e1 f7       	brne	.-8      	; 0x13c2 <TWI_voidSendReapeatedStartCondition+0x1a>
}
    13ca:	08 95       	ret

000013cc <TWI_voidSendSlaveAdd_WriteRequest>:

void TWI_voidSendSlaveAdd_WriteRequest(u8 copy_u8SlaveAddress)
{
	if ((copy_u8SlaveAddress < 128) && (copy_u8SlaveAddress > 0))
    13cc:	18 16       	cp	r1, r24
    13ce:	c4 f4       	brge	.+48     	; 0x1400 <TWI_voidSendSlaveAdd_WriteRequest+0x34>
	{
		_TWDR = copy_u8SlaveAddress << 1;
    13d0:	88 0f       	add	r24, r24
    13d2:	e3 e2       	ldi	r30, 0x23	; 35
    13d4:	f0 e0       	ldi	r31, 0x00	; 0
    13d6:	80 83       	st	Z, r24
		CLR_BIT(_TWDR, 0);
    13d8:	80 81       	ld	r24, Z
    13da:	8e 7f       	andi	r24, 0xFE	; 254
    13dc:	80 83       	st	Z, r24

		// Clear Start condition Flag
		CLR_BIT(_TWCR, _TWSTA);
    13de:	e6 e5       	ldi	r30, 0x56	; 86
    13e0:	f0 e0       	ldi	r31, 0x00	; 0
    13e2:	80 81       	ld	r24, Z
    13e4:	8f 7d       	andi	r24, 0xDF	; 223
    13e6:	80 83       	st	Z, r24

		SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    13e8:	80 81       	ld	r24, Z
    13ea:	80 68       	ori	r24, 0x80	; 128
    13ec:	80 83       	st	Z, r24
		while(0 == GET_BIT(_TWCR, _TWINT));
    13ee:	80 81       	ld	r24, Z
    13f0:	88 23       	and	r24, r24
    13f2:	ec f7       	brge	.-6      	; 0x13ee <TWI_voidSendSlaveAdd_WriteRequest+0x22>
		// Check ACK is Positive
		while(STATUS_VALUE != SlaveAddress_Write_ACK);
    13f4:	e1 e2       	ldi	r30, 0x21	; 33
    13f6:	f0 e0       	ldi	r31, 0x00	; 0
    13f8:	80 81       	ld	r24, Z
    13fa:	88 7f       	andi	r24, 0xF8	; 248
    13fc:	88 31       	cpi	r24, 0x18	; 24
    13fe:	e1 f7       	brne	.-8      	; 0x13f8 <TWI_voidSendSlaveAdd_WriteRequest+0x2c>
    1400:	08 95       	ret

00001402 <TWI_voidSendSlaveAdd_ReadRequest>:
	}
}

void TWI_voidSendSlaveAdd_ReadRequest(u8 copy_u8SlaveAddress)
{
	if ((copy_u8SlaveAddress < 128) && (copy_u8SlaveAddress > 0))
    1402:	18 16       	cp	r1, r24
    1404:	c4 f4       	brge	.+48     	; 0x1436 <TWI_voidSendSlaveAdd_ReadRequest+0x34>
	{
		_TWDR = copy_u8SlaveAddress << 1;
    1406:	88 0f       	add	r24, r24
    1408:	e3 e2       	ldi	r30, 0x23	; 35
    140a:	f0 e0       	ldi	r31, 0x00	; 0
    140c:	80 83       	st	Z, r24
		SET_BIT(_TWDR, 0);
    140e:	80 81       	ld	r24, Z
    1410:	81 60       	ori	r24, 0x01	; 1
    1412:	80 83       	st	Z, r24

		// Clear Start condition Flag
		CLR_BIT(_TWCR, _TWSTA);
    1414:	e6 e5       	ldi	r30, 0x56	; 86
    1416:	f0 e0       	ldi	r31, 0x00	; 0
    1418:	80 81       	ld	r24, Z
    141a:	8f 7d       	andi	r24, 0xDF	; 223
    141c:	80 83       	st	Z, r24

		SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    141e:	80 81       	ld	r24, Z
    1420:	80 68       	ori	r24, 0x80	; 128
    1422:	80 83       	st	Z, r24
		while(0 == GET_BIT(_TWCR, _TWINT));
    1424:	80 81       	ld	r24, Z
    1426:	88 23       	and	r24, r24
    1428:	ec f7       	brge	.-6      	; 0x1424 <TWI_voidSendSlaveAdd_ReadRequest+0x22>
		// Check ACK is Positive
		while(STATUS_VALUE != SlaveAddress_Read_ACK);
    142a:	e1 e2       	ldi	r30, 0x21	; 33
    142c:	f0 e0       	ldi	r31, 0x00	; 0
    142e:	80 81       	ld	r24, Z
    1430:	88 7f       	andi	r24, 0xF8	; 248
    1432:	80 34       	cpi	r24, 0x40	; 64
    1434:	e1 f7       	brne	.-8      	; 0x142e <TWI_voidSendSlaveAdd_ReadRequest+0x2c>
    1436:	08 95       	ret

00001438 <TWI_voidWriteMasterDataByte>:
	}
}

void TWI_voidWriteMasterDataByte(u8 copy_u8Data)
{
	_TWDR = copy_u8Data;
    1438:	83 b9       	out	0x03, r24	; 3
	// Clear Start condition Flag
	SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    143a:	e6 e5       	ldi	r30, 0x56	; 86
    143c:	f0 e0       	ldi	r31, 0x00	; 0
    143e:	80 81       	ld	r24, Z
    1440:	80 68       	ori	r24, 0x80	; 128
    1442:	80 83       	st	Z, r24
	while(0 == GET_BIT(_TWCR, _TWINT));
    1444:	80 81       	ld	r24, Z
    1446:	88 23       	and	r24, r24
    1448:	ec f7       	brge	.-6      	; 0x1444 <TWI_voidWriteMasterDataByte+0xc>
	// Check ACK is Positive
	while(STATUS_VALUE != Master_Data_Transmit_ACK);
    144a:	e1 e2       	ldi	r30, 0x21	; 33
    144c:	f0 e0       	ldi	r31, 0x00	; 0
    144e:	80 81       	ld	r24, Z
    1450:	88 7f       	andi	r24, 0xF8	; 248
    1452:	88 32       	cpi	r24, 0x28	; 40
    1454:	e1 f7       	brne	.-8      	; 0x144e <TWI_voidWriteMasterDataByte+0x16>
}
    1456:	08 95       	ret

00001458 <TWI_voidReadMasterDataByteNACK>:

void TWI_voidReadMasterDataByteNACK(u8 *copy_u8PtrData)
{
    1458:	dc 01       	movw	r26, r24
	CLR_BIT(_TWCR, _TWEA);	//Disable ACK
    145a:	e6 e5       	ldi	r30, 0x56	; 86
    145c:	f0 e0       	ldi	r31, 0x00	; 0
    145e:	80 81       	ld	r24, Z
    1460:	8f 7b       	andi	r24, 0xBF	; 191
    1462:	80 83       	st	Z, r24
	if (copy_u8PtrData != NULL)
    1464:	10 97       	sbiw	r26, 0x00	; 0
    1466:	71 f0       	breq	.+28     	; 0x1484 <TWI_voidReadMasterDataByteNACK+0x2c>
	{
		// Clear Start condition Flag
		SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    1468:	80 81       	ld	r24, Z
    146a:	80 68       	ori	r24, 0x80	; 128
    146c:	80 83       	st	Z, r24
		while(0 == GET_BIT(_TWCR, _TWINT));
    146e:	80 81       	ld	r24, Z
    1470:	88 23       	and	r24, r24
    1472:	ec f7       	brge	.-6      	; 0x146e <TWI_voidReadMasterDataByteNACK+0x16>
		// Check NACK
	while(STATUS_VALUE != Master_Data_Receive_NACK);
    1474:	e1 e2       	ldi	r30, 0x21	; 33
    1476:	f0 e0       	ldi	r31, 0x00	; 0
    1478:	80 81       	ld	r24, Z
    147a:	88 7f       	andi	r24, 0xF8	; 248
    147c:	88 35       	cpi	r24, 0x58	; 88
    147e:	e1 f7       	brne	.-8      	; 0x1478 <TWI_voidReadMasterDataByteNACK+0x20>
		*copy_u8PtrData = _TWDR;
    1480:	83 b1       	in	r24, 0x03	; 3
    1482:	8c 93       	st	X, r24
	}
	SET_BIT(_TWCR, _TWEA);	// //Enable ACK
    1484:	e6 e5       	ldi	r30, 0x56	; 86
    1486:	f0 e0       	ldi	r31, 0x00	; 0
    1488:	80 81       	ld	r24, Z
    148a:	80 64       	ori	r24, 0x40	; 64
    148c:	80 83       	st	Z, r24
}
    148e:	08 95       	ret

00001490 <TWI_voidReadMasterDataByteACK>:


void TWI_voidReadMasterDataByteACK(u8 *copy_u8PtrData)
{
    1490:	dc 01       	movw	r26, r24
	if (copy_u8PtrData != NULL)
    1492:	00 97       	sbiw	r24, 0x00	; 0
    1494:	81 f0       	breq	.+32     	; 0x14b6 <TWI_voidReadMasterDataByteACK+0x26>
	{
		// Clear Start condition Flag
		SET_BIT(_TWCR, _TWINT);	//Clear the TWINT Flag
    1496:	e6 e5       	ldi	r30, 0x56	; 86
    1498:	f0 e0       	ldi	r31, 0x00	; 0
    149a:	80 81       	ld	r24, Z
    149c:	80 68       	ori	r24, 0x80	; 128
    149e:	80 83       	st	Z, r24
		while(0 == GET_BIT(_TWCR, _TWINT));
    14a0:	80 81       	ld	r24, Z
    14a2:	88 23       	and	r24, r24
    14a4:	ec f7       	brge	.-6      	; 0x14a0 <TWI_voidReadMasterDataByteACK+0x10>
		// Check ACK is Positive
		while(STATUS_VALUE != Master_Data_Receive_ACK);
    14a6:	e1 e2       	ldi	r30, 0x21	; 33
    14a8:	f0 e0       	ldi	r31, 0x00	; 0
    14aa:	80 81       	ld	r24, Z
    14ac:	88 7f       	andi	r24, 0xF8	; 248
    14ae:	80 35       	cpi	r24, 0x50	; 80
    14b0:	e1 f7       	brne	.-8      	; 0x14aa <TWI_voidReadMasterDataByteACK+0x1a>
		*copy_u8PtrData = _TWDR;
    14b2:	83 b1       	in	r24, 0x03	; 3
    14b4:	8c 93       	st	X, r24
    14b6:	08 95       	ret

000014b8 <TMR2_voidStop>:
 * @param	void
 * @return	void
 */
void TMR2_voidStop(void)
{
	CLR_BIT(_TCCR2,0);
    14b8:	e5 e4       	ldi	r30, 0x45	; 69
    14ba:	f0 e0       	ldi	r31, 0x00	; 0
    14bc:	80 81       	ld	r24, Z
    14be:	8e 7f       	andi	r24, 0xFE	; 254
    14c0:	80 83       	st	Z, r24
	CLR_BIT(_TCCR2,1);
    14c2:	80 81       	ld	r24, Z
    14c4:	8d 7f       	andi	r24, 0xFD	; 253
    14c6:	80 83       	st	Z, r24
	CLR_BIT(_TCCR2,2);
    14c8:	80 81       	ld	r24, Z
    14ca:	8b 7f       	andi	r24, 0xFB	; 251
    14cc:	80 83       	st	Z, r24
}
    14ce:	08 95       	ret

000014d0 <TMR2_Preload_value_set>:
 * @param	value: The preload value to be set
 * @return	void
 */
void TMR2_Preload_value_set(u8 value)
{
	_TCNT2 = value;
    14d0:	84 bd       	out	0x24, r24	; 36
}
    14d2:	08 95       	ret

000014d4 <TMR2_voidSetDelay_ms_using_CTC>:
#elif TMR2_PRESCALER == 8
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR2_OCR2_val + 1) * 0.5);
#elif TMR2_PRESCALER == 32
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR2_OCR2_val + 1) * 2);
#elif TMR2_PRESCALER == 64
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR2_OCR2_val + 1) * 4);
    14d4:	a0 e0       	ldi	r26, 0x00	; 0
    14d6:	b0 e0       	ldi	r27, 0x00	; 0
    14d8:	bc 01       	movw	r22, r24
    14da:	cd 01       	movw	r24, r26
    14dc:	28 ee       	ldi	r18, 0xE8	; 232
    14de:	33 e0       	ldi	r19, 0x03	; 3
    14e0:	40 e0       	ldi	r20, 0x00	; 0
    14e2:	50 e0       	ldi	r21, 0x00	; 0
    14e4:	0e 94 fc 30 	call	0x61f8	; 0x61f8 <__mulsi3>
    14e8:	0e 94 2f 31 	call	0x625e	; 0x625e <__udivmodsi4>
    14ec:	30 93 b3 01 	sts	0x01B3, r19
    14f0:	20 93 b2 01 	sts	0x01B2, r18
#elif TMR2_PRESCALER == 256
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR2_OCR2_val + 1) * 16);
#elif TMR2_PRESCALER == 1024
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR2_OCR2_val + 1) * 64);
#endif
}
    14f4:	08 95       	ret

000014f6 <TMR2_voidSetDutyCycle>:
	copy_u8_duty = 100 - copy_u8_duty;
	_OCR2 = (((u16)copy_u8_duty * 256) / 100) - 510;
	#endif	//Phase_correct_PWM_MODE2
	}
#endif // TMR2_MODE
}
    14f6:	08 95       	ret

000014f8 <TMR2_voidSendCallBack_OCM>:
 * @return	void
 */

void TMR2_voidSendCallBack_OCM(void (*PtrF)(void))
{
	if(PtrF != NULL)
    14f8:	00 97       	sbiw	r24, 0x00	; 0
    14fa:	21 f0       	breq	.+8      	; 0x1504 <TMR2_voidSendCallBack_OCM+0xc>
	{
		privatePTR_OC = PtrF;
    14fc:	90 93 b5 01 	sts	0x01B5, r25
    1500:	80 93 b4 01 	sts	0x01B4, r24
    1504:	08 95       	ret

00001506 <TMR2_voidInit>:
	case FastPWM2:
		SET_BIT(_TCCR2, 3);
		SET_BIT(_TCCR2, 6);
		break;
	case CTC2:
		SET_BIT(_TCCR2, 3);
    1506:	e5 e4       	ldi	r30, 0x45	; 69
    1508:	f0 e0       	ldi	r31, 0x00	; 0
    150a:	80 81       	ld	r24, Z
    150c:	88 60       	ori	r24, 0x08	; 8
    150e:	80 83       	st	Z, r24
		CLR_BIT(_TCCR2, 6);
    1510:	80 81       	ld	r24, Z
    1512:	8f 7b       	andi	r24, 0xBF	; 191
    1514:	80 83       	st	Z, r24
	SET_BIT(_TIMSK, 6);
}
#elif TMR2_MODE == TMR2_CTC_MODE
static void Enable_OCI2(void)
{
	SET_BIT(_TIMSK, 7);
    1516:	e9 e5       	ldi	r30, 0x59	; 89
    1518:	f0 e0       	ldi	r31, 0x00	; 0
    151a:	80 81       	ld	r24, Z
    151c:	80 68       	ori	r24, 0x80	; 128
    151e:	80 83       	st	Z, r24
	Enable_OVI2();
	TMR2_Preload_value_set(TMR2_PRELOAD);
#elif TMR2_MODE == TMR2_CTC_MODE
	select_mode(CTC2);
	Enable_OCI2();
	_OCR2 = (TMR2_OCR2_val);
    1520:	89 ef       	ldi	r24, 0xF9	; 249
    1522:	83 bd       	out	0x23, r24	; 35
		SET_BIT(_TCCR2, 4);
		SET_BIT(_TCCR2, 5);
		break;
	}
#endif	// TMR2_MODE
}
    1524:	08 95       	ret

00001526 <TMR2_voidStart>:
		SET_BIT(_TCCR2,0);
		SET_BIT(_TCCR2,1);
		CLR_BIT(_TCCR2,2);
		break;
	case 64:
		CLR_BIT(_TCCR2,0);
    1526:	e5 e4       	ldi	r30, 0x45	; 69
    1528:	f0 e0       	ldi	r31, 0x00	; 0
    152a:	80 81       	ld	r24, Z
    152c:	8e 7f       	andi	r24, 0xFE	; 254
    152e:	80 83       	st	Z, r24
		CLR_BIT(_TCCR2,1);
    1530:	80 81       	ld	r24, Z
    1532:	8d 7f       	andi	r24, 0xFD	; 253
    1534:	80 83       	st	Z, r24
		SET_BIT(_TCCR2,2);
    1536:	80 81       	ld	r24, Z
    1538:	84 60       	ori	r24, 0x04	; 4
    153a:	80 83       	st	Z, r24
 * @return	void
 */
void TMR2_voidStart(void)
{
	PrescalerValue_set((u16)TMR2_PRESCALER);
}
    153c:	08 95       	ret

0000153e <__vector_5>:
// TIMER2 COMP - CTC Mode ISR
void __vector_4(void) __attribute__((signal));


void __vector_5(void)
{
    153e:	1f 92       	push	r1
    1540:	0f 92       	push	r0
    1542:	0f b6       	in	r0, 0x3f	; 63
    1544:	0f 92       	push	r0
    1546:	11 24       	eor	r1, r1
    1548:	2f 93       	push	r18
    154a:	3f 93       	push	r19
    154c:	4f 93       	push	r20
    154e:	5f 93       	push	r21
    1550:	6f 93       	push	r22
    1552:	7f 93       	push	r23
    1554:	8f 93       	push	r24
    1556:	9f 93       	push	r25
    1558:	af 93       	push	r26
    155a:	bf 93       	push	r27
    155c:	ef 93       	push	r30
    155e:	ff 93       	push	r31
	static u16 count = 0;
	count ++;
    1560:	80 91 b8 01 	lds	r24, 0x01B8
    1564:	90 91 b9 01 	lds	r25, 0x01B9
    1568:	01 96       	adiw	r24, 0x01	; 1
    156a:	90 93 b9 01 	sts	0x01B9, r25
    156e:	80 93 b8 01 	sts	0x01B8, r24
	if(count == TMR2_OVERFLOW)
    1572:	81 5d       	subi	r24, 0xD1	; 209
    1574:	93 40       	sbci	r25, 0x03	; 3
    1576:	39 f4       	brne	.+14     	; 0x1586 <__vector_5+0x48>
	{
		TMR2_Preload_value_set(113);
    1578:	81 e7       	ldi	r24, 0x71	; 113
    157a:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <TMR2_Preload_value_set>
		count = 0;
    157e:	10 92 b9 01 	sts	0x01B9, r1
    1582:	10 92 b8 01 	sts	0x01B8, r1
			{
				privatePTR_OV();
			}
	}

}
    1586:	ff 91       	pop	r31
    1588:	ef 91       	pop	r30
    158a:	bf 91       	pop	r27
    158c:	af 91       	pop	r26
    158e:	9f 91       	pop	r25
    1590:	8f 91       	pop	r24
    1592:	7f 91       	pop	r23
    1594:	6f 91       	pop	r22
    1596:	5f 91       	pop	r21
    1598:	4f 91       	pop	r20
    159a:	3f 91       	pop	r19
    159c:	2f 91       	pop	r18
    159e:	0f 90       	pop	r0
    15a0:	0f be       	out	0x3f, r0	; 63
    15a2:	0f 90       	pop	r0
    15a4:	1f 90       	pop	r1
    15a6:	18 95       	reti

000015a8 <__vector_4>:


void __vector_4(void)
{
    15a8:	1f 92       	push	r1
    15aa:	0f 92       	push	r0
    15ac:	0f b6       	in	r0, 0x3f	; 63
    15ae:	0f 92       	push	r0
    15b0:	11 24       	eor	r1, r1
    15b2:	2f 93       	push	r18
    15b4:	3f 93       	push	r19
    15b6:	4f 93       	push	r20
    15b8:	5f 93       	push	r21
    15ba:	6f 93       	push	r22
    15bc:	7f 93       	push	r23
    15be:	8f 93       	push	r24
    15c0:	9f 93       	push	r25
    15c2:	af 93       	push	r26
    15c4:	bf 93       	push	r27
    15c6:	ef 93       	push	r30
    15c8:	ff 93       	push	r31
	static u16 count = 0;
	count ++;
    15ca:	80 91 b6 01 	lds	r24, 0x01B6
    15ce:	90 91 b7 01 	lds	r25, 0x01B7
    15d2:	01 96       	adiw	r24, 0x01	; 1
    15d4:	90 93 b7 01 	sts	0x01B7, r25
    15d8:	80 93 b6 01 	sts	0x01B6, r24
	if(count == private_CTC_counter)
    15dc:	20 91 b2 01 	lds	r18, 0x01B2
    15e0:	30 91 b3 01 	lds	r19, 0x01B3
    15e4:	82 17       	cp	r24, r18
    15e6:	93 07       	cpc	r25, r19
    15e8:	59 f4       	brne	.+22     	; 0x1600 <__vector_4+0x58>
	{
		count = 0;
    15ea:	10 92 b7 01 	sts	0x01B7, r1
    15ee:	10 92 b6 01 	sts	0x01B6, r1
		if(privatePTR_OC !=NULL)
    15f2:	e0 91 b4 01 	lds	r30, 0x01B4
    15f6:	f0 91 b5 01 	lds	r31, 0x01B5
    15fa:	30 97       	sbiw	r30, 0x00	; 0
    15fc:	09 f0       	breq	.+2      	; 0x1600 <__vector_4+0x58>
			{
			privatePTR_OC();
    15fe:	09 95       	icall
			}
	}
}
    1600:	ff 91       	pop	r31
    1602:	ef 91       	pop	r30
    1604:	bf 91       	pop	r27
    1606:	af 91       	pop	r26
    1608:	9f 91       	pop	r25
    160a:	8f 91       	pop	r24
    160c:	7f 91       	pop	r23
    160e:	6f 91       	pop	r22
    1610:	5f 91       	pop	r21
    1612:	4f 91       	pop	r20
    1614:	3f 91       	pop	r19
    1616:	2f 91       	pop	r18
    1618:	0f 90       	pop	r0
    161a:	0f be       	out	0x3f, r0	; 63
    161c:	0f 90       	pop	r0
    161e:	1f 90       	pop	r1
    1620:	18 95       	reti

00001622 <TMR1_voidStop>:
 * @param	void
 * @return	void
 */
void TMR1_voidStop(void)
{
	CLR_BIT(_TCCR1B, _CS10);
    1622:	ee e4       	ldi	r30, 0x4E	; 78
    1624:	f0 e0       	ldi	r31, 0x00	; 0
    1626:	80 81       	ld	r24, Z
    1628:	8e 7f       	andi	r24, 0xFE	; 254
    162a:	80 83       	st	Z, r24
	CLR_BIT(_TCCR1B, _CS11);
    162c:	80 81       	ld	r24, Z
    162e:	8d 7f       	andi	r24, 0xFD	; 253
    1630:	80 83       	st	Z, r24
	CLR_BIT(_TCCR1B, _CS12);
    1632:	80 81       	ld	r24, Z
    1634:	8b 7f       	andi	r24, 0xFB	; 251
    1636:	80 83       	st	Z, r24
}
    1638:	08 95       	ret

0000163a <TMR1_voidSetCompareMatchValueA>:

void TMR1_voidSetCompareMatchValueA(u16 copy_u8CompareMatchValueA){
	_OCR1A = copy_u8CompareMatchValueA;
    163a:	9b bd       	out	0x2b, r25	; 43
    163c:	8a bd       	out	0x2a, r24	; 42
}
    163e:	08 95       	ret

00001640 <TMR1_voidSetFreq_Mode14>:

//under condition ticktime = 4 microsecond
void TMR1_voidSetFreq_Mode14(u16 copy_u16_frequency)
{
#if TMR1_PRESCALER == 64
	_ICR1 = (1000000UL / copy_u16_frequency) / 4 - 1;
    1640:	9c 01       	movw	r18, r24
    1642:	40 e0       	ldi	r20, 0x00	; 0
    1644:	50 e0       	ldi	r21, 0x00	; 0
    1646:	60 e9       	ldi	r22, 0x90	; 144
    1648:	70 ed       	ldi	r23, 0xD0	; 208
    164a:	83 e0       	ldi	r24, 0x03	; 3
    164c:	90 e0       	ldi	r25, 0x00	; 0
    164e:	0e 94 2f 31 	call	0x625e	; 0x625e <__udivmodsi4>
    1652:	21 50       	subi	r18, 0x01	; 1
    1654:	30 40       	sbci	r19, 0x00	; 0
    1656:	37 bd       	out	0x27, r19	; 39
    1658:	26 bd       	out	0x26, r18	; 38
#endif// TMR1_PRESCALER
}
    165a:	08 95       	ret

0000165c <TMR1_voidInit>:
 * @return	void
 */
void TMR1_voidInit(void)
{
#if TMR1_MODE 	== TMR1_FastPWM_MODE_14
	CLR_BIT(_TCCR1A, _WGM10);
    165c:	af e4       	ldi	r26, 0x4F	; 79
    165e:	b0 e0       	ldi	r27, 0x00	; 0
    1660:	8c 91       	ld	r24, X
    1662:	8e 7f       	andi	r24, 0xFE	; 254
    1664:	8c 93       	st	X, r24
	SET_BIT(_TCCR1A, _WGM11);
    1666:	8c 91       	ld	r24, X
    1668:	82 60       	ori	r24, 0x02	; 2
    166a:	8c 93       	st	X, r24
	SET_BIT(_TCCR1B, _WGM12);
    166c:	ee e4       	ldi	r30, 0x4E	; 78
    166e:	f0 e0       	ldi	r31, 0x00	; 0
    1670:	80 81       	ld	r24, Z
    1672:	88 60       	ori	r24, 0x08	; 8
    1674:	80 83       	st	Z, r24
	SET_BIT(_TCCR1B, _WGM13);
    1676:	80 81       	ld	r24, Z
    1678:	80 61       	ori	r24, 0x10	; 16
    167a:	80 83       	st	Z, r24
	switch(TMR1_FastPWM_14_MODE)
	{
	case non_inverting1:
		CLR_BIT(_TCCR1A, _COM1A0);
    167c:	8c 91       	ld	r24, X
    167e:	8f 7b       	andi	r24, 0xBF	; 191
    1680:	8c 93       	st	X, r24
		SET_BIT(_TCCR1A, _COM1A1);
    1682:	8c 91       	ld	r24, X
    1684:	80 68       	ori	r24, 0x80	; 128
    1686:	8c 93       	st	X, r24
	case inverting1:
		SET_BIT(_TCCR1A, _COM1A0);
		SET_BIT(_TCCR1A, _COM1A1);
		break;
	}
	TMR1_voidSetFreq_Mode14(50);
    1688:	82 e3       	ldi	r24, 0x32	; 50
    168a:	90 e0       	ldi	r25, 0x00	; 0
    168c:	0e 94 20 0b 	call	0x1640	; 0x1640 <TMR1_voidSetFreq_Mode14>
#endif // TMR1_MODE
}
    1690:	08 95       	ret

00001692 <TMR1_voidSetDuty_Mode14>:
	_ICR1 = (1000000UL / copy_u16_frequency) / 4 - 1;
#endif// TMR1_PRESCALER
}

void TMR1_voidSetDuty_Mode14(f32 copy_u8_duty)
{
    1692:	ef 92       	push	r14
    1694:	ff 92       	push	r15
    1696:	0f 93       	push	r16
    1698:	1f 93       	push	r17
    169a:	7b 01       	movw	r14, r22
    169c:	8c 01       	movw	r16, r24
	if(copy_u8_duty <= 100)
    169e:	20 e0       	ldi	r18, 0x00	; 0
    16a0:	30 e0       	ldi	r19, 0x00	; 0
    16a2:	48 ec       	ldi	r20, 0xC8	; 200
    16a4:	52 e4       	ldi	r21, 0x42	; 66
    16a6:	0e 94 25 04 	call	0x84a	; 0x84a <__lesf2>
    16aa:	18 16       	cp	r1, r24
    16ac:	4c f1       	brlt	.+82     	; 0x1700 <TMR1_voidSetDuty_Mode14+0x6e>
		{
		#if TMR1_FastPWM_14_MODE == non_inverting1
			if(copy_u8_duty == 0){
    16ae:	c8 01       	movw	r24, r16
    16b0:	b7 01       	movw	r22, r14
    16b2:	20 e0       	ldi	r18, 0x00	; 0
    16b4:	30 e0       	ldi	r19, 0x00	; 0
    16b6:	40 e0       	ldi	r20, 0x00	; 0
    16b8:	50 e0       	ldi	r21, 0x00	; 0
    16ba:	0e 94 c5 03 	call	0x78a	; 0x78a <__eqsf2>
    16be:	88 23       	and	r24, r24
    16c0:	19 f4       	brne	.+6      	; 0x16c8 <TMR1_voidSetDuty_Mode14+0x36>
				_OCR1A = 0;
    16c2:	1b bc       	out	0x2b, r1	; 43
    16c4:	1a bc       	out	0x2a, r1	; 42
    16c6:	1c c0       	rjmp	.+56     	; 0x1700 <TMR1_voidSetDuty_Mode14+0x6e>
			}
			else{
				_OCR1A = ((copy_u8_duty * (_ICR1+1)) / 100) -1;
    16c8:	66 b5       	in	r22, 0x26	; 38
    16ca:	77 b5       	in	r23, 0x27	; 39
    16cc:	6f 5f       	subi	r22, 0xFF	; 255
    16ce:	7f 4f       	sbci	r23, 0xFF	; 255
    16d0:	80 e0       	ldi	r24, 0x00	; 0
    16d2:	90 e0       	ldi	r25, 0x00	; 0
    16d4:	0e 94 07 05 	call	0xa0e	; 0xa0e <__floatunsisf>
    16d8:	a8 01       	movw	r20, r16
    16da:	97 01       	movw	r18, r14
    16dc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    16e0:	20 e0       	ldi	r18, 0x00	; 0
    16e2:	30 e0       	ldi	r19, 0x00	; 0
    16e4:	48 ec       	ldi	r20, 0xC8	; 200
    16e6:	52 e4       	ldi	r21, 0x42	; 66
    16e8:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    16ec:	20 e0       	ldi	r18, 0x00	; 0
    16ee:	30 e0       	ldi	r19, 0x00	; 0
    16f0:	40 e8       	ldi	r20, 0x80	; 128
    16f2:	5f e3       	ldi	r21, 0x3F	; 63
    16f4:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
    16f8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16fc:	7b bd       	out	0x2b, r23	; 43
    16fe:	6a bd       	out	0x2a, r22	; 42
				copy_u8_duty = 100 - copy_u8_duty;
				_OCR1A = (((float)copy_u8_duty * (_ICR1+1)) / 100) -1;
			}
		#endif	//TMR1_FastPWM_14_MODE
		}
}
    1700:	1f 91       	pop	r17
    1702:	0f 91       	pop	r16
    1704:	ff 90       	pop	r15
    1706:	ef 90       	pop	r14
    1708:	08 95       	ret

0000170a <TMR1_voidStart>:
		CLR_BIT(_TCCR1B, _CS10);
		SET_BIT(_TCCR1B, _CS11);
		CLR_BIT(_TCCR1B, _CS12);
		break;
	case 64:
		SET_BIT(_TCCR1B, _CS10);
    170a:	ee e4       	ldi	r30, 0x4E	; 78
    170c:	f0 e0       	ldi	r31, 0x00	; 0
    170e:	80 81       	ld	r24, Z
    1710:	81 60       	ori	r24, 0x01	; 1
    1712:	80 83       	st	Z, r24
		SET_BIT(_TCCR1B, _CS11);
    1714:	80 81       	ld	r24, Z
    1716:	82 60       	ori	r24, 0x02	; 2
    1718:	80 83       	st	Z, r24
		CLR_BIT(_TCCR1B, _CS12);
    171a:	80 81       	ld	r24, Z
    171c:	8b 7f       	andi	r24, 0xFB	; 251
    171e:	80 83       	st	Z, r24


void TMR1_voidStart(void)
{
	PrescalerValue_set((u16)TMR1_PRESCALER);
}
    1720:	08 95       	ret

00001722 <TMR0_voidStop>:
 * @param	void
 * @return	void
 */
void TMR0_voidStop(void)
{
	CLR_BIT(_TCCR0,0);
    1722:	e3 e5       	ldi	r30, 0x53	; 83
    1724:	f0 e0       	ldi	r31, 0x00	; 0
    1726:	80 81       	ld	r24, Z
    1728:	8e 7f       	andi	r24, 0xFE	; 254
    172a:	80 83       	st	Z, r24
	CLR_BIT(_TCCR0,1);
    172c:	80 81       	ld	r24, Z
    172e:	8d 7f       	andi	r24, 0xFD	; 253
    1730:	80 83       	st	Z, r24
	CLR_BIT(_TCCR0,2);
    1732:	80 81       	ld	r24, Z
    1734:	8b 7f       	andi	r24, 0xFB	; 251
    1736:	80 83       	st	Z, r24
}
    1738:	08 95       	ret

0000173a <TMR0_Preload_value_set>:
 * @param	value: The preload value to be set
 * @return	void
 */
void TMR0_Preload_value_set(u8 value)
{
	_TCNT0 = value;
    173a:	82 bf       	out	0x32, r24	; 50
}
    173c:	08 95       	ret

0000173e <TMR0_voidSetDelay_ms_using_CTC>:
#if TMR0_PRESCALER == 1
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR0_OCR0_val + 1) * 0.0625);
#elif TMR0_PRESCALER == 8
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR0_OCR0_val + 1) * 0.5);
#elif TMR0_PRESCALER == 64
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR0_OCR0_val + 1) * 4);
    173e:	a0 e0       	ldi	r26, 0x00	; 0
    1740:	b0 e0       	ldi	r27, 0x00	; 0
    1742:	bc 01       	movw	r22, r24
    1744:	cd 01       	movw	r24, r26
    1746:	28 ee       	ldi	r18, 0xE8	; 232
    1748:	33 e0       	ldi	r19, 0x03	; 3
    174a:	40 e0       	ldi	r20, 0x00	; 0
    174c:	50 e0       	ldi	r21, 0x00	; 0
    174e:	0e 94 fc 30 	call	0x61f8	; 0x61f8 <__mulsi3>
    1752:	67 2f       	mov	r22, r23
    1754:	78 2f       	mov	r23, r24
    1756:	89 2f       	mov	r24, r25
    1758:	99 27       	eor	r25, r25
    175a:	70 93 bb 01 	sts	0x01BB, r23
    175e:	60 93 ba 01 	sts	0x01BA, r22
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR0_OCR0_val + 1) * 16);

#elif TMR0_PRESCALER == 1024
	private_CTC_counter = ((u32)_del_ms*1000) / ((TMR0_OCR0_val + 1) * 64);
#endif
}
    1762:	08 95       	ret

00001764 <TMR0_voidSetDutyCycle>:
	copy_u8_duty = 100 - copy_u8_duty;
	_OCR0 = (((u16)copy_u8_duty * 256) / 100) - 510;;
	#endif	//Phase_Correct_PWM_MODE
	}
#endif // TMR0_MODE
}
    1764:	08 95       	ret

00001766 <TMR0_voidSendCallBack_OVF>:
 * @param	PtrF: A pointer to the overflow callback function
 * @return	void
 */
void TMR0_voidSendCallBack_OVF(void (*PtrF)(void))
{
	if(PtrF != NULL)
    1766:	00 97       	sbiw	r24, 0x00	; 0
    1768:	21 f0       	breq	.+8      	; 0x1772 <TMR0_voidSendCallBack_OVF+0xc>
	{
		privatePTR_OV = PtrF;
    176a:	90 93 c1 01 	sts	0x01C1, r25
    176e:	80 93 c0 01 	sts	0x01C0, r24
    1772:	08 95       	ret

00001774 <TMR0_voidSendCallBack_OCM>:
 * @return	void
 */

void TMR0_voidSendCallBack_OCM(void (*PtrF)(void))
{
	if(PtrF != NULL)
    1774:	00 97       	sbiw	r24, 0x00	; 0
    1776:	21 f0       	breq	.+8      	; 0x1780 <TMR0_voidSendCallBack_OCM+0xc>
	{
		privatePTR_OC = PtrF;
    1778:	90 93 bd 01 	sts	0x01BD, r25
    177c:	80 93 bc 01 	sts	0x01BC, r24
    1780:	08 95       	ret

00001782 <TMR0_voidInit>:
static void select_mode(u8 mode)
{
	switch(mode)
	{
	case Normal:
		CLR_BIT(_TCCR0, 3);
    1782:	e3 e5       	ldi	r30, 0x53	; 83
    1784:	f0 e0       	ldi	r31, 0x00	; 0
    1786:	80 81       	ld	r24, Z
    1788:	87 7f       	andi	r24, 0xF7	; 247
    178a:	80 83       	st	Z, r24
		CLR_BIT(_TCCR0, 6);
    178c:	80 81       	ld	r24, Z
    178e:	8f 7b       	andi	r24, 0xBF	; 191
    1790:	80 83       	st	Z, r24
}

#if TMR0_MODE 	== TMR0_NORMAL_MODE
static void Enable_OVI0(void)
{
	SET_BIT(_TIMSK, 0);
    1792:	e9 e5       	ldi	r30, 0x59	; 89
    1794:	f0 e0       	ldi	r31, 0x00	; 0
    1796:	80 81       	ld	r24, Z
    1798:	81 60       	ori	r24, 0x01	; 1
    179a:	80 83       	st	Z, r24
void TMR0_voidInit(void)
{
#if TMR0_MODE 	== TMR0_NORMAL_MODE
	select_mode(Normal);
	Enable_OVI0();
	TMR0_Preload_value_set(TMR0_PRELOAD);
    179c:	80 e0       	ldi	r24, 0x00	; 0
    179e:	0e 94 9d 0b 	call	0x173a	; 0x173a <TMR0_Preload_value_set>
		SET_BIT(_TCCR0, 4);
		SET_BIT(_TCCR0, 5);
		break;
	}
#endif
}
    17a2:	08 95       	ret

000017a4 <TMR0_voidStart>:
		CLR_BIT(_TCCR0,0);
		SET_BIT(_TCCR0,1);
		CLR_BIT(_TCCR0,2);
		break;
	case 64:
		SET_BIT(_TCCR0,0);
    17a4:	e3 e5       	ldi	r30, 0x53	; 83
    17a6:	f0 e0       	ldi	r31, 0x00	; 0
    17a8:	80 81       	ld	r24, Z
    17aa:	81 60       	ori	r24, 0x01	; 1
    17ac:	80 83       	st	Z, r24
		SET_BIT(_TCCR0,1);
    17ae:	80 81       	ld	r24, Z
    17b0:	82 60       	ori	r24, 0x02	; 2
    17b2:	80 83       	st	Z, r24
		CLR_BIT(_TCCR0,2);
    17b4:	80 81       	ld	r24, Z
    17b6:	8b 7f       	andi	r24, 0xFB	; 251
    17b8:	80 83       	st	Z, r24
 * @return	void
 */
void TMR0_voidStart(void)
{
	PrescalerValue_set((u16)TMR0_PRESCALER);
}
    17ba:	08 95       	ret

000017bc <__vector_11>:
//CTC Mode ISR
void __vector_10(void) __attribute__((signal));


void __vector_11(void)
{
    17bc:	1f 92       	push	r1
    17be:	0f 92       	push	r0
    17c0:	0f b6       	in	r0, 0x3f	; 63
    17c2:	0f 92       	push	r0
    17c4:	11 24       	eor	r1, r1
    17c6:	2f 93       	push	r18
    17c8:	3f 93       	push	r19
    17ca:	4f 93       	push	r20
    17cc:	5f 93       	push	r21
    17ce:	6f 93       	push	r22
    17d0:	7f 93       	push	r23
    17d2:	8f 93       	push	r24
    17d4:	9f 93       	push	r25
    17d6:	af 93       	push	r26
    17d8:	bf 93       	push	r27
    17da:	ef 93       	push	r30
    17dc:	ff 93       	push	r31
	static u16 local_u16ovCounter = 0;
	local_u16ovCounter++;
    17de:	80 91 c2 01 	lds	r24, 0x01C2
    17e2:	90 91 c3 01 	lds	r25, 0x01C3
    17e6:	01 96       	adiw	r24, 0x01	; 1
    17e8:	90 93 c3 01 	sts	0x01C3, r25
    17ec:	80 93 c2 01 	sts	0x01C2, r24

	if (TMR0_OVERFLOW == local_u16ovCounter) {
    17f0:	06 97       	sbiw	r24, 0x06	; 6
    17f2:	61 f4       	brne	.+24     	; 0x180c <__vector_11+0x50>
		// Reload preload value
		_TCNT0 = TMR0_PRELOAD;
    17f4:	12 be       	out	0x32, r1	; 50
		// Clear the counter
		local_u16ovCounter = 0;
    17f6:	10 92 c3 01 	sts	0x01C3, r1
    17fa:	10 92 c2 01 	sts	0x01C2, r1

		// Call the callback function if assigned
		if (privatePTR_OV != NULL) {
    17fe:	e0 91 c0 01 	lds	r30, 0x01C0
    1802:	f0 91 c1 01 	lds	r31, 0x01C1
    1806:	30 97       	sbiw	r30, 0x00	; 0
    1808:	09 f0       	breq	.+2      	; 0x180c <__vector_11+0x50>
			privatePTR_OV();
    180a:	09 95       	icall
		}
	}
}
    180c:	ff 91       	pop	r31
    180e:	ef 91       	pop	r30
    1810:	bf 91       	pop	r27
    1812:	af 91       	pop	r26
    1814:	9f 91       	pop	r25
    1816:	8f 91       	pop	r24
    1818:	7f 91       	pop	r23
    181a:	6f 91       	pop	r22
    181c:	5f 91       	pop	r21
    181e:	4f 91       	pop	r20
    1820:	3f 91       	pop	r19
    1822:	2f 91       	pop	r18
    1824:	0f 90       	pop	r0
    1826:	0f be       	out	0x3f, r0	; 63
    1828:	0f 90       	pop	r0
    182a:	1f 90       	pop	r1
    182c:	18 95       	reti

0000182e <__vector_10>:


void __vector_10(void)
{
    182e:	1f 92       	push	r1
    1830:	0f 92       	push	r0
    1832:	0f b6       	in	r0, 0x3f	; 63
    1834:	0f 92       	push	r0
    1836:	11 24       	eor	r1, r1
    1838:	2f 93       	push	r18
    183a:	3f 93       	push	r19
    183c:	4f 93       	push	r20
    183e:	5f 93       	push	r21
    1840:	6f 93       	push	r22
    1842:	7f 93       	push	r23
    1844:	8f 93       	push	r24
    1846:	9f 93       	push	r25
    1848:	af 93       	push	r26
    184a:	bf 93       	push	r27
    184c:	ef 93       	push	r30
    184e:	ff 93       	push	r31
	static u16 count = 0;
	count ++;
    1850:	80 91 be 01 	lds	r24, 0x01BE
    1854:	90 91 bf 01 	lds	r25, 0x01BF
    1858:	01 96       	adiw	r24, 0x01	; 1
    185a:	90 93 bf 01 	sts	0x01BF, r25
    185e:	80 93 be 01 	sts	0x01BE, r24
	if(count == private_CTC_counter)
    1862:	20 91 ba 01 	lds	r18, 0x01BA
    1866:	30 91 bb 01 	lds	r19, 0x01BB
    186a:	82 17       	cp	r24, r18
    186c:	93 07       	cpc	r25, r19
    186e:	59 f4       	brne	.+22     	; 0x1886 <__vector_10+0x58>
	{
		count = 0;
    1870:	10 92 bf 01 	sts	0x01BF, r1
    1874:	10 92 be 01 	sts	0x01BE, r1
		if(privatePTR_OC !=NULL)
    1878:	e0 91 bc 01 	lds	r30, 0x01BC
    187c:	f0 91 bd 01 	lds	r31, 0x01BD
    1880:	30 97       	sbiw	r30, 0x00	; 0
    1882:	09 f0       	breq	.+2      	; 0x1886 <__vector_10+0x58>
			{
			privatePTR_OC();
    1884:	09 95       	icall
			}
	}
}
    1886:	ff 91       	pop	r31
    1888:	ef 91       	pop	r30
    188a:	bf 91       	pop	r27
    188c:	af 91       	pop	r26
    188e:	9f 91       	pop	r25
    1890:	8f 91       	pop	r24
    1892:	7f 91       	pop	r23
    1894:	6f 91       	pop	r22
    1896:	5f 91       	pop	r21
    1898:	4f 91       	pop	r20
    189a:	3f 91       	pop	r19
    189c:	2f 91       	pop	r18
    189e:	0f 90       	pop	r0
    18a0:	0f be       	out	0x3f, r0	; 63
    18a2:	0f 90       	pop	r0
    18a4:	1f 90       	pop	r1
    18a6:	18 95       	reti

000018a8 <SPI_voidInit>:
   SET_BIT(_SPCR, 0);
   CLR_BIT(_SPCR, 1);
   CLR_BIT(_SPSR, 0);

#elif SPI_MODE	==	SLAVE
   CLR_BIT(_SPCR, 4);
    18a8:	ed e2       	ldi	r30, 0x2D	; 45
    18aa:	f0 e0       	ldi	r31, 0x00	; 0
    18ac:	80 81       	ld	r24, Z
    18ae:	8f 7e       	andi	r24, 0xEF	; 239
    18b0:	80 83       	st	Z, r24
#endif //SPI_MODE

   // Data Order --> LSB:SET	or  MSB:CLEAR
   SET_BIT(_SPCR, 5);
    18b2:	80 81       	ld	r24, Z
    18b4:	80 62       	ori	r24, 0x20	; 32
    18b6:	80 83       	st	Z, r24

   //POLARITY, PHASE	--> Falling Rising	Setup Sample
   SET_BIT(_SPCR, 3);
    18b8:	80 81       	ld	r24, Z
    18ba:	88 60       	ori	r24, 0x08	; 8
    18bc:	80 83       	st	Z, r24
   SET_BIT(_SPCR, 2);
    18be:	80 81       	ld	r24, Z
    18c0:	84 60       	ori	r24, 0x04	; 4
    18c2:	80 83       	st	Z, r24

   // enable SPI
	SET_BIT(_SPCR, 6);
    18c4:	80 81       	ld	r24, Z
    18c6:	80 64       	ori	r24, 0x40	; 64
    18c8:	80 83       	st	Z, r24
}
    18ca:	08 95       	ret

000018cc <SPI_voidTranseive>:

void SPI_voidTranseive(u8 copy_u8_TX_data, u8 * copy_u8_RX_data)
{
    18cc:	98 2f       	mov	r25, r24
    18ce:	db 01       	movw	r26, r22
	if (copy_u8_RX_data != NULL)
    18d0:	61 15       	cp	r22, r1
    18d2:	71 05       	cpc	r23, r1
    18d4:	69 f0       	breq	.+26     	; 0x18f0 <SPI_voidTranseive+0x24>
	{
		while(GET_BIT(_SPSR, 6));	// To prevent collision (Writing in buffer while still have the data to be sent
    18d6:	ee e2       	ldi	r30, 0x2E	; 46
    18d8:	f0 e0       	ldi	r31, 0x00	; 0
    18da:	80 81       	ld	r24, Z
    18dc:	86 fd       	sbrc	r24, 6
    18de:	fd cf       	rjmp	.-6      	; 0x18da <SPI_voidTranseive+0xe>
		_SPDR = copy_u8_TX_data;	// write buffer >> Data register
    18e0:	9f b9       	out	0x0f, r25	; 15
		while(!GET_BIT(_SPSR, 7));	// blocking
    18e2:	ee e2       	ldi	r30, 0x2E	; 46
    18e4:	f0 e0       	ldi	r31, 0x00	; 0
    18e6:	80 81       	ld	r24, Z
    18e8:	88 23       	and	r24, r24
    18ea:	ec f7       	brge	.-6      	; 0x18e6 <SPI_voidTranseive+0x1a>
		*copy_u8_RX_data =  _SPDR;	// Read data from buffer (Receive)
    18ec:	8f b1       	in	r24, 0x0f	; 15
    18ee:	8c 93       	st	X, r24
    18f0:	08 95       	ret

000018f2 <SPI_voidTransmit_Async>:
		return;
	}
}

void SPI_voidTransmit_Async(u8 copy_u8_TX_data, void(*PtrFunc)(u8 copy_u8_RX_data))
{
    18f2:	98 2f       	mov	r25, r24
	if (PtrFunc != NULL)
    18f4:	61 15       	cp	r22, r1
    18f6:	71 05       	cpc	r23, r1
    18f8:	79 f0       	breq	.+30     	; 0x1918 <SPI_voidTransmit_Async+0x26>
	{
		// Enable SPI Interrupt
		SET_BIT(_SPCR, 7);
    18fa:	ed e2       	ldi	r30, 0x2D	; 45
    18fc:	f0 e0       	ldi	r31, 0x00	; 0
    18fe:	80 81       	ld	r24, Z
    1900:	80 68       	ori	r24, 0x80	; 128
    1902:	80 83       	st	Z, r24

		Private_pCallback = PtrFunc;
    1904:	70 93 c5 01 	sts	0x01C5, r23
    1908:	60 93 c4 01 	sts	0x01C4, r22
		while(GET_BIT(_SPSR, 6));	// To prevent collision (Writing in buffer while still have the data to be sent
    190c:	ee e2       	ldi	r30, 0x2E	; 46
    190e:	f0 e0       	ldi	r31, 0x00	; 0
    1910:	80 81       	ld	r24, Z
    1912:	86 fd       	sbrc	r24, 6
    1914:	fd cf       	rjmp	.-6      	; 0x1910 <SPI_voidTransmit_Async+0x1e>
		_SPDR = copy_u8_TX_data;	// write buffer >> Data register
    1916:	9f b9       	out	0x0f, r25	; 15
    1918:	08 95       	ret

0000191a <__vector_12>:

/* ----------------- Section : ISRs -----------------*/
void __vector_12(void) __attribute__((signal));

void __vector_12(void)
{
    191a:	1f 92       	push	r1
    191c:	0f 92       	push	r0
    191e:	0f b6       	in	r0, 0x3f	; 63
    1920:	0f 92       	push	r0
    1922:	11 24       	eor	r1, r1
    1924:	2f 93       	push	r18
    1926:	3f 93       	push	r19
    1928:	4f 93       	push	r20
    192a:	5f 93       	push	r21
    192c:	6f 93       	push	r22
    192e:	7f 93       	push	r23
    1930:	8f 93       	push	r24
    1932:	9f 93       	push	r25
    1934:	af 93       	push	r26
    1936:	bf 93       	push	r27
    1938:	ef 93       	push	r30
    193a:	ff 93       	push	r31
	if(Private_pCallback)
    193c:	e0 91 c4 01 	lds	r30, 0x01C4
    1940:	f0 91 c5 01 	lds	r31, 0x01C5
    1944:	30 97       	sbiw	r30, 0x00	; 0
    1946:	11 f0       	breq	.+4      	; 0x194c <__vector_12+0x32>
	{
		Private_pCallback(_SPDR);
    1948:	8f b1       	in	r24, 0x0f	; 15
    194a:	09 95       	icall
	}
}
    194c:	ff 91       	pop	r31
    194e:	ef 91       	pop	r30
    1950:	bf 91       	pop	r27
    1952:	af 91       	pop	r26
    1954:	9f 91       	pop	r25
    1956:	8f 91       	pop	r24
    1958:	7f 91       	pop	r23
    195a:	6f 91       	pop	r22
    195c:	5f 91       	pop	r21
    195e:	4f 91       	pop	r20
    1960:	3f 91       	pop	r19
    1962:	2f 91       	pop	r18
    1964:	0f 90       	pop	r0
    1966:	0f be       	out	0x3f, r0	; 63
    1968:	0f 90       	pop	r0
    196a:	1f 90       	pop	r1
    196c:	18 95       	reti

0000196e <Port_Init>:
 * 			   		the function will make PA_4, PA_5 as Output  and PA_6 as Input
 * @param	1- Pin_ConfigType *pins_cfg 	-> which is a pointer to a structure of data type "Pin_ConfigType"
 * @return	void
 */
void Port_Init (Pin_ConfigType *pins_cfg)
{
    196e:	4f 92       	push	r4
    1970:	5f 92       	push	r5
    1972:	6f 92       	push	r6
    1974:	7f 92       	push	r7
    1976:	8f 92       	push	r8
    1978:	9f 92       	push	r9
    197a:	af 92       	push	r10
    197c:	bf 92       	push	r11
    197e:	cf 92       	push	r12
    1980:	df 92       	push	r13
    1982:	ef 92       	push	r14
    1984:	ff 92       	push	r15
    1986:	0f 93       	push	r16
    1988:	1f 93       	push	r17
    198a:	cf 93       	push	r28
    198c:	df 93       	push	r29
    198e:	fc 01       	movw	r30, r24
    1990:	40 e0       	ldi	r20, 0x00	; 0
    1992:	50 e0       	ldi	r21, 0x00	; 0
			{
				SET_BIT(_DDRB, pins_cfg[i].Pin);
			}
			else
			{
				CLR_BIT(_DDRB, pins_cfg[i].Pin);
    1994:	0f 2e       	mov	r0, r31
    1996:	f7 e3       	ldi	r31, 0x37	; 55
    1998:	ef 2e       	mov	r14, r31
    199a:	ff 24       	eor	r15, r15
    199c:	f0 2d       	mov	r31, r0
    199e:	61 e0       	ldi	r22, 0x01	; 1
    19a0:	70 e0       	ldi	r23, 0x00	; 0
				SET_BIT(_PORTB, pins_cfg[i].Pin);
    19a2:	0f 2e       	mov	r0, r31
    19a4:	f8 e3       	ldi	r31, 0x38	; 56
    19a6:	8f 2e       	mov	r8, r31
    19a8:	99 24       	eor	r9, r9
    19aa:	f0 2d       	mov	r31, r0
			{
				SET_BIT(_DDRA, pins_cfg[i].Pin);
			}
			else
			{
				CLR_BIT(_DDRA, pins_cfg[i].Pin);
    19ac:	0a e3       	ldi	r16, 0x3A	; 58
    19ae:	10 e0       	ldi	r17, 0x00	; 0
				SET_BIT(_PORTA, pins_cfg[i].Pin);
    19b0:	0f 2e       	mov	r0, r31
    19b2:	fb e3       	ldi	r31, 0x3B	; 59
    19b4:	6f 2e       	mov	r6, r31
    19b6:	77 24       	eor	r7, r7
    19b8:	f0 2d       	mov	r31, r0
			{
				SET_BIT(_DDRC, pins_cfg[i].Pin);
			}
			else
			{
				CLR_BIT(_DDRC, pins_cfg[i].Pin);
    19ba:	c4 e3       	ldi	r28, 0x34	; 52
    19bc:	d0 e0       	ldi	r29, 0x00	; 0
				SET_BIT(_PORTC, pins_cfg[i].Pin);
    19be:	0f 2e       	mov	r0, r31
    19c0:	f5 e3       	ldi	r31, 0x35	; 53
    19c2:	af 2e       	mov	r10, r31
    19c4:	bb 24       	eor	r11, r11
    19c6:	f0 2d       	mov	r31, r0
			{
				SET_BIT(_DDRD, pins_cfg[i].Pin);
			}
			else
			{
				CLR_BIT(_DDRD, pins_cfg[i].Pin);
    19c8:	0f 2e       	mov	r0, r31
    19ca:	f1 e3       	ldi	r31, 0x31	; 49
    19cc:	4f 2e       	mov	r4, r31
    19ce:	55 24       	eor	r5, r5
    19d0:	f0 2d       	mov	r31, r0
				SET_BIT(_PORTD, pins_cfg[i].Pin);
    19d2:	0f 2e       	mov	r0, r31
    19d4:	f2 e3       	ldi	r31, 0x32	; 50
    19d6:	cf 2e       	mov	r12, r31
    19d8:	dd 24       	eor	r13, r13
    19da:	f0 2d       	mov	r31, r0
	for(int i = 0 ; i < 32 ; i ++)
	{
		if((pins_cfg[i].Port) == -1){
			break;
		}
		switch(pins_cfg[i].Port)
    19dc:	80 81       	ld	r24, Z
    19de:	81 30       	cpi	r24, 0x01	; 1
    19e0:	51 f1       	breq	.+84     	; 0x1a36 <Port_Init+0xc8>
    19e2:	81 30       	cpi	r24, 0x01	; 1
    19e4:	38 f0       	brcs	.+14     	; 0x19f4 <Port_Init+0x86>
    19e6:	82 30       	cpi	r24, 0x02	; 2
    19e8:	09 f4       	brne	.+2      	; 0x19ec <Port_Init+0x7e>
    19ea:	46 c0       	rjmp	.+140    	; 0x1a78 <Port_Init+0x10a>
    19ec:	83 30       	cpi	r24, 0x03	; 3
    19ee:	09 f0       	breq	.+2      	; 0x19f2 <Port_Init+0x84>
    19f0:	82 c0       	rjmp	.+260    	; 0x1af6 <Port_Init+0x188>
    19f2:	61 c0       	rjmp	.+194    	; 0x1ab6 <Port_Init+0x148>
		{
		case Dio_PORTA:
			if((pins_cfg[i].Direction) == STD_OUT)
    19f4:	82 81       	ldd	r24, Z+2	; 0x02
    19f6:	81 30       	cpi	r24, 0x01	; 1
    19f8:	61 f4       	brne	.+24     	; 0x1a12 <Port_Init+0xa4>
			{
				SET_BIT(_DDRA, pins_cfg[i].Pin);
    19fa:	d8 01       	movw	r26, r16
    19fc:	2c 91       	ld	r18, X
    19fe:	cb 01       	movw	r24, r22
    1a00:	01 80       	ldd	r0, Z+1	; 0x01
    1a02:	02 c0       	rjmp	.+4      	; 0x1a08 <Port_Init+0x9a>
    1a04:	88 0f       	add	r24, r24
    1a06:	99 1f       	adc	r25, r25
    1a08:	0a 94       	dec	r0
    1a0a:	e2 f7       	brpl	.-8      	; 0x1a04 <Port_Init+0x96>
    1a0c:	28 2b       	or	r18, r24
    1a0e:	2c 93       	st	X, r18
    1a10:	72 c0       	rjmp	.+228    	; 0x1af6 <Port_Init+0x188>
			}
			else
			{
				CLR_BIT(_DDRA, pins_cfg[i].Pin);
    1a12:	d8 01       	movw	r26, r16
    1a14:	3c 91       	ld	r19, X
    1a16:	cb 01       	movw	r24, r22
    1a18:	01 80       	ldd	r0, Z+1	; 0x01
    1a1a:	02 c0       	rjmp	.+4      	; 0x1a20 <Port_Init+0xb2>
    1a1c:	88 0f       	add	r24, r24
    1a1e:	99 1f       	adc	r25, r25
    1a20:	0a 94       	dec	r0
    1a22:	e2 f7       	brpl	.-8      	; 0x1a1c <Port_Init+0xae>
    1a24:	28 2f       	mov	r18, r24
    1a26:	20 95       	com	r18
    1a28:	23 23       	and	r18, r19
    1a2a:	2c 93       	st	X, r18
				SET_BIT(_PORTA, pins_cfg[i].Pin);
    1a2c:	d3 01       	movw	r26, r6
    1a2e:	2c 91       	ld	r18, X
    1a30:	82 2b       	or	r24, r18
    1a32:	8c 93       	st	X, r24
    1a34:	60 c0       	rjmp	.+192    	; 0x1af6 <Port_Init+0x188>
			}
			break;
		case Dio_PORTB:
			if((pins_cfg[i].Direction) == STD_OUT)
    1a36:	82 81       	ldd	r24, Z+2	; 0x02
    1a38:	81 30       	cpi	r24, 0x01	; 1
    1a3a:	61 f4       	brne	.+24     	; 0x1a54 <Port_Init+0xe6>
			{
				SET_BIT(_DDRB, pins_cfg[i].Pin);
    1a3c:	d7 01       	movw	r26, r14
    1a3e:	2c 91       	ld	r18, X
    1a40:	cb 01       	movw	r24, r22
    1a42:	01 80       	ldd	r0, Z+1	; 0x01
    1a44:	02 c0       	rjmp	.+4      	; 0x1a4a <Port_Init+0xdc>
    1a46:	88 0f       	add	r24, r24
    1a48:	99 1f       	adc	r25, r25
    1a4a:	0a 94       	dec	r0
    1a4c:	e2 f7       	brpl	.-8      	; 0x1a46 <Port_Init+0xd8>
    1a4e:	28 2b       	or	r18, r24
    1a50:	2c 93       	st	X, r18
    1a52:	51 c0       	rjmp	.+162    	; 0x1af6 <Port_Init+0x188>
			}
			else
			{
				CLR_BIT(_DDRB, pins_cfg[i].Pin);
    1a54:	d7 01       	movw	r26, r14
    1a56:	3c 91       	ld	r19, X
    1a58:	cb 01       	movw	r24, r22
    1a5a:	01 80       	ldd	r0, Z+1	; 0x01
    1a5c:	02 c0       	rjmp	.+4      	; 0x1a62 <Port_Init+0xf4>
    1a5e:	88 0f       	add	r24, r24
    1a60:	99 1f       	adc	r25, r25
    1a62:	0a 94       	dec	r0
    1a64:	e2 f7       	brpl	.-8      	; 0x1a5e <Port_Init+0xf0>
    1a66:	28 2f       	mov	r18, r24
    1a68:	20 95       	com	r18
    1a6a:	23 23       	and	r18, r19
    1a6c:	2c 93       	st	X, r18
				SET_BIT(_PORTB, pins_cfg[i].Pin);
    1a6e:	d4 01       	movw	r26, r8
    1a70:	2c 91       	ld	r18, X
    1a72:	82 2b       	or	r24, r18
    1a74:	8c 93       	st	X, r24
    1a76:	3f c0       	rjmp	.+126    	; 0x1af6 <Port_Init+0x188>
			}
			break;
		case Dio_PORTC:
			if((pins_cfg[i].Direction) == STD_OUT)
    1a78:	82 81       	ldd	r24, Z+2	; 0x02
    1a7a:	81 30       	cpi	r24, 0x01	; 1
    1a7c:	59 f4       	brne	.+22     	; 0x1a94 <Port_Init+0x126>
			{
				SET_BIT(_DDRC, pins_cfg[i].Pin);
    1a7e:	28 81       	ld	r18, Y
    1a80:	cb 01       	movw	r24, r22
    1a82:	01 80       	ldd	r0, Z+1	; 0x01
    1a84:	02 c0       	rjmp	.+4      	; 0x1a8a <Port_Init+0x11c>
    1a86:	88 0f       	add	r24, r24
    1a88:	99 1f       	adc	r25, r25
    1a8a:	0a 94       	dec	r0
    1a8c:	e2 f7       	brpl	.-8      	; 0x1a86 <Port_Init+0x118>
    1a8e:	28 2b       	or	r18, r24
    1a90:	28 83       	st	Y, r18
    1a92:	31 c0       	rjmp	.+98     	; 0x1af6 <Port_Init+0x188>
			}
			else
			{
				CLR_BIT(_DDRC, pins_cfg[i].Pin);
    1a94:	38 81       	ld	r19, Y
    1a96:	cb 01       	movw	r24, r22
    1a98:	01 80       	ldd	r0, Z+1	; 0x01
    1a9a:	02 c0       	rjmp	.+4      	; 0x1aa0 <Port_Init+0x132>
    1a9c:	88 0f       	add	r24, r24
    1a9e:	99 1f       	adc	r25, r25
    1aa0:	0a 94       	dec	r0
    1aa2:	e2 f7       	brpl	.-8      	; 0x1a9c <Port_Init+0x12e>
    1aa4:	28 2f       	mov	r18, r24
    1aa6:	20 95       	com	r18
    1aa8:	23 23       	and	r18, r19
    1aaa:	28 83       	st	Y, r18
				SET_BIT(_PORTC, pins_cfg[i].Pin);
    1aac:	d5 01       	movw	r26, r10
    1aae:	2c 91       	ld	r18, X
    1ab0:	82 2b       	or	r24, r18
    1ab2:	8c 93       	st	X, r24
    1ab4:	20 c0       	rjmp	.+64     	; 0x1af6 <Port_Init+0x188>
			}
			break;
		case Dio_PORTD:
			if((pins_cfg[i].Direction) == STD_OUT)
    1ab6:	82 81       	ldd	r24, Z+2	; 0x02
    1ab8:	81 30       	cpi	r24, 0x01	; 1
    1aba:	61 f4       	brne	.+24     	; 0x1ad4 <Port_Init+0x166>
			{
				SET_BIT(_DDRD, pins_cfg[i].Pin);
    1abc:	d2 01       	movw	r26, r4
    1abe:	2c 91       	ld	r18, X
    1ac0:	cb 01       	movw	r24, r22
    1ac2:	01 80       	ldd	r0, Z+1	; 0x01
    1ac4:	02 c0       	rjmp	.+4      	; 0x1aca <Port_Init+0x15c>
    1ac6:	88 0f       	add	r24, r24
    1ac8:	99 1f       	adc	r25, r25
    1aca:	0a 94       	dec	r0
    1acc:	e2 f7       	brpl	.-8      	; 0x1ac6 <Port_Init+0x158>
    1ace:	28 2b       	or	r18, r24
    1ad0:	2c 93       	st	X, r18
    1ad2:	11 c0       	rjmp	.+34     	; 0x1af6 <Port_Init+0x188>
			}
			else
			{
				CLR_BIT(_DDRD, pins_cfg[i].Pin);
    1ad4:	d2 01       	movw	r26, r4
    1ad6:	3c 91       	ld	r19, X
    1ad8:	cb 01       	movw	r24, r22
    1ada:	01 80       	ldd	r0, Z+1	; 0x01
    1adc:	02 c0       	rjmp	.+4      	; 0x1ae2 <Port_Init+0x174>
    1ade:	88 0f       	add	r24, r24
    1ae0:	99 1f       	adc	r25, r25
    1ae2:	0a 94       	dec	r0
    1ae4:	e2 f7       	brpl	.-8      	; 0x1ade <Port_Init+0x170>
    1ae6:	28 2f       	mov	r18, r24
    1ae8:	20 95       	com	r18
    1aea:	23 23       	and	r18, r19
    1aec:	2c 93       	st	X, r18
				SET_BIT(_PORTD, pins_cfg[i].Pin);
    1aee:	d6 01       	movw	r26, r12
    1af0:	2c 91       	ld	r18, X
    1af2:	82 2b       	or	r24, r18
    1af4:	8c 93       	st	X, r24
 * @param	1- Pin_ConfigType *pins_cfg 	-> which is a pointer to a structure of data type "Pin_ConfigType"
 * @return	void
 */
void Port_Init (Pin_ConfigType *pins_cfg)
{
	for(int i = 0 ; i < 32 ; i ++)
    1af6:	4f 5f       	subi	r20, 0xFF	; 255
    1af8:	5f 4f       	sbci	r21, 0xFF	; 255
    1afa:	33 96       	adiw	r30, 0x03	; 3
    1afc:	40 32       	cpi	r20, 0x20	; 32
    1afe:	51 05       	cpc	r21, r1
    1b00:	09 f0       	breq	.+2      	; 0x1b04 <Port_Init+0x196>
    1b02:	6c cf       	rjmp	.-296    	; 0x19dc <Port_Init+0x6e>
			}
			break;
		default: break;
		}
	}
}
    1b04:	df 91       	pop	r29
    1b06:	cf 91       	pop	r28
    1b08:	1f 91       	pop	r17
    1b0a:	0f 91       	pop	r16
    1b0c:	ff 90       	pop	r15
    1b0e:	ef 90       	pop	r14
    1b10:	df 90       	pop	r13
    1b12:	cf 90       	pop	r12
    1b14:	bf 90       	pop	r11
    1b16:	af 90       	pop	r10
    1b18:	9f 90       	pop	r9
    1b1a:	8f 90       	pop	r8
    1b1c:	7f 90       	pop	r7
    1b1e:	6f 90       	pop	r6
    1b20:	5f 90       	pop	r5
    1b22:	4f 90       	pop	r4
    1b24:	08 95       	ret

00001b26 <Port_SetPinDirection>:
 * @param	1- Pin 			-> to choose the PIN to set its Direction  EX: (PA_2)
 * 			2- Direction 	-> to choose the Direction to the PIN  	Ex : (1 for HIGH or 0 for LOW)
 * @return	void
 */
void Port_SetPinDirection (Dio_ChannelType Pin,Dio_DirectionType Direction)
{
    1b26:	48 2f       	mov	r20, r24
	switch(Pin/8)
    1b28:	86 95       	lsr	r24
    1b2a:	86 95       	lsr	r24
    1b2c:	86 95       	lsr	r24
    1b2e:	81 30       	cpi	r24, 0x01	; 1
    1b30:	31 f1       	breq	.+76     	; 0x1b7e <Port_SetPinDirection+0x58>
    1b32:	81 30       	cpi	r24, 0x01	; 1
    1b34:	38 f0       	brcs	.+14     	; 0x1b44 <Port_SetPinDirection+0x1e>
    1b36:	82 30       	cpi	r24, 0x02	; 2
    1b38:	09 f4       	brne	.+2      	; 0x1b3c <Port_SetPinDirection+0x16>
    1b3a:	42 c0       	rjmp	.+132    	; 0x1bc0 <Port_SetPinDirection+0x9a>
    1b3c:	83 30       	cpi	r24, 0x03	; 3
    1b3e:	09 f0       	breq	.+2      	; 0x1b42 <Port_SetPinDirection+0x1c>
    1b40:	80 c0       	rjmp	.+256    	; 0x1c42 <Port_SetPinDirection+0x11c>
    1b42:	5f c0       	rjmp	.+190    	; 0x1c02 <Port_SetPinDirection+0xdc>
	{
	case Dio_PORTA:
		if(Direction == STD_OUT)
    1b44:	61 30       	cpi	r22, 0x01	; 1
    1b46:	69 f4       	brne	.+26     	; 0x1b62 <Port_SetPinDirection+0x3c>
			SET_BIT(_DDRA, Pin);
    1b48:	ea e3       	ldi	r30, 0x3A	; 58
    1b4a:	f0 e0       	ldi	r31, 0x00	; 0
    1b4c:	20 81       	ld	r18, Z
    1b4e:	81 e0       	ldi	r24, 0x01	; 1
    1b50:	90 e0       	ldi	r25, 0x00	; 0
    1b52:	02 c0       	rjmp	.+4      	; 0x1b58 <Port_SetPinDirection+0x32>
    1b54:	88 0f       	add	r24, r24
    1b56:	99 1f       	adc	r25, r25
    1b58:	4a 95       	dec	r20
    1b5a:	e2 f7       	brpl	.-8      	; 0x1b54 <Port_SetPinDirection+0x2e>
    1b5c:	28 2b       	or	r18, r24
    1b5e:	20 83       	st	Z, r18
    1b60:	08 95       	ret
		else
			CLR_BIT(_DDRA, Pin);
    1b62:	ea e3       	ldi	r30, 0x3A	; 58
    1b64:	f0 e0       	ldi	r31, 0x00	; 0
    1b66:	20 81       	ld	r18, Z
    1b68:	81 e0       	ldi	r24, 0x01	; 1
    1b6a:	90 e0       	ldi	r25, 0x00	; 0
    1b6c:	02 c0       	rjmp	.+4      	; 0x1b72 <Port_SetPinDirection+0x4c>
    1b6e:	88 0f       	add	r24, r24
    1b70:	99 1f       	adc	r25, r25
    1b72:	4a 95       	dec	r20
    1b74:	e2 f7       	brpl	.-8      	; 0x1b6e <Port_SetPinDirection+0x48>
    1b76:	80 95       	com	r24
    1b78:	82 23       	and	r24, r18
    1b7a:	80 83       	st	Z, r24
    1b7c:	08 95       	ret
		break;
	case Dio_PORTB:
		if(Direction == STD_OUT)
    1b7e:	61 30       	cpi	r22, 0x01	; 1
    1b80:	79 f4       	brne	.+30     	; 0x1ba0 <Port_SetPinDirection+0x7a>
			SET_BIT(_DDRB, Pin % 8);
    1b82:	e7 e3       	ldi	r30, 0x37	; 55
    1b84:	f0 e0       	ldi	r31, 0x00	; 0
    1b86:	20 81       	ld	r18, Z
    1b88:	34 2f       	mov	r19, r20
    1b8a:	37 70       	andi	r19, 0x07	; 7
    1b8c:	81 e0       	ldi	r24, 0x01	; 1
    1b8e:	90 e0       	ldi	r25, 0x00	; 0
    1b90:	02 c0       	rjmp	.+4      	; 0x1b96 <Port_SetPinDirection+0x70>
    1b92:	88 0f       	add	r24, r24
    1b94:	99 1f       	adc	r25, r25
    1b96:	3a 95       	dec	r19
    1b98:	e2 f7       	brpl	.-8      	; 0x1b92 <Port_SetPinDirection+0x6c>
    1b9a:	28 2b       	or	r18, r24
    1b9c:	20 83       	st	Z, r18
    1b9e:	08 95       	ret
		else
			CLR_BIT(_DDRB, Pin % 8);
    1ba0:	e7 e3       	ldi	r30, 0x37	; 55
    1ba2:	f0 e0       	ldi	r31, 0x00	; 0
    1ba4:	30 81       	ld	r19, Z
    1ba6:	24 2f       	mov	r18, r20
    1ba8:	27 70       	andi	r18, 0x07	; 7
    1baa:	81 e0       	ldi	r24, 0x01	; 1
    1bac:	90 e0       	ldi	r25, 0x00	; 0
    1bae:	02 c0       	rjmp	.+4      	; 0x1bb4 <Port_SetPinDirection+0x8e>
    1bb0:	88 0f       	add	r24, r24
    1bb2:	99 1f       	adc	r25, r25
    1bb4:	2a 95       	dec	r18
    1bb6:	e2 f7       	brpl	.-8      	; 0x1bb0 <Port_SetPinDirection+0x8a>
    1bb8:	80 95       	com	r24
    1bba:	83 23       	and	r24, r19
    1bbc:	80 83       	st	Z, r24
    1bbe:	08 95       	ret
		break;
	case Dio_PORTC:
		if(Direction == STD_OUT)
    1bc0:	61 30       	cpi	r22, 0x01	; 1
    1bc2:	79 f4       	brne	.+30     	; 0x1be2 <Port_SetPinDirection+0xbc>
			SET_BIT(_DDRC, Pin % 8);
    1bc4:	e4 e3       	ldi	r30, 0x34	; 52
    1bc6:	f0 e0       	ldi	r31, 0x00	; 0
    1bc8:	20 81       	ld	r18, Z
    1bca:	34 2f       	mov	r19, r20
    1bcc:	37 70       	andi	r19, 0x07	; 7
    1bce:	81 e0       	ldi	r24, 0x01	; 1
    1bd0:	90 e0       	ldi	r25, 0x00	; 0
    1bd2:	02 c0       	rjmp	.+4      	; 0x1bd8 <Port_SetPinDirection+0xb2>
    1bd4:	88 0f       	add	r24, r24
    1bd6:	99 1f       	adc	r25, r25
    1bd8:	3a 95       	dec	r19
    1bda:	e2 f7       	brpl	.-8      	; 0x1bd4 <Port_SetPinDirection+0xae>
    1bdc:	28 2b       	or	r18, r24
    1bde:	20 83       	st	Z, r18
    1be0:	08 95       	ret
		else
			CLR_BIT(_DDRC, Pin % 8);
    1be2:	e4 e3       	ldi	r30, 0x34	; 52
    1be4:	f0 e0       	ldi	r31, 0x00	; 0
    1be6:	30 81       	ld	r19, Z
    1be8:	24 2f       	mov	r18, r20
    1bea:	27 70       	andi	r18, 0x07	; 7
    1bec:	81 e0       	ldi	r24, 0x01	; 1
    1bee:	90 e0       	ldi	r25, 0x00	; 0
    1bf0:	02 c0       	rjmp	.+4      	; 0x1bf6 <Port_SetPinDirection+0xd0>
    1bf2:	88 0f       	add	r24, r24
    1bf4:	99 1f       	adc	r25, r25
    1bf6:	2a 95       	dec	r18
    1bf8:	e2 f7       	brpl	.-8      	; 0x1bf2 <Port_SetPinDirection+0xcc>
    1bfa:	80 95       	com	r24
    1bfc:	83 23       	and	r24, r19
    1bfe:	80 83       	st	Z, r24
    1c00:	08 95       	ret
		break;
	case Dio_PORTD:
		if(Direction == STD_OUT)
    1c02:	61 30       	cpi	r22, 0x01	; 1
    1c04:	79 f4       	brne	.+30     	; 0x1c24 <Port_SetPinDirection+0xfe>
			SET_BIT(_DDRD, Pin % 8);
    1c06:	e1 e3       	ldi	r30, 0x31	; 49
    1c08:	f0 e0       	ldi	r31, 0x00	; 0
    1c0a:	20 81       	ld	r18, Z
    1c0c:	34 2f       	mov	r19, r20
    1c0e:	37 70       	andi	r19, 0x07	; 7
    1c10:	81 e0       	ldi	r24, 0x01	; 1
    1c12:	90 e0       	ldi	r25, 0x00	; 0
    1c14:	02 c0       	rjmp	.+4      	; 0x1c1a <Port_SetPinDirection+0xf4>
    1c16:	88 0f       	add	r24, r24
    1c18:	99 1f       	adc	r25, r25
    1c1a:	3a 95       	dec	r19
    1c1c:	e2 f7       	brpl	.-8      	; 0x1c16 <Port_SetPinDirection+0xf0>
    1c1e:	28 2b       	or	r18, r24
    1c20:	20 83       	st	Z, r18
    1c22:	08 95       	ret
		else
			CLR_BIT(_DDRD, Pin % 8);
    1c24:	e1 e3       	ldi	r30, 0x31	; 49
    1c26:	f0 e0       	ldi	r31, 0x00	; 0
    1c28:	30 81       	ld	r19, Z
    1c2a:	24 2f       	mov	r18, r20
    1c2c:	27 70       	andi	r18, 0x07	; 7
    1c2e:	81 e0       	ldi	r24, 0x01	; 1
    1c30:	90 e0       	ldi	r25, 0x00	; 0
    1c32:	02 c0       	rjmp	.+4      	; 0x1c38 <Port_SetPinDirection+0x112>
    1c34:	88 0f       	add	r24, r24
    1c36:	99 1f       	adc	r25, r25
    1c38:	2a 95       	dec	r18
    1c3a:	e2 f7       	brpl	.-8      	; 0x1c34 <Port_SetPinDirection+0x10e>
    1c3c:	80 95       	com	r24
    1c3e:	83 23       	and	r24, r19
    1c40:	80 83       	st	Z, r24
    1c42:	08 95       	ret

00001c44 <ICU_voidInit>:
/* ----------------- Section : Software Interfaces Implementation -----------------*/

void ICU_voidInit(void)
{
	// Timer 1 mode --> Normal
	CLR_BIT(_TCCR1A, _WGM10);
    1c44:	ef e4       	ldi	r30, 0x4F	; 79
    1c46:	f0 e0       	ldi	r31, 0x00	; 0
    1c48:	80 81       	ld	r24, Z
    1c4a:	8e 7f       	andi	r24, 0xFE	; 254
    1c4c:	80 83       	st	Z, r24
	CLR_BIT(_TCCR1A, _WGM11);
    1c4e:	80 81       	ld	r24, Z
    1c50:	8d 7f       	andi	r24, 0xFD	; 253
    1c52:	80 83       	st	Z, r24
	CLR_BIT(_TCCR1B, _WGM12);
    1c54:	ee e4       	ldi	r30, 0x4E	; 78
    1c56:	f0 e0       	ldi	r31, 0x00	; 0
    1c58:	80 81       	ld	r24, Z
    1c5a:	87 7f       	andi	r24, 0xF7	; 247
    1c5c:	80 83       	st	Z, r24
	CLR_BIT(_TCCR1B, _WGM13);
    1c5e:	80 81       	ld	r24, Z
    1c60:	8f 7e       	andi	r24, 0xEF	; 239
    1c62:	80 83       	st	Z, r24
#if ICU_Starting_Edge == FAIILING
	// Edge select --> Falling
	CLR_BIT(_TCCR1B, _ICES1);
#elif ICU_Starting_Edge == RISING
	SET_BIT(_TCCR1B, _ICES1);
    1c64:	80 81       	ld	r24, Z
    1c66:	80 64       	ori	r24, 0x40	; 64
    1c68:	80 83       	st	Z, r24
#endif
	// ICU Interrupt Enable
	SET_BIT(_TIMSK, _TICIE1);
    1c6a:	a9 e5       	ldi	r26, 0x59	; 89
    1c6c:	b0 e0       	ldi	r27, 0x00	; 0
    1c6e:	8c 91       	ld	r24, X
    1c70:	80 62       	ori	r24, 0x20	; 32
    1c72:	8c 93       	st	X, r24

	// Start Timer  --> for 64 prescaler
	SET_BIT(_TCCR1B, _CS10);
    1c74:	80 81       	ld	r24, Z
    1c76:	81 60       	ori	r24, 0x01	; 1
    1c78:	80 83       	st	Z, r24
	SET_BIT(_TCCR1B, _CS11);
    1c7a:	80 81       	ld	r24, Z
    1c7c:	82 60       	ori	r24, 0x02	; 2
    1c7e:	80 83       	st	Z, r24
	CLR_BIT(_TCCR1B, _CS12);
    1c80:	80 81       	ld	r24, Z
    1c82:	8b 7f       	andi	r24, 0xFB	; 251
    1c84:	80 83       	st	Z, r24

}
    1c86:	08 95       	ret

00001c88 <ICU_voidGetDutyCycle>:

void ICU_voidGetDutyCycle(u8 * copy_u8_duty)
{
    1c88:	cf 92       	push	r12
    1c8a:	df 92       	push	r13
    1c8c:	ef 92       	push	r14
    1c8e:	ff 92       	push	r15
    1c90:	0f 93       	push	r16
    1c92:	1f 93       	push	r17
    1c94:	cf 93       	push	r28
    1c96:	df 93       	push	r29
    1c98:	ec 01       	movw	r28, r24
	if(copy_u8_duty != NULL)
    1c9a:	00 97       	sbiw	r24, 0x00	; 0
    1c9c:	e9 f0       	breq	.+58     	; 0x1cd8 <ICU_voidGetDutyCycle+0x50>
	{
		*copy_u8_duty = ((u32) private_u16_On_Period * 100 ) / (private_u16_On_Period + private_u16_Off_Period);
    1c9e:	60 91 ca 01 	lds	r22, 0x01CA
    1ca2:	70 91 cb 01 	lds	r23, 0x01CB
    1ca6:	c0 90 ca 01 	lds	r12, 0x01CA
    1caa:	d0 90 cb 01 	lds	r13, 0x01CB
    1cae:	e0 90 cc 01 	lds	r14, 0x01CC
    1cb2:	f0 90 cd 01 	lds	r15, 0x01CD
    1cb6:	80 e0       	ldi	r24, 0x00	; 0
    1cb8:	90 e0       	ldi	r25, 0x00	; 0
    1cba:	24 e6       	ldi	r18, 0x64	; 100
    1cbc:	30 e0       	ldi	r19, 0x00	; 0
    1cbe:	40 e0       	ldi	r20, 0x00	; 0
    1cc0:	50 e0       	ldi	r21, 0x00	; 0
    1cc2:	0e 94 fc 30 	call	0x61f8	; 0x61f8 <__mulsi3>
    1cc6:	ec 0c       	add	r14, r12
    1cc8:	fd 1c       	adc	r15, r13
    1cca:	00 e0       	ldi	r16, 0x00	; 0
    1ccc:	10 e0       	ldi	r17, 0x00	; 0
    1cce:	a8 01       	movw	r20, r16
    1cd0:	97 01       	movw	r18, r14
    1cd2:	0e 94 2f 31 	call	0x625e	; 0x625e <__udivmodsi4>
    1cd6:	28 83       	st	Y, r18
	}
}
    1cd8:	df 91       	pop	r29
    1cda:	cf 91       	pop	r28
    1cdc:	1f 91       	pop	r17
    1cde:	0f 91       	pop	r16
    1ce0:	ff 90       	pop	r15
    1ce2:	ef 90       	pop	r14
    1ce4:	df 90       	pop	r13
    1ce6:	cf 90       	pop	r12
    1ce8:	08 95       	ret

00001cea <ICU_voidGetFrequency>:

void ICU_voidGetFrequency(u32 * copy_u32_freq_HZ)
{
    1cea:	cf 93       	push	r28
    1cec:	df 93       	push	r29
    1cee:	ec 01       	movw	r28, r24
	if(copy_u32_freq_HZ != NULL)
    1cf0:	00 97       	sbiw	r24, 0x00	; 0
    1cf2:	b1 f0       	breq	.+44     	; 0x1d20 <ICU_voidGetFrequency+0x36>
	{
		*copy_u32_freq_HZ = 1000000UL / (private_u16_On_Period + private_u16_Off_Period);		// 1 S = 1000000 us
    1cf4:	80 91 ca 01 	lds	r24, 0x01CA
    1cf8:	90 91 cb 01 	lds	r25, 0x01CB
    1cfc:	20 91 cc 01 	lds	r18, 0x01CC
    1d00:	30 91 cd 01 	lds	r19, 0x01CD
    1d04:	28 0f       	add	r18, r24
    1d06:	39 1f       	adc	r19, r25
    1d08:	40 e0       	ldi	r20, 0x00	; 0
    1d0a:	50 e0       	ldi	r21, 0x00	; 0
    1d0c:	60 e4       	ldi	r22, 0x40	; 64
    1d0e:	72 e4       	ldi	r23, 0x42	; 66
    1d10:	8f e0       	ldi	r24, 0x0F	; 15
    1d12:	90 e0       	ldi	r25, 0x00	; 0
    1d14:	0e 94 2f 31 	call	0x625e	; 0x625e <__udivmodsi4>
    1d18:	28 83       	st	Y, r18
    1d1a:	39 83       	std	Y+1, r19	; 0x01
    1d1c:	4a 83       	std	Y+2, r20	; 0x02
    1d1e:	5b 83       	std	Y+3, r21	; 0x03
	}
}
    1d20:	df 91       	pop	r29
    1d22:	cf 91       	pop	r28
    1d24:	08 95       	ret

00001d26 <ICU_u32GetFallingEdgeTime>:

u32 ICU_u32GetFallingEdgeTime(void)
{
    // Assuming the time is in microseconds
    return (u32)private_u16_On_Period;
    1d26:	20 91 ca 01 	lds	r18, 0x01CA
    1d2a:	30 91 cb 01 	lds	r19, 0x01CB
    1d2e:	40 e0       	ldi	r20, 0x00	; 0
    1d30:	50 e0       	ldi	r21, 0x00	; 0
}
    1d32:	62 2f       	mov	r22, r18
    1d34:	73 2f       	mov	r23, r19
    1d36:	84 2f       	mov	r24, r20
    1d38:	95 2f       	mov	r25, r21
    1d3a:	08 95       	ret

00001d3c <__vector_6>:

//ICU ISR
void __vector_6(void) __attribute__((signal));

void __vector_6(void)
{
    1d3c:	1f 92       	push	r1
    1d3e:	0f 92       	push	r0
    1d40:	0f b6       	in	r0, 0x3f	; 63
    1d42:	0f 92       	push	r0
    1d44:	11 24       	eor	r1, r1
    1d46:	2f 93       	push	r18
    1d48:	3f 93       	push	r19
    1d4a:	4f 93       	push	r20
    1d4c:	5f 93       	push	r21
    1d4e:	8f 93       	push	r24
    1d50:	9f 93       	push	r25
    1d52:	ef 93       	push	r30
    1d54:	ff 93       	push	r31
	static u8 local_edge_falg = ICU_Starting_Edge;
	static u16 local_u16_OldValue = 0 ;
	static u16 local_u16_CounterValue = 0 ;

	local_u16_CounterValue = _ICR1;
    1d56:	26 b5       	in	r18, 0x26	; 38
    1d58:	37 b5       	in	r19, 0x27	; 39
    1d5a:	30 93 c7 01 	sts	0x01C7, r19
    1d5e:	20 93 c6 01 	sts	0x01C6, r18

	if(local_edge_falg == RISING)
    1d62:	80 91 76 01 	lds	r24, 0x0176
    1d66:	81 30       	cpi	r24, 0x01	; 1
    1d68:	c9 f4       	brne	.+50     	; 0x1d9c <__vector_6+0x60>
	{
		private_u16_Off_Period = (local_u16_CounterValue - local_u16_OldValue) * 4;   // 4 : tick time for 64 prescaler
    1d6a:	80 91 c8 01 	lds	r24, 0x01C8
    1d6e:	90 91 c9 01 	lds	r25, 0x01C9
    1d72:	a9 01       	movw	r20, r18
    1d74:	48 1b       	sub	r20, r24
    1d76:	59 0b       	sbc	r21, r25
    1d78:	ca 01       	movw	r24, r20
    1d7a:	88 0f       	add	r24, r24
    1d7c:	99 1f       	adc	r25, r25
    1d7e:	88 0f       	add	r24, r24
    1d80:	99 1f       	adc	r25, r25
    1d82:	90 93 cd 01 	sts	0x01CD, r25
    1d86:	80 93 cc 01 	sts	0x01CC, r24
		CLR_BIT(_TCCR1B, _ICES1);
    1d8a:	ee e4       	ldi	r30, 0x4E	; 78
    1d8c:	f0 e0       	ldi	r31, 0x00	; 0
    1d8e:	80 81       	ld	r24, Z
    1d90:	8f 7b       	andi	r24, 0xBF	; 191
    1d92:	80 83       	st	Z, r24
		local_edge_falg = FALLING;
    1d94:	82 e0       	ldi	r24, 0x02	; 2
    1d96:	80 93 76 01 	sts	0x0176, r24
    1d9a:	1a c0       	rjmp	.+52     	; 0x1dd0 <__vector_6+0x94>
	}
	else if(local_edge_falg == FALLING)
    1d9c:	82 30       	cpi	r24, 0x02	; 2
    1d9e:	c1 f4       	brne	.+48     	; 0x1dd0 <__vector_6+0x94>
	{
		private_u16_On_Period = (local_u16_CounterValue - local_u16_OldValue) * 4;   // 4 : tick time for 64 prescaler
    1da0:	80 91 c8 01 	lds	r24, 0x01C8
    1da4:	90 91 c9 01 	lds	r25, 0x01C9
    1da8:	a9 01       	movw	r20, r18
    1daa:	48 1b       	sub	r20, r24
    1dac:	59 0b       	sbc	r21, r25
    1dae:	ca 01       	movw	r24, r20
    1db0:	88 0f       	add	r24, r24
    1db2:	99 1f       	adc	r25, r25
    1db4:	88 0f       	add	r24, r24
    1db6:	99 1f       	adc	r25, r25
    1db8:	90 93 cb 01 	sts	0x01CB, r25
    1dbc:	80 93 ca 01 	sts	0x01CA, r24
		SET_BIT(_TCCR1B, _ICES1);
    1dc0:	ee e4       	ldi	r30, 0x4E	; 78
    1dc2:	f0 e0       	ldi	r31, 0x00	; 0
    1dc4:	80 81       	ld	r24, Z
    1dc6:	80 64       	ori	r24, 0x40	; 64
    1dc8:	80 83       	st	Z, r24
		local_edge_falg = RISING;
    1dca:	81 e0       	ldi	r24, 0x01	; 1
    1dcc:	80 93 76 01 	sts	0x0176, r24
	}
	local_u16_OldValue = _ICR1;
    1dd0:	86 b5       	in	r24, 0x26	; 38
    1dd2:	97 b5       	in	r25, 0x27	; 39
    1dd4:	90 93 c9 01 	sts	0x01C9, r25
    1dd8:	80 93 c8 01 	sts	0x01C8, r24
}
    1ddc:	ff 91       	pop	r31
    1dde:	ef 91       	pop	r30
    1de0:	9f 91       	pop	r25
    1de2:	8f 91       	pop	r24
    1de4:	5f 91       	pop	r21
    1de6:	4f 91       	pop	r20
    1de8:	3f 91       	pop	r19
    1dea:	2f 91       	pop	r18
    1dec:	0f 90       	pop	r0
    1dee:	0f be       	out	0x3f, r0	; 63
    1df0:	0f 90       	pop	r0
    1df2:	1f 90       	pop	r1
    1df4:	18 95       	reti

00001df6 <GI_voidEnable>:
 * @param	void
 * @return	void
 */
void GI_voidEnable(void)
{
	SET_BIT(_SREG, GLE);
    1df6:	ef e5       	ldi	r30, 0x5F	; 95
    1df8:	f0 e0       	ldi	r31, 0x00	; 0
    1dfa:	80 81       	ld	r24, Z
    1dfc:	80 68       	ori	r24, 0x80	; 128
    1dfe:	80 83       	st	Z, r24
}
    1e00:	08 95       	ret

00001e02 <GI_voidDisable>:
 * @param	void
 * @return	void
 */
void GI_voidDisable(void)
{
	CLR_BIT(_SREG, GLE);
    1e02:	ef e5       	ldi	r30, 0x5F	; 95
    1e04:	f0 e0       	ldi	r31, 0x00	; 0
    1e06:	80 81       	ld	r24, Z
    1e08:	8f 77       	andi	r24, 0x7F	; 127
    1e0a:	80 83       	st	Z, r24
}
    1e0c:	08 95       	ret

00001e0e <EXTI_voidInit>:
 * 			2- copy_u8SenseControl		-> External interrupt Modes (RISING_EDGE, FALLING_EDGE, LOW_LEVEL or LOGICAL_CHANGE)
 * @return	void
 */
void EXTI_voidInit(u8 copy_u8InterruptSource, u8 copy_u8SenseControl)
{
	switch (copy_u8InterruptSource)
    1e0e:	81 30       	cpi	r24, 0x01	; 1
    1e10:	81 f1       	breq	.+96     	; 0x1e72 <EXTI_voidInit+0x64>
    1e12:	81 30       	cpi	r24, 0x01	; 1
    1e14:	20 f0       	brcs	.+8      	; 0x1e1e <EXTI_voidInit+0x10>
    1e16:	82 30       	cpi	r24, 0x02	; 2
    1e18:	09 f0       	breq	.+2      	; 0x1e1c <EXTI_voidInit+0xe>
    1e1a:	62 c0       	rjmp	.+196    	; 0x1ee0 <EXTI_voidInit+0xd2>
    1e1c:	54 c0       	rjmp	.+168    	; 0x1ec6 <EXTI_voidInit+0xb8>
	{
	case EXTI_INT0:
		switch (copy_u8SenseControl)
    1e1e:	62 30       	cpi	r22, 0x02	; 2
    1e20:	f9 f0       	breq	.+62     	; 0x1e60 <EXTI_voidInit+0x52>
    1e22:	63 30       	cpi	r22, 0x03	; 3
    1e24:	a1 f0       	breq	.+40     	; 0x1e4e <EXTI_voidInit+0x40>
    1e26:	61 30       	cpi	r22, 0x01	; 1
    1e28:	49 f0       	breq	.+18     	; 0x1e3c <EXTI_voidInit+0x2e>
		{
		default:
		case RISING_EDGE:
			SET_BIT(_MCUCR, ISC00);
    1e2a:	e5 e5       	ldi	r30, 0x55	; 85
    1e2c:	f0 e0       	ldi	r31, 0x00	; 0
    1e2e:	80 81       	ld	r24, Z
    1e30:	81 60       	ori	r24, 0x01	; 1
    1e32:	80 83       	st	Z, r24
			SET_BIT(_MCUCR, ISC01);
    1e34:	80 81       	ld	r24, Z
    1e36:	82 60       	ori	r24, 0x02	; 2
    1e38:	80 83       	st	Z, r24
    1e3a:	08 95       	ret
			break;
		case FALLING_EDGE:
			CLR_BIT(_MCUCR, ISC00);
    1e3c:	e5 e5       	ldi	r30, 0x55	; 85
    1e3e:	f0 e0       	ldi	r31, 0x00	; 0
    1e40:	80 81       	ld	r24, Z
    1e42:	8e 7f       	andi	r24, 0xFE	; 254
    1e44:	80 83       	st	Z, r24
			SET_BIT(_MCUCR, ISC01);
    1e46:	80 81       	ld	r24, Z
    1e48:	82 60       	ori	r24, 0x02	; 2
    1e4a:	80 83       	st	Z, r24
    1e4c:	08 95       	ret
			break;
		case LOGICAL_CHANGE:
			SET_BIT(_MCUCR, ISC00);
    1e4e:	e5 e5       	ldi	r30, 0x55	; 85
    1e50:	f0 e0       	ldi	r31, 0x00	; 0
    1e52:	80 81       	ld	r24, Z
    1e54:	81 60       	ori	r24, 0x01	; 1
    1e56:	80 83       	st	Z, r24
			CLR_BIT(_MCUCR, ISC01);
    1e58:	80 81       	ld	r24, Z
    1e5a:	8d 7f       	andi	r24, 0xFD	; 253
    1e5c:	80 83       	st	Z, r24
    1e5e:	08 95       	ret
			break;
		case LOW_LEVEL:
			CLR_BIT(_MCUCR, ISC00);
    1e60:	e5 e5       	ldi	r30, 0x55	; 85
    1e62:	f0 e0       	ldi	r31, 0x00	; 0
    1e64:	80 81       	ld	r24, Z
    1e66:	8e 7f       	andi	r24, 0xFE	; 254
    1e68:	80 83       	st	Z, r24
			CLR_BIT(_MCUCR, ISC01);
    1e6a:	80 81       	ld	r24, Z
    1e6c:	8d 7f       	andi	r24, 0xFD	; 253
    1e6e:	80 83       	st	Z, r24
    1e70:	08 95       	ret
			break;
		}
		break;

	case EXTI_INT1:
		switch (copy_u8SenseControl)
    1e72:	62 30       	cpi	r22, 0x02	; 2
    1e74:	f9 f0       	breq	.+62     	; 0x1eb4 <EXTI_voidInit+0xa6>
    1e76:	63 30       	cpi	r22, 0x03	; 3
    1e78:	a1 f0       	breq	.+40     	; 0x1ea2 <EXTI_voidInit+0x94>
    1e7a:	61 30       	cpi	r22, 0x01	; 1
    1e7c:	49 f0       	breq	.+18     	; 0x1e90 <EXTI_voidInit+0x82>
		{
		default:
		case RISING_EDGE:
			SET_BIT(_MCUCR, ISC10);
    1e7e:	e5 e5       	ldi	r30, 0x55	; 85
    1e80:	f0 e0       	ldi	r31, 0x00	; 0
    1e82:	80 81       	ld	r24, Z
    1e84:	84 60       	ori	r24, 0x04	; 4
    1e86:	80 83       	st	Z, r24
			SET_BIT(_MCUCR, ISC11);
    1e88:	80 81       	ld	r24, Z
    1e8a:	88 60       	ori	r24, 0x08	; 8
    1e8c:	80 83       	st	Z, r24
    1e8e:	08 95       	ret
			break;
		case FALLING_EDGE:
			CLR_BIT(_MCUCR, ISC10);
    1e90:	e5 e5       	ldi	r30, 0x55	; 85
    1e92:	f0 e0       	ldi	r31, 0x00	; 0
    1e94:	80 81       	ld	r24, Z
    1e96:	8b 7f       	andi	r24, 0xFB	; 251
    1e98:	80 83       	st	Z, r24
			SET_BIT(_MCUCR, ISC11);
    1e9a:	80 81       	ld	r24, Z
    1e9c:	88 60       	ori	r24, 0x08	; 8
    1e9e:	80 83       	st	Z, r24
    1ea0:	08 95       	ret
			break;
		case LOGICAL_CHANGE:
			SET_BIT(_MCUCR, ISC10);
    1ea2:	e5 e5       	ldi	r30, 0x55	; 85
    1ea4:	f0 e0       	ldi	r31, 0x00	; 0
    1ea6:	80 81       	ld	r24, Z
    1ea8:	84 60       	ori	r24, 0x04	; 4
    1eaa:	80 83       	st	Z, r24
			CLR_BIT(_MCUCR, ISC11);
    1eac:	80 81       	ld	r24, Z
    1eae:	87 7f       	andi	r24, 0xF7	; 247
    1eb0:	80 83       	st	Z, r24
    1eb2:	08 95       	ret
			break;
		case LOW_LEVEL:
			CLR_BIT(_MCUCR, ISC10);
    1eb4:	e5 e5       	ldi	r30, 0x55	; 85
    1eb6:	f0 e0       	ldi	r31, 0x00	; 0
    1eb8:	80 81       	ld	r24, Z
    1eba:	8b 7f       	andi	r24, 0xFB	; 251
    1ebc:	80 83       	st	Z, r24
			CLR_BIT(_MCUCR, ISC11);
    1ebe:	80 81       	ld	r24, Z
    1ec0:	87 7f       	andi	r24, 0xF7	; 247
    1ec2:	80 83       	st	Z, r24
    1ec4:	08 95       	ret
			break;
		}
		break;

	case EXTI_INT2:
		switch (copy_u8SenseControl)
    1ec6:	61 30       	cpi	r22, 0x01	; 1
    1ec8:	31 f0       	breq	.+12     	; 0x1ed6 <EXTI_voidInit+0xc8>
		{
		default:
		case RISING_EDGE:
			SET_BIT(_MCUCSR, ISC2);
    1eca:	e4 e5       	ldi	r30, 0x54	; 84
    1ecc:	f0 e0       	ldi	r31, 0x00	; 0
    1ece:	80 81       	ld	r24, Z
    1ed0:	80 64       	ori	r24, 0x40	; 64
    1ed2:	80 83       	st	Z, r24
    1ed4:	08 95       	ret
			break;
		case FALLING_EDGE:
			CLR_BIT(_MCUCSR, ISC2);
    1ed6:	e4 e5       	ldi	r30, 0x54	; 84
    1ed8:	f0 e0       	ldi	r31, 0x00	; 0
    1eda:	80 81       	ld	r24, Z
    1edc:	8f 7b       	andi	r24, 0xBF	; 191
    1ede:	80 83       	st	Z, r24
    1ee0:	08 95       	ret

00001ee2 <EXTI_voidEnable>:
 * @param	1- copy_u8InterruptSource 	-> External interrupt source (EXTI_INTx where x = (0, 1 or 2))
 * @return	void
 */
void EXTI_voidEnable(u8 copy_u8InterruptSource)
{
	switch (copy_u8InterruptSource)
    1ee2:	81 30       	cpi	r24, 0x01	; 1
    1ee4:	59 f0       	breq	.+22     	; 0x1efc <EXTI_voidEnable+0x1a>
    1ee6:	81 30       	cpi	r24, 0x01	; 1
    1ee8:	18 f0       	brcs	.+6      	; 0x1ef0 <EXTI_voidEnable+0xe>
    1eea:	82 30       	cpi	r24, 0x02	; 2
    1eec:	91 f4       	brne	.+36     	; 0x1f12 <EXTI_voidEnable+0x30>
    1eee:	0c c0       	rjmp	.+24     	; 0x1f08 <EXTI_voidEnable+0x26>
	{
	case EXTI_INT0:
		SET_BIT(_GICR, INT0);
    1ef0:	eb e5       	ldi	r30, 0x5B	; 91
    1ef2:	f0 e0       	ldi	r31, 0x00	; 0
    1ef4:	80 81       	ld	r24, Z
    1ef6:	80 64       	ori	r24, 0x40	; 64
    1ef8:	80 83       	st	Z, r24
    1efa:	08 95       	ret
		break;
	case EXTI_INT1:
		SET_BIT(_GICR, INT1);
    1efc:	eb e5       	ldi	r30, 0x5B	; 91
    1efe:	f0 e0       	ldi	r31, 0x00	; 0
    1f00:	80 81       	ld	r24, Z
    1f02:	80 68       	ori	r24, 0x80	; 128
    1f04:	80 83       	st	Z, r24
    1f06:	08 95       	ret
		break;
	case EXTI_INT2:
		SET_BIT(_GICR, INT2);
    1f08:	eb e5       	ldi	r30, 0x5B	; 91
    1f0a:	f0 e0       	ldi	r31, 0x00	; 0
    1f0c:	80 81       	ld	r24, Z
    1f0e:	80 62       	ori	r24, 0x20	; 32
    1f10:	80 83       	st	Z, r24
    1f12:	08 95       	ret

00001f14 <EXTI_voidDisable>:
 * @param	1- copy_u8InterruptSource 	-> External interrupt source (EXTI_INTx where x = (0, 1 or 2))
 * @return	void
 */
void EXTI_voidDisable(u8 copy_u8InterruptSource)
{
	switch (copy_u8InterruptSource)
    1f14:	81 30       	cpi	r24, 0x01	; 1
    1f16:	59 f0       	breq	.+22     	; 0x1f2e <EXTI_voidDisable+0x1a>
    1f18:	81 30       	cpi	r24, 0x01	; 1
    1f1a:	18 f0       	brcs	.+6      	; 0x1f22 <EXTI_voidDisable+0xe>
    1f1c:	82 30       	cpi	r24, 0x02	; 2
    1f1e:	91 f4       	brne	.+36     	; 0x1f44 <EXTI_voidDisable+0x30>
    1f20:	0c c0       	rjmp	.+24     	; 0x1f3a <EXTI_voidDisable+0x26>
	{
	case EXTI_INT0:
		CLR_BIT(_GICR, INT0);
    1f22:	eb e5       	ldi	r30, 0x5B	; 91
    1f24:	f0 e0       	ldi	r31, 0x00	; 0
    1f26:	80 81       	ld	r24, Z
    1f28:	8f 7b       	andi	r24, 0xBF	; 191
    1f2a:	80 83       	st	Z, r24
    1f2c:	08 95       	ret
		break;
	case EXTI_INT1:
		CLR_BIT(_GICR, INT1);
    1f2e:	eb e5       	ldi	r30, 0x5B	; 91
    1f30:	f0 e0       	ldi	r31, 0x00	; 0
    1f32:	80 81       	ld	r24, Z
    1f34:	8f 77       	andi	r24, 0x7F	; 127
    1f36:	80 83       	st	Z, r24
    1f38:	08 95       	ret
		break;
	case EXTI_INT2:
		CLR_BIT(_GICR, INT2);
    1f3a:	eb e5       	ldi	r30, 0x5B	; 91
    1f3c:	f0 e0       	ldi	r31, 0x00	; 0
    1f3e:	80 81       	ld	r24, Z
    1f40:	8f 7d       	andi	r24, 0xDF	; 223
    1f42:	80 83       	st	Z, r24
    1f44:	08 95       	ret

00001f46 <EXTI0_voidSendCallBack>:
}

//CallBack Functions Implementation for EXTI0, 1, 2
void EXTI0_voidSendCallBack(void (*PtrF0)(void))
{
	if(PtrF0 !=NULL)
    1f46:	00 97       	sbiw	r24, 0x00	; 0
    1f48:	21 f0       	breq	.+8      	; 0x1f52 <EXTI0_voidSendCallBack+0xc>
	{
		EXTI_prviate_PtrCallBack0 = PtrF0;
    1f4a:	90 93 d3 01 	sts	0x01D3, r25
    1f4e:	80 93 d2 01 	sts	0x01D2, r24
    1f52:	08 95       	ret

00001f54 <EXTI1_voidSendCallBack>:
	}
}

void EXTI1_voidSendCallBack(void (*PtrF1)(void))
{
	if(PtrF1 !=NULL)
    1f54:	00 97       	sbiw	r24, 0x00	; 0
    1f56:	21 f0       	breq	.+8      	; 0x1f60 <EXTI1_voidSendCallBack+0xc>
	{
		EXTI_prviate_PtrCallBack1 = PtrF1;
    1f58:	90 93 d1 01 	sts	0x01D1, r25
    1f5c:	80 93 d0 01 	sts	0x01D0, r24
    1f60:	08 95       	ret

00001f62 <EXTI2_voidSendCallBack>:
	}
}

void EXTI2_voidSendCallBack(void (*PtrF2)(void))
{
	if(PtrF2 !=NULL)
    1f62:	00 97       	sbiw	r24, 0x00	; 0
    1f64:	21 f0       	breq	.+8      	; 0x1f6e <EXTI2_voidSendCallBack+0xc>
	{
		EXTI_prviate_PtrCallBack2 = PtrF2;
    1f66:	90 93 cf 01 	sts	0x01CF, r25
    1f6a:	80 93 ce 01 	sts	0x01CE, r24
    1f6e:	08 95       	ret

00001f70 <__vector_1>:
//EXTI2 ISR
void __vector_3(void) __attribute__((signal));


void __vector_1(void)
{
    1f70:	1f 92       	push	r1
    1f72:	0f 92       	push	r0
    1f74:	0f b6       	in	r0, 0x3f	; 63
    1f76:	0f 92       	push	r0
    1f78:	11 24       	eor	r1, r1
    1f7a:	2f 93       	push	r18
    1f7c:	3f 93       	push	r19
    1f7e:	4f 93       	push	r20
    1f80:	5f 93       	push	r21
    1f82:	6f 93       	push	r22
    1f84:	7f 93       	push	r23
    1f86:	8f 93       	push	r24
    1f88:	9f 93       	push	r25
    1f8a:	af 93       	push	r26
    1f8c:	bf 93       	push	r27
    1f8e:	ef 93       	push	r30
    1f90:	ff 93       	push	r31
	if(EXTI_prviate_PtrCallBack0 !=NULL)
    1f92:	e0 91 d2 01 	lds	r30, 0x01D2
    1f96:	f0 91 d3 01 	lds	r31, 0x01D3
    1f9a:	30 97       	sbiw	r30, 0x00	; 0
    1f9c:	09 f0       	breq	.+2      	; 0x1fa0 <__vector_1+0x30>
	{
		EXTI_prviate_PtrCallBack0();
    1f9e:	09 95       	icall
	}
}
    1fa0:	ff 91       	pop	r31
    1fa2:	ef 91       	pop	r30
    1fa4:	bf 91       	pop	r27
    1fa6:	af 91       	pop	r26
    1fa8:	9f 91       	pop	r25
    1faa:	8f 91       	pop	r24
    1fac:	7f 91       	pop	r23
    1fae:	6f 91       	pop	r22
    1fb0:	5f 91       	pop	r21
    1fb2:	4f 91       	pop	r20
    1fb4:	3f 91       	pop	r19
    1fb6:	2f 91       	pop	r18
    1fb8:	0f 90       	pop	r0
    1fba:	0f be       	out	0x3f, r0	; 63
    1fbc:	0f 90       	pop	r0
    1fbe:	1f 90       	pop	r1
    1fc0:	18 95       	reti

00001fc2 <__vector_2>:

void __vector_2(void)
{
    1fc2:	1f 92       	push	r1
    1fc4:	0f 92       	push	r0
    1fc6:	0f b6       	in	r0, 0x3f	; 63
    1fc8:	0f 92       	push	r0
    1fca:	11 24       	eor	r1, r1
    1fcc:	2f 93       	push	r18
    1fce:	3f 93       	push	r19
    1fd0:	4f 93       	push	r20
    1fd2:	5f 93       	push	r21
    1fd4:	6f 93       	push	r22
    1fd6:	7f 93       	push	r23
    1fd8:	8f 93       	push	r24
    1fda:	9f 93       	push	r25
    1fdc:	af 93       	push	r26
    1fde:	bf 93       	push	r27
    1fe0:	ef 93       	push	r30
    1fe2:	ff 93       	push	r31
	if(EXTI_prviate_PtrCallBack1 !=NULL)
    1fe4:	e0 91 d0 01 	lds	r30, 0x01D0
    1fe8:	f0 91 d1 01 	lds	r31, 0x01D1
    1fec:	30 97       	sbiw	r30, 0x00	; 0
    1fee:	09 f0       	breq	.+2      	; 0x1ff2 <__vector_2+0x30>
	{
		EXTI_prviate_PtrCallBack1();
    1ff0:	09 95       	icall
	}
}
    1ff2:	ff 91       	pop	r31
    1ff4:	ef 91       	pop	r30
    1ff6:	bf 91       	pop	r27
    1ff8:	af 91       	pop	r26
    1ffa:	9f 91       	pop	r25
    1ffc:	8f 91       	pop	r24
    1ffe:	7f 91       	pop	r23
    2000:	6f 91       	pop	r22
    2002:	5f 91       	pop	r21
    2004:	4f 91       	pop	r20
    2006:	3f 91       	pop	r19
    2008:	2f 91       	pop	r18
    200a:	0f 90       	pop	r0
    200c:	0f be       	out	0x3f, r0	; 63
    200e:	0f 90       	pop	r0
    2010:	1f 90       	pop	r1
    2012:	18 95       	reti

00002014 <__vector_3>:

void __vector_3(void)
{
    2014:	1f 92       	push	r1
    2016:	0f 92       	push	r0
    2018:	0f b6       	in	r0, 0x3f	; 63
    201a:	0f 92       	push	r0
    201c:	11 24       	eor	r1, r1
    201e:	2f 93       	push	r18
    2020:	3f 93       	push	r19
    2022:	4f 93       	push	r20
    2024:	5f 93       	push	r21
    2026:	6f 93       	push	r22
    2028:	7f 93       	push	r23
    202a:	8f 93       	push	r24
    202c:	9f 93       	push	r25
    202e:	af 93       	push	r26
    2030:	bf 93       	push	r27
    2032:	ef 93       	push	r30
    2034:	ff 93       	push	r31
	if(EXTI_prviate_PtrCallBack2 !=NULL)
    2036:	e0 91 ce 01 	lds	r30, 0x01CE
    203a:	f0 91 cf 01 	lds	r31, 0x01CF
    203e:	30 97       	sbiw	r30, 0x00	; 0
    2040:	09 f0       	breq	.+2      	; 0x2044 <__vector_3+0x30>
	{
		EXTI_prviate_PtrCallBack2();
    2042:	09 95       	icall
	}
}
    2044:	ff 91       	pop	r31
    2046:	ef 91       	pop	r30
    2048:	bf 91       	pop	r27
    204a:	af 91       	pop	r26
    204c:	9f 91       	pop	r25
    204e:	8f 91       	pop	r24
    2050:	7f 91       	pop	r23
    2052:	6f 91       	pop	r22
    2054:	5f 91       	pop	r21
    2056:	4f 91       	pop	r20
    2058:	3f 91       	pop	r19
    205a:	2f 91       	pop	r18
    205c:	0f 90       	pop	r0
    205e:	0f be       	out	0x3f, r0	; 63
    2060:	0f 90       	pop	r0
    2062:	1f 90       	pop	r1
    2064:	18 95       	reti

00002066 <Dio_WriteChannel>:
 * @param	1- ChannelId 	-> to choose the right PIN  EX: (PA_0) refers to PIN0 in PORTA
 * 			2- Level		-> to choose the level on that PIN	(0 or 1)
 * @return	void
 */
void Dio_WriteChannel(Dio_ChannelType ChannelId, Dio_LevelType Level)
{
    2066:	48 2f       	mov	r20, r24
	switch(ChannelId/8)
    2068:	86 95       	lsr	r24
    206a:	86 95       	lsr	r24
    206c:	86 95       	lsr	r24
    206e:	81 30       	cpi	r24, 0x01	; 1
    2070:	31 f1       	breq	.+76     	; 0x20be <Dio_WriteChannel+0x58>
    2072:	81 30       	cpi	r24, 0x01	; 1
    2074:	38 f0       	brcs	.+14     	; 0x2084 <Dio_WriteChannel+0x1e>
    2076:	82 30       	cpi	r24, 0x02	; 2
    2078:	09 f4       	brne	.+2      	; 0x207c <Dio_WriteChannel+0x16>
    207a:	42 c0       	rjmp	.+132    	; 0x2100 <Dio_WriteChannel+0x9a>
    207c:	83 30       	cpi	r24, 0x03	; 3
    207e:	09 f0       	breq	.+2      	; 0x2082 <Dio_WriteChannel+0x1c>
    2080:	80 c0       	rjmp	.+256    	; 0x2182 <Dio_WriteChannel+0x11c>
    2082:	5f c0       	rjmp	.+190    	; 0x2142 <Dio_WriteChannel+0xdc>
	{
	case Dio_PORTA:
		if(Level == 1)
    2084:	61 30       	cpi	r22, 0x01	; 1
    2086:	69 f4       	brne	.+26     	; 0x20a2 <Dio_WriteChannel+0x3c>
			SET_BIT(_PORTA, ChannelId);
    2088:	eb e3       	ldi	r30, 0x3B	; 59
    208a:	f0 e0       	ldi	r31, 0x00	; 0
    208c:	20 81       	ld	r18, Z
    208e:	81 e0       	ldi	r24, 0x01	; 1
    2090:	90 e0       	ldi	r25, 0x00	; 0
    2092:	02 c0       	rjmp	.+4      	; 0x2098 <Dio_WriteChannel+0x32>
    2094:	88 0f       	add	r24, r24
    2096:	99 1f       	adc	r25, r25
    2098:	4a 95       	dec	r20
    209a:	e2 f7       	brpl	.-8      	; 0x2094 <Dio_WriteChannel+0x2e>
    209c:	28 2b       	or	r18, r24
    209e:	20 83       	st	Z, r18
    20a0:	08 95       	ret
		else
			CLR_BIT(_PORTA, ChannelId);
    20a2:	eb e3       	ldi	r30, 0x3B	; 59
    20a4:	f0 e0       	ldi	r31, 0x00	; 0
    20a6:	20 81       	ld	r18, Z
    20a8:	81 e0       	ldi	r24, 0x01	; 1
    20aa:	90 e0       	ldi	r25, 0x00	; 0
    20ac:	02 c0       	rjmp	.+4      	; 0x20b2 <Dio_WriteChannel+0x4c>
    20ae:	88 0f       	add	r24, r24
    20b0:	99 1f       	adc	r25, r25
    20b2:	4a 95       	dec	r20
    20b4:	e2 f7       	brpl	.-8      	; 0x20ae <Dio_WriteChannel+0x48>
    20b6:	80 95       	com	r24
    20b8:	82 23       	and	r24, r18
    20ba:	80 83       	st	Z, r24
    20bc:	08 95       	ret
		break;
	case Dio_PORTB:
		if(Level == 1)
    20be:	61 30       	cpi	r22, 0x01	; 1
    20c0:	79 f4       	brne	.+30     	; 0x20e0 <Dio_WriteChannel+0x7a>
			SET_BIT(_PORTB, ChannelId % 8);
    20c2:	e8 e3       	ldi	r30, 0x38	; 56
    20c4:	f0 e0       	ldi	r31, 0x00	; 0
    20c6:	20 81       	ld	r18, Z
    20c8:	34 2f       	mov	r19, r20
    20ca:	37 70       	andi	r19, 0x07	; 7
    20cc:	81 e0       	ldi	r24, 0x01	; 1
    20ce:	90 e0       	ldi	r25, 0x00	; 0
    20d0:	02 c0       	rjmp	.+4      	; 0x20d6 <Dio_WriteChannel+0x70>
    20d2:	88 0f       	add	r24, r24
    20d4:	99 1f       	adc	r25, r25
    20d6:	3a 95       	dec	r19
    20d8:	e2 f7       	brpl	.-8      	; 0x20d2 <Dio_WriteChannel+0x6c>
    20da:	28 2b       	or	r18, r24
    20dc:	20 83       	st	Z, r18
    20de:	08 95       	ret
		else
			CLR_BIT(_PORTB, ChannelId % 8);
    20e0:	e8 e3       	ldi	r30, 0x38	; 56
    20e2:	f0 e0       	ldi	r31, 0x00	; 0
    20e4:	30 81       	ld	r19, Z
    20e6:	24 2f       	mov	r18, r20
    20e8:	27 70       	andi	r18, 0x07	; 7
    20ea:	81 e0       	ldi	r24, 0x01	; 1
    20ec:	90 e0       	ldi	r25, 0x00	; 0
    20ee:	02 c0       	rjmp	.+4      	; 0x20f4 <Dio_WriteChannel+0x8e>
    20f0:	88 0f       	add	r24, r24
    20f2:	99 1f       	adc	r25, r25
    20f4:	2a 95       	dec	r18
    20f6:	e2 f7       	brpl	.-8      	; 0x20f0 <Dio_WriteChannel+0x8a>
    20f8:	80 95       	com	r24
    20fa:	83 23       	and	r24, r19
    20fc:	80 83       	st	Z, r24
    20fe:	08 95       	ret
		break;
	case Dio_PORTC:
		if(Level == 1)
    2100:	61 30       	cpi	r22, 0x01	; 1
    2102:	79 f4       	brne	.+30     	; 0x2122 <Dio_WriteChannel+0xbc>
			SET_BIT(_PORTC, ChannelId % 8);
    2104:	e5 e3       	ldi	r30, 0x35	; 53
    2106:	f0 e0       	ldi	r31, 0x00	; 0
    2108:	20 81       	ld	r18, Z
    210a:	34 2f       	mov	r19, r20
    210c:	37 70       	andi	r19, 0x07	; 7
    210e:	81 e0       	ldi	r24, 0x01	; 1
    2110:	90 e0       	ldi	r25, 0x00	; 0
    2112:	02 c0       	rjmp	.+4      	; 0x2118 <Dio_WriteChannel+0xb2>
    2114:	88 0f       	add	r24, r24
    2116:	99 1f       	adc	r25, r25
    2118:	3a 95       	dec	r19
    211a:	e2 f7       	brpl	.-8      	; 0x2114 <Dio_WriteChannel+0xae>
    211c:	28 2b       	or	r18, r24
    211e:	20 83       	st	Z, r18
    2120:	08 95       	ret
		else
			CLR_BIT(_PORTC, ChannelId % 8);
    2122:	e5 e3       	ldi	r30, 0x35	; 53
    2124:	f0 e0       	ldi	r31, 0x00	; 0
    2126:	30 81       	ld	r19, Z
    2128:	24 2f       	mov	r18, r20
    212a:	27 70       	andi	r18, 0x07	; 7
    212c:	81 e0       	ldi	r24, 0x01	; 1
    212e:	90 e0       	ldi	r25, 0x00	; 0
    2130:	02 c0       	rjmp	.+4      	; 0x2136 <Dio_WriteChannel+0xd0>
    2132:	88 0f       	add	r24, r24
    2134:	99 1f       	adc	r25, r25
    2136:	2a 95       	dec	r18
    2138:	e2 f7       	brpl	.-8      	; 0x2132 <Dio_WriteChannel+0xcc>
    213a:	80 95       	com	r24
    213c:	83 23       	and	r24, r19
    213e:	80 83       	st	Z, r24
    2140:	08 95       	ret
		break;
	case Dio_PORTD:
		if(Level == 1)
    2142:	61 30       	cpi	r22, 0x01	; 1
    2144:	79 f4       	brne	.+30     	; 0x2164 <Dio_WriteChannel+0xfe>
			SET_BIT(_PORTD, ChannelId % 8);
    2146:	e2 e3       	ldi	r30, 0x32	; 50
    2148:	f0 e0       	ldi	r31, 0x00	; 0
    214a:	20 81       	ld	r18, Z
    214c:	34 2f       	mov	r19, r20
    214e:	37 70       	andi	r19, 0x07	; 7
    2150:	81 e0       	ldi	r24, 0x01	; 1
    2152:	90 e0       	ldi	r25, 0x00	; 0
    2154:	02 c0       	rjmp	.+4      	; 0x215a <Dio_WriteChannel+0xf4>
    2156:	88 0f       	add	r24, r24
    2158:	99 1f       	adc	r25, r25
    215a:	3a 95       	dec	r19
    215c:	e2 f7       	brpl	.-8      	; 0x2156 <Dio_WriteChannel+0xf0>
    215e:	28 2b       	or	r18, r24
    2160:	20 83       	st	Z, r18
    2162:	08 95       	ret
		else
			CLR_BIT(_PORTD, ChannelId % 8);
    2164:	e2 e3       	ldi	r30, 0x32	; 50
    2166:	f0 e0       	ldi	r31, 0x00	; 0
    2168:	30 81       	ld	r19, Z
    216a:	24 2f       	mov	r18, r20
    216c:	27 70       	andi	r18, 0x07	; 7
    216e:	81 e0       	ldi	r24, 0x01	; 1
    2170:	90 e0       	ldi	r25, 0x00	; 0
    2172:	02 c0       	rjmp	.+4      	; 0x2178 <Dio_WriteChannel+0x112>
    2174:	88 0f       	add	r24, r24
    2176:	99 1f       	adc	r25, r25
    2178:	2a 95       	dec	r18
    217a:	e2 f7       	brpl	.-8      	; 0x2174 <Dio_WriteChannel+0x10e>
    217c:	80 95       	com	r24
    217e:	83 23       	and	r24, r19
    2180:	80 83       	st	Z, r24
    2182:	08 95       	ret

00002184 <Dio_ReadChannel>:
 * Dio_ReadChannel : This function READ the level on a PIN
 * @param	1- ChannelId 	-> to choose the PIN to read from  EX: (PA_0) refers to PIN0 in PORTA
 * @return	Dio_LevelType 	-> if 1 then the level id HIGH, if 0 then the level id LOW
 */
Dio_LevelType Dio_ReadChannel(Dio_ChannelType ChannelId)
{
    2184:	28 2f       	mov	r18, r24
	Dio_LevelType ret = STD_LOW;
	switch(ChannelId /8)
    2186:	86 95       	lsr	r24
    2188:	86 95       	lsr	r24
    218a:	86 95       	lsr	r24
    218c:	81 30       	cpi	r24, 0x01	; 1
    218e:	89 f0       	breq	.+34     	; 0x21b2 <Dio_ReadChannel+0x2e>
    2190:	81 30       	cpi	r24, 0x01	; 1
    2192:	30 f0       	brcs	.+12     	; 0x21a0 <Dio_ReadChannel+0x1c>
    2194:	82 30       	cpi	r24, 0x02	; 2
    2196:	b9 f0       	breq	.+46     	; 0x21c6 <Dio_ReadChannel+0x42>
    2198:	83 30       	cpi	r24, 0x03	; 3
    219a:	f9 f0       	breq	.+62     	; 0x21da <Dio_ReadChannel+0x56>
    219c:	80 e0       	ldi	r24, 0x00	; 0
    219e:	08 95       	ret
	{
	case Dio_PORTA:
		ret = GET_BIT(_PINA, ChannelId);
    21a0:	89 b3       	in	r24, 0x19	; 25
    21a2:	90 e0       	ldi	r25, 0x00	; 0
    21a4:	02 c0       	rjmp	.+4      	; 0x21aa <Dio_ReadChannel+0x26>
    21a6:	95 95       	asr	r25
    21a8:	87 95       	ror	r24
    21aa:	2a 95       	dec	r18
    21ac:	e2 f7       	brpl	.-8      	; 0x21a6 <Dio_ReadChannel+0x22>
    21ae:	81 70       	andi	r24, 0x01	; 1
    21b0:	08 95       	ret
		break;
	case Dio_PORTB:
		ret = GET_BIT(_PINB, ChannelId %8);
    21b2:	86 b3       	in	r24, 0x16	; 22
    21b4:	90 e0       	ldi	r25, 0x00	; 0
    21b6:	27 70       	andi	r18, 0x07	; 7
    21b8:	02 c0       	rjmp	.+4      	; 0x21be <Dio_ReadChannel+0x3a>
    21ba:	95 95       	asr	r25
    21bc:	87 95       	ror	r24
    21be:	2a 95       	dec	r18
    21c0:	e2 f7       	brpl	.-8      	; 0x21ba <Dio_ReadChannel+0x36>
    21c2:	81 70       	andi	r24, 0x01	; 1
    21c4:	08 95       	ret
		break;
	case Dio_PORTC:
		ret = GET_BIT(_PINC, ChannelId % 8);
    21c6:	83 b3       	in	r24, 0x13	; 19
    21c8:	90 e0       	ldi	r25, 0x00	; 0
    21ca:	27 70       	andi	r18, 0x07	; 7
    21cc:	02 c0       	rjmp	.+4      	; 0x21d2 <Dio_ReadChannel+0x4e>
    21ce:	95 95       	asr	r25
    21d0:	87 95       	ror	r24
    21d2:	2a 95       	dec	r18
    21d4:	e2 f7       	brpl	.-8      	; 0x21ce <Dio_ReadChannel+0x4a>
    21d6:	81 70       	andi	r24, 0x01	; 1
    21d8:	08 95       	ret
		break;
	case Dio_PORTD:
		ret = GET_BIT(_PIND, ChannelId % 8);
    21da:	80 b3       	in	r24, 0x10	; 16
    21dc:	90 e0       	ldi	r25, 0x00	; 0
    21de:	27 70       	andi	r18, 0x07	; 7
    21e0:	02 c0       	rjmp	.+4      	; 0x21e6 <Dio_ReadChannel+0x62>
    21e2:	95 95       	asr	r25
    21e4:	87 95       	ror	r24
    21e6:	2a 95       	dec	r18
    21e8:	e2 f7       	brpl	.-8      	; 0x21e2 <Dio_ReadChannel+0x5e>
    21ea:	81 70       	andi	r24, 0x01	; 1
		break;
	default:	break;
	}
	return ret;
}
    21ec:	08 95       	ret

000021ee <Dio_FlipChannel>:
 * Dio_FlipChannel : This function toggle the level on a PIN
 * @param	1- ChannelId 	-> to choose the PIN to toggle its level  EX: (PA_0) refers to PIN0 in PORTA
 * @return	Dio_LevelType 	-> return the level of the pin after toggling --> 1 for level HIGH,  0 for level LOW
 */
Dio_LevelType Dio_FlipChannel(Dio_ChannelType ChannelId)
{
    21ee:	38 2f       	mov	r19, r24
	Dio_LevelType ret = STD_LOW;
	switch(ChannelId / 8)
    21f0:	86 95       	lsr	r24
    21f2:	86 95       	lsr	r24
    21f4:	86 95       	lsr	r24
    21f6:	81 30       	cpi	r24, 0x01	; 1
    21f8:	f9 f0       	breq	.+62     	; 0x2238 <Dio_FlipChannel+0x4a>
    21fa:	81 30       	cpi	r24, 0x01	; 1
    21fc:	38 f0       	brcs	.+14     	; 0x220c <Dio_FlipChannel+0x1e>
    21fe:	82 30       	cpi	r24, 0x02	; 2
    2200:	a9 f1       	breq	.+106    	; 0x226c <Dio_FlipChannel+0x7e>
    2202:	83 30       	cpi	r24, 0x03	; 3
    2204:	09 f4       	brne	.+2      	; 0x2208 <Dio_FlipChannel+0x1a>
    2206:	4c c0       	rjmp	.+152    	; 0x22a0 <Dio_FlipChannel+0xb2>
    2208:	80 e0       	ldi	r24, 0x00	; 0
    220a:	08 95       	ret
	{
	case Dio_PORTA:
		TOG_BIT(_PORTA, ChannelId);
    220c:	eb e3       	ldi	r30, 0x3B	; 59
    220e:	f0 e0       	ldi	r31, 0x00	; 0
    2210:	20 81       	ld	r18, Z
    2212:	81 e0       	ldi	r24, 0x01	; 1
    2214:	90 e0       	ldi	r25, 0x00	; 0
    2216:	03 2e       	mov	r0, r19
    2218:	02 c0       	rjmp	.+4      	; 0x221e <Dio_FlipChannel+0x30>
    221a:	88 0f       	add	r24, r24
    221c:	99 1f       	adc	r25, r25
    221e:	0a 94       	dec	r0
    2220:	e2 f7       	brpl	.-8      	; 0x221a <Dio_FlipChannel+0x2c>
    2222:	28 27       	eor	r18, r24
    2224:	20 83       	st	Z, r18
		ret = GET_BIT(_PORTA, ChannelId);
    2226:	80 81       	ld	r24, Z
    2228:	90 e0       	ldi	r25, 0x00	; 0
    222a:	02 c0       	rjmp	.+4      	; 0x2230 <Dio_FlipChannel+0x42>
    222c:	95 95       	asr	r25
    222e:	87 95       	ror	r24
    2230:	3a 95       	dec	r19
    2232:	e2 f7       	brpl	.-8      	; 0x222c <Dio_FlipChannel+0x3e>
    2234:	81 70       	andi	r24, 0x01	; 1
    2236:	08 95       	ret
		break;
	case Dio_PORTB:
		TOG_BIT(_PORTB, ChannelId % 8);
    2238:	e8 e3       	ldi	r30, 0x38	; 56
    223a:	f0 e0       	ldi	r31, 0x00	; 0
    223c:	40 81       	ld	r20, Z
    223e:	23 2f       	mov	r18, r19
    2240:	30 e0       	ldi	r19, 0x00	; 0
    2242:	27 70       	andi	r18, 0x07	; 7
    2244:	30 70       	andi	r19, 0x00	; 0
    2246:	81 e0       	ldi	r24, 0x01	; 1
    2248:	90 e0       	ldi	r25, 0x00	; 0
    224a:	02 2e       	mov	r0, r18
    224c:	02 c0       	rjmp	.+4      	; 0x2252 <Dio_FlipChannel+0x64>
    224e:	88 0f       	add	r24, r24
    2250:	99 1f       	adc	r25, r25
    2252:	0a 94       	dec	r0
    2254:	e2 f7       	brpl	.-8      	; 0x224e <Dio_FlipChannel+0x60>
    2256:	48 27       	eor	r20, r24
    2258:	40 83       	st	Z, r20
		ret = GET_BIT(_PORTB, ChannelId %8);
    225a:	80 81       	ld	r24, Z
    225c:	90 e0       	ldi	r25, 0x00	; 0
    225e:	02 c0       	rjmp	.+4      	; 0x2264 <Dio_FlipChannel+0x76>
    2260:	95 95       	asr	r25
    2262:	87 95       	ror	r24
    2264:	2a 95       	dec	r18
    2266:	e2 f7       	brpl	.-8      	; 0x2260 <Dio_FlipChannel+0x72>
    2268:	81 70       	andi	r24, 0x01	; 1
    226a:	08 95       	ret
		break;
	case Dio_PORTC:
		TOG_BIT(_PORTC, ChannelId % 8);
    226c:	e5 e3       	ldi	r30, 0x35	; 53
    226e:	f0 e0       	ldi	r31, 0x00	; 0
    2270:	40 81       	ld	r20, Z
    2272:	23 2f       	mov	r18, r19
    2274:	30 e0       	ldi	r19, 0x00	; 0
    2276:	27 70       	andi	r18, 0x07	; 7
    2278:	30 70       	andi	r19, 0x00	; 0
    227a:	81 e0       	ldi	r24, 0x01	; 1
    227c:	90 e0       	ldi	r25, 0x00	; 0
    227e:	02 2e       	mov	r0, r18
    2280:	02 c0       	rjmp	.+4      	; 0x2286 <Dio_FlipChannel+0x98>
    2282:	88 0f       	add	r24, r24
    2284:	99 1f       	adc	r25, r25
    2286:	0a 94       	dec	r0
    2288:	e2 f7       	brpl	.-8      	; 0x2282 <Dio_FlipChannel+0x94>
    228a:	48 27       	eor	r20, r24
    228c:	40 83       	st	Z, r20
		ret = GET_BIT(_PORTC, ChannelId % 8);
    228e:	80 81       	ld	r24, Z
    2290:	90 e0       	ldi	r25, 0x00	; 0
    2292:	02 c0       	rjmp	.+4      	; 0x2298 <Dio_FlipChannel+0xaa>
    2294:	95 95       	asr	r25
    2296:	87 95       	ror	r24
    2298:	2a 95       	dec	r18
    229a:	e2 f7       	brpl	.-8      	; 0x2294 <Dio_FlipChannel+0xa6>
    229c:	81 70       	andi	r24, 0x01	; 1
    229e:	08 95       	ret
		break;
	case Dio_PORTD:
		TOG_BIT(_PORTD, ChannelId % 8);
    22a0:	e2 e3       	ldi	r30, 0x32	; 50
    22a2:	f0 e0       	ldi	r31, 0x00	; 0
    22a4:	40 81       	ld	r20, Z
    22a6:	23 2f       	mov	r18, r19
    22a8:	30 e0       	ldi	r19, 0x00	; 0
    22aa:	27 70       	andi	r18, 0x07	; 7
    22ac:	30 70       	andi	r19, 0x00	; 0
    22ae:	81 e0       	ldi	r24, 0x01	; 1
    22b0:	90 e0       	ldi	r25, 0x00	; 0
    22b2:	02 2e       	mov	r0, r18
    22b4:	02 c0       	rjmp	.+4      	; 0x22ba <Dio_FlipChannel+0xcc>
    22b6:	88 0f       	add	r24, r24
    22b8:	99 1f       	adc	r25, r25
    22ba:	0a 94       	dec	r0
    22bc:	e2 f7       	brpl	.-8      	; 0x22b6 <Dio_FlipChannel+0xc8>
    22be:	48 27       	eor	r20, r24
    22c0:	40 83       	st	Z, r20
		ret = GET_BIT(_PORTD, ChannelId % 8);
    22c2:	80 81       	ld	r24, Z
    22c4:	90 e0       	ldi	r25, 0x00	; 0
    22c6:	02 c0       	rjmp	.+4      	; 0x22cc <Dio_FlipChannel+0xde>
    22c8:	95 95       	asr	r25
    22ca:	87 95       	ror	r24
    22cc:	2a 95       	dec	r18
    22ce:	e2 f7       	brpl	.-8      	; 0x22c8 <Dio_FlipChannel+0xda>
    22d0:	81 70       	andi	r24, 0x01	; 1
		break;
	default:	break;
	}
	return ret;
}
    22d2:	08 95       	ret

000022d4 <Dio_ReadPort>:
 * @return	Dio_PortLevelType 	-> return the level of the PORT
 */
Dio_PortLevelType Dio_ReadPort(Dio_PortType PortId)
{
	Dio_PortLevelType ret = 0;
	switch(PortId)
    22d4:	81 30       	cpi	r24, 0x01	; 1
    22d6:	51 f0       	breq	.+20     	; 0x22ec <Dio_ReadPort+0x18>
    22d8:	81 30       	cpi	r24, 0x01	; 1
    22da:	30 f0       	brcs	.+12     	; 0x22e8 <Dio_ReadPort+0x14>
    22dc:	82 30       	cpi	r24, 0x02	; 2
    22de:	41 f0       	breq	.+16     	; 0x22f0 <Dio_ReadPort+0x1c>
    22e0:	83 30       	cpi	r24, 0x03	; 3
    22e2:	41 f0       	breq	.+16     	; 0x22f4 <Dio_ReadPort+0x20>
    22e4:	80 e0       	ldi	r24, 0x00	; 0
    22e6:	08 95       	ret
	{
	case Dio_PORTA:
		ret = _PINA;
    22e8:	89 b3       	in	r24, 0x19	; 25
    22ea:	08 95       	ret
		break;
	case Dio_PORTB:
		ret = _PINB;
    22ec:	86 b3       	in	r24, 0x16	; 22
    22ee:	08 95       	ret
		break;
	case Dio_PORTC:
		ret = _PINC;
    22f0:	83 b3       	in	r24, 0x13	; 19
    22f2:	08 95       	ret
		break;
	case Dio_PORTD:
		ret =_PIND;
    22f4:	80 b3       	in	r24, 0x10	; 16
			break;
	}
	return ret;
}
    22f6:	08 95       	ret

000022f8 <Dio_WritePort>:
 * 			2- Level 	-> the level to write 	Ex : (255) to write 1111 1111
 * @return	Dio_LevelType 	-> return the level of the PORT
 */
void Dio_WritePort(Dio_PortType PortId,Dio_PortLevelType Level)
{
	switch(PortId)
    22f8:	81 30       	cpi	r24, 0x01	; 1
    22fa:	49 f0       	breq	.+18     	; 0x230e <Dio_WritePort+0x16>
    22fc:	81 30       	cpi	r24, 0x01	; 1
    22fe:	28 f0       	brcs	.+10     	; 0x230a <Dio_WritePort+0x12>
    2300:	82 30       	cpi	r24, 0x02	; 2
    2302:	39 f0       	breq	.+14     	; 0x2312 <Dio_WritePort+0x1a>
    2304:	83 30       	cpi	r24, 0x03	; 3
    2306:	41 f4       	brne	.+16     	; 0x2318 <Dio_WritePort+0x20>
    2308:	06 c0       	rjmp	.+12     	; 0x2316 <Dio_WritePort+0x1e>
		{
		case Dio_PORTA:
			_PORTA = Level;
    230a:	6b bb       	out	0x1b, r22	; 27
    230c:	08 95       	ret
			break;
		case Dio_PORTB:
			_PORTB = Level;
    230e:	68 bb       	out	0x18, r22	; 24
    2310:	08 95       	ret
			break;
		case Dio_PORTC:
			_PORTC = Level;
    2312:	65 bb       	out	0x15, r22	; 21
    2314:	08 95       	ret
			break;
		case Dio_PORTD:
			_PORTD = Level;
    2316:	62 bb       	out	0x12, r22	; 18
    2318:	08 95       	ret

0000231a <ADC_void_Init>:
	case AREF:
		CLR_BIT(_ADMUX, 6);
		CLR_BIT(_ADMUX, 7);
		break;
	case AVCC :
		SET_BIT(_ADMUX, 6);
    231a:	e7 e2       	ldi	r30, 0x27	; 39
    231c:	f0 e0       	ldi	r31, 0x00	; 0
    231e:	80 81       	ld	r24, Z
    2320:	80 64       	ori	r24, 0x40	; 64
    2322:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 7);
    2324:	80 81       	ld	r24, Z
    2326:	8f 77       	andi	r24, 0x7F	; 127
    2328:	80 83       	st	Z, r24
static void ADC_voidLeft_Adjust_Result(void)
{
	switch(ADC_Left_Adjust_Result)
	{
	case LEFT:
		SET_BIT(_ADMUX, 5);
    232a:	80 81       	ld	r24, Z
    232c:	80 62       	ori	r24, 0x20	; 32
    232e:	80 83       	st	Z, r24
		CLR_BIT(_ADCSRA, 0);
		SET_BIT(_ADCSRA, 1);
		SET_BIT(_ADCSRA, 2);
		break;
	case 128:
		SET_BIT(_ADCSRA, 0);
    2330:	e6 e2       	ldi	r30, 0x26	; 38
    2332:	f0 e0       	ldi	r31, 0x00	; 0
    2334:	80 81       	ld	r24, Z
    2336:	81 60       	ori	r24, 0x01	; 1
    2338:	80 83       	st	Z, r24
		SET_BIT(_ADCSRA, 1);
    233a:	80 81       	ld	r24, Z
    233c:	82 60       	ori	r24, 0x02	; 2
    233e:	80 83       	st	Z, r24
		SET_BIT(_ADCSRA, 2);
    2340:	80 81       	ld	r24, Z
    2342:	84 60       	ori	r24, 0x04	; 4
    2344:	80 83       	st	Z, r24
void ADC_void_Init(void)
{
	ADC_voidSetVoltageReference();
	ADC_voidLeft_Adjust_Result();
	ADC_voidSet_Prescaler();
	SET_BIT(_ADCSRA, 7); // Enable ADC
    2346:	80 81       	ld	r24, Z
    2348:	80 68       	ori	r24, 0x80	; 128
    234a:	80 83       	st	Z, r24
}
    234c:	08 95       	ret

0000234e <ADC_void_Read_CH>:
	default: break;
	}
}
static void ADC_Select_Channel(u8 u8_Copy_CH)
{
	switch(u8_Copy_CH)
    234e:	83 30       	cpi	r24, 0x03	; 3
    2350:	09 f4       	brne	.+2      	; 0x2354 <ADC_void_Read_CH+0x6>
    2352:	4a c0       	rjmp	.+148    	; 0x23e8 <ADC_void_Read_CH+0x9a>
    2354:	84 30       	cpi	r24, 0x04	; 4
    2356:	28 f4       	brcc	.+10     	; 0x2362 <ADC_void_Read_CH+0x14>
    2358:	81 30       	cpi	r24, 0x01	; 1
    235a:	11 f1       	breq	.+68     	; 0x23a0 <ADC_void_Read_CH+0x52>
    235c:	82 30       	cpi	r24, 0x02	; 2
    235e:	90 f5       	brcc	.+100    	; 0x23c4 <ADC_void_Read_CH+0x76>
    2360:	0d c0       	rjmp	.+26     	; 0x237c <ADC_void_Read_CH+0x2e>
    2362:	85 30       	cpi	r24, 0x05	; 5
    2364:	09 f4       	brne	.+2      	; 0x2368 <ADC_void_Read_CH+0x1a>
    2366:	64 c0       	rjmp	.+200    	; 0x2430 <ADC_void_Read_CH+0xe2>
    2368:	85 30       	cpi	r24, 0x05	; 5
    236a:	08 f4       	brcc	.+2      	; 0x236e <ADC_void_Read_CH+0x20>
    236c:	4f c0       	rjmp	.+158    	; 0x240c <ADC_void_Read_CH+0xbe>
    236e:	86 30       	cpi	r24, 0x06	; 6
    2370:	09 f4       	brne	.+2      	; 0x2374 <ADC_void_Read_CH+0x26>
    2372:	70 c0       	rjmp	.+224    	; 0x2454 <ADC_void_Read_CH+0x106>
    2374:	87 30       	cpi	r24, 0x07	; 7
    2376:	09 f0       	breq	.+2      	; 0x237a <ADC_void_Read_CH+0x2c>
    2378:	90 c0       	rjmp	.+288    	; 0x249a <ADC_void_Read_CH+0x14c>
    237a:	7e c0       	rjmp	.+252    	; 0x2478 <ADC_void_Read_CH+0x12a>
	{
	case(ADC0_SE):
		CLR_BIT(_ADMUX, 0);
    237c:	e7 e2       	ldi	r30, 0x27	; 39
    237e:	f0 e0       	ldi	r31, 0x00	; 0
    2380:	80 81       	ld	r24, Z
    2382:	8e 7f       	andi	r24, 0xFE	; 254
    2384:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 1);
    2386:	80 81       	ld	r24, Z
    2388:	8d 7f       	andi	r24, 0xFD	; 253
    238a:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 2);
    238c:	80 81       	ld	r24, Z
    238e:	8b 7f       	andi	r24, 0xFB	; 251
    2390:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    2392:	80 81       	ld	r24, Z
    2394:	87 7f       	andi	r24, 0xF7	; 247
    2396:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    2398:	80 81       	ld	r24, Z
    239a:	8f 7e       	andi	r24, 0xEF	; 239
    239c:	80 83       	st	Z, r24
    239e:	7d c0       	rjmp	.+250    	; 0x249a <ADC_void_Read_CH+0x14c>
		break;
	case(ADC1_SE):
		SET_BIT(_ADMUX, 0);
    23a0:	e7 e2       	ldi	r30, 0x27	; 39
    23a2:	f0 e0       	ldi	r31, 0x00	; 0
    23a4:	80 81       	ld	r24, Z
    23a6:	81 60       	ori	r24, 0x01	; 1
    23a8:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 1);
    23aa:	80 81       	ld	r24, Z
    23ac:	8d 7f       	andi	r24, 0xFD	; 253
    23ae:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 2);
    23b0:	80 81       	ld	r24, Z
    23b2:	8b 7f       	andi	r24, 0xFB	; 251
    23b4:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    23b6:	80 81       	ld	r24, Z
    23b8:	87 7f       	andi	r24, 0xF7	; 247
    23ba:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    23bc:	80 81       	ld	r24, Z
    23be:	8f 7e       	andi	r24, 0xEF	; 239
    23c0:	80 83       	st	Z, r24
    23c2:	6b c0       	rjmp	.+214    	; 0x249a <ADC_void_Read_CH+0x14c>
		break;
	case(ADC2_SE):
		CLR_BIT(_ADMUX, 0);
    23c4:	e7 e2       	ldi	r30, 0x27	; 39
    23c6:	f0 e0       	ldi	r31, 0x00	; 0
    23c8:	80 81       	ld	r24, Z
    23ca:	8e 7f       	andi	r24, 0xFE	; 254
    23cc:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 1);
    23ce:	80 81       	ld	r24, Z
    23d0:	82 60       	ori	r24, 0x02	; 2
    23d2:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 2);
    23d4:	80 81       	ld	r24, Z
    23d6:	8b 7f       	andi	r24, 0xFB	; 251
    23d8:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    23da:	80 81       	ld	r24, Z
    23dc:	87 7f       	andi	r24, 0xF7	; 247
    23de:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    23e0:	80 81       	ld	r24, Z
    23e2:	8f 7e       	andi	r24, 0xEF	; 239
    23e4:	80 83       	st	Z, r24
    23e6:	59 c0       	rjmp	.+178    	; 0x249a <ADC_void_Read_CH+0x14c>
		break;
	case(ADC3_SE):
		SET_BIT(_ADMUX, 0);
    23e8:	e7 e2       	ldi	r30, 0x27	; 39
    23ea:	f0 e0       	ldi	r31, 0x00	; 0
    23ec:	80 81       	ld	r24, Z
    23ee:	81 60       	ori	r24, 0x01	; 1
    23f0:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 1);
    23f2:	80 81       	ld	r24, Z
    23f4:	82 60       	ori	r24, 0x02	; 2
    23f6:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 2);
    23f8:	80 81       	ld	r24, Z
    23fa:	8b 7f       	andi	r24, 0xFB	; 251
    23fc:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    23fe:	80 81       	ld	r24, Z
    2400:	87 7f       	andi	r24, 0xF7	; 247
    2402:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    2404:	80 81       	ld	r24, Z
    2406:	8f 7e       	andi	r24, 0xEF	; 239
    2408:	80 83       	st	Z, r24
    240a:	47 c0       	rjmp	.+142    	; 0x249a <ADC_void_Read_CH+0x14c>
		break;
	case(ADC4_SE):
		CLR_BIT(_ADMUX, 0);
    240c:	e7 e2       	ldi	r30, 0x27	; 39
    240e:	f0 e0       	ldi	r31, 0x00	; 0
    2410:	80 81       	ld	r24, Z
    2412:	8e 7f       	andi	r24, 0xFE	; 254
    2414:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 1);
    2416:	80 81       	ld	r24, Z
    2418:	8d 7f       	andi	r24, 0xFD	; 253
    241a:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 2);
    241c:	80 81       	ld	r24, Z
    241e:	84 60       	ori	r24, 0x04	; 4
    2420:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    2422:	80 81       	ld	r24, Z
    2424:	87 7f       	andi	r24, 0xF7	; 247
    2426:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    2428:	80 81       	ld	r24, Z
    242a:	8f 7e       	andi	r24, 0xEF	; 239
    242c:	80 83       	st	Z, r24
    242e:	35 c0       	rjmp	.+106    	; 0x249a <ADC_void_Read_CH+0x14c>
		break;
	case(ADC5_SE):
		SET_BIT(_ADMUX, 0);
    2430:	e7 e2       	ldi	r30, 0x27	; 39
    2432:	f0 e0       	ldi	r31, 0x00	; 0
    2434:	80 81       	ld	r24, Z
    2436:	81 60       	ori	r24, 0x01	; 1
    2438:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 1);
    243a:	80 81       	ld	r24, Z
    243c:	8d 7f       	andi	r24, 0xFD	; 253
    243e:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 2);
    2440:	80 81       	ld	r24, Z
    2442:	84 60       	ori	r24, 0x04	; 4
    2444:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    2446:	80 81       	ld	r24, Z
    2448:	87 7f       	andi	r24, 0xF7	; 247
    244a:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    244c:	80 81       	ld	r24, Z
    244e:	8f 7e       	andi	r24, 0xEF	; 239
    2450:	80 83       	st	Z, r24
    2452:	23 c0       	rjmp	.+70     	; 0x249a <ADC_void_Read_CH+0x14c>
		break;
	case(ADC6_SE):
		CLR_BIT(_ADMUX, 0);
    2454:	e7 e2       	ldi	r30, 0x27	; 39
    2456:	f0 e0       	ldi	r31, 0x00	; 0
    2458:	80 81       	ld	r24, Z
    245a:	8e 7f       	andi	r24, 0xFE	; 254
    245c:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 1);
    245e:	80 81       	ld	r24, Z
    2460:	82 60       	ori	r24, 0x02	; 2
    2462:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 2);
    2464:	80 81       	ld	r24, Z
    2466:	84 60       	ori	r24, 0x04	; 4
    2468:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    246a:	80 81       	ld	r24, Z
    246c:	87 7f       	andi	r24, 0xF7	; 247
    246e:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    2470:	80 81       	ld	r24, Z
    2472:	8f 7e       	andi	r24, 0xEF	; 239
    2474:	80 83       	st	Z, r24
    2476:	11 c0       	rjmp	.+34     	; 0x249a <ADC_void_Read_CH+0x14c>
		break;
	case(ADC7_SE):
		SET_BIT(_ADMUX, 0);
    2478:	e7 e2       	ldi	r30, 0x27	; 39
    247a:	f0 e0       	ldi	r31, 0x00	; 0
    247c:	80 81       	ld	r24, Z
    247e:	81 60       	ori	r24, 0x01	; 1
    2480:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 1);
    2482:	80 81       	ld	r24, Z
    2484:	82 60       	ori	r24, 0x02	; 2
    2486:	80 83       	st	Z, r24
		SET_BIT(_ADMUX, 2);
    2488:	80 81       	ld	r24, Z
    248a:	84 60       	ori	r24, 0x04	; 4
    248c:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 3);
    248e:	80 81       	ld	r24, Z
    2490:	87 7f       	andi	r24, 0xF7	; 247
    2492:	80 83       	st	Z, r24
		CLR_BIT(_ADMUX, 4);
    2494:	80 81       	ld	r24, Z
    2496:	8f 7e       	andi	r24, 0xEF	; 239
    2498:	80 83       	st	Z, r24

u16 ADC_void_Read_CH(u8 u8_Copychannel)
{
	u16 result = 0;
	ADC_Select_Channel(u8_Copychannel);
	SET_BIT(_ADCSRA , 6); // ADC start conversion
    249a:	e6 e2       	ldi	r30, 0x26	; 38
    249c:	f0 e0       	ldi	r31, 0x00	; 0
    249e:	80 81       	ld	r24, Z
    24a0:	80 64       	ori	r24, 0x40	; 64
    24a2:	80 83       	st	Z, r24
	while(_ADCSRA & (1 << 6));
    24a4:	80 81       	ld	r24, Z
    24a6:	86 fd       	sbrc	r24, 6
    24a8:	fd cf       	rjmp	.-6      	; 0x24a4 <ADC_void_Read_CH+0x156>
	switch(ADC_Left_Adjust_Result)
	{
	case LEFT:
		 result = (_ADCL >> 6);
    24aa:	84 b1       	in	r24, 0x04	; 4
    24ac:	82 95       	swap	r24
    24ae:	86 95       	lsr	r24
    24b0:	86 95       	lsr	r24
    24b2:	83 70       	andi	r24, 0x03	; 3
    24b4:	90 e0       	ldi	r25, 0x00	; 0
		 result |= (_ADCH << 2);
    24b6:	25 b1       	in	r18, 0x05	; 5
    24b8:	30 e0       	ldi	r19, 0x00	; 0
    24ba:	22 0f       	add	r18, r18
    24bc:	33 1f       	adc	r19, r19
    24be:	22 0f       	add	r18, r18
    24c0:	33 1f       	adc	r19, r19
    24c2:	28 2b       	or	r18, r24
    24c4:	39 2b       	or	r19, r25
		 result = _ADCL;
		 result |= (_ADCH << 8);
		break;
	}
	return result;
}
    24c6:	82 2f       	mov	r24, r18
    24c8:	93 2f       	mov	r25, r19
    24ca:	08 95       	ret

000024cc <Ultra_Sonic_Distance_in_cm>:
	_delay_ms(60);
}

u16 Ultra_Sonic_Distance_in_cm(void)
{
	return (ICU_u32GetFallingEdgeTime() / 58);
    24cc:	0e 94 93 0e 	call	0x1d26	; 0x1d26 <ICU_u32GetFallingEdgeTime>
    24d0:	2a e3       	ldi	r18, 0x3A	; 58
    24d2:	30 e0       	ldi	r19, 0x00	; 0
    24d4:	40 e0       	ldi	r20, 0x00	; 0
    24d6:	50 e0       	ldi	r21, 0x00	; 0
    24d8:	0e 94 2f 31 	call	0x625e	; 0x625e <__udivmodsi4>
    24dc:	82 2f       	mov	r24, r18
    24de:	93 2f       	mov	r25, r19
}
    24e0:	08 95       	ret

000024e2 <Ultra_Sonic_void_trigger>:
#include "../../_MY_LIBS/BIT_MATH.h"
#include "../../_MCAL/HICU/ICU_Interface.h"
#include "util/delay.h"

void Ultra_Sonic_void_trigger(u8 channel)
{
    24e2:	1f 93       	push	r17
    24e4:	18 2f       	mov	r17, r24
	Dio_WriteChannel(channel, 1);
    24e6:	61 e0       	ldi	r22, 0x01	; 1
    24e8:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    24ec:	85 e3       	ldi	r24, 0x35	; 53
    24ee:	8a 95       	dec	r24
    24f0:	f1 f7       	brne	.-4      	; 0x24ee <Ultra_Sonic_void_trigger+0xc>
	_delay_us(10);
	Dio_WriteChannel(channel, 0);
    24f2:	81 2f       	mov	r24, r17
    24f4:	60 e0       	ldi	r22, 0x00	; 0
    24f6:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    24fa:	28 e5       	ldi	r18, 0x58	; 88
    24fc:	32 e0       	ldi	r19, 0x02	; 2
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    24fe:	40 e9       	ldi	r20, 0x90	; 144
    2500:	51 e0       	ldi	r21, 0x01	; 1
    2502:	ca 01       	movw	r24, r20
    2504:	01 97       	sbiw	r24, 0x01	; 1
    2506:	f1 f7       	brne	.-4      	; 0x2504 <Ultra_Sonic_void_trigger+0x22>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2508:	21 50       	subi	r18, 0x01	; 1
    250a:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    250c:	d1 f7       	brne	.-12     	; 0x2502 <Ultra_Sonic_void_trigger+0x20>
	_delay_ms(60);
}
    250e:	1f 91       	pop	r17
    2510:	08 95       	ret

00002512 <Simple_Scheduler>:
    TMR0_voidSendCallBack_OVF(Simple_Scheduler);
}

/*-----------------------------------------------------*/
static void Simple_Scheduler(void)
{
    2512:	cf 92       	push	r12
    2514:	df 92       	push	r13
    2516:	ef 92       	push	r14
    2518:	ff 92       	push	r15
    251a:	1f 93       	push	r17
    251c:	cf 93       	push	r28
    251e:	df 93       	push	r29
    2520:	10 e0       	ldi	r17, 0x00	; 0
    for (u8 i = 0; i <= created_tasks_number ; i++)
    {
    	if (My_Tasks[i].Task_FuncPtr == NULL)
    2522:	0f 2e       	mov	r0, r31
    2524:	f3 e2       	ldi	r31, 0x23	; 35
    2526:	cf 2e       	mov	r12, r31
    2528:	f8 e0       	ldi	r31, 0x08	; 8
    252a:	df 2e       	mov	r13, r31
    252c:	f0 2d       	mov	r31, r0
    	{
    		continue;
    	}
        if (temp_priodicity[i] == 0)
    252e:	0f 2e       	mov	r0, r31
    2530:	f7 e1       	ldi	r31, 0x17	; 23
    2532:	ef 2e       	mov	r14, r31
    2534:	f8 e0       	ldi	r31, 0x08	; 8
    2536:	ff 2e       	mov	r15, r31
    2538:	f0 2d       	mov	r31, r0
/*-----------------------------------------------------*/
static void Simple_Scheduler(void)
{
    for (u8 i = 0; i <= created_tasks_number ; i++)
    {
    	if (My_Tasks[i].Task_FuncPtr == NULL)
    253a:	c1 2f       	mov	r28, r17
    253c:	d0 e0       	ldi	r29, 0x00	; 0
    253e:	ce 01       	movw	r24, r28
    2540:	88 0f       	add	r24, r24
    2542:	99 1f       	adc	r25, r25
    2544:	88 0f       	add	r24, r24
    2546:	99 1f       	adc	r25, r25
    2548:	88 0f       	add	r24, r24
    254a:	99 1f       	adc	r25, r25
    254c:	8c 1b       	sub	r24, r28
    254e:	9d 0b       	sbc	r25, r29
    2550:	f6 01       	movw	r30, r12
    2552:	e8 0f       	add	r30, r24
    2554:	f9 1f       	adc	r31, r25
    2556:	40 81       	ld	r20, Z
    2558:	51 81       	ldd	r21, Z+1	; 0x01
    255a:	41 15       	cp	r20, r1
    255c:	51 05       	cpc	r21, r1
    255e:	71 f1       	breq	.+92     	; 0x25bc <Simple_Scheduler+0xaa>
    	{
    		continue;
    	}
        if (temp_priodicity[i] == 0)
    2560:	ce 01       	movw	r24, r28
    2562:	88 0f       	add	r24, r24
    2564:	99 1f       	adc	r25, r25
    2566:	f7 01       	movw	r30, r14
    2568:	e8 0f       	add	r30, r24
    256a:	f9 1f       	adc	r31, r25
    256c:	20 81       	ld	r18, Z
    256e:	31 81       	ldd	r19, Z+1	; 0x01
    2570:	21 15       	cp	r18, r1
    2572:	31 05       	cpc	r19, r1
    2574:	c9 f4       	brne	.+50     	; 0x25a8 <Simple_Scheduler+0x96>
        {
            My_Tasks[i].Task_FuncPtr();
    2576:	fa 01       	movw	r30, r20
    2578:	09 95       	icall
            temp_priodicity[i] = My_Tasks[i].Task_Periodicity;
    257a:	ce 01       	movw	r24, r28
    257c:	88 0f       	add	r24, r24
    257e:	99 1f       	adc	r25, r25
    2580:	d7 01       	movw	r26, r14
    2582:	a8 0f       	add	r26, r24
    2584:	b9 1f       	adc	r27, r25
    2586:	ce 01       	movw	r24, r28
    2588:	88 0f       	add	r24, r24
    258a:	99 1f       	adc	r25, r25
    258c:	88 0f       	add	r24, r24
    258e:	99 1f       	adc	r25, r25
    2590:	88 0f       	add	r24, r24
    2592:	99 1f       	adc	r25, r25
    2594:	8c 1b       	sub	r24, r28
    2596:	9d 0b       	sbc	r25, r29
    2598:	f6 01       	movw	r30, r12
    259a:	e8 0f       	add	r30, r24
    259c:	f9 1f       	adc	r31, r25
    259e:	82 81       	ldd	r24, Z+2	; 0x02
    25a0:	93 81       	ldd	r25, Z+3	; 0x03
    25a2:	8d 93       	st	X+, r24
    25a4:	9c 93       	st	X, r25
    25a6:	0a c0       	rjmp	.+20     	; 0x25bc <Simple_Scheduler+0xaa>
        }
        else
        {
        	temp_priodicity[i]--;
    25a8:	ce 01       	movw	r24, r28
    25aa:	88 0f       	add	r24, r24
    25ac:	99 1f       	adc	r25, r25
    25ae:	f7 01       	movw	r30, r14
    25b0:	e8 0f       	add	r30, r24
    25b2:	f9 1f       	adc	r31, r25
    25b4:	c9 01       	movw	r24, r18
    25b6:	01 97       	sbiw	r24, 0x01	; 1
    25b8:	91 83       	std	Z+1, r25	; 0x01
    25ba:	80 83       	st	Z, r24
}

/*-----------------------------------------------------*/
static void Simple_Scheduler(void)
{
    for (u8 i = 0; i <= created_tasks_number ; i++)
    25bc:	1f 5f       	subi	r17, 0xFF	; 255
    25be:	80 91 d4 01 	lds	r24, 0x01D4
    25c2:	81 17       	cp	r24, r17
    25c4:	08 f0       	brcs	.+2      	; 0x25c8 <Simple_Scheduler+0xb6>
    25c6:	b9 cf       	rjmp	.-142    	; 0x253a <Simple_Scheduler+0x28>
        else
        {
        	temp_priodicity[i]--;
        }
    }
}
    25c8:	df 91       	pop	r29
    25ca:	cf 91       	pop	r28
    25cc:	1f 91       	pop	r17
    25ce:	ff 90       	pop	r15
    25d0:	ef 90       	pop	r14
    25d2:	df 90       	pop	r13
    25d4:	cf 90       	pop	r12
    25d6:	08 95       	ret

000025d8 <Task_Creat>:
static void Simple_Scheduler(void);
static void shift_array_index(u8 index);

/* ----------------- Section : Software Interfaces Implementation -----------------*/
void Task_Creat(u8 Copy_u8Priority, u16 Copy_u8Periodicity, void (*Fptr)(void), u16 Copy_u16InitialDelay)
{
    25d8:	cf 92       	push	r12
    25da:	df 92       	push	r13
    25dc:	ef 92       	push	r14
    25de:	ff 92       	push	r15
    25e0:	1f 93       	push	r17
    25e2:	cf 93       	push	r28
    25e4:	df 93       	push	r29
    25e6:	18 2f       	mov	r17, r24
    25e8:	6b 01       	movw	r12, r22
    25ea:	7a 01       	movw	r14, r20
    25ec:	e9 01       	movw	r28, r18
	u8 flag = 0;
	//check if the priority (index) is repeated
	for (int i = 0; i<created_tasks_number ; i++)
    25ee:	60 91 d4 01 	lds	r22, 0x01D4
    25f2:	46 2f       	mov	r20, r22
    25f4:	50 e0       	ldi	r21, 0x00	; 0
    25f6:	14 16       	cp	r1, r20
    25f8:	15 06       	cpc	r1, r21
    25fa:	0c f0       	brlt	.+2      	; 0x25fe <Task_Creat+0x26>
    25fc:	42 c0       	rjmp	.+132    	; 0x2682 <Task_Creat+0xaa>
	{
		if (Copy_u8Priority == My_Tasks[i].Task_Priority)
    25fe:	80 91 29 08 	lds	r24, 0x0829
    2602:	81 17       	cp	r24, r17
    2604:	79 f0       	breq	.+30     	; 0x2624 <Task_Creat+0x4c>
    2606:	e0 e3       	ldi	r30, 0x30	; 48
    2608:	f8 e0       	ldi	r31, 0x08	; 8
    260a:	20 e0       	ldi	r18, 0x00	; 0
    260c:	30 e0       	ldi	r19, 0x00	; 0
    260e:	04 c0       	rjmp	.+8      	; 0x2618 <Task_Creat+0x40>
    2610:	80 81       	ld	r24, Z
    2612:	37 96       	adiw	r30, 0x07	; 7
    2614:	81 17       	cp	r24, r17
    2616:	31 f0       	breq	.+12     	; 0x2624 <Task_Creat+0x4c>
/* ----------------- Section : Software Interfaces Implementation -----------------*/
void Task_Creat(u8 Copy_u8Priority, u16 Copy_u8Periodicity, void (*Fptr)(void), u16 Copy_u16InitialDelay)
{
	u8 flag = 0;
	//check if the priority (index) is repeated
	for (int i = 0; i<created_tasks_number ; i++)
    2618:	2f 5f       	subi	r18, 0xFF	; 255
    261a:	3f 4f       	sbci	r19, 0xFF	; 255
    261c:	24 17       	cp	r18, r20
    261e:	35 07       	cpc	r19, r21
    2620:	bc f3       	brlt	.-18     	; 0x2610 <Task_Creat+0x38>
    2622:	2f c0       	rjmp	.+94     	; 0x2682 <Task_Creat+0xaa>
    }
}

static void shift_array_index(u8 index)
{
	for(int i = index; i< created_tasks_number-1 ; i ++)
    2624:	21 2f       	mov	r18, r17
    2626:	30 e0       	ldi	r19, 0x00	; 0
    2628:	ca 01       	movw	r24, r20
    262a:	01 97       	sbiw	r24, 0x01	; 1
    262c:	28 17       	cp	r18, r24
    262e:	39 07       	cpc	r19, r25
    2630:	3c f5       	brge	.+78     	; 0x2680 <Task_Creat+0xa8>
    2632:	c9 01       	movw	r24, r18
    2634:	88 0f       	add	r24, r24
    2636:	99 1f       	adc	r25, r25
    2638:	88 0f       	add	r24, r24
    263a:	99 1f       	adc	r25, r25
    263c:	88 0f       	add	r24, r24
    263e:	99 1f       	adc	r25, r25
    2640:	82 1b       	sub	r24, r18
    2642:	93 0b       	sbc	r25, r19
    2644:	fc 01       	movw	r30, r24
    2646:	e7 5d       	subi	r30, 0xD7	; 215
    2648:	f7 4f       	sbci	r31, 0xF7	; 247
    264a:	ac 01       	movw	r20, r24
    264c:	40 95       	com	r20
    264e:	50 95       	com	r21
    2650:	86 2f       	mov	r24, r22
    2652:	90 e0       	ldi	r25, 0x00	; 0
    2654:	28 0f       	add	r18, r24
    2656:	39 1f       	adc	r19, r25
    2658:	c9 01       	movw	r24, r18
    265a:	88 0f       	add	r24, r24
    265c:	99 1f       	adc	r25, r25
    265e:	88 0f       	add	r24, r24
    2660:	99 1f       	adc	r25, r25
    2662:	88 0f       	add	r24, r24
    2664:	99 1f       	adc	r25, r25
    2666:	82 1b       	sub	r24, r18
    2668:	93 0b       	sbc	r25, r19
    266a:	8d 5d       	subi	r24, 0xDD	; 221
    266c:	97 4f       	sbci	r25, 0xF7	; 247
    266e:	48 0f       	add	r20, r24
    2670:	59 1f       	adc	r21, r25
	{
		My_Tasks[i].Task_Priority++;
    2672:	80 81       	ld	r24, Z
    2674:	8f 5f       	subi	r24, 0xFF	; 255
    2676:	80 83       	st	Z, r24
    2678:	37 96       	adiw	r30, 0x07	; 7
    }
}

static void shift_array_index(u8 index)
{
	for(int i = index; i< created_tasks_number-1 ; i ++)
    267a:	e4 17       	cp	r30, r20
    267c:	f5 07       	cpc	r31, r21
    267e:	c9 f7       	brne	.-14     	; 0x2672 <Task_Creat+0x9a>
	}

	if (flag == 1)
	{
		shift_array_index(Copy_u8Priority);
		Copy_u8Priority++;
    2680:	1f 5f       	subi	r17, 0xFF	; 255
	}
	My_Tasks[Copy_u8Priority].Task_FuncPtr = Fptr;
    2682:	81 2f       	mov	r24, r17
    2684:	90 e0       	ldi	r25, 0x00	; 0
    2686:	dc 01       	movw	r26, r24
    2688:	aa 0f       	add	r26, r26
    268a:	bb 1f       	adc	r27, r27
    268c:	aa 0f       	add	r26, r26
    268e:	bb 1f       	adc	r27, r27
    2690:	aa 0f       	add	r26, r26
    2692:	bb 1f       	adc	r27, r27
    2694:	a8 1b       	sub	r26, r24
    2696:	b9 0b       	sbc	r27, r25
    2698:	ad 5d       	subi	r26, 0xDD	; 221
    269a:	b7 4f       	sbci	r27, 0xF7	; 247
    269c:	fd 01       	movw	r30, r26
    269e:	e1 92       	st	Z+, r14
    26a0:	f1 92       	st	Z+, r15
	My_Tasks[Copy_u8Priority].Task_Periodicity = Copy_u8Periodicity;
    26a2:	d1 82       	std	Z+1, r13	; 0x01
    26a4:	c0 82       	st	Z, r12
	My_Tasks[Copy_u8Priority].Task_Priority = Copy_u8Priority;
    26a6:	16 96       	adiw	r26, 0x06	; 6
    26a8:	1c 93       	st	X, r17
    26aa:	16 97       	sbiw	r26, 0x06	; 6
	My_Tasks[Copy_u8Priority].Task_InitialDelay = Copy_u16InitialDelay;
    26ac:	15 96       	adiw	r26, 0x05	; 5
    26ae:	dc 93       	st	X, r29
    26b0:	ce 93       	st	-X, r28
    26b2:	14 97       	sbiw	r26, 0x04	; 4

    temp_priodicity[Copy_u8Priority] = Copy_u16InitialDelay;
    26b4:	88 0f       	add	r24, r24
    26b6:	99 1f       	adc	r25, r25
    26b8:	89 5e       	subi	r24, 0xE9	; 233
    26ba:	97 4f       	sbci	r25, 0xF7	; 247
    26bc:	fc 01       	movw	r30, r24
    26be:	d1 83       	std	Z+1, r29	; 0x01
    26c0:	c0 83       	st	Z, r28
    created_tasks_number++;
    26c2:	86 2f       	mov	r24, r22
    26c4:	8f 5f       	subi	r24, 0xFF	; 255
    26c6:	80 93 d4 01 	sts	0x01D4, r24
}
    26ca:	df 91       	pop	r29
    26cc:	cf 91       	pop	r28
    26ce:	1f 91       	pop	r17
    26d0:	ff 90       	pop	r15
    26d2:	ef 90       	pop	r14
    26d4:	df 90       	pop	r13
    26d6:	cf 90       	pop	r12
    26d8:	08 95       	ret

000026da <Scheduler_Start>:

void Scheduler_Start(void) {
    TMR0_voidInit();
    26da:	0e 94 c1 0b 	call	0x1782	; 0x1782 <TMR0_voidInit>
    TMR0_voidStart();
    26de:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <TMR0_voidStart>
    TMR0_voidSendCallBack_OVF(Simple_Scheduler);
    26e2:	89 e8       	ldi	r24, 0x89	; 137
    26e4:	92 e1       	ldi	r25, 0x12	; 18
    26e6:	0e 94 b3 0b 	call	0x1766	; 0x1766 <TMR0_voidSendCallBack_OVF>
}
    26ea:	08 95       	ret

000026ec <SRVM_voidOff>:


void SRVM_voidOff(void)
{
	/* TMR1 stop */
	TMR1_voidStop();
    26ec:	0e 94 11 0b 	call	0x1622	; 0x1622 <TMR1_voidStop>
}
    26f0:	08 95       	ret

000026f2 <SRVM_voidOn>:
/*------------------- Statics -------------------------*/
static u8 timer1Initialized = 0;		// the purpose of it is to init TMR0 only once

/* ----------------- Section : Software Interfaces Implementation -----------------*/
void SRVM_voidOn(u8 Copy_u8Angle)
{
    26f2:	1f 93       	push	r17
    26f4:	18 2f       	mov	r17, r24
	if (timer1Initialized == 0)
    26f6:	80 91 d5 01 	lds	r24, 0x01D5
    26fa:	88 23       	and	r24, r24
    26fc:	29 f4       	brne	.+10     	; 0x2708 <SRVM_voidOn+0x16>
	{
	/* TMR1 init at pwm mode 14 */
	TMR1_voidInit();
    26fe:	0e 94 2e 0b 	call	0x165c	; 0x165c <TMR1_voidInit>

	timer1Initialized = 1;
    2702:	81 e0       	ldi	r24, 0x01	; 1
    2704:	80 93 d5 01 	sts	0x01D5, r24
	}

	/* Set pwm duty cycle between 5 : 10
	 depend on desired angle[0 : 180] */
	f32 duty_cycle = (f32) ( 5 + (Copy_u8Angle *(5/ 180.0) ));
	TMR1_voidSetDuty_Mode14(duty_cycle);
    2708:	61 2f       	mov	r22, r17
    270a:	70 e0       	ldi	r23, 0x00	; 0
    270c:	88 27       	eor	r24, r24
    270e:	77 fd       	sbrc	r23, 7
    2710:	80 95       	com	r24
    2712:	98 2f       	mov	r25, r24
    2714:	0e 94 55 04 	call	0x8aa	; 0x8aa <__floatsisf>
    2718:	29 e3       	ldi	r18, 0x39	; 57
    271a:	3e e8       	ldi	r19, 0x8E	; 142
    271c:	43 ee       	ldi	r20, 0xE3	; 227
    271e:	5c e3       	ldi	r21, 0x3C	; 60
    2720:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2724:	20 e0       	ldi	r18, 0x00	; 0
    2726:	30 e0       	ldi	r19, 0x00	; 0
    2728:	40 ea       	ldi	r20, 0xA0	; 160
    272a:	50 e4       	ldi	r21, 0x40	; 64
    272c:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <__addsf3>
    2730:	0e 94 49 0b 	call	0x1692	; 0x1692 <TMR1_voidSetDuty_Mode14>

	/* TMR1 start */
	TMR1_voidStart();
    2734:	0e 94 85 0b 	call	0x170a	; 0x170a <TMR1_voidStart>
}
    2738:	1f 91       	pop	r17
    273a:	08 95       	ret

0000273c <LCD4_Command_Write>:
	Dio_WriteChannel(EN,STD_LOW);
	_delay_ms(1);
}

void LCD4_Command_Write(u8 command)
{
    273c:	ef 92       	push	r14
    273e:	ff 92       	push	r15
    2740:	1f 93       	push	r17
    2742:	18 2f       	mov	r17, r24
	Dio_WriteChannel(RS,STD_LOW);
    2744:	83 e0       	ldi	r24, 0x03	; 3
    2746:	60 e0       	ldi	r22, 0x00	; 0
    2748:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>

	Dio_WriteChannel(D4,GET_BIT(command,4));
    274c:	61 2f       	mov	r22, r17
    274e:	62 95       	swap	r22
    2750:	6f 70       	andi	r22, 0x0F	; 15
    2752:	61 70       	andi	r22, 0x01	; 1
    2754:	88 e0       	ldi	r24, 0x08	; 8
    2756:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D5,GET_BIT(command,5));
    275a:	61 2f       	mov	r22, r17
    275c:	62 95       	swap	r22
    275e:	66 95       	lsr	r22
    2760:	67 70       	andi	r22, 0x07	; 7
    2762:	61 70       	andi	r22, 0x01	; 1
    2764:	89 e0       	ldi	r24, 0x09	; 9
    2766:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D6,GET_BIT(command,6));
    276a:	61 2f       	mov	r22, r17
    276c:	62 95       	swap	r22
    276e:	66 95       	lsr	r22
    2770:	66 95       	lsr	r22
    2772:	63 70       	andi	r22, 0x03	; 3
    2774:	61 70       	andi	r22, 0x01	; 1
    2776:	8a e0       	ldi	r24, 0x0A	; 10
    2778:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D7,GET_BIT(command,7));
    277c:	61 2f       	mov	r22, r17
    277e:	66 1f       	adc	r22, r22
    2780:	66 27       	eor	r22, r22
    2782:	66 1f       	adc	r22, r22
    2784:	8b e0       	ldi	r24, 0x0B	; 11
    2786:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(EN,STD_HIGH);
    278a:	82 e0       	ldi	r24, 0x02	; 2
    278c:	61 e0       	ldi	r22, 0x01	; 1
    278e:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    2792:	0f 2e       	mov	r0, r31
    2794:	f0 ea       	ldi	r31, 0xA0	; 160
    2796:	ef 2e       	mov	r14, r31
    2798:	ff e0       	ldi	r31, 0x0F	; 15
    279a:	ff 2e       	mov	r15, r31
    279c:	f0 2d       	mov	r31, r0
    279e:	c7 01       	movw	r24, r14
    27a0:	01 97       	sbiw	r24, 0x01	; 1
    27a2:	f1 f7       	brne	.-4      	; 0x27a0 <LCD4_Command_Write+0x64>
	_delay_ms(1);
	Dio_WriteChannel(EN,STD_LOW);
    27a4:	82 e0       	ldi	r24, 0x02	; 2
    27a6:	60 e0       	ldi	r22, 0x00	; 0
    27a8:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    27ac:	c7 01       	movw	r24, r14
    27ae:	01 97       	sbiw	r24, 0x01	; 1
    27b0:	f1 f7       	brne	.-4      	; 0x27ae <LCD4_Command_Write+0x72>
	_delay_ms(1);

	Dio_WriteChannel(D4,GET_BIT(command,0));
    27b2:	61 2f       	mov	r22, r17
    27b4:	61 70       	andi	r22, 0x01	; 1
    27b6:	88 e0       	ldi	r24, 0x08	; 8
    27b8:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D5,GET_BIT(command,1));
    27bc:	61 2f       	mov	r22, r17
    27be:	66 95       	lsr	r22
    27c0:	61 70       	andi	r22, 0x01	; 1
    27c2:	89 e0       	ldi	r24, 0x09	; 9
    27c4:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D6,GET_BIT(command,2));
    27c8:	61 2f       	mov	r22, r17
    27ca:	66 95       	lsr	r22
    27cc:	66 95       	lsr	r22
    27ce:	61 70       	andi	r22, 0x01	; 1
    27d0:	8a e0       	ldi	r24, 0x0A	; 10
    27d2:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D7,GET_BIT(command,3));
    27d6:	16 95       	lsr	r17
    27d8:	16 95       	lsr	r17
    27da:	16 95       	lsr	r17
    27dc:	11 70       	andi	r17, 0x01	; 1
    27de:	8b e0       	ldi	r24, 0x0B	; 11
    27e0:	61 2f       	mov	r22, r17
    27e2:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(EN,STD_HIGH);
    27e6:	82 e0       	ldi	r24, 0x02	; 2
    27e8:	61 e0       	ldi	r22, 0x01	; 1
    27ea:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    27ee:	c7 01       	movw	r24, r14
    27f0:	01 97       	sbiw	r24, 0x01	; 1
    27f2:	f1 f7       	brne	.-4      	; 0x27f0 <LCD4_Command_Write+0xb4>
	_delay_ms(1);
	Dio_WriteChannel(EN,STD_LOW);
    27f4:	82 e0       	ldi	r24, 0x02	; 2
    27f6:	60 e0       	ldi	r22, 0x00	; 0
    27f8:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    27fc:	c7 01       	movw	r24, r14
    27fe:	01 97       	sbiw	r24, 0x01	; 1
    2800:	f1 f7       	brne	.-4      	; 0x27fe <LCD4_Command_Write+0xc2>
	_delay_ms(1);
}
    2802:	1f 91       	pop	r17
    2804:	ff 90       	pop	r15
    2806:	ef 90       	pop	r14
    2808:	08 95       	ret

0000280a <lcd4_set_cursor>:
	}
	lcd4_disply_char_at_X_Y(MemPos, row, col);
}

void lcd4_set_cursor(u8 row, u8 coul){
    coul--;
    280a:	61 50       	subi	r22, 0x01	; 1
    switch (row){
    280c:	82 30       	cpi	r24, 0x02	; 2
    280e:	89 f0       	breq	.+34     	; 0x2832 <lcd4_set_cursor+0x28>
    2810:	83 30       	cpi	r24, 0x03	; 3
    2812:	18 f4       	brcc	.+6      	; 0x281a <lcd4_set_cursor+0x10>
    2814:	81 30       	cpi	r24, 0x01	; 1
    2816:	21 f5       	brne	.+72     	; 0x2860 <lcd4_set_cursor+0x56>
    2818:	05 c0       	rjmp	.+10     	; 0x2824 <lcd4_set_cursor+0x1a>
    281a:	83 30       	cpi	r24, 0x03	; 3
    281c:	91 f0       	breq	.+36     	; 0x2842 <lcd4_set_cursor+0x38>
    281e:	84 30       	cpi	r24, 0x04	; 4
    2820:	f9 f4       	brne	.+62     	; 0x2860 <lcd4_set_cursor+0x56>
    2822:	17 c0       	rjmp	.+46     	; 0x2852 <lcd4_set_cursor+0x48>
        case ROW1:
            LCD4_Command_Write(0x80+coul);
    2824:	86 2f       	mov	r24, r22
    2826:	80 58       	subi	r24, 0x80	; 128
    2828:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
            current_pos = 0;
    282c:	10 92 d6 01 	sts	0x01D6, r1
    2830:	08 95       	ret
        break;
        case ROW2:
            LCD4_Command_Write(0xC0+coul);
    2832:	86 2f       	mov	r24, r22
    2834:	80 54       	subi	r24, 0x40	; 64
    2836:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
            current_pos = 20;
    283a:	84 e1       	ldi	r24, 0x14	; 20
    283c:	80 93 d6 01 	sts	0x01D6, r24
    2840:	08 95       	ret
        break;
        case ROW3:
            LCD4_Command_Write(0x94+coul);
    2842:	86 2f       	mov	r24, r22
    2844:	8c 56       	subi	r24, 0x6C	; 108
    2846:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
            current_pos = 40;
    284a:	88 e2       	ldi	r24, 0x28	; 40
    284c:	80 93 d6 01 	sts	0x01D6, r24
    2850:	08 95       	ret
        break;
        case ROW4:
            LCD4_Command_Write(0xD4+coul);
    2852:	86 2f       	mov	r24, r22
    2854:	8c 52       	subi	r24, 0x2C	; 44
    2856:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
            current_pos = 60;
    285a:	8c e3       	ldi	r24, 0x3C	; 60
    285c:	80 93 d6 01 	sts	0x01D6, r24
    2860:	08 95       	ret

00002862 <lcd4_CLR>:
 * @param	void
 * @return	void
 */
void lcd4_CLR(void)
{
	LCD4_Command_Write(0x01);
    2862:	81 e0       	ldi	r24, 0x01	; 1
    2864:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
	current_pos = 0;
    2868:	10 92 d6 01 	sts	0x01D6, r1
}
    286c:	08 95       	ret

0000286e <lcd4_Init>:
 * lcd4_Init : This function initializes the LCD 4bit
 * @param	void
 * @return	void
 */
void lcd4_Init(void)
{
    286e:	0f 93       	push	r16
    2870:	1f 93       	push	r17
    2872:	24 ef       	ldi	r18, 0xF4	; 244
    2874:	31 e0       	ldi	r19, 0x01	; 1
    2876:	40 e9       	ldi	r20, 0x90	; 144
    2878:	51 e0       	ldi	r21, 0x01	; 1
    287a:	ca 01       	movw	r24, r20
    287c:	01 97       	sbiw	r24, 0x01	; 1
    287e:	f1 f7       	brne	.-4      	; 0x287c <lcd4_Init+0xe>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2880:	21 50       	subi	r18, 0x01	; 1
    2882:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2884:	d1 f7       	brne	.-12     	; 0x287a <lcd4_Init+0xc>
	_delay_ms(50);
	LCD4_Command_Write(LCD_CURSOR_HOME);
    2886:	82 e0       	ldi	r24, 0x02	; 2
    2888:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
	LCD4_Command_Write(LCD_FUNCTION_SET_4_BIT_2_LINE_8_DOTS);	//LCD 4bit mode, 2 line
    288c:	88 e2       	ldi	r24, 0x28	; 40
    288e:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
    2892:	00 ea       	ldi	r16, 0xA0	; 160
    2894:	1f e0       	ldi	r17, 0x0F	; 15
    2896:	c8 01       	movw	r24, r16
    2898:	01 97       	sbiw	r24, 0x01	; 1
    289a:	f1 f7       	brne	.-4      	; 0x2898 <lcd4_Init+0x2a>
	_delay_ms(1);
	LCD4_Command_Write(LCD_DISPLAY_ON_UNDER_LINE_CURSOR_ON_BLOCK_CURSOR_ON); //cursor on off,blink  0x0f,0x0c,0x0e
    289c:	8f e0       	ldi	r24, 0x0F	; 15
    289e:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
    28a2:	c8 01       	movw	r24, r16
    28a4:	01 97       	sbiw	r24, 0x01	; 1
    28a6:	f1 f7       	brne	.-4      	; 0x28a4 <lcd4_Init+0x36>
	_delay_ms(1);
	LCD4_Command_Write(LCD_CLEAR_COMMAND); //clear screen
    28a8:	81 e0       	ldi	r24, 0x01	; 1
    28aa:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
    28ae:	80 e4       	ldi	r24, 0x40	; 64
    28b0:	9f e1       	ldi	r25, 0x1F	; 31
    28b2:	01 97       	sbiw	r24, 0x01	; 1
    28b4:	f1 f7       	brne	.-4      	; 0x28b2 <lcd4_Init+0x44>
	_delay_ms(2);
	LCD4_Command_Write(LCD_ENTRY_MODE_INC_SHIFT_OFF);	//increase DDRAM address
    28b6:	86 e0       	ldi	r24, 0x06	; 6
    28b8:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
    28bc:	c8 01       	movw	r24, r16
    28be:	01 97       	sbiw	r24, 0x01	; 1
    28c0:	f1 f7       	brne	.-4      	; 0x28be <lcd4_Init+0x50>
	_delay_ms(1);

	LCD4_Command_Write(LCD_DISPLAY_ON_UNDER_LINE_CURSOR_OFF_BLOCK_CURSOR_OFF);
    28c2:	8c e0       	ldi	r24, 0x0C	; 12
    28c4:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
	LCD4_Command_Write(LCD_DDRAM_START);
    28c8:	80 e8       	ldi	r24, 0x80	; 128
    28ca:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
}
    28ce:	1f 91       	pop	r17
    28d0:	0f 91       	pop	r16
    28d2:	08 95       	ret

000028d4 <LCD_Data_write>:
    }
}
/* ----------------- Section : Static "Private" Functions Declaration Implementation -----------------*/

static void LCD_Data_write(u8 data)
{
    28d4:	ef 92       	push	r14
    28d6:	ff 92       	push	r15
    28d8:	1f 93       	push	r17
    28da:	18 2f       	mov	r17, r24
	Dio_WriteChannel(RS,STD_HIGH);
    28dc:	83 e0       	ldi	r24, 0x03	; 3
    28de:	61 e0       	ldi	r22, 0x01	; 1
    28e0:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>

	Dio_WriteChannel(D4,GET_BIT(data,4));
    28e4:	61 2f       	mov	r22, r17
    28e6:	62 95       	swap	r22
    28e8:	6f 70       	andi	r22, 0x0F	; 15
    28ea:	61 70       	andi	r22, 0x01	; 1
    28ec:	88 e0       	ldi	r24, 0x08	; 8
    28ee:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D5,GET_BIT(data,5));
    28f2:	61 2f       	mov	r22, r17
    28f4:	62 95       	swap	r22
    28f6:	66 95       	lsr	r22
    28f8:	67 70       	andi	r22, 0x07	; 7
    28fa:	61 70       	andi	r22, 0x01	; 1
    28fc:	89 e0       	ldi	r24, 0x09	; 9
    28fe:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D6,GET_BIT(data,6));
    2902:	61 2f       	mov	r22, r17
    2904:	62 95       	swap	r22
    2906:	66 95       	lsr	r22
    2908:	66 95       	lsr	r22
    290a:	63 70       	andi	r22, 0x03	; 3
    290c:	61 70       	andi	r22, 0x01	; 1
    290e:	8a e0       	ldi	r24, 0x0A	; 10
    2910:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D7,GET_BIT(data,7));
    2914:	61 2f       	mov	r22, r17
    2916:	66 1f       	adc	r22, r22
    2918:	66 27       	eor	r22, r22
    291a:	66 1f       	adc	r22, r22
    291c:	8b e0       	ldi	r24, 0x0B	; 11
    291e:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(EN,STD_HIGH);
    2922:	82 e0       	ldi	r24, 0x02	; 2
    2924:	61 e0       	ldi	r22, 0x01	; 1
    2926:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    292a:	0f 2e       	mov	r0, r31
    292c:	f0 ea       	ldi	r31, 0xA0	; 160
    292e:	ef 2e       	mov	r14, r31
    2930:	ff e0       	ldi	r31, 0x0F	; 15
    2932:	ff 2e       	mov	r15, r31
    2934:	f0 2d       	mov	r31, r0
    2936:	c7 01       	movw	r24, r14
    2938:	01 97       	sbiw	r24, 0x01	; 1
    293a:	f1 f7       	brne	.-4      	; 0x2938 <LCD_Data_write+0x64>
	_delay_ms(1);
	Dio_WriteChannel(EN,STD_LOW);
    293c:	82 e0       	ldi	r24, 0x02	; 2
    293e:	60 e0       	ldi	r22, 0x00	; 0
    2940:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    2944:	c7 01       	movw	r24, r14
    2946:	01 97       	sbiw	r24, 0x01	; 1
    2948:	f1 f7       	brne	.-4      	; 0x2946 <LCD_Data_write+0x72>
	_delay_ms(1);

	Dio_WriteChannel(D4,GET_BIT(data,0));
    294a:	61 2f       	mov	r22, r17
    294c:	61 70       	andi	r22, 0x01	; 1
    294e:	88 e0       	ldi	r24, 0x08	; 8
    2950:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D5,GET_BIT(data,1));
    2954:	61 2f       	mov	r22, r17
    2956:	66 95       	lsr	r22
    2958:	61 70       	andi	r22, 0x01	; 1
    295a:	89 e0       	ldi	r24, 0x09	; 9
    295c:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D6,GET_BIT(data,2));
    2960:	61 2f       	mov	r22, r17
    2962:	66 95       	lsr	r22
    2964:	66 95       	lsr	r22
    2966:	61 70       	andi	r22, 0x01	; 1
    2968:	8a e0       	ldi	r24, 0x0A	; 10
    296a:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(D7,GET_BIT(data,3));
    296e:	16 95       	lsr	r17
    2970:	16 95       	lsr	r17
    2972:	16 95       	lsr	r17
    2974:	11 70       	andi	r17, 0x01	; 1
    2976:	8b e0       	ldi	r24, 0x0B	; 11
    2978:	61 2f       	mov	r22, r17
    297a:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(EN,STD_HIGH);
    297e:	82 e0       	ldi	r24, 0x02	; 2
    2980:	61 e0       	ldi	r22, 0x01	; 1
    2982:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    2986:	c7 01       	movw	r24, r14
    2988:	01 97       	sbiw	r24, 0x01	; 1
    298a:	f1 f7       	brne	.-4      	; 0x2988 <LCD_Data_write+0xb4>
	_delay_ms(1);
	Dio_WriteChannel(EN,STD_LOW);
    298c:	82 e0       	ldi	r24, 0x02	; 2
    298e:	60 e0       	ldi	r22, 0x00	; 0
    2990:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    2994:	c7 01       	movw	r24, r14
    2996:	01 97       	sbiw	r24, 0x01	; 1
    2998:	f1 f7       	brne	.-4      	; 0x2996 <LCD_Data_write+0xc2>
	_delay_ms(1);
}
    299a:	1f 91       	pop	r17
    299c:	ff 90       	pop	r15
    299e:	ef 90       	pop	r14
    29a0:	08 95       	ret

000029a2 <lcd4_disply_char_at_X_Y>:
 * 			3- col : the Column position of the character
 * 			Ex ('A', 2, 3) -> will display A @ [2,3]
 * @return	void
 */
void lcd4_disply_char_at_X_Y (u8 data, u8 row, u8 col)
{
    29a2:	1f 93       	push	r17
    29a4:	18 2f       	mov	r17, r24
    29a6:	86 2f       	mov	r24, r22
	lcd4_set_cursor(row, col);
    29a8:	64 2f       	mov	r22, r20
    29aa:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
	LCD_Data_write(data);
    29ae:	81 2f       	mov	r24, r17
    29b0:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <LCD_Data_write>
}
    29b4:	1f 91       	pop	r17
    29b6:	08 95       	ret

000029b8 <lcd4_disply_CustomCharacter>:
 * 			Ex: u8 customChar[] = {0x0E, 0x1B, 0x1F, 0x1F, 0x1F, 0x1F, 0x1B, 0x0E};
 * 				lcd4_disply_CustomCharacter(1, 5, customChar, 0);
 * @return	void
 */
void lcd4_disply_CustomCharacter(u8 row, u8 col, u8* CustomCharacter, u8 MemPos)
{
    29b8:	df 92       	push	r13
    29ba:	ef 92       	push	r14
    29bc:	ff 92       	push	r15
    29be:	0f 93       	push	r16
    29c0:	1f 93       	push	r17
    29c2:	cf 93       	push	r28
    29c4:	df 93       	push	r29
    29c6:	e8 2e       	mov	r14, r24
    29c8:	d6 2e       	mov	r13, r22
    29ca:	8a 01       	movw	r16, r20
    29cc:	f2 2e       	mov	r15, r18
	LCD4_Command_Write(LCD_CGRAM_START + (MemPos * 8));
    29ce:	82 2f       	mov	r24, r18
    29d0:	88 0f       	add	r24, r24
    29d2:	88 0f       	add	r24, r24
    29d4:	88 0f       	add	r24, r24
    29d6:	80 5c       	subi	r24, 0xC0	; 192
    29d8:	0e 94 9e 13 	call	0x273c	; 0x273c <LCD4_Command_Write>
    29dc:	c0 e0       	ldi	r28, 0x00	; 0
    29de:	d0 e0       	ldi	r29, 0x00	; 0
	for(int i = 0 ; i < 8 ; i++)
	{
		LCD_Data_write(CustomCharacter[i]);
    29e0:	f8 01       	movw	r30, r16
    29e2:	ec 0f       	add	r30, r28
    29e4:	fd 1f       	adc	r31, r29
    29e6:	80 81       	ld	r24, Z
    29e8:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <LCD_Data_write>
 * @return	void
 */
void lcd4_disply_CustomCharacter(u8 row, u8 col, u8* CustomCharacter, u8 MemPos)
{
	LCD4_Command_Write(LCD_CGRAM_START + (MemPos * 8));
	for(int i = 0 ; i < 8 ; i++)
    29ec:	21 96       	adiw	r28, 0x01	; 1
    29ee:	c8 30       	cpi	r28, 0x08	; 8
    29f0:	d1 05       	cpc	r29, r1
    29f2:	b1 f7       	brne	.-20     	; 0x29e0 <lcd4_disply_CustomCharacter+0x28>
	{
		LCD_Data_write(CustomCharacter[i]);
	}
	lcd4_disply_char_at_X_Y(MemPos, row, col);
    29f4:	8f 2d       	mov	r24, r15
    29f6:	6e 2d       	mov	r22, r14
    29f8:	4d 2d       	mov	r20, r13
    29fa:	0e 94 d1 14 	call	0x29a2	; 0x29a2 <lcd4_disply_char_at_X_Y>
}
    29fe:	df 91       	pop	r29
    2a00:	cf 91       	pop	r28
    2a02:	1f 91       	pop	r17
    2a04:	0f 91       	pop	r16
    2a06:	ff 90       	pop	r15
    2a08:	ef 90       	pop	r14
    2a0a:	df 90       	pop	r13
    2a0c:	08 95       	ret

00002a0e <lcd4_disply_char>:
 * lcd4_disply_char : This function displays a character on the LCD 4bit
 * @param	data which is the character to display Ex: 'A'
 * @return	void
 */
void lcd4_disply_char (const u8 character)
{
    2a0e:	1f 93       	push	r17
    2a10:	18 2f       	mov	r17, r24
	if(current_pos == 20 )
    2a12:	80 91 d6 01 	lds	r24, 0x01D6
    2a16:	84 31       	cpi	r24, 0x14	; 20
    2a18:	29 f4       	brne	.+10     	; 0x2a24 <lcd4_disply_char+0x16>
	{
		lcd4_set_cursor(2, 1);
    2a1a:	82 e0       	ldi	r24, 0x02	; 2
    2a1c:	61 e0       	ldi	r22, 0x01	; 1
    2a1e:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
    2a22:	16 c0       	rjmp	.+44     	; 0x2a50 <lcd4_disply_char+0x42>
	}
	else if(current_pos == 40 )
    2a24:	88 32       	cpi	r24, 0x28	; 40
    2a26:	29 f4       	brne	.+10     	; 0x2a32 <lcd4_disply_char+0x24>
	{
		lcd4_set_cursor(3, 1);
    2a28:	83 e0       	ldi	r24, 0x03	; 3
    2a2a:	61 e0       	ldi	r22, 0x01	; 1
    2a2c:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
    2a30:	0f c0       	rjmp	.+30     	; 0x2a50 <lcd4_disply_char+0x42>
	}
	else if(current_pos == 60 )
    2a32:	8c 33       	cpi	r24, 0x3C	; 60
    2a34:	29 f4       	brne	.+10     	; 0x2a40 <lcd4_disply_char+0x32>
	{
		lcd4_set_cursor(4, 1);
    2a36:	84 e0       	ldi	r24, 0x04	; 4
    2a38:	61 e0       	ldi	r22, 0x01	; 1
    2a3a:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
    2a3e:	08 c0       	rjmp	.+16     	; 0x2a50 <lcd4_disply_char+0x42>
	}
	else if (current_pos == 80)
    2a40:	80 35       	cpi	r24, 0x50	; 80
    2a42:	31 f4       	brne	.+12     	; 0x2a50 <lcd4_disply_char+0x42>
	{
		lcd4_set_cursor(1, 1);
    2a44:	81 e0       	ldi	r24, 0x01	; 1
    2a46:	61 e0       	ldi	r22, 0x01	; 1
    2a48:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
		current_pos = 0;
    2a4c:	10 92 d6 01 	sts	0x01D6, r1
	}
	LCD_Data_write(character);
    2a50:	81 2f       	mov	r24, r17
    2a52:	0e 94 6a 14 	call	0x28d4	; 0x28d4 <LCD_Data_write>
	current_pos ++;
    2a56:	80 91 d6 01 	lds	r24, 0x01D6
    2a5a:	8f 5f       	subi	r24, 0xFF	; 255
    2a5c:	80 93 d6 01 	sts	0x01D6, r24
}
    2a60:	1f 91       	pop	r17
    2a62:	08 95       	ret

00002a64 <displayTextAnimated>:
        default:
        	break;
    }
}

void displayTextAnimated(const char *text) {
    2a64:	cf 92       	push	r12
    2a66:	df 92       	push	r13
    2a68:	ef 92       	push	r14
    2a6a:	ff 92       	push	r15
    2a6c:	0f 93       	push	r16
    2a6e:	1f 93       	push	r17
    2a70:	cf 93       	push	r28
    2a72:	df 93       	push	r29
    2a74:	fc 01       	movw	r30, r24
    for (int i = 0; text[i] != '\0'; i++) {
    2a76:	20 81       	ld	r18, Z
    2a78:	22 23       	and	r18, r18
    2a7a:	e9 f0       	breq	.+58     	; 0x2ab6 <displayTextAnimated+0x52>
    2a7c:	7c 01       	movw	r14, r24
        lcd4_disply_char(text[i]);
    2a7e:	0f 2e       	mov	r0, r31
    2a80:	f4 ef       	ldi	r31, 0xF4	; 244
    2a82:	cf 2e       	mov	r12, r31
    2a84:	f1 e0       	ldi	r31, 0x01	; 1
    2a86:	df 2e       	mov	r13, r31
    2a88:	f0 2d       	mov	r31, r0
    2a8a:	c0 e9       	ldi	r28, 0x90	; 144
    2a8c:	d1 e0       	ldi	r29, 0x01	; 1
    2a8e:	ce 01       	movw	r24, r28
    2a90:	0c 2f       	mov	r16, r28
    2a92:	19 2f       	mov	r17, r25
    2a94:	82 2f       	mov	r24, r18
    2a96:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <lcd4_disply_char>
    2a9a:	96 01       	movw	r18, r12
    2a9c:	ce 01       	movw	r24, r28
    2a9e:	01 97       	sbiw	r24, 0x01	; 1
    2aa0:	f1 f7       	brne	.-4      	; 0x2a9e <displayTextAnimated+0x3a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2aa2:	21 50       	subi	r18, 0x01	; 1
    2aa4:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2aa6:	d1 f7       	brne	.-12     	; 0x2a9c <displayTextAnimated+0x38>
        	break;
    }
}

void displayTextAnimated(const char *text) {
    for (int i = 0; text[i] != '\0'; i++) {
    2aa8:	f7 01       	movw	r30, r14
    2aaa:	21 81       	ldd	r18, Z+1	; 0x01
    2aac:	08 94       	sec
    2aae:	e1 1c       	adc	r14, r1
    2ab0:	f1 1c       	adc	r15, r1
    2ab2:	22 23       	and	r18, r18
    2ab4:	79 f7       	brne	.-34     	; 0x2a94 <displayTextAnimated+0x30>
        lcd4_disply_char(text[i]);
        _delay_ms(50); // Adjust the delay as needed
    }
}
    2ab6:	df 91       	pop	r29
    2ab8:	cf 91       	pop	r28
    2aba:	1f 91       	pop	r17
    2abc:	0f 91       	pop	r16
    2abe:	ff 90       	pop	r15
    2ac0:	ef 90       	pop	r14
    2ac2:	df 90       	pop	r13
    2ac4:	cf 90       	pop	r12
    2ac6:	08 95       	ret

00002ac8 <lcd4_disply_string>:
 * lcd4_disply_string : This function displays whole string on the LCD 4bit
 * @param	data which is the string to display Ex: "Mahmoud El Arabi"
 * @return	void
 */
void lcd4_disply_string (const u8* str)
{
    2ac8:	cf 93       	push	r28
    2aca:	df 93       	push	r29
    2acc:	ec 01       	movw	r28, r24
	 while (*str){
    2ace:	88 81       	ld	r24, Y
    2ad0:	88 23       	and	r24, r24
    2ad2:	31 f0       	breq	.+12     	; 0x2ae0 <lcd4_disply_string+0x18>
	lcd4_disply_char(*str);
    2ad4:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <lcd4_disply_char>
	str++;
    2ad8:	21 96       	adiw	r28, 0x01	; 1
 * @param	data which is the string to display Ex: "Mahmoud El Arabi"
 * @return	void
 */
void lcd4_disply_string (const u8* str)
{
	 while (*str){
    2ada:	88 81       	ld	r24, Y
    2adc:	88 23       	and	r24, r24
    2ade:	d1 f7       	brne	.-12     	; 0x2ad4 <lcd4_disply_string+0xc>
	lcd4_disply_char(*str);
	str++;
	}
}
    2ae0:	df 91       	pop	r29
    2ae2:	cf 91       	pop	r28
    2ae4:	08 95       	ret

00002ae6 <lcd4_disply_string_at_X_Y>:
 * 			3- col : the Column position of the 1st character of the string which is 'M' here
 * 			Ex ("Mahmoud El Arabi", 2, 3) -> will display "Mahmoud El Arabi" @ [2,3]
 * @return	void
 */
void lcd4_disply_string_at_X_Y(u8* data, u8 row, u8 col)
{
    2ae6:	0f 93       	push	r16
    2ae8:	1f 93       	push	r17
    2aea:	8c 01       	movw	r16, r24
    2aec:	86 2f       	mov	r24, r22
	lcd4_set_cursor(row, col);
    2aee:	64 2f       	mov	r22, r20
    2af0:	0e 94 05 14 	call	0x280a	; 0x280a <lcd4_set_cursor>
	lcd4_disply_string(data);
    2af4:	c8 01       	movw	r24, r16
    2af6:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <lcd4_disply_string>
}
    2afa:	1f 91       	pop	r17
    2afc:	0f 91       	pop	r16
    2afe:	08 95       	ret

00002b00 <lcd4_disply_num>:
/**
 * lcd4_disply_num : This function converts the nu,ber to string and displays it on the LCD 4bit
 * @param	num which is the number to display
 * @return	void
 */
void lcd4_disply_num(u16 num) {
    2b00:	0f 93       	push	r16
    2b02:	1f 93       	push	r17
    2b04:	df 93       	push	r29
    2b06:	cf 93       	push	r28
    2b08:	cd b7       	in	r28, 0x3d	; 61
    2b0a:	de b7       	in	r29, 0x3e	; 62
    2b0c:	27 97       	sbiw	r28, 0x07	; 7
    2b0e:	0f b6       	in	r0, 0x3f	; 63
    2b10:	f8 94       	cli
    2b12:	de bf       	out	0x3e, r29	; 62
    2b14:	0f be       	out	0x3f, r0	; 63
    2b16:	cd bf       	out	0x3d, r28	; 61
    char num_str[7];  // Assuming a 7-character buffer is sufficient
    snprintf(num_str, sizeof(num_str), "%d", num);
    2b18:	2d b7       	in	r18, 0x3d	; 61
    2b1a:	3e b7       	in	r19, 0x3e	; 62
    2b1c:	28 50       	subi	r18, 0x08	; 8
    2b1e:	30 40       	sbci	r19, 0x00	; 0
    2b20:	0f b6       	in	r0, 0x3f	; 63
    2b22:	f8 94       	cli
    2b24:	3e bf       	out	0x3e, r19	; 62
    2b26:	0f be       	out	0x3f, r0	; 63
    2b28:	2d bf       	out	0x3d, r18	; 61
    2b2a:	ed b7       	in	r30, 0x3d	; 61
    2b2c:	fe b7       	in	r31, 0x3e	; 62
    2b2e:	31 96       	adiw	r30, 0x01	; 1
    2b30:	9e 01       	movw	r18, r28
    2b32:	2f 5f       	subi	r18, 0xFF	; 255
    2b34:	3f 4f       	sbci	r19, 0xFF	; 255
    2b36:	31 83       	std	Z+1, r19	; 0x01
    2b38:	20 83       	st	Z, r18
    2b3a:	27 e0       	ldi	r18, 0x07	; 7
    2b3c:	30 e0       	ldi	r19, 0x00	; 0
    2b3e:	33 83       	std	Z+3, r19	; 0x03
    2b40:	22 83       	std	Z+2, r18	; 0x02
    2b42:	20 e6       	ldi	r18, 0x60	; 96
    2b44:	30 e0       	ldi	r19, 0x00	; 0
    2b46:	35 83       	std	Z+5, r19	; 0x05
    2b48:	24 83       	std	Z+4, r18	; 0x04
    2b4a:	97 83       	std	Z+7, r25	; 0x07
    2b4c:	86 83       	std	Z+6, r24	; 0x06
    2b4e:	0e 94 bc 32 	call	0x6578	; 0x6578 <snprintf>

    // Display the string on the LCD character by character
    for (int i = 0; num_str[i] != '\0'; i++) {
    2b52:	89 81       	ldd	r24, Y+1	; 0x01
    2b54:	ed b7       	in	r30, 0x3d	; 61
    2b56:	fe b7       	in	r31, 0x3e	; 62
    2b58:	38 96       	adiw	r30, 0x08	; 8
    2b5a:	0f b6       	in	r0, 0x3f	; 63
    2b5c:	f8 94       	cli
    2b5e:	fe bf       	out	0x3e, r31	; 62
    2b60:	0f be       	out	0x3f, r0	; 63
    2b62:	ed bf       	out	0x3d, r30	; 61
    2b64:	88 23       	and	r24, r24
    2b66:	51 f0       	breq	.+20     	; 0x2b7c <lcd4_disply_num+0x7c>
    2b68:	8e 01       	movw	r16, r28
    2b6a:	0e 5f       	subi	r16, 0xFE	; 254
    2b6c:	1f 4f       	sbci	r17, 0xFF	; 255
        lcd4_disply_char(num_str[i]);
    2b6e:	0e 94 07 15 	call	0x2a0e	; 0x2a0e <lcd4_disply_char>
void lcd4_disply_num(u16 num) {
    char num_str[7];  // Assuming a 7-character buffer is sufficient
    snprintf(num_str, sizeof(num_str), "%d", num);

    // Display the string on the LCD character by character
    for (int i = 0; num_str[i] != '\0'; i++) {
    2b72:	f8 01       	movw	r30, r16
    2b74:	81 91       	ld	r24, Z+
    2b76:	8f 01       	movw	r16, r30
    2b78:	88 23       	and	r24, r24
    2b7a:	c9 f7       	brne	.-14     	; 0x2b6e <lcd4_disply_num+0x6e>
        lcd4_disply_char(num_str[i]);
    }
}
    2b7c:	27 96       	adiw	r28, 0x07	; 7
    2b7e:	0f b6       	in	r0, 0x3f	; 63
    2b80:	f8 94       	cli
    2b82:	de bf       	out	0x3e, r29	; 62
    2b84:	0f be       	out	0x3f, r0	; 63
    2b86:	cd bf       	out	0x3d, r28	; 61
    2b88:	cf 91       	pop	r28
    2b8a:	df 91       	pop	r29
    2b8c:	1f 91       	pop	r17
    2b8e:	0f 91       	pop	r16
    2b90:	08 95       	ret

00002b92 <Keypad_Init>:
														{'1','2','3','-'},
														{'#','0','=','+'}};

void Keypad_Init(void)
{
	Dio_WriteChannel(R1, 1);
    2b92:	80 e1       	ldi	r24, 0x10	; 16
    2b94:	61 e0       	ldi	r22, 0x01	; 1
    2b96:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(R2, 1);
    2b9a:	81 e1       	ldi	r24, 0x11	; 17
    2b9c:	61 e0       	ldi	r22, 0x01	; 1
    2b9e:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(R3, 1);
    2ba2:	82 e1       	ldi	r24, 0x12	; 18
    2ba4:	61 e0       	ldi	r22, 0x01	; 1
    2ba6:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(R4, 1);
    2baa:	83 e1       	ldi	r24, 0x13	; 19
    2bac:	61 e0       	ldi	r22, 0x01	; 1
    2bae:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
}
    2bb2:	08 95       	ret

00002bb4 <Keypad_Get_value>:

void Keypad_Get_value(u8 *value) {
    2bb4:	4f 92       	push	r4
    2bb6:	5f 92       	push	r5
    2bb8:	7f 92       	push	r7
    2bba:	8f 92       	push	r8
    2bbc:	9f 92       	push	r9
    2bbe:	af 92       	push	r10
    2bc0:	bf 92       	push	r11
    2bc2:	cf 92       	push	r12
    2bc4:	df 92       	push	r13
    2bc6:	ef 92       	push	r14
    2bc8:	ff 92       	push	r15
    2bca:	0f 93       	push	r16
    2bcc:	1f 93       	push	r17
    2bce:	df 93       	push	r29
    2bd0:	cf 93       	push	r28
    2bd2:	00 d0       	rcall	.+0      	; 0x2bd4 <Keypad_Get_value+0x20>
    2bd4:	00 d0       	rcall	.+0      	; 0x2bd6 <Keypad_Get_value+0x22>
    2bd6:	cd b7       	in	r28, 0x3d	; 61
    2bd8:	de b7       	in	r29, 0x3e	; 62
    2bda:	2c 01       	movw	r4, r24
    u8 rows[keypad_rows] = {R1, R2, R3, R4};
    2bdc:	80 e1       	ldi	r24, 0x10	; 16
    2bde:	89 83       	std	Y+1, r24	; 0x01
    2be0:	81 e1       	ldi	r24, 0x11	; 17
    2be2:	8a 83       	std	Y+2, r24	; 0x02
    2be4:	82 e1       	ldi	r24, 0x12	; 18
    2be6:	8b 83       	std	Y+3, r24	; 0x03
    2be8:	83 e1       	ldi	r24, 0x13	; 19
    2bea:	8c 83       	std	Y+4, r24	; 0x04
    u8 columns[keypad_coul] = {C1, C2, C3, C4};
    2bec:	00 e0       	ldi	r16, 0x00	; 0
    2bee:	10 e0       	ldi	r17, 0x00	; 0

    // Loop through rows and columns to scan for a pressed key
    u8 row, col;
    for (row = 0; row < keypad_rows; row++) {
        Dio_WriteChannel(rows[row], STD_LOW);
    2bf0:	5e 01       	movw	r10, r28
    2bf2:	08 94       	sec
    2bf4:	a1 1c       	adc	r10, r1
    2bf6:	b1 1c       	adc	r11, r1
        for (col = 0; col < keypad_coul; col++) {
            if (Dio_ReadChannel(columns[col]) == STD_LOW) {
    2bf8:	0f 2e       	mov	r0, r31
    2bfa:	f4 e1       	ldi	r31, 0x14	; 20
    2bfc:	9f 2e       	mov	r9, r31
    2bfe:	f0 2d       	mov	r31, r0
    2c00:	0f 2e       	mov	r0, r31
    2c02:	f5 e1       	ldi	r31, 0x15	; 21
    2c04:	8f 2e       	mov	r8, r31
    2c06:	f0 2d       	mov	r31, r0
    2c08:	0f 2e       	mov	r0, r31
    2c0a:	f6 e1       	ldi	r31, 0x16	; 22
    2c0c:	7f 2e       	mov	r7, r31
    2c0e:	f0 2d       	mov	r31, r0
	Dio_WriteChannel(R4, 1);
}

void Keypad_Get_value(u8 *value) {
    u8 rows[keypad_rows] = {R1, R2, R3, R4};
    u8 columns[keypad_coul] = {C1, C2, C3, C4};
    2c10:	68 01       	movw	r12, r16

    // Loop through rows and columns to scan for a pressed key
    u8 row, col;
    for (row = 0; row < keypad_rows; row++) {
        Dio_WriteChannel(rows[row], STD_LOW);
    2c12:	f5 01       	movw	r30, r10
    2c14:	e0 0f       	add	r30, r16
    2c16:	f1 1f       	adc	r31, r17
    2c18:	e0 80       	ld	r14, Z
    2c1a:	8e 2d       	mov	r24, r14
    2c1c:	60 e0       	ldi	r22, 0x00	; 0
    2c1e:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
        for (col = 0; col < keypad_coul; col++) {
            if (Dio_ReadChannel(columns[col]) == STD_LOW) {
    2c22:	f9 2c       	mov	r15, r9
    2c24:	89 2d       	mov	r24, r9
    2c26:	0e 94 c2 10 	call	0x2184	; 0x2184 <Dio_ReadChannel>
    2c2a:	88 23       	and	r24, r24
    2c2c:	19 f4       	brne	.+6      	; 0x2c34 <Keypad_Get_value+0x80>
    2c2e:	80 e0       	ldi	r24, 0x00	; 0
    2c30:	90 e0       	ldi	r25, 0x00	; 0
    2c32:	1d c0       	rjmp	.+58     	; 0x2c6e <Keypad_Get_value+0xba>
    2c34:	f8 2c       	mov	r15, r8
    2c36:	88 2d       	mov	r24, r8
    2c38:	0e 94 c2 10 	call	0x2184	; 0x2184 <Dio_ReadChannel>
    2c3c:	88 23       	and	r24, r24
    2c3e:	19 f4       	brne	.+6      	; 0x2c46 <Keypad_Get_value+0x92>
    2c40:	81 e0       	ldi	r24, 0x01	; 1
    2c42:	90 e0       	ldi	r25, 0x00	; 0
    2c44:	14 c0       	rjmp	.+40     	; 0x2c6e <Keypad_Get_value+0xba>
    2c46:	f7 2c       	mov	r15, r7
    2c48:	87 2d       	mov	r24, r7
    2c4a:	0e 94 c2 10 	call	0x2184	; 0x2184 <Dio_ReadChannel>
    2c4e:	88 23       	and	r24, r24
    2c50:	19 f4       	brne	.+6      	; 0x2c58 <Keypad_Get_value+0xa4>
    2c52:	82 e0       	ldi	r24, 0x02	; 2
    2c54:	90 e0       	ldi	r25, 0x00	; 0
    2c56:	0b c0       	rjmp	.+22     	; 0x2c6e <Keypad_Get_value+0xba>
    2c58:	87 e1       	ldi	r24, 0x17	; 23
    2c5a:	0e 94 c2 10 	call	0x2184	; 0x2184 <Dio_ReadChannel>
    2c5e:	88 23       	and	r24, r24
    2c60:	c1 f4       	brne	.+48     	; 0x2c92 <Keypad_Get_value+0xde>
    2c62:	83 e0       	ldi	r24, 0x03	; 3
    2c64:	90 e0       	ldi	r25, 0x00	; 0
    2c66:	0f 2e       	mov	r0, r31
    2c68:	f7 e1       	ldi	r31, 0x17	; 23
    2c6a:	ff 2e       	mov	r15, r31
    2c6c:	f0 2d       	mov	r31, r0
                *value = btn_values[row][col];
    2c6e:	f6 01       	movw	r30, r12
    2c70:	ee 0f       	add	r30, r30
    2c72:	ff 1f       	adc	r31, r31
    2c74:	ee 0f       	add	r30, r30
    2c76:	ff 1f       	adc	r31, r31
    2c78:	e8 0f       	add	r30, r24
    2c7a:	f9 1f       	adc	r31, r25
    2c7c:	ee 55       	subi	r30, 0x5E	; 94
    2c7e:	fe 4f       	sbci	r31, 0xFE	; 254
    2c80:	80 81       	ld	r24, Z
    2c82:	f2 01       	movw	r30, r4
    2c84:	80 83       	st	Z, r24
                while (Dio_ReadChannel(columns[col]) == STD_LOW);
    2c86:	8f 2d       	mov	r24, r15
    2c88:	0e 94 c2 10 	call	0x2184	; 0x2184 <Dio_ReadChannel>
    2c8c:	88 23       	and	r24, r24
    2c8e:	d9 f3       	breq	.-10     	; 0x2c86 <Keypad_Get_value+0xd2>
    2c90:	0d c0       	rjmp	.+26     	; 0x2cac <Keypad_Get_value+0xf8>
                return;
            }
        }
        Dio_WriteChannel(rows[row], STD_HIGH);
    2c92:	8e 2d       	mov	r24, r14
    2c94:	61 e0       	ldi	r22, 0x01	; 1
    2c96:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    2c9a:	0f 5f       	subi	r16, 0xFF	; 255
    2c9c:	1f 4f       	sbci	r17, 0xFF	; 255
    u8 rows[keypad_rows] = {R1, R2, R3, R4};
    u8 columns[keypad_coul] = {C1, C2, C3, C4};

    // Loop through rows and columns to scan for a pressed key
    u8 row, col;
    for (row = 0; row < keypad_rows; row++) {
    2c9e:	04 30       	cpi	r16, 0x04	; 4
    2ca0:	11 05       	cpc	r17, r1
    2ca2:	09 f0       	breq	.+2      	; 0x2ca6 <Keypad_Get_value+0xf2>
    2ca4:	b5 cf       	rjmp	.-150    	; 0x2c10 <Keypad_Get_value+0x5c>
                return;
            }
        }
        Dio_WriteChannel(rows[row], STD_HIGH);
    }
    *value = 'T';
    2ca6:	84 e5       	ldi	r24, 0x54	; 84
    2ca8:	f2 01       	movw	r30, r4
    2caa:	80 83       	st	Z, r24
}
    2cac:	0f 90       	pop	r0
    2cae:	0f 90       	pop	r0
    2cb0:	0f 90       	pop	r0
    2cb2:	0f 90       	pop	r0
    2cb4:	cf 91       	pop	r28
    2cb6:	df 91       	pop	r29
    2cb8:	1f 91       	pop	r17
    2cba:	0f 91       	pop	r16
    2cbc:	ff 90       	pop	r15
    2cbe:	ef 90       	pop	r14
    2cc0:	df 90       	pop	r13
    2cc2:	cf 90       	pop	r12
    2cc4:	bf 90       	pop	r11
    2cc6:	af 90       	pop	r10
    2cc8:	9f 90       	pop	r9
    2cca:	8f 90       	pop	r8
    2ccc:	7f 90       	pop	r7
    2cce:	5f 90       	pop	r5
    2cd0:	4f 90       	pop	r4
    2cd2:	08 95       	ret

00002cd4 <EEPROM_voidRead_Page>:
	TWI_voidSendStopCondition();
	_delay_ms(5);	// delay to eeprom to store the data
}

void EEPROM_voidRead_Page(u16 copy_u16WordAdd, u8 *copy_u8PtrReceivedData, u8 copy_u8Size)
{
    2cd4:	af 92       	push	r10
    2cd6:	bf 92       	push	r11
    2cd8:	cf 92       	push	r12
    2cda:	df 92       	push	r13
    2cdc:	ef 92       	push	r14
    2cde:	ff 92       	push	r15
    2ce0:	0f 93       	push	r16
    2ce2:	1f 93       	push	r17
    2ce4:	cf 93       	push	r28
    2ce6:	df 93       	push	r29
    2ce8:	18 2f       	mov	r17, r24
    2cea:	6b 01       	movw	r12, r22
    2cec:	f4 2e       	mov	r15, r20
//	SET_BIT(_TWCR, _TWEA);
    u8 local_u8Add = (copy_u16WordAdd >> 8) | EEPROM_FIXED_ADDRESS;
    2cee:	09 2f       	mov	r16, r25
    2cf0:	00 65       	ori	r16, 0x50	; 80
    TWI_voidSendStartCondition();
    2cf2:	0e 94 b9 09 	call	0x1372	; 0x1372 <TWI_voidSendStartCondition>
    TWI_voidSendSlaveAdd_WriteRequest(local_u8Add);
    2cf6:	80 2f       	mov	r24, r16
    2cf8:	0e 94 e6 09 	call	0x13cc	; 0x13cc <TWI_voidSendSlaveAdd_WriteRequest>
    TWI_voidWriteMasterDataByte((u8)copy_u16WordAdd);
    2cfc:	81 2f       	mov	r24, r17
    2cfe:	0e 94 1c 0a 	call	0x1438	; 0x1438 <TWI_voidWriteMasterDataByte>

    TWI_voidSendReapeatedStartCondition();
    2d02:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <TWI_voidSendReapeatedStartCondition>

    TWI_voidSendSlaveAdd_ReadRequest(local_u8Add);
    2d06:	80 2f       	mov	r24, r16
    2d08:	0e 94 01 0a 	call	0x1402	; 0x1402 <TWI_voidSendSlaveAdd_ReadRequest>

    for (int i = 0; i < copy_u8Size; i++)
    2d0c:	cf 2d       	mov	r28, r15
    2d0e:	d0 e0       	ldi	r29, 0x00	; 0
    2d10:	1c 16       	cp	r1, r28
    2d12:	1d 06       	cpc	r1, r29
    2d14:	e4 f4       	brge	.+56     	; 0x2d4e <EEPROM_voidRead_Page+0x7a>
    2d16:	00 e0       	ldi	r16, 0x00	; 0
    2d18:	10 e0       	ldi	r17, 0x00	; 0
    {
    	TWI_voidReadMasterDataByteACK(&copy_u8PtrReceivedData[i]);
    	if(i == copy_u8Size -1)
    2d1a:	7e 01       	movw	r14, r28
    2d1c:	08 94       	sec
    2d1e:	e1 08       	sbc	r14, r1
    2d20:	f1 08       	sbc	r15, r1
    	{
    		CLR_BIT(_TWCR, _TWEA);
    2d22:	0f 2e       	mov	r0, r31
    2d24:	f6 e5       	ldi	r31, 0x56	; 86
    2d26:	af 2e       	mov	r10, r31
    2d28:	bb 24       	eor	r11, r11
    2d2a:	f0 2d       	mov	r31, r0

    TWI_voidSendSlaveAdd_ReadRequest(local_u8Add);

    for (int i = 0; i < copy_u8Size; i++)
    {
    	TWI_voidReadMasterDataByteACK(&copy_u8PtrReceivedData[i]);
    2d2c:	c6 01       	movw	r24, r12
    2d2e:	80 0f       	add	r24, r16
    2d30:	91 1f       	adc	r25, r17
    2d32:	0e 94 48 0a 	call	0x1490	; 0x1490 <TWI_voidReadMasterDataByteACK>
    	if(i == copy_u8Size -1)
    2d36:	e0 16       	cp	r14, r16
    2d38:	f1 06       	cpc	r15, r17
    2d3a:	21 f4       	brne	.+8      	; 0x2d44 <EEPROM_voidRead_Page+0x70>
    	{
    		CLR_BIT(_TWCR, _TWEA);
    2d3c:	f5 01       	movw	r30, r10
    2d3e:	80 81       	ld	r24, Z
    2d40:	8f 7b       	andi	r24, 0xBF	; 191
    2d42:	80 83       	st	Z, r24

    TWI_voidSendReapeatedStartCondition();

    TWI_voidSendSlaveAdd_ReadRequest(local_u8Add);

    for (int i = 0; i < copy_u8Size; i++)
    2d44:	0f 5f       	subi	r16, 0xFF	; 255
    2d46:	1f 4f       	sbci	r17, 0xFF	; 255
    2d48:	0c 17       	cp	r16, r28
    2d4a:	1d 07       	cpc	r17, r29
    2d4c:	7c f3       	brlt	.-34     	; 0x2d2c <EEPROM_voidRead_Page+0x58>
    	if(i == copy_u8Size -1)
    	{
    		CLR_BIT(_TWCR, _TWEA);
    	}
    }
    TWI_voidSendStopCondition();
    2d4e:	0e 94 cb 09 	call	0x1396	; 0x1396 <TWI_voidSendStopCondition>
    2d52:	80 e2       	ldi	r24, 0x20	; 32
    2d54:	9e e4       	ldi	r25, 0x4E	; 78
    2d56:	01 97       	sbiw	r24, 0x01	; 1
    2d58:	f1 f7       	brne	.-4      	; 0x2d56 <EEPROM_voidRead_Page+0x82>

    _delay_ms(5);  // Delay for EEPROM to store the data
}
    2d5a:	df 91       	pop	r29
    2d5c:	cf 91       	pop	r28
    2d5e:	1f 91       	pop	r17
    2d60:	0f 91       	pop	r16
    2d62:	ff 90       	pop	r15
    2d64:	ef 90       	pop	r14
    2d66:	df 90       	pop	r13
    2d68:	cf 90       	pop	r12
    2d6a:	bf 90       	pop	r11
    2d6c:	af 90       	pop	r10
    2d6e:	08 95       	ret

00002d70 <EEPROM_voidWrite_Page>:
	}
}


void EEPROM_voidWrite_Page(u16 copy_u16WordAdd, u8 *copy_u8Data, u8 copy_u8Size)
{
    2d70:	cf 92       	push	r12
    2d72:	df 92       	push	r13
    2d74:	ff 92       	push	r15
    2d76:	0f 93       	push	r16
    2d78:	1f 93       	push	r17
    2d7a:	cf 93       	push	r28
    2d7c:	df 93       	push	r29
    2d7e:	18 2f       	mov	r17, r24
    2d80:	09 2f       	mov	r16, r25
    2d82:	6b 01       	movw	r12, r22
    2d84:	f4 2e       	mov	r15, r20

	u8 local_u8Add = (copy_u16WordAdd >> 8) | EEPROM_FIXED_ADDRESS ;
	TWI_voidSendStartCondition();
    2d86:	0e 94 b9 09 	call	0x1372	; 0x1372 <TWI_voidSendStartCondition>
	TWI_voidSendSlaveAdd_WriteRequest(local_u8Add);
    2d8a:	80 2f       	mov	r24, r16
    2d8c:	80 65       	ori	r24, 0x50	; 80
    2d8e:	0e 94 e6 09 	call	0x13cc	; 0x13cc <TWI_voidSendSlaveAdd_WriteRequest>

	TWI_voidWriteMasterDataByte((u8)copy_u16WordAdd);
    2d92:	81 2f       	mov	r24, r17
    2d94:	0e 94 1c 0a 	call	0x1438	; 0x1438 <TWI_voidWriteMasterDataByte>
	for (int i = 0; i <copy_u8Size ; i++ )
    2d98:	cf 2d       	mov	r28, r15
    2d9a:	d0 e0       	ldi	r29, 0x00	; 0
    2d9c:	1c 16       	cp	r1, r28
    2d9e:	1d 06       	cpc	r1, r29
    2da0:	6c f4       	brge	.+26     	; 0x2dbc <EEPROM_voidWrite_Page+0x4c>
    2da2:	00 e0       	ldi	r16, 0x00	; 0
    2da4:	10 e0       	ldi	r17, 0x00	; 0
		{
			TWI_voidWriteMasterDataByte(copy_u8Data[i]);
    2da6:	f6 01       	movw	r30, r12
    2da8:	e0 0f       	add	r30, r16
    2daa:	f1 1f       	adc	r31, r17
    2dac:	80 81       	ld	r24, Z
    2dae:	0e 94 1c 0a 	call	0x1438	; 0x1438 <TWI_voidWriteMasterDataByte>
	u8 local_u8Add = (copy_u16WordAdd >> 8) | EEPROM_FIXED_ADDRESS ;
	TWI_voidSendStartCondition();
	TWI_voidSendSlaveAdd_WriteRequest(local_u8Add);

	TWI_voidWriteMasterDataByte((u8)copy_u16WordAdd);
	for (int i = 0; i <copy_u8Size ; i++ )
    2db2:	0f 5f       	subi	r16, 0xFF	; 255
    2db4:	1f 4f       	sbci	r17, 0xFF	; 255
    2db6:	0c 17       	cp	r16, r28
    2db8:	1d 07       	cpc	r17, r29
    2dba:	ac f3       	brlt	.-22     	; 0x2da6 <EEPROM_voidWrite_Page+0x36>
		{
			TWI_voidWriteMasterDataByte(copy_u8Data[i]);
		}

	TWI_voidSendStopCondition();
    2dbc:	0e 94 cb 09 	call	0x1396	; 0x1396 <TWI_voidSendStopCondition>
    2dc0:	80 e2       	ldi	r24, 0x20	; 32
    2dc2:	9e e4       	ldi	r25, 0x4E	; 78
    2dc4:	01 97       	sbiw	r24, 0x01	; 1
    2dc6:	f1 f7       	brne	.-4      	; 0x2dc4 <EEPROM_voidWrite_Page+0x54>
	_delay_ms(5);	// delay to eeprom to store the data
}
    2dc8:	df 91       	pop	r29
    2dca:	cf 91       	pop	r28
    2dcc:	1f 91       	pop	r17
    2dce:	0f 91       	pop	r16
    2dd0:	ff 90       	pop	r15
    2dd2:	df 90       	pop	r13
    2dd4:	cf 90       	pop	r12
    2dd6:	08 95       	ret

00002dd8 <EEPROM_voidWrite_Byte>:
{
	TWI_voidInitMaster(255);
}

void EEPROM_voidWrite_Byte(u16 copy_u16WordAdd, u8 copy_u8Data)
{
    2dd8:	ff 92       	push	r15
    2dda:	0f 93       	push	r16
    2ddc:	1f 93       	push	r17
    2dde:	18 2f       	mov	r17, r24
    2de0:	09 2f       	mov	r16, r25
    2de2:	f6 2e       	mov	r15, r22
	u8 local_u8Add = (copy_u16WordAdd >> 8) | EEPROM_FIXED_ADDRESS ;
	TWI_voidSendStartCondition();
    2de4:	0e 94 b9 09 	call	0x1372	; 0x1372 <TWI_voidSendStartCondition>
	TWI_voidSendSlaveAdd_WriteRequest(local_u8Add);
    2de8:	80 2f       	mov	r24, r16
    2dea:	80 65       	ori	r24, 0x50	; 80
    2dec:	0e 94 e6 09 	call	0x13cc	; 0x13cc <TWI_voidSendSlaveAdd_WriteRequest>

	TWI_voidWriteMasterDataByte((u8)copy_u16WordAdd);
    2df0:	81 2f       	mov	r24, r17
    2df2:	0e 94 1c 0a 	call	0x1438	; 0x1438 <TWI_voidWriteMasterDataByte>
	TWI_voidWriteMasterDataByte(copy_u8Data);
    2df6:	8f 2d       	mov	r24, r15
    2df8:	0e 94 1c 0a 	call	0x1438	; 0x1438 <TWI_voidWriteMasterDataByte>
	TWI_voidSendStopCondition();
    2dfc:	0e 94 cb 09 	call	0x1396	; 0x1396 <TWI_voidSendStopCondition>
    2e00:	80 e2       	ldi	r24, 0x20	; 32
    2e02:	9e e4       	ldi	r25, 0x4E	; 78
    2e04:	01 97       	sbiw	r24, 0x01	; 1
    2e06:	f1 f7       	brne	.-4      	; 0x2e04 <EEPROM_voidWrite_Byte+0x2c>
	_delay_ms(5);	// delay to eeprom to store the data
}
    2e08:	1f 91       	pop	r17
    2e0a:	0f 91       	pop	r16
    2e0c:	ff 90       	pop	r15
    2e0e:	08 95       	ret

00002e10 <EEPROM_voidRead_Byte>:

void EEPROM_voidRead_Byte(u16 copy_u16WordAdd, u8 *copy_u8PtrReceivedData)
{
    2e10:	0f 93       	push	r16
    2e12:	1f 93       	push	r17
    2e14:	cf 93       	push	r28
    2e16:	df 93       	push	r29
    2e18:	08 2f       	mov	r16, r24
    2e1a:	eb 01       	movw	r28, r22
	if(copy_u8PtrReceivedData != NULL)
    2e1c:	61 15       	cp	r22, r1
    2e1e:	71 05       	cpc	r23, r1
    2e20:	c1 f0       	breq	.+48     	; 0x2e52 <EEPROM_voidRead_Byte+0x42>
	{
		// CLR_BIT(_TWCR, _TWEA);
		u8 local_u8Add = (copy_u16WordAdd >> 8) | EEPROM_FIXED_ADDRESS ;
    2e22:	19 2f       	mov	r17, r25
    2e24:	10 65       	ori	r17, 0x50	; 80
		TWI_voidSendStartCondition();
    2e26:	0e 94 b9 09 	call	0x1372	; 0x1372 <TWI_voidSendStartCondition>
		TWI_voidSendSlaveAdd_WriteRequest(local_u8Add);
    2e2a:	81 2f       	mov	r24, r17
    2e2c:	0e 94 e6 09 	call	0x13cc	; 0x13cc <TWI_voidSendSlaveAdd_WriteRequest>
		TWI_voidWriteMasterDataByte((u8)copy_u16WordAdd);
    2e30:	80 2f       	mov	r24, r16
    2e32:	0e 94 1c 0a 	call	0x1438	; 0x1438 <TWI_voidWriteMasterDataByte>

		TWI_voidSendReapeatedStartCondition();
    2e36:	0e 94 d4 09 	call	0x13a8	; 0x13a8 <TWI_voidSendReapeatedStartCondition>

		TWI_voidSendSlaveAdd_ReadRequest(local_u8Add);
    2e3a:	81 2f       	mov	r24, r17
    2e3c:	0e 94 01 0a 	call	0x1402	; 0x1402 <TWI_voidSendSlaveAdd_ReadRequest>

		TWI_voidReadMasterDataByteNACK(copy_u8PtrReceivedData);
    2e40:	ce 01       	movw	r24, r28
    2e42:	0e 94 2c 0a 	call	0x1458	; 0x1458 <TWI_voidReadMasterDataByteNACK>

		TWI_voidSendStopCondition();
    2e46:	0e 94 cb 09 	call	0x1396	; 0x1396 <TWI_voidSendStopCondition>
    2e4a:	80 e2       	ldi	r24, 0x20	; 32
    2e4c:	9e e4       	ldi	r25, 0x4E	; 78
    2e4e:	01 97       	sbiw	r24, 0x01	; 1
    2e50:	f1 f7       	brne	.-4      	; 0x2e4e <EEPROM_voidRead_Byte+0x3e>

		_delay_ms(5);	// delay to eeprom to store the data
	}
}
    2e52:	df 91       	pop	r29
    2e54:	cf 91       	pop	r28
    2e56:	1f 91       	pop	r17
    2e58:	0f 91       	pop	r16
    2e5a:	08 95       	ret

00002e5c <EEPROM_Init>:
#include <util/delay.h>

/* ----------------- Section : Software Interfaces Implementation -----------------*/
void EEPROM_Init(void)
{
	TWI_voidInitMaster(255);
    2e5c:	8f ef       	ldi	r24, 0xFF	; 255
    2e5e:	0e 94 a2 09 	call	0x1344	; 0x1344 <TWI_voidInitMaster>
}
    2e62:	08 95       	ret

00002e64 <DCM_voidOff>:
 * @param	void
 * @return	void
 */
void DCM_voidOff(void)
{
	TMR0_voidStop();
    2e64:	0e 94 91 0b 	call	0x1722	; 0x1722 <TMR0_voidStop>
	timerInitialized =0;
    2e68:	10 92 d7 01 	sts	0x01D7, r1
	Dio_WriteChannel(DC_MOTOR_EN_PIN, 0);
    2e6c:	8e e0       	ldi	r24, 0x0E	; 14
    2e6e:	60 e0       	ldi	r22, 0x00	; 0
    2e70:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
}
    2e74:	08 95       	ret

00002e76 <DCM_voidControlSpeed>:
 * DCM_voidControlSpeed : control the speed of a DC motor connected to an H-Bridge motor driver using PWM from TIMERS
 * @param	Copy_u8Speed --> [0 : 100] the desired speed of the motor. Ranges from 0  to 100
 * @return	void
 */
void DCM_voidControlSpeed(u8 Copy_u8Speed)
{
    2e76:	1f 93       	push	r17
    2e78:	18 2f       	mov	r17, r24
	if (timerInitialized == 0)
    2e7a:	80 91 d7 01 	lds	r24, 0x01D7
    2e7e:	88 23       	and	r24, r24
    2e80:	29 f4       	brne	.+10     	; 0x2e8c <DCM_voidControlSpeed+0x16>
	{
		TMR0_voidInit();
    2e82:	0e 94 c1 0b 	call	0x1782	; 0x1782 <TMR0_voidInit>
		timerInitialized = 1;  // Set the flag to indicate initialization
    2e86:	81 e0       	ldi	r24, 0x01	; 1
    2e88:	80 93 d7 01 	sts	0x01D7, r24
	}
	TMR0_voidSetDutyCycle(Copy_u8Speed);
    2e8c:	81 2f       	mov	r24, r17
    2e8e:	0e 94 b2 0b 	call	0x1764	; 0x1764 <TMR0_voidSetDutyCycle>
	TMR0_voidStart();
    2e92:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <TMR0_voidStart>
}
    2e96:	1f 91       	pop	r17
    2e98:	08 95       	ret

00002e9a <DCM_voidOn>:
 * DCM_voidOn : used to turn on a DC motor using an H-Bridge motor driver on FARES PCB Kit
 * @param	Copy_u8Direction --> the desired direction of the motor --> [DCM_CLOCK_WISE or DCM_COUNTER_CLOCK_WISE]
 * @return	void
 */
void DCM_voidOn(u8 Copy_u8Direction)
{
    2e9a:	1f 93       	push	r17
    2e9c:	18 2f       	mov	r17, r24
	Dio_WriteChannel(DC_MOTOR_EN_PIN, 1);
    2e9e:	8e e0       	ldi	r24, 0x0E	; 14
    2ea0:	61 e0       	ldi	r22, 0x01	; 1
    2ea2:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	DCM_voidControlSpeed(100);
    2ea6:	84 e6       	ldi	r24, 0x64	; 100
    2ea8:	0e 94 3b 17 	call	0x2e76	; 0x2e76 <DCM_voidControlSpeed>
	switch(Copy_u8Direction)
    2eac:	11 30       	cpi	r17, 0x01	; 1
    2eae:	19 f0       	breq	.+6      	; 0x2eb6 <DCM_voidOn+0x1c>
    2eb0:	12 30       	cpi	r17, 0x02	; 2
    2eb2:	51 f4       	brne	.+20     	; 0x2ec8 <DCM_voidOn+0x2e>
    2eb4:	05 c0       	rjmp	.+10     	; 0x2ec0 <DCM_voidOn+0x26>
	{
	case DCM_CLOCK_WISE:
		Dio_WriteChannel(DC_MOTOR_DIR_PIN, 1);
    2eb6:	8d e0       	ldi	r24, 0x0D	; 13
    2eb8:	61 e0       	ldi	r22, 0x01	; 1
    2eba:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    2ebe:	04 c0       	rjmp	.+8      	; 0x2ec8 <DCM_voidOn+0x2e>
		break;
	case DCM_COUNTER_CLOCK_WISE:
		Dio_WriteChannel(DC_MOTOR_DIR_PIN, 0);
    2ec0:	8d e0       	ldi	r24, 0x0D	; 13
    2ec2:	60 e0       	ldi	r22, 0x00	; 0
    2ec4:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
		break;
	default: break;
	}
}
    2ec8:	1f 91       	pop	r17
    2eca:	08 95       	ret

00002ecc <Segment_Write>:
 * @param	1- num : which is the number to display
 * 			2- seg_index : which is the number of the segment 0, 1, 2 or 3
 * @return	void
 */
void Segment_Write(u8 num, u8 seg_index)
{
    2ecc:	1f 93       	push	r17
    2ece:	18 2f       	mov	r17, r24
	switch(seg_index)
    2ed0:	61 30       	cpi	r22, 0x01	; 1
    2ed2:	c9 f0       	breq	.+50     	; 0x2f06 <Segment_Write+0x3a>
    2ed4:	61 30       	cpi	r22, 0x01	; 1
    2ed6:	30 f0       	brcs	.+12     	; 0x2ee4 <Segment_Write+0x18>
    2ed8:	62 30       	cpi	r22, 0x02	; 2
    2eda:	31 f1       	breq	.+76     	; 0x2f28 <Segment_Write+0x5c>
    2edc:	63 30       	cpi	r22, 0x03	; 3
    2ede:	09 f0       	breq	.+2      	; 0x2ee2 <Segment_Write+0x16>
    2ee0:	44 c0       	rjmp	.+136    	; 0x2f6a <Segment_Write+0x9e>
    2ee2:	33 c0       	rjmp	.+102    	; 0x2f4a <Segment_Write+0x7e>
	{
	case 0:
		CLR_BIT(_PORTA, 3);
    2ee4:	eb e3       	ldi	r30, 0x3B	; 59
    2ee6:	f0 e0       	ldi	r31, 0x00	; 0
    2ee8:	80 81       	ld	r24, Z
    2eea:	87 7f       	andi	r24, 0xF7	; 247
    2eec:	80 83       	st	Z, r24
		SET_BIT(_PORTA, 2);
    2eee:	80 81       	ld	r24, Z
    2ef0:	84 60       	ori	r24, 0x04	; 4
    2ef2:	80 83       	st	Z, r24
		SET_BIT(_PORTB, 5);
    2ef4:	e8 e3       	ldi	r30, 0x38	; 56
    2ef6:	f0 e0       	ldi	r31, 0x00	; 0
    2ef8:	80 81       	ld	r24, Z
    2efa:	80 62       	ori	r24, 0x20	; 32
    2efc:	80 83       	st	Z, r24
		SET_BIT(_PORTB, 6);
    2efe:	80 81       	ld	r24, Z
    2f00:	80 64       	ori	r24, 0x40	; 64
    2f02:	80 83       	st	Z, r24
    2f04:	32 c0       	rjmp	.+100    	; 0x2f6a <Segment_Write+0x9e>
		break;
	case 1:
		SET_BIT(_PORTA, 3);
    2f06:	eb e3       	ldi	r30, 0x3B	; 59
    2f08:	f0 e0       	ldi	r31, 0x00	; 0
    2f0a:	80 81       	ld	r24, Z
    2f0c:	88 60       	ori	r24, 0x08	; 8
    2f0e:	80 83       	st	Z, r24
		CLR_BIT(_PORTA, 2);
    2f10:	80 81       	ld	r24, Z
    2f12:	8b 7f       	andi	r24, 0xFB	; 251
    2f14:	80 83       	st	Z, r24
		SET_BIT(_PORTB, 5);
    2f16:	e8 e3       	ldi	r30, 0x38	; 56
    2f18:	f0 e0       	ldi	r31, 0x00	; 0
    2f1a:	80 81       	ld	r24, Z
    2f1c:	80 62       	ori	r24, 0x20	; 32
    2f1e:	80 83       	st	Z, r24
		SET_BIT(_PORTB, 6);
    2f20:	80 81       	ld	r24, Z
    2f22:	80 64       	ori	r24, 0x40	; 64
    2f24:	80 83       	st	Z, r24
    2f26:	21 c0       	rjmp	.+66     	; 0x2f6a <Segment_Write+0x9e>
		break;
	case 2:
		SET_BIT(_PORTA, 3);
    2f28:	eb e3       	ldi	r30, 0x3B	; 59
    2f2a:	f0 e0       	ldi	r31, 0x00	; 0
    2f2c:	80 81       	ld	r24, Z
    2f2e:	88 60       	ori	r24, 0x08	; 8
    2f30:	80 83       	st	Z, r24
		SET_BIT(_PORTA, 2);
    2f32:	80 81       	ld	r24, Z
    2f34:	84 60       	ori	r24, 0x04	; 4
    2f36:	80 83       	st	Z, r24
		CLR_BIT(_PORTB, 5);
    2f38:	e8 e3       	ldi	r30, 0x38	; 56
    2f3a:	f0 e0       	ldi	r31, 0x00	; 0
    2f3c:	80 81       	ld	r24, Z
    2f3e:	8f 7d       	andi	r24, 0xDF	; 223
    2f40:	80 83       	st	Z, r24
		SET_BIT(_PORTB, 6);
    2f42:	80 81       	ld	r24, Z
    2f44:	80 64       	ori	r24, 0x40	; 64
    2f46:	80 83       	st	Z, r24
    2f48:	10 c0       	rjmp	.+32     	; 0x2f6a <Segment_Write+0x9e>
		break;
	case 3:
		SET_BIT(_PORTA, 3);
    2f4a:	eb e3       	ldi	r30, 0x3B	; 59
    2f4c:	f0 e0       	ldi	r31, 0x00	; 0
    2f4e:	80 81       	ld	r24, Z
    2f50:	88 60       	ori	r24, 0x08	; 8
    2f52:	80 83       	st	Z, r24
		SET_BIT(_PORTA, 2);
    2f54:	80 81       	ld	r24, Z
    2f56:	84 60       	ori	r24, 0x04	; 4
    2f58:	80 83       	st	Z, r24
		SET_BIT(_PORTB, 5);
    2f5a:	e8 e3       	ldi	r30, 0x38	; 56
    2f5c:	f0 e0       	ldi	r31, 0x00	; 0
    2f5e:	80 81       	ld	r24, Z
    2f60:	80 62       	ori	r24, 0x20	; 32
    2f62:	80 83       	st	Z, r24
		CLR_BIT(_PORTB, 6);
    2f64:	80 81       	ld	r24, Z
    2f66:	8f 7b       	andi	r24, 0xBF	; 191
    2f68:	80 83       	st	Z, r24
		break;
	}
	if (num >9){
    2f6a:	1a 30       	cpi	r17, 0x0A	; 10
    2f6c:	d0 f4       	brcc	.+52     	; 0x2fa2 <Segment_Write+0xd6>
		return;
	}
	else{
		Dio_WriteChannel(PB_0 , (num & 0x01));
    2f6e:	61 2f       	mov	r22, r17
    2f70:	61 70       	andi	r22, 0x01	; 1
    2f72:	88 e0       	ldi	r24, 0x08	; 8
    2f74:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
		Dio_WriteChannel(PB_1 , ((num>>1) & 0x01));
    2f78:	61 2f       	mov	r22, r17
    2f7a:	66 95       	lsr	r22
    2f7c:	61 70       	andi	r22, 0x01	; 1
    2f7e:	89 e0       	ldi	r24, 0x09	; 9
    2f80:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
		Dio_WriteChannel(PB_2 , ((num>>2) & 0x01));
    2f84:	61 2f       	mov	r22, r17
    2f86:	66 95       	lsr	r22
    2f88:	66 95       	lsr	r22
    2f8a:	61 70       	andi	r22, 0x01	; 1
    2f8c:	8a e0       	ldi	r24, 0x0A	; 10
    2f8e:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
		Dio_WriteChannel(PB_4 , ((num>>3) & 0x01));
    2f92:	61 2f       	mov	r22, r17
    2f94:	66 95       	lsr	r22
    2f96:	66 95       	lsr	r22
    2f98:	66 95       	lsr	r22
    2f9a:	61 70       	andi	r22, 0x01	; 1
    2f9c:	8c e0       	ldi	r24, 0x0C	; 12
    2f9e:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	}
}
    2fa2:	1f 91       	pop	r17
    2fa4:	08 95       	ret

00002fa6 <main>:
u8 d1;
u8 d2;

u8 Received = 0;

int main() {
    2fa6:	0f 93       	push	r16
    2fa8:	1f 93       	push	r17
    2faa:	cf 93       	push	r28
    2fac:	df 93       	push	r29
	Port_Init(pins);
    2fae:	87 e7       	ldi	r24, 0x77	; 119
    2fb0:	91 e0       	ldi	r25, 0x01	; 1
    2fb2:	0e 94 b7 0c 	call	0x196e	; 0x196e <Port_Init>
	GI_voidEnable();
    2fb6:	0e 94 fb 0e 	call	0x1df6	; 0x1df6 <GI_voidEnable>
	lcd4_Init();
    2fba:	0e 94 37 14 	call	0x286e	; 0x286e <lcd4_Init>
	ICU_voidInit();
    2fbe:	0e 94 22 0e 	call	0x1c44	; 0x1c44 <ICU_voidInit>
	SPI_voidInit();
    2fc2:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <SPI_voidInit>

	Dio_WriteChannel(PA_1, 1);
    2fc6:	81 e0       	ldi	r24, 0x01	; 1
    2fc8:	61 e0       	ldi	r22, 0x01	; 1
    2fca:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
	Dio_WriteChannel(PA_4, 0);
    2fce:	84 e0       	ldi	r24, 0x04	; 4
    2fd0:	60 e0       	ldi	r22, 0x00	; 0
    2fd2:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
				Dio_WriteChannel(PA_4, 1);
				Dio_WriteChannel(PA_1, 0);
				do
				{
					SPI_voidTranseive(0x77, &Received);
				}while (GET_BIT(_PINB, 4) == 0);
    2fd6:	c6 e3       	ldi	r28, 0x36	; 54
    2fd8:	d0 e0       	ldi	r29, 0x00	; 0
			{
				Dio_WriteChannel(PA_4, 1);
				Dio_WriteChannel(PA_1, 0);
				do
				{
					SPI_voidTranseive(0x77, &Received);
    2fda:	88 ed       	ldi	r24, 0xD8	; 216
    2fdc:	91 e0       	ldi	r25, 0x01	; 1
    2fde:	08 2f       	mov	r16, r24
    2fe0:	19 2f       	mov	r17, r25
	Dio_WriteChannel(PA_1, 1);
	Dio_WriteChannel(PA_4, 0);

	while (1)
    {
    	Ultra_Sonic_void_trigger(PC_0);
    2fe2:	80 e1       	ldi	r24, 0x10	; 16
    2fe4:	0e 94 71 12 	call	0x24e2	; 0x24e2 <Ultra_Sonic_void_trigger>
    	d1 = Ultra_Sonic_Distance_in_cm();
    2fe8:	0e 94 66 12 	call	0x24cc	; 0x24cc <Ultra_Sonic_Distance_in_cm>
    2fec:	80 93 4d 08 	sts	0x084D, r24

    	if( (d1 < 20) && (d2 > 20) )
    2ff0:	84 31       	cpi	r24, 0x14	; 20
    2ff2:	b8 f7       	brcc	.-18     	; 0x2fe2 <main+0x3c>
    2ff4:	80 91 4e 08 	lds	r24, 0x084E
    2ff8:	85 31       	cpi	r24, 0x15	; 21
    2ffa:	e0 f0       	brcs	.+56     	; 0x3034 <main+0x8e>
    	{
    		Dio_WriteChannel(PA_4, 1);
    2ffc:	84 e0       	ldi	r24, 0x04	; 4
    2ffe:	61 e0       	ldi	r22, 0x01	; 1
    3000:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    		Dio_WriteChannel(PA_1, 0);
    3004:	81 e0       	ldi	r24, 0x01	; 1
    3006:	60 e0       	ldi	r22, 0x00	; 0
    3008:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    		do
    		{
    			SPI_voidTranseive(0x66, &Received);
    300c:	86 e6       	ldi	r24, 0x66	; 102
    300e:	60 2f       	mov	r22, r16
    3010:	71 2f       	mov	r23, r17
    3012:	0e 94 66 0c 	call	0x18cc	; 0x18cc <SPI_voidTranseive>
    		}while (GET_BIT(_PINB, 4) == 0);
    3016:	88 81       	ld	r24, Y
    3018:	84 ff       	sbrs	r24, 4
    301a:	f8 cf       	rjmp	.-16     	; 0x300c <main+0x66>
    		Dio_WriteChannel(PA_1, 1);
    301c:	81 e0       	ldi	r24, 0x01	; 1
    301e:	61 e0       	ldi	r22, 0x01	; 1
    3020:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    		Dio_WriteChannel(PA_4, 0);
    3024:	84 e0       	ldi	r24, 0x04	; 4
    3026:	60 e0       	ldi	r22, 0x00	; 0
    3028:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    	}
    	if( (d1 < 20) && (d2 < 20) )
    302c:	80 91 4d 08 	lds	r24, 0x084D
    3030:	84 31       	cpi	r24, 0x14	; 20
    3032:	b8 f6       	brcc	.-82     	; 0x2fe2 <main+0x3c>
    3034:	80 91 4e 08 	lds	r24, 0x084E
    3038:	84 31       	cpi	r24, 0x14	; 20
    303a:	98 f6       	brcc	.-90     	; 0x2fe2 <main+0x3c>
			{
				Dio_WriteChannel(PA_4, 1);
    303c:	84 e0       	ldi	r24, 0x04	; 4
    303e:	61 e0       	ldi	r22, 0x01	; 1
    3040:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
				Dio_WriteChannel(PA_1, 0);
    3044:	81 e0       	ldi	r24, 0x01	; 1
    3046:	60 e0       	ldi	r22, 0x00	; 0
    3048:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
				do
				{
					SPI_voidTranseive(0x77, &Received);
    304c:	87 e7       	ldi	r24, 0x77	; 119
    304e:	60 2f       	mov	r22, r16
    3050:	71 2f       	mov	r23, r17
    3052:	0e 94 66 0c 	call	0x18cc	; 0x18cc <SPI_voidTranseive>
				}while (GET_BIT(_PINB, 4) == 0);
    3056:	88 81       	ld	r24, Y
    3058:	84 ff       	sbrs	r24, 4
    305a:	f8 cf       	rjmp	.-16     	; 0x304c <main+0xa6>
				Dio_WriteChannel(PA_1, 1);
    305c:	81 e0       	ldi	r24, 0x01	; 1
    305e:	61 e0       	ldi	r22, 0x01	; 1
    3060:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
				Dio_WriteChannel(PA_4, 0);
    3064:	84 e0       	ldi	r24, 0x04	; 4
    3066:	60 e0       	ldi	r22, 0x00	; 0
    3068:	0e 94 33 10 	call	0x2066	; 0x2066 <Dio_WriteChannel>
    306c:	ba cf       	rjmp	.-140    	; 0x2fe2 <main+0x3c>

0000306e <vPortFree>:
     * https://www.FreeRTOS.org for more information. */
    ( void ) pv;

    /* Force an assert as it is invalid to call this function. */
    configASSERT( pv == NULL );
}
    306e:	08 95       	ret

00003070 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    /* Only required when static memory is not cleared. */
    xNextFreeByte = ( size_t ) 0;
    3070:	10 92 da 01 	sts	0x01DA, r1
    3074:	10 92 d9 01 	sts	0x01D9, r1
}
    3078:	08 95       	ret

0000307a <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    307a:	80 91 d9 01 	lds	r24, 0x01D9
    307e:	90 91 da 01 	lds	r25, 0x01DA
    3082:	2b ed       	ldi	r18, 0xDB	; 219
    3084:	35 e0       	ldi	r19, 0x05	; 5
    3086:	28 1b       	sub	r18, r24
    3088:	39 0b       	sbc	r19, r25
    return( configADJUSTED_HEAP_SIZE - xNextFreeByte );
}
    308a:	82 2f       	mov	r24, r18
    308c:	93 2f       	mov	r25, r19
    308e:	08 95       	ret

00003090 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void * pvPortMalloc( size_t xWantedSize )
{
    3090:	cf 93       	push	r28
    3092:	df 93       	push	r29
    3094:	ec 01       	movw	r28, r24
            }
        }
    }
    #endif /* if ( portBYTE_ALIGNMENT != 1 ) */

    vTaskSuspendAll();
    3096:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <vTaskSuspendAll>
    {
        if( pucAlignedHeap == NULL )
    309a:	80 91 db 01 	lds	r24, 0x01DB
    309e:	90 91 dc 01 	lds	r25, 0x01DC
    30a2:	89 2b       	or	r24, r25
    30a4:	31 f4       	brne	.+12     	; 0x30b2 <pvPortMalloc+0x22>
        {
            /* Ensure the heap starts on a correctly aligned boundary. */
            pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT - 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
    30a6:	8d ed       	ldi	r24, 0xDD	; 221
    30a8:	91 e0       	ldi	r25, 0x01	; 1
    30aa:	90 93 dc 01 	sts	0x01DC, r25
    30ae:	80 93 db 01 	sts	0x01DB, r24
        }

        /* Check there is enough room left for the allocation and. */
        if( ( xWantedSize > 0 ) &&                                /* valid size */
    30b2:	20 97       	sbiw	r28, 0x00	; 0
    30b4:	d1 f0       	breq	.+52     	; 0x30ea <pvPortMalloc+0x5a>
    30b6:	40 91 d9 01 	lds	r20, 0x01D9
    30ba:	50 91 da 01 	lds	r21, 0x01DA
    30be:	9e 01       	movw	r18, r28
    30c0:	24 0f       	add	r18, r20
    30c2:	35 1f       	adc	r19, r21
    30c4:	85 e0       	ldi	r24, 0x05	; 5
    30c6:	2b 3d       	cpi	r18, 0xDB	; 219
    30c8:	38 07       	cpc	r19, r24
    30ca:	78 f4       	brcc	.+30     	; 0x30ea <pvPortMalloc+0x5a>
    30cc:	42 17       	cp	r20, r18
    30ce:	53 07       	cpc	r21, r19
    30d0:	60 f4       	brcc	.+24     	; 0x30ea <pvPortMalloc+0x5a>
            ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
            ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */
        {
            /* Return the next free byte then increment the index past this
             * block. */
            pvReturn = pucAlignedHeap + xNextFreeByte;
    30d2:	80 91 db 01 	lds	r24, 0x01DB
    30d6:	90 91 dc 01 	lds	r25, 0x01DC
    30da:	ec 01       	movw	r28, r24
    30dc:	c4 0f       	add	r28, r20
    30de:	d5 1f       	adc	r29, r21
            xNextFreeByte += xWantedSize;
    30e0:	30 93 da 01 	sts	0x01DA, r19
    30e4:	20 93 d9 01 	sts	0x01D9, r18
    30e8:	02 c0       	rjmp	.+4      	; 0x30ee <pvPortMalloc+0x5e>
    30ea:	c0 e0       	ldi	r28, 0x00	; 0
    30ec:	d0 e0       	ldi	r29, 0x00	; 0
        }

        traceMALLOC( pvReturn, xWantedSize );
    }
    ( void ) xTaskResumeAll();
    30ee:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>
        }
    }
    #endif

    return pvReturn;
}
    30f2:	8c 2f       	mov	r24, r28
    30f4:	9d 2f       	mov	r25, r29
    30f6:	df 91       	pop	r29
    30f8:	cf 91       	pop	r28
    30fa:	08 95       	ret

000030fc <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    30fc:	fc 01       	movw	r30, r24
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    30fe:	91 e1       	ldi	r25, 0x11	; 17
    3100:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    3102:	22 e2       	ldi	r18, 0x22	; 34
    3104:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    3106:	83 e3       	ldi	r24, 0x33	; 51
    3108:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    310a:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    310c:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
    310e:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    3110:	80 e8       	ldi	r24, 0x80	; 128
    3112:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
    3114:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
    3116:	82 e0       	ldi	r24, 0x02	; 2
    3118:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
    311a:	83 e0       	ldi	r24, 0x03	; 3
    311c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
    311e:	84 e0       	ldi	r24, 0x04	; 4
    3120:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
    3122:	85 e0       	ldi	r24, 0x05	; 5
    3124:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
    3126:	86 e0       	ldi	r24, 0x06	; 6
    3128:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
    312a:	87 e0       	ldi	r24, 0x07	; 7
    312c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
    312e:	88 e0       	ldi	r24, 0x08	; 8
    3130:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
    3132:	89 e0       	ldi	r24, 0x09	; 9
    3134:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
    3136:	80 e1       	ldi	r24, 0x10	; 16
    3138:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
    313a:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
    313c:	82 e1       	ldi	r24, 0x12	; 18
    313e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
    3140:	83 e1       	ldi	r24, 0x13	; 19
    3142:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
    3144:	84 e1       	ldi	r24, 0x14	; 20
    3146:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
    3148:	85 e1       	ldi	r24, 0x15	; 21
    314a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
    314c:	86 e1       	ldi	r24, 0x16	; 22
    314e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
    3150:	87 e1       	ldi	r24, 0x17	; 23
    3152:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
    3154:	88 e1       	ldi	r24, 0x18	; 24
    3156:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
    3158:	89 e1       	ldi	r24, 0x19	; 25
    315a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
    315c:	80 e2       	ldi	r24, 0x20	; 32
    315e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
    3160:	81 e2       	ldi	r24, 0x21	; 33
    3162:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
    3164:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
    3166:	83 e2       	ldi	r24, 0x23	; 35
    3168:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    316a:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
    316c:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
    316e:	86 e2       	ldi	r24, 0x26	; 38
    3170:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
    3172:	87 e2       	ldi	r24, 0x27	; 39
    3174:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
    3176:	88 e2       	ldi	r24, 0x28	; 40
    3178:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
    317a:	89 e2       	ldi	r24, 0x29	; 41
    317c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
    317e:	80 e3       	ldi	r24, 0x30	; 48
    3180:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
    3182:	81 e3       	ldi	r24, 0x31	; 49
    3184:	82 93       	st	-Z, r24
    3186:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    3188:	8e 2f       	mov	r24, r30
    318a:	9f 2f       	mov	r25, r31
    318c:	08 95       	ret

0000318e <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    318e:	08 95       	ret

00003190 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
    3190:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    3192:	89 ef       	ldi	r24, 0xF9	; 249
    3194:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    3196:	8b e0       	ldi	r24, 0x0B	; 11
    3198:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    319a:	e9 e5       	ldi	r30, 0x59	; 89
    319c:	f0 e0       	ldi	r31, 0x00	; 0
    319e:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    31a0:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    31a2:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    31a4:	a0 91 b9 07 	lds	r26, 0x07B9
    31a8:	b0 91 ba 07 	lds	r27, 0x07BA
    31ac:	cd 91       	ld	r28, X+
    31ae:	cd bf       	out	0x3d, r28	; 61
    31b0:	dd 91       	ld	r29, X+
    31b2:	de bf       	out	0x3e, r29	; 62
    31b4:	ff 91       	pop	r31
    31b6:	ef 91       	pop	r30
    31b8:	df 91       	pop	r29
    31ba:	cf 91       	pop	r28
    31bc:	bf 91       	pop	r27
    31be:	af 91       	pop	r26
    31c0:	9f 91       	pop	r25
    31c2:	8f 91       	pop	r24
    31c4:	7f 91       	pop	r23
    31c6:	6f 91       	pop	r22
    31c8:	5f 91       	pop	r21
    31ca:	4f 91       	pop	r20
    31cc:	3f 91       	pop	r19
    31ce:	2f 91       	pop	r18
    31d0:	1f 91       	pop	r17
    31d2:	0f 91       	pop	r16
    31d4:	ff 90       	pop	r15
    31d6:	ef 90       	pop	r14
    31d8:	df 90       	pop	r13
    31da:	cf 90       	pop	r12
    31dc:	bf 90       	pop	r11
    31de:	af 90       	pop	r10
    31e0:	9f 90       	pop	r9
    31e2:	8f 90       	pop	r8
    31e4:	7f 90       	pop	r7
    31e6:	6f 90       	pop	r6
    31e8:	5f 90       	pop	r5
    31ea:	4f 90       	pop	r4
    31ec:	3f 90       	pop	r3
    31ee:	2f 90       	pop	r2
    31f0:	1f 90       	pop	r1
    31f2:	0f 90       	pop	r0
    31f4:	0f be       	out	0x3f, r0	; 63
    31f6:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    31f8:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    31fa:	81 e0       	ldi	r24, 0x01	; 1
    31fc:	08 95       	ret

000031fe <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    31fe:	0f 92       	push	r0
    3200:	0f b6       	in	r0, 0x3f	; 63
    3202:	f8 94       	cli
    3204:	0f 92       	push	r0
    3206:	1f 92       	push	r1
    3208:	11 24       	eor	r1, r1
    320a:	2f 92       	push	r2
    320c:	3f 92       	push	r3
    320e:	4f 92       	push	r4
    3210:	5f 92       	push	r5
    3212:	6f 92       	push	r6
    3214:	7f 92       	push	r7
    3216:	8f 92       	push	r8
    3218:	9f 92       	push	r9
    321a:	af 92       	push	r10
    321c:	bf 92       	push	r11
    321e:	cf 92       	push	r12
    3220:	df 92       	push	r13
    3222:	ef 92       	push	r14
    3224:	ff 92       	push	r15
    3226:	0f 93       	push	r16
    3228:	1f 93       	push	r17
    322a:	2f 93       	push	r18
    322c:	3f 93       	push	r19
    322e:	4f 93       	push	r20
    3230:	5f 93       	push	r21
    3232:	6f 93       	push	r22
    3234:	7f 93       	push	r23
    3236:	8f 93       	push	r24
    3238:	9f 93       	push	r25
    323a:	af 93       	push	r26
    323c:	bf 93       	push	r27
    323e:	cf 93       	push	r28
    3240:	df 93       	push	r29
    3242:	ef 93       	push	r30
    3244:	ff 93       	push	r31
    3246:	a0 91 b9 07 	lds	r26, 0x07B9
    324a:	b0 91 ba 07 	lds	r27, 0x07BA
    324e:	0d b6       	in	r0, 0x3d	; 61
    3250:	0d 92       	st	X+, r0
    3252:	0e b6       	in	r0, 0x3e	; 62
    3254:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    3256:	0e 94 79 27 	call	0x4ef2	; 0x4ef2 <xTaskIncrementTick>
    325a:	88 23       	and	r24, r24
    325c:	11 f0       	breq	.+4      	; 0x3262 <vPortYieldFromTick+0x64>
	{
		vTaskSwitchContext();
    325e:	0e 94 72 25 	call	0x4ae4	; 0x4ae4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
    3262:	a0 91 b9 07 	lds	r26, 0x07B9
    3266:	b0 91 ba 07 	lds	r27, 0x07BA
    326a:	cd 91       	ld	r28, X+
    326c:	cd bf       	out	0x3d, r28	; 61
    326e:	dd 91       	ld	r29, X+
    3270:	de bf       	out	0x3e, r29	; 62
    3272:	ff 91       	pop	r31
    3274:	ef 91       	pop	r30
    3276:	df 91       	pop	r29
    3278:	cf 91       	pop	r28
    327a:	bf 91       	pop	r27
    327c:	af 91       	pop	r26
    327e:	9f 91       	pop	r25
    3280:	8f 91       	pop	r24
    3282:	7f 91       	pop	r23
    3284:	6f 91       	pop	r22
    3286:	5f 91       	pop	r21
    3288:	4f 91       	pop	r20
    328a:	3f 91       	pop	r19
    328c:	2f 91       	pop	r18
    328e:	1f 91       	pop	r17
    3290:	0f 91       	pop	r16
    3292:	ff 90       	pop	r15
    3294:	ef 90       	pop	r14
    3296:	df 90       	pop	r13
    3298:	cf 90       	pop	r12
    329a:	bf 90       	pop	r11
    329c:	af 90       	pop	r10
    329e:	9f 90       	pop	r9
    32a0:	8f 90       	pop	r8
    32a2:	7f 90       	pop	r7
    32a4:	6f 90       	pop	r6
    32a6:	5f 90       	pop	r5
    32a8:	4f 90       	pop	r4
    32aa:	3f 90       	pop	r3
    32ac:	2f 90       	pop	r2
    32ae:	1f 90       	pop	r1
    32b0:	0f 90       	pop	r0
    32b2:	0f be       	out	0x3f, r0	; 63
    32b4:	0f 90       	pop	r0

	asm volatile ( "ret" );
    32b6:	08 95       	ret

000032b8 <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
    32b8:	0e 94 ff 18 	call	0x31fe	; 0x31fe <vPortYieldFromTick>
		asm volatile ( "reti" );
    32bc:	18 95       	reti

000032be <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    32be:	0f 92       	push	r0
    32c0:	0f b6       	in	r0, 0x3f	; 63
    32c2:	f8 94       	cli
    32c4:	0f 92       	push	r0
    32c6:	1f 92       	push	r1
    32c8:	11 24       	eor	r1, r1
    32ca:	2f 92       	push	r2
    32cc:	3f 92       	push	r3
    32ce:	4f 92       	push	r4
    32d0:	5f 92       	push	r5
    32d2:	6f 92       	push	r6
    32d4:	7f 92       	push	r7
    32d6:	8f 92       	push	r8
    32d8:	9f 92       	push	r9
    32da:	af 92       	push	r10
    32dc:	bf 92       	push	r11
    32de:	cf 92       	push	r12
    32e0:	df 92       	push	r13
    32e2:	ef 92       	push	r14
    32e4:	ff 92       	push	r15
    32e6:	0f 93       	push	r16
    32e8:	1f 93       	push	r17
    32ea:	2f 93       	push	r18
    32ec:	3f 93       	push	r19
    32ee:	4f 93       	push	r20
    32f0:	5f 93       	push	r21
    32f2:	6f 93       	push	r22
    32f4:	7f 93       	push	r23
    32f6:	8f 93       	push	r24
    32f8:	9f 93       	push	r25
    32fa:	af 93       	push	r26
    32fc:	bf 93       	push	r27
    32fe:	cf 93       	push	r28
    3300:	df 93       	push	r29
    3302:	ef 93       	push	r30
    3304:	ff 93       	push	r31
    3306:	a0 91 b9 07 	lds	r26, 0x07B9
    330a:	b0 91 ba 07 	lds	r27, 0x07BA
    330e:	0d b6       	in	r0, 0x3d	; 61
    3310:	0d 92       	st	X+, r0
    3312:	0e b6       	in	r0, 0x3e	; 62
    3314:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3316:	0e 94 72 25 	call	0x4ae4	; 0x4ae4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    331a:	a0 91 b9 07 	lds	r26, 0x07B9
    331e:	b0 91 ba 07 	lds	r27, 0x07BA
    3322:	cd 91       	ld	r28, X+
    3324:	cd bf       	out	0x3d, r28	; 61
    3326:	dd 91       	ld	r29, X+
    3328:	de bf       	out	0x3e, r29	; 62
    332a:	ff 91       	pop	r31
    332c:	ef 91       	pop	r30
    332e:	df 91       	pop	r29
    3330:	cf 91       	pop	r28
    3332:	bf 91       	pop	r27
    3334:	af 91       	pop	r26
    3336:	9f 91       	pop	r25
    3338:	8f 91       	pop	r24
    333a:	7f 91       	pop	r23
    333c:	6f 91       	pop	r22
    333e:	5f 91       	pop	r21
    3340:	4f 91       	pop	r20
    3342:	3f 91       	pop	r19
    3344:	2f 91       	pop	r18
    3346:	1f 91       	pop	r17
    3348:	0f 91       	pop	r16
    334a:	ff 90       	pop	r15
    334c:	ef 90       	pop	r14
    334e:	df 90       	pop	r13
    3350:	cf 90       	pop	r12
    3352:	bf 90       	pop	r11
    3354:	af 90       	pop	r10
    3356:	9f 90       	pop	r9
    3358:	8f 90       	pop	r8
    335a:	7f 90       	pop	r7
    335c:	6f 90       	pop	r6
    335e:	5f 90       	pop	r5
    3360:	4f 90       	pop	r4
    3362:	3f 90       	pop	r3
    3364:	2f 90       	pop	r2
    3366:	1f 90       	pop	r1
    3368:	0f 90       	pop	r0
    336a:	0f be       	out	0x3f, r0	; 63
    336c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    336e:	08 95       	ret

00003370 <xEventGroupClearBits>:
}
/*-----------------------------------------------------------*/

EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup,
                                  const EventBits_t uxBitsToClear )
{
    3370:	fc 01       	movw	r30, r24
    /* Check the user is not attempting to clear the bits used by the kernel
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    taskENTER_CRITICAL();
    3372:	0f b6       	in	r0, 0x3f	; 63
    3374:	f8 94       	cli
    3376:	0f 92       	push	r0
    {
        traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );

        /* The value returned is the event group value prior to the bits being
         * cleared. */
        uxReturn = pxEventBits->uxEventBits;
    3378:	20 81       	ld	r18, Z
    337a:	31 81       	ldd	r19, Z+1	; 0x01

        /* Clear the bits. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    337c:	60 95       	com	r22
    337e:	70 95       	com	r23
    3380:	62 23       	and	r22, r18
    3382:	73 23       	and	r23, r19
    3384:	71 83       	std	Z+1, r23	; 0x01
    3386:	60 83       	st	Z, r22
    }
    taskEXIT_CRITICAL();
    3388:	0f 90       	pop	r0
    338a:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
}
    338c:	82 2f       	mov	r24, r18
    338e:	93 2f       	mov	r25, r19
    3390:	08 95       	ret

00003392 <xEventGroupGetBitsFromISR>:

#endif /* if ( ( configUSE_TRACE_FACILITY == 1 ) && ( INCLUDE_xTimerPendFunctionCall == 1 ) && ( configUSE_TIMERS == 1 ) ) */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
{
    3392:	fc 01       	movw	r30, r24
        uxReturn = pxEventBits->uxEventBits;
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return uxReturn;
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
    3394:	80 81       	ld	r24, Z
    3396:	91 81       	ldd	r25, Z+1	; 0x01
    3398:	08 95       	ret

0000339a <vEventGroupClearBitsCallback>:
/* For internal use only - execute a 'clear bits' command that was pended from
 * an interrupt. */
void vEventGroupClearBitsCallback( void * pvEventGroup,
                                   const uint32_t ulBitsToClear )
{
    ( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    339a:	ba 01       	movw	r22, r20
    339c:	0e 94 b8 19 	call	0x3370	; 0x3370 <xEventGroupClearBits>
}
    33a0:	08 95       	ret

000033a2 <prvTestWaitCondition>:
                                        const EventBits_t uxBitsToWaitFor,
                                        const BaseType_t xWaitForAllBits )
{
    BaseType_t xWaitConditionMet = pdFALSE;

    if( xWaitForAllBits == pdFALSE )
    33a2:	44 23       	and	r20, r20
    33a4:	39 f4       	brne	.+14     	; 0x33b4 <prvTestWaitCondition+0x12>
    33a6:	20 e0       	ldi	r18, 0x00	; 0
    33a8:	86 23       	and	r24, r22
    33aa:	97 23       	and	r25, r23
    33ac:	89 2b       	or	r24, r25
    33ae:	49 f0       	breq	.+18     	; 0x33c2 <prvTestWaitCondition+0x20>
    33b0:	21 e0       	ldi	r18, 0x01	; 1
    33b2:	07 c0       	rjmp	.+14     	; 0x33c2 <prvTestWaitCondition+0x20>
    33b4:	20 e0       	ldi	r18, 0x00	; 0
    33b6:	86 23       	and	r24, r22
    33b8:	97 23       	and	r25, r23
    33ba:	86 17       	cp	r24, r22
    33bc:	97 07       	cpc	r25, r23
    33be:	09 f4       	brne	.+2      	; 0x33c2 <prvTestWaitCondition+0x20>
    33c0:	21 e0       	ldi	r18, 0x01	; 1
            mtCOVERAGE_TEST_MARKER();
        }
    }

    return xWaitConditionMet;
}
    33c2:	82 2f       	mov	r24, r18
    33c4:	08 95       	ret

000033c6 <xEventGroupSetBits>:
} /*lint !e818 EventGroupHandle_t is a typedef used in other functions to so can't be pointer to const. */
/*-----------------------------------------------------------*/

EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup,
                                const EventBits_t uxBitsToSet )
{
    33c6:	cf 92       	push	r12
    33c8:	df 92       	push	r13
    33ca:	ef 92       	push	r14
    33cc:	ff 92       	push	r15
    33ce:	0f 93       	push	r16
    33d0:	1f 93       	push	r17
    33d2:	cf 93       	push	r28
    33d4:	df 93       	push	r29
    33d6:	ec 01       	movw	r28, r24
    33d8:	8b 01       	movw	r16, r22
     * itself. */
    configASSERT( xEventGroup );
    configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );

    pxList = &( pxEventBits->xTasksWaitingForBits );
    pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    33da:	0f 2e       	mov	r0, r31
    33dc:	f5 e0       	ldi	r31, 0x05	; 5
    33de:	cf 2e       	mov	r12, r31
    33e0:	dd 24       	eor	r13, r13
    33e2:	f0 2d       	mov	r31, r0
    33e4:	c8 0e       	add	r12, r24
    33e6:	d9 1e       	adc	r13, r25
    vTaskSuspendAll();
    33e8:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );

        pxListItem = listGET_HEAD_ENTRY( pxList );
    33ec:	ef 81       	ldd	r30, Y+7	; 0x07
    33ee:	f8 85       	ldd	r31, Y+8	; 0x08

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;
    33f0:	88 81       	ld	r24, Y
    33f2:	99 81       	ldd	r25, Y+1	; 0x01
    33f4:	80 2b       	or	r24, r16
    33f6:	91 2b       	or	r25, r17
    33f8:	99 83       	std	Y+1, r25	; 0x01
    33fa:	88 83       	st	Y, r24

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    33fc:	ce 16       	cp	r12, r30
    33fe:	df 06       	cpc	r13, r31
    3400:	49 f1       	breq	.+82     	; 0x3454 <xEventGroupSetBits+0x8e>
    3402:	ee 24       	eor	r14, r14
    3404:	ff 24       	eor	r15, r15
        {
            pxNext = listGET_NEXT( pxListItem );
    3406:	02 81       	ldd	r16, Z+2	; 0x02
    3408:	13 81       	ldd	r17, Z+3	; 0x03
            uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
    340a:	80 81       	ld	r24, Z
    340c:	91 81       	ldd	r25, Z+1	; 0x01
            xMatchFound = pdFALSE;

            /* Split the bits waited for from the control bits. */
            uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
    340e:	ac 01       	movw	r20, r24
    3410:	40 70       	andi	r20, 0x00	; 0
            uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
    3412:	9c 01       	movw	r18, r24
    3414:	30 70       	andi	r19, 0x00	; 0

            if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
    3416:	92 fd       	sbrc	r25, 2
    3418:	07 c0       	rjmp	.+14     	; 0x3428 <xEventGroupSetBits+0x62>
            {
                /* Just looking for single bit being set. */
                if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
    341a:	88 81       	ld	r24, Y
    341c:	99 81       	ldd	r25, Y+1	; 0x01
    341e:	82 23       	and	r24, r18
    3420:	93 23       	and	r25, r19
    3422:	89 2b       	or	r24, r25
    3424:	41 f4       	brne	.+16     	; 0x3436 <xEventGroupSetBits+0x70>
    3426:	11 c0       	rjmp	.+34     	; 0x344a <xEventGroupSetBits+0x84>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
    3428:	88 81       	ld	r24, Y
    342a:	99 81       	ldd	r25, Y+1	; 0x01
    342c:	82 23       	and	r24, r18
    342e:	93 23       	and	r25, r19
    3430:	82 17       	cp	r24, r18
    3432:	93 07       	cpc	r25, r19
    3434:	51 f4       	brne	.+20     	; 0x344a <xEventGroupSetBits+0x84>
            }

            if( xMatchFound != pdFALSE )
            {
                /* The bits match.  Should the bits be cleared on exit? */
                if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
    3436:	50 ff       	sbrs	r21, 0
    3438:	02 c0       	rjmp	.+4      	; 0x343e <xEventGroupSetBits+0x78>
                {
                    uxBitsToClear |= uxBitsWaitedFor;
    343a:	e2 2a       	or	r14, r18
    343c:	f3 2a       	or	r15, r19
                /* Store the actual event flag value in the task's event list
                 * item before removing the task from the event list.  The
                 * eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
                 * that is was unblocked due to its required bits matching, rather
                 * than because it timed out. */
                vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
    343e:	68 81       	ld	r22, Y
    3440:	79 81       	ldd	r23, Y+1	; 0x01
    3442:	72 60       	ori	r23, 0x02	; 2
    3444:	cf 01       	movw	r24, r30
    3446:	0e 94 6f 26 	call	0x4cde	; 0x4cde <vTaskRemoveFromUnorderedEventList>

        /* Set the bits. */
        pxEventBits->uxEventBits |= uxBitsToSet;

        /* See if the new bit value should unblock any tasks. */
        while( pxListItem != pxListEnd )
    344a:	c0 16       	cp	r12, r16
    344c:	d1 06       	cpc	r13, r17
    344e:	21 f0       	breq	.+8      	; 0x3458 <xEventGroupSetBits+0x92>
    3450:	f8 01       	movw	r30, r16
    3452:	d9 cf       	rjmp	.-78     	; 0x3406 <xEventGroupSetBits+0x40>
    3454:	ee 24       	eor	r14, r14
    3456:	ff 24       	eor	r15, r15
            pxListItem = pxNext;
        }

        /* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
         * bit was set in the control word. */
        pxEventBits->uxEventBits &= ~uxBitsToClear;
    3458:	97 01       	movw	r18, r14
    345a:	20 95       	com	r18
    345c:	30 95       	com	r19
    345e:	88 81       	ld	r24, Y
    3460:	99 81       	ldd	r25, Y+1	; 0x01
    3462:	82 23       	and	r24, r18
    3464:	93 23       	and	r25, r19
    3466:	99 83       	std	Y+1, r25	; 0x01
    3468:	88 83       	st	Y, r24
    }
    ( void ) xTaskResumeAll();
    346a:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>

    return pxEventBits->uxEventBits;
}
    346e:	88 81       	ld	r24, Y
    3470:	99 81       	ldd	r25, Y+1	; 0x01
    3472:	df 91       	pop	r29
    3474:	cf 91       	pop	r28
    3476:	1f 91       	pop	r17
    3478:	0f 91       	pop	r16
    347a:	ff 90       	pop	r15
    347c:	ef 90       	pop	r14
    347e:	df 90       	pop	r13
    3480:	cf 90       	pop	r12
    3482:	08 95       	ret

00003484 <vEventGroupSetBitsCallback>:
/* For internal use only - execute a 'set bits' command that was pended from
 * an interrupt. */
void vEventGroupSetBitsCallback( void * pvEventGroup,
                                 const uint32_t ulBitsToSet )
{
    ( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet ); /*lint !e9079 Can't avoid cast to void* as a generic timer callback prototype. Callback casts back to original type so safe. */
    3484:	ba 01       	movw	r22, r20
    3486:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <xEventGroupSetBits>
}
    348a:	08 95       	ret

0000348c <vEventGroupDelete>:
    return pxEventBits->uxEventBits;
}
/*-----------------------------------------------------------*/

void vEventGroupDelete( EventGroupHandle_t xEventGroup )
{
    348c:	cf 93       	push	r28
    348e:	df 93       	push	r29
    3490:	ec 01       	movw	r28, r24

    configASSERT( pxEventBits );

    pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );

    vTaskSuspendAll();
    3492:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <vTaskSuspendAll>
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    3496:	8a 81       	ldd	r24, Y+2	; 0x02
    3498:	88 23       	and	r24, r24
    349a:	49 f0       	breq	.+18     	; 0x34ae <vEventGroupDelete+0x22>
        {
            /* Unblock the task, returning 0 as the event list is being deleted
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
    349c:	8f 81       	ldd	r24, Y+7	; 0x07
    349e:	98 85       	ldd	r25, Y+8	; 0x08
    34a0:	60 e0       	ldi	r22, 0x00	; 0
    34a2:	72 e0       	ldi	r23, 0x02	; 2
    34a4:	0e 94 6f 26 	call	0x4cde	; 0x4cde <vTaskRemoveFromUnorderedEventList>

    vTaskSuspendAll();
    {
        traceEVENT_GROUP_DELETE( xEventGroup );

        while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
    34a8:	8a 81       	ldd	r24, Y+2	; 0x02
    34aa:	88 23       	and	r24, r24
    34ac:	b9 f7       	brne	.-18     	; 0x349c <vEventGroupDelete+0x10>
             * and cannot therefore have any bits set. */
            configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
            vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
        }
    }
    ( void ) xTaskResumeAll();
    34ae:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The event group can only have been allocated dynamically - free
         * it again. */
        vPortFree( pxEventBits );
    34b2:	ce 01       	movw	r24, r28
    34b4:	0e 94 37 18 	call	0x306e	; 0x306e <vPortFree>
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    34b8:	df 91       	pop	r29
    34ba:	cf 91       	pop	r28
    34bc:	08 95       	ret

000034be <xEventGroupWaitBits>:
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                                 const EventBits_t uxBitsToWaitFor,
                                 const BaseType_t xClearOnExit,
                                 const BaseType_t xWaitForAllBits,
                                 TickType_t xTicksToWait )
{
    34be:	af 92       	push	r10
    34c0:	bf 92       	push	r11
    34c2:	cf 92       	push	r12
    34c4:	df 92       	push	r13
    34c6:	ef 92       	push	r14
    34c8:	ff 92       	push	r15
    34ca:	0f 93       	push	r16
    34cc:	1f 93       	push	r17
    34ce:	cf 93       	push	r28
    34d0:	df 93       	push	r29
    34d2:	6c 01       	movw	r12, r24
    34d4:	7b 01       	movw	r14, r22
    34d6:	a4 2e       	mov	r10, r20
    34d8:	b2 2e       	mov	r11, r18
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
    34da:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <vTaskSuspendAll>
    {
        const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
    34de:	f6 01       	movw	r30, r12
    34e0:	c0 81       	ld	r28, Z
    34e2:	d1 81       	ldd	r29, Z+1	; 0x01

        /* Check to see if the wait condition is already met or not. */
        xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
    34e4:	ce 01       	movw	r24, r28
    34e6:	b7 01       	movw	r22, r14
    34e8:	4b 2d       	mov	r20, r11
    34ea:	0e 94 d1 19 	call	0x33a2	; 0x33a2 <prvTestWaitCondition>

        if( xWaitConditionMet != pdFALSE )
    34ee:	88 23       	and	r24, r24
    34f0:	59 f0       	breq	.+22     	; 0x3508 <xEventGroupWaitBits+0x4a>
             * block. */
            uxReturn = uxCurrentEventBits;
            xTicksToWait = ( TickType_t ) 0;

            /* Clear the wait bits if requested to do so. */
            if( xClearOnExit != pdFALSE )
    34f2:	aa 20       	and	r10, r10
    34f4:	09 f1       	breq	.+66     	; 0x3538 <xEventGroupWaitBits+0x7a>
            {
                pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    34f6:	c7 01       	movw	r24, r14
    34f8:	80 95       	com	r24
    34fa:	90 95       	com	r25
    34fc:	8c 23       	and	r24, r28
    34fe:	9d 23       	and	r25, r29
    3500:	f6 01       	movw	r30, r12
    3502:	91 83       	std	Z+1, r25	; 0x01
    3504:	80 83       	st	Z, r24
    3506:	18 c0       	rjmp	.+48     	; 0x3538 <xEventGroupWaitBits+0x7a>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        else if( xTicksToWait == ( TickType_t ) 0 )
    3508:	01 15       	cp	r16, r1
    350a:	11 05       	cpc	r17, r1
    350c:	a9 f0       	breq	.+42     	; 0x3538 <xEventGroupWaitBits+0x7a>
        {
            /* The task is going to block to wait for its required bits to be
             * set.  uxControlBits are used to remember the specified behaviour of
             * this call to xEventGroupWaitBits() - for use when the event bits
             * unblock the task. */
            if( xClearOnExit != pdFALSE )
    350e:	aa 20       	and	r10, r10
    3510:	19 f0       	breq	.+6      	; 0x3518 <xEventGroupWaitBits+0x5a>
    3512:	60 e0       	ldi	r22, 0x00	; 0
    3514:	71 e0       	ldi	r23, 0x01	; 1
    3516:	02 c0       	rjmp	.+4      	; 0x351c <xEventGroupWaitBits+0x5e>
    3518:	60 e0       	ldi	r22, 0x00	; 0
    351a:	70 e0       	ldi	r23, 0x00	; 0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            if( xWaitForAllBits != pdFALSE )
    351c:	b1 10       	cpse	r11, r1
            {
                uxControlBits |= eventWAIT_FOR_ALL_BITS;
    351e:	74 60       	ori	r23, 0x04	; 4
            }

            /* Store the bits that the calling task is waiting for in the
             * task's event list item so the kernel knows when a match is
             * found.  Then enter the blocked state. */
            vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
    3520:	6e 29       	or	r22, r14
    3522:	7f 29       	or	r23, r15
    3524:	c6 01       	movw	r24, r12
    3526:	02 96       	adiw	r24, 0x02	; 2
    3528:	a8 01       	movw	r20, r16
    352a:	0e 94 6b 2e 	call	0x5cd6	; 0x5cd6 <vTaskPlaceOnUnorderedEventList>
            uxReturn = 0;

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    352e:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>

    if( xTicksToWait != ( TickType_t ) 0 )
    {
        if( xAlreadyYielded == pdFALSE )
    3532:	88 23       	and	r24, r24
    3534:	39 f4       	brne	.+14     	; 0x3544 <xEventGroupWaitBits+0x86>
    3536:	04 c0       	rjmp	.+8      	; 0x3540 <xEventGroupWaitBits+0x82>
            uxReturn = 0;

            traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    3538:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>
    353c:	9e 01       	movw	r18, r28
    353e:	22 c0       	rjmp	.+68     	; 0x3584 <xEventGroupWaitBits+0xc6>

    if( xTicksToWait != ( TickType_t ) 0 )
    {
        if( xAlreadyYielded == pdFALSE )
        {
            portYIELD_WITHIN_API();
    3540:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    3544:	0e 94 9b 28 	call	0x5136	; 0x5136 <uxTaskResetEventItemValue>
    3548:	ec 01       	movw	r28, r24

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    354a:	91 fd       	sbrc	r25, 1
    354c:	19 c0       	rjmp	.+50     	; 0x3580 <xEventGroupWaitBits+0xc2>
        {
            taskENTER_CRITICAL();
    354e:	0f b6       	in	r0, 0x3f	; 63
    3550:	f8 94       	cli
    3552:	0f 92       	push	r0
            {
                /* The task timed out, just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    3554:	f6 01       	movw	r30, r12
    3556:	c0 81       	ld	r28, Z
    3558:	d1 81       	ldd	r29, Z+1	; 0x01

                /* It is possible that the event bits were updated between this
                 * task leaving the Blocked state and running again. */
                if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
    355a:	ce 01       	movw	r24, r28
    355c:	b7 01       	movw	r22, r14
    355e:	4b 2d       	mov	r20, r11
    3560:	0e 94 d1 19 	call	0x33a2	; 0x33a2 <prvTestWaitCondition>
    3564:	88 23       	and	r24, r24
    3566:	51 f0       	breq	.+20     	; 0x357c <xEventGroupWaitBits+0xbe>
                {
                    if( xClearOnExit != pdFALSE )
    3568:	aa 20       	and	r10, r10
    356a:	41 f0       	breq	.+16     	; 0x357c <xEventGroupWaitBits+0xbe>
                    {
                        pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    356c:	c7 01       	movw	r24, r14
    356e:	80 95       	com	r24
    3570:	90 95       	com	r25
    3572:	8c 23       	and	r24, r28
    3574:	9d 23       	and	r25, r29
    3576:	f6 01       	movw	r30, r12
    3578:	91 83       	std	Z+1, r25	; 0x01
    357a:	80 83       	st	Z, r24
                    mtCOVERAGE_TEST_MARKER();
                }

                xTimeoutOccurred = pdTRUE;
            }
            taskEXIT_CRITICAL();
    357c:	0f 90       	pop	r0
    357e:	0f be       	out	0x3f, r0	; 63
        {
            /* The task unblocked because the bits were set. */
        }

        /* The task blocked so control bits may have been set. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    3580:	9e 01       	movw	r18, r28
    3582:	30 70       	andi	r19, 0x00	; 0

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
}
    3584:	82 2f       	mov	r24, r18
    3586:	93 2f       	mov	r25, r19
    3588:	df 91       	pop	r29
    358a:	cf 91       	pop	r28
    358c:	1f 91       	pop	r17
    358e:	0f 91       	pop	r16
    3590:	ff 90       	pop	r15
    3592:	ef 90       	pop	r14
    3594:	df 90       	pop	r13
    3596:	cf 90       	pop	r12
    3598:	bf 90       	pop	r11
    359a:	af 90       	pop	r10
    359c:	08 95       	ret

0000359e <xEventGroupSync>:

EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                             const EventBits_t uxBitsToSet,
                             const EventBits_t uxBitsToWaitFor,
                             TickType_t xTicksToWait )
{
    359e:	af 92       	push	r10
    35a0:	bf 92       	push	r11
    35a2:	cf 92       	push	r12
    35a4:	df 92       	push	r13
    35a6:	ef 92       	push	r14
    35a8:	ff 92       	push	r15
    35aa:	0f 93       	push	r16
    35ac:	1f 93       	push	r17
    35ae:	cf 93       	push	r28
    35b0:	df 93       	push	r29
    35b2:	ec 01       	movw	r28, r24
    35b4:	7b 01       	movw	r14, r22
    35b6:	6a 01       	movw	r12, r20
    35b8:	59 01       	movw	r10, r18
    {
        configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
    }
    #endif

    vTaskSuspendAll();
    35ba:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <vTaskSuspendAll>
    {
        uxOriginalBitValue = pxEventBits->uxEventBits;
    35be:	08 81       	ld	r16, Y
    35c0:	19 81       	ldd	r17, Y+1	; 0x01

        ( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
    35c2:	ce 01       	movw	r24, r28
    35c4:	b7 01       	movw	r22, r14
    35c6:	0e 94 e3 19 	call	0x33c6	; 0x33c6 <xEventGroupSetBits>

        if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
    35ca:	e0 2a       	or	r14, r16
    35cc:	f1 2a       	or	r15, r17
    35ce:	96 01       	movw	r18, r12
    35d0:	2e 21       	and	r18, r14
    35d2:	3f 21       	and	r19, r15
    35d4:	2c 15       	cp	r18, r12
    35d6:	3d 05       	cpc	r19, r13
    35d8:	49 f4       	brne	.+18     	; 0x35ec <xEventGroupSync+0x4e>
            /* All the rendezvous bits are now set - no need to block. */
            uxReturn = ( uxOriginalBitValue | uxBitsToSet );

            /* Rendezvous always clear the bits.  They will have been cleared
             * already unless this is the only task in the rendezvous. */
            pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    35da:	20 95       	com	r18
    35dc:	30 95       	com	r19
    35de:	88 81       	ld	r24, Y
    35e0:	99 81       	ldd	r25, Y+1	; 0x01
    35e2:	82 23       	and	r24, r18
    35e4:	93 23       	and	r25, r19
    35e6:	99 83       	std	Y+1, r25	; 0x01
    35e8:	88 83       	st	Y, r24
    35ea:	11 c0       	rjmp	.+34     	; 0x360e <xEventGroupSync+0x70>

            xTicksToWait = 0;
        }
        else
        {
            if( xTicksToWait != ( TickType_t ) 0 )
    35ec:	a1 14       	cp	r10, r1
    35ee:	b1 04       	cpc	r11, r1
    35f0:	61 f0       	breq	.+24     	; 0x360a <xEventGroupSync+0x6c>
                traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );

                /* Store the bits that the calling task is waiting for in the
                 * task's event list item so the kernel knows when a match is
                 * found.  Then enter the blocked state. */
                vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
    35f2:	b6 01       	movw	r22, r12
    35f4:	75 60       	ori	r23, 0x05	; 5
    35f6:	ce 01       	movw	r24, r28
    35f8:	02 96       	adiw	r24, 0x02	; 2
    35fa:	a5 01       	movw	r20, r10
    35fc:	0e 94 6b 2e 	call	0x5cd6	; 0x5cd6 <vTaskPlaceOnUnorderedEventList>
                uxReturn = pxEventBits->uxEventBits;
                xTimeoutOccurred = pdTRUE;
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    3600:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>

    if( xTicksToWait != ( TickType_t ) 0 )
    {
        if( xAlreadyYielded == pdFALSE )
    3604:	88 23       	and	r24, r24
    3606:	41 f4       	brne	.+16     	; 0x3618 <xEventGroupSync+0x7a>
    3608:	05 c0       	rjmp	.+10     	; 0x3614 <xEventGroupSync+0x76>
            }
            else
            {
                /* The rendezvous bits were not set, but no block time was
                 * specified - just return the current event bit value. */
                uxReturn = pxEventBits->uxEventBits;
    360a:	e8 80       	ld	r14, Y
    360c:	f9 80       	ldd	r15, Y+1	; 0x01
                xTimeoutOccurred = pdTRUE;
            }
        }
    }
    xAlreadyYielded = xTaskResumeAll();
    360e:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>
    3612:	1d c0       	rjmp	.+58     	; 0x364e <xEventGroupSync+0xb0>

    if( xTicksToWait != ( TickType_t ) 0 )
    {
        if( xAlreadyYielded == pdFALSE )
        {
            portYIELD_WITHIN_API();
    3614:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>

        /* The task blocked to wait for its required bits to be set - at this
         * point either the required bits were set or the block time expired.  If
         * the required bits were set they will have been stored in the task's
         * event list item, and they should now be retrieved then cleared. */
        uxReturn = uxTaskResetEventItemValue();
    3618:	0e 94 9b 28 	call	0x5136	; 0x5136 <uxTaskResetEventItemValue>
    361c:	7c 01       	movw	r14, r24

        if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
    361e:	91 fd       	sbrc	r25, 1
    3620:	13 c0       	rjmp	.+38     	; 0x3648 <xEventGroupSync+0xaa>
        {
            /* The task timed out, just return the current event bit value. */
            taskENTER_CRITICAL();
    3622:	0f b6       	in	r0, 0x3f	; 63
    3624:	f8 94       	cli
    3626:	0f 92       	push	r0
            {
                uxReturn = pxEventBits->uxEventBits;
    3628:	e8 80       	ld	r14, Y
    362a:	f9 80       	ldd	r15, Y+1	; 0x01

                /* Although the task got here because it timed out before the
                 * bits it was waiting for were set, it is possible that since it
                 * unblocked another task has set the bits.  If this is the case
                 * then it needs to clear the bits before exiting. */
                if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
    362c:	c6 01       	movw	r24, r12
    362e:	8e 21       	and	r24, r14
    3630:	9f 21       	and	r25, r15
    3632:	8c 15       	cp	r24, r12
    3634:	9d 05       	cpc	r25, r13
    3636:	31 f4       	brne	.+12     	; 0x3644 <xEventGroupSync+0xa6>
                {
                    pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
    3638:	80 95       	com	r24
    363a:	90 95       	com	r25
    363c:	8e 21       	and	r24, r14
    363e:	9f 21       	and	r25, r15
    3640:	99 83       	std	Y+1, r25	; 0x01
    3642:	88 83       	st	Y, r24
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }
            }
            taskEXIT_CRITICAL();
    3644:	0f 90       	pop	r0
    3646:	0f be       	out	0x3f, r0	; 63
            /* The task unblocked because the bits were set. */
        }

        /* Control bits might be set as the task had blocked should not be
         * returned. */
        uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
    3648:	8f ef       	ldi	r24, 0xFF	; 255
    364a:	e8 22       	and	r14, r24
    364c:	ff 24       	eor	r15, r15

    /* Prevent compiler warnings when trace macros are not used. */
    ( void ) xTimeoutOccurred;

    return uxReturn;
}
    364e:	8e 2d       	mov	r24, r14
    3650:	9f 2d       	mov	r25, r15
    3652:	df 91       	pop	r29
    3654:	cf 91       	pop	r28
    3656:	1f 91       	pop	r17
    3658:	0f 91       	pop	r16
    365a:	ff 90       	pop	r15
    365c:	ef 90       	pop	r14
    365e:	df 90       	pop	r13
    3660:	cf 90       	pop	r12
    3662:	bf 90       	pop	r11
    3664:	af 90       	pop	r10
    3666:	08 95       	ret

00003668 <xEventGroupCreate>:
/*-----------------------------------------------------------*/

#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    EventGroupHandle_t xEventGroupCreate( void )
    {
    3668:	cf 93       	push	r28
    366a:	df 93       	push	r29
         * TickType_t alignment requirements the cast is safe.  In other cases,
         * where the natural word size of the architecture is less than
         * sizeof( TickType_t ), the TickType_t variables will be accessed in two
         * or more reads operations, and the alignment requirements is only that
         * of each individual read. */
        pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) ); /*lint !e9087 !e9079 see comment above. */
    366c:	8b e0       	ldi	r24, 0x0B	; 11
    366e:	90 e0       	ldi	r25, 0x00	; 0
    3670:	0e 94 48 18 	call	0x3090	; 0x3090 <pvPortMalloc>
    3674:	ec 01       	movw	r28, r24

        if( pxEventBits != NULL )
    3676:	20 97       	sbiw	r28, 0x00	; 0
    3678:	31 f0       	breq	.+12     	; 0x3686 <xEventGroupCreate+0x1e>
        {
            pxEventBits->uxEventBits = 0;
    367a:	fe 01       	movw	r30, r28
    367c:	11 92       	st	Z+, r1
    367e:	11 92       	st	Z+, r1
            vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
    3680:	cf 01       	movw	r24, r30
    3682:	0e 94 48 1b 	call	0x3690	; 0x3690 <vListInitialise>
        {
            traceEVENT_GROUP_CREATE_FAILED(); /*lint !e9063 Else branch only exists to allow tracing and does not generate code if trace macros are not defined. */
        }

        return pxEventBits;
    }
    3686:	8c 2f       	mov	r24, r28
    3688:	9d 2f       	mov	r25, r29
    368a:	df 91       	pop	r29
    368c:	cf 91       	pop	r28
    368e:	08 95       	ret

00003690 <vListInitialise>:
/*-----------------------------------------------------------
* PUBLIC LIST API documented in list.h
*----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    3690:	fc 01       	movw	r30, r24
    /* The list structure contains a list item which is used to mark the
     * end of the list.  To initialise the list the list end is inserted
     * as the only list entry. */
    pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    3692:	9c 01       	movw	r18, r24
    3694:	2d 5f       	subi	r18, 0xFD	; 253
    3696:	3f 4f       	sbci	r19, 0xFF	; 255
    3698:	32 83       	std	Z+2, r19	; 0x02
    369a:	21 83       	std	Z+1, r18	; 0x01

    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );

    /* The list end value is the highest possible value in the list to
     * ensure it remains at the end of the list. */
    pxList->xListEnd.xItemValue = portMAX_DELAY;
    369c:	8f ef       	ldi	r24, 0xFF	; 255
    369e:	9f ef       	ldi	r25, 0xFF	; 255
    36a0:	94 83       	std	Z+4, r25	; 0x04
    36a2:	83 83       	std	Z+3, r24	; 0x03

    /* The list end next and previous pointers point to itself so we know
     * when the list is empty. */
    pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );     /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    36a4:	36 83       	std	Z+6, r19	; 0x06
    36a6:	25 83       	std	Z+5, r18	; 0x05
    pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd ); /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    36a8:	30 87       	std	Z+8, r19	; 0x08
    36aa:	27 83       	std	Z+7, r18	; 0x07
        pxList->xListEnd.pxContainer = NULL;
        listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( &( pxList->xListEnd ) );
    }
    #endif

    pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    36ac:	10 82       	st	Z, r1

    /* Write known values into the list if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList );
    listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList );
}
    36ae:	08 95       	ret

000036b0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
    /* Make sure the list item is not recorded as being on a list. */
    pxItem->pxContainer = NULL;
    36b0:	fc 01       	movw	r30, r24
    36b2:	11 86       	std	Z+9, r1	; 0x09
    36b4:	10 86       	std	Z+8, r1	; 0x08

    /* Write known values into the list item if
     * configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
    listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
    listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
    36b6:	08 95       	ret

000036b8 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList,
                     ListItem_t * const pxNewListItem )
{
    36b8:	ac 01       	movw	r20, r24
    ListItem_t * const pxIndex = pxList->pxIndex;
    36ba:	fc 01       	movw	r30, r24
    36bc:	a1 81       	ldd	r26, Z+1	; 0x01
    36be:	b2 81       	ldd	r27, Z+2	; 0x02
    listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

    /* Insert a new list item into pxList, but rather than sort the list,
     * makes the new list item the last item to be removed by a call to
     * listGET_OWNER_OF_NEXT_ENTRY(). */
    pxNewListItem->pxNext = pxIndex;
    36c0:	fb 01       	movw	r30, r22
    36c2:	b3 83       	std	Z+3, r27	; 0x03
    36c4:	a2 83       	std	Z+2, r26	; 0x02
    pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    36c6:	14 96       	adiw	r26, 0x04	; 4
    36c8:	8d 91       	ld	r24, X+
    36ca:	9c 91       	ld	r25, X
    36cc:	15 97       	sbiw	r26, 0x05	; 5
    36ce:	95 83       	std	Z+5, r25	; 0x05
    36d0:	84 83       	std	Z+4, r24	; 0x04

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    pxIndex->pxPrevious->pxNext = pxNewListItem;
    36d2:	14 96       	adiw	r26, 0x04	; 4
    36d4:	ed 91       	ld	r30, X+
    36d6:	fc 91       	ld	r31, X
    36d8:	15 97       	sbiw	r26, 0x05	; 5
    36da:	73 83       	std	Z+3, r23	; 0x03
    36dc:	62 83       	std	Z+2, r22	; 0x02
    pxIndex->pxPrevious = pxNewListItem;
    36de:	15 96       	adiw	r26, 0x05	; 5
    36e0:	7c 93       	st	X, r23
    36e2:	6e 93       	st	-X, r22
    36e4:	14 97       	sbiw	r26, 0x04	; 4

    /* Remember which list the item is in. */
    pxNewListItem->pxContainer = pxList;
    36e6:	fb 01       	movw	r30, r22
    36e8:	51 87       	std	Z+9, r21	; 0x09
    36ea:	40 87       	std	Z+8, r20	; 0x08

    ( pxList->uxNumberOfItems )++;
    36ec:	fa 01       	movw	r30, r20
    36ee:	80 81       	ld	r24, Z
    36f0:	8f 5f       	subi	r24, 0xFF	; 255
    36f2:	80 83       	st	Z, r24
}
    36f4:	08 95       	ret

000036f6 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList,
                  ListItem_t * const pxNewListItem )
{
    36f6:	cf 93       	push	r28
    36f8:	df 93       	push	r29
    36fa:	ac 01       	movw	r20, r24
    36fc:	eb 01       	movw	r28, r22
    ListItem_t * pxIterator;
    const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    36fe:	28 81       	ld	r18, Y
    3700:	39 81       	ldd	r19, Y+1	; 0x01
     * new list item should be placed after it.  This ensures that TCBs which are
     * stored in ready lists (all of which have the same xItemValue value) get a
     * share of the CPU.  However, if the xItemValue is the same as the back marker
     * the iteration loop below will not end.  Therefore the value is checked
     * first, and the algorithm slightly modified if necessary. */
    if( xValueOfInsertion == portMAX_DELAY )
    3702:	8f ef       	ldi	r24, 0xFF	; 255
    3704:	2f 3f       	cpi	r18, 0xFF	; 255
    3706:	38 07       	cpc	r19, r24
    3708:	21 f4       	brne	.+8      	; 0x3712 <vListInsert+0x1c>
    {
        pxIterator = pxList->xListEnd.pxPrevious;
    370a:	fa 01       	movw	r30, r20
    370c:	a7 81       	ldd	r26, Z+7	; 0x07
    370e:	b0 85       	ldd	r27, Z+8	; 0x08
    3710:	0d c0       	rjmp	.+26     	; 0x372c <vListInsert+0x36>
        *   5) If the FreeRTOS port supports interrupt nesting then ensure that
        *      the priority of the tick interrupt is at or below
        *      configMAX_SYSCALL_INTERRUPT_PRIORITY.
        **********************************************************************/

        for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    3712:	da 01       	movw	r26, r20
    3714:	13 96       	adiw	r26, 0x03	; 3
    3716:	12 96       	adiw	r26, 0x02	; 2
    3718:	ed 91       	ld	r30, X+
    371a:	fc 91       	ld	r31, X
    371c:	13 97       	sbiw	r26, 0x03	; 3
    371e:	80 81       	ld	r24, Z
    3720:	91 81       	ldd	r25, Z+1	; 0x01
    3722:	28 17       	cp	r18, r24
    3724:	39 07       	cpc	r19, r25
    3726:	10 f0       	brcs	.+4      	; 0x372c <vListInsert+0x36>
    3728:	df 01       	movw	r26, r30
    372a:	f5 cf       	rjmp	.-22     	; 0x3716 <vListInsert+0x20>
            /* There is nothing to do here, just iterating to the wanted
             * insertion position. */
        }
    }

    pxNewListItem->pxNext = pxIterator->pxNext;
    372c:	12 96       	adiw	r26, 0x02	; 2
    372e:	ed 91       	ld	r30, X+
    3730:	fc 91       	ld	r31, X
    3732:	13 97       	sbiw	r26, 0x03	; 3
    3734:	fb 83       	std	Y+3, r31	; 0x03
    3736:	ea 83       	std	Y+2, r30	; 0x02
    pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    3738:	d5 83       	std	Z+5, r29	; 0x05
    373a:	c4 83       	std	Z+4, r28	; 0x04
    pxNewListItem->pxPrevious = pxIterator;
    373c:	bd 83       	std	Y+5, r27	; 0x05
    373e:	ac 83       	std	Y+4, r26	; 0x04
    pxIterator->pxNext = pxNewListItem;
    3740:	13 96       	adiw	r26, 0x03	; 3
    3742:	dc 93       	st	X, r29
    3744:	ce 93       	st	-X, r28
    3746:	12 97       	sbiw	r26, 0x02	; 2

    /* Remember which list the item is in.  This allows fast removal of the
     * item later. */
    pxNewListItem->pxContainer = pxList;
    3748:	59 87       	std	Y+9, r21	; 0x09
    374a:	48 87       	std	Y+8, r20	; 0x08

    ( pxList->uxNumberOfItems )++;
    374c:	fa 01       	movw	r30, r20
    374e:	80 81       	ld	r24, Z
    3750:	8f 5f       	subi	r24, 0xFF	; 255
    3752:	80 83       	st	Z, r24
}
    3754:	df 91       	pop	r29
    3756:	cf 91       	pop	r28
    3758:	08 95       	ret

0000375a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    375a:	cf 93       	push	r28
    375c:	df 93       	push	r29
    375e:	ec 01       	movw	r28, r24
/* The list item knows which list it is in.  Obtain the list from the list
 * item. */
    List_t * const pxList = pxItemToRemove->pxContainer;
    3760:	28 85       	ldd	r18, Y+8	; 0x08
    3762:	39 85       	ldd	r19, Y+9	; 0x09

    pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3764:	ea 81       	ldd	r30, Y+2	; 0x02
    3766:	fb 81       	ldd	r31, Y+3	; 0x03
    3768:	8c 81       	ldd	r24, Y+4	; 0x04
    376a:	9d 81       	ldd	r25, Y+5	; 0x05
    376c:	95 83       	std	Z+5, r25	; 0x05
    376e:	84 83       	std	Z+4, r24	; 0x04
    pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    3770:	ac 81       	ldd	r26, Y+4	; 0x04
    3772:	bd 81       	ldd	r27, Y+5	; 0x05
    3774:	13 96       	adiw	r26, 0x03	; 3
    3776:	fc 93       	st	X, r31
    3778:	ee 93       	st	-X, r30
    377a:	12 97       	sbiw	r26, 0x02	; 2

    /* Only used during decision coverage testing. */
    mtCOVERAGE_TEST_DELAY();

    /* Make sure the index is left pointing to a valid item. */
    if( pxList->pxIndex == pxItemToRemove )
    377c:	d9 01       	movw	r26, r18
    377e:	11 96       	adiw	r26, 0x01	; 1
    3780:	ed 91       	ld	r30, X+
    3782:	fc 91       	ld	r31, X
    3784:	12 97       	sbiw	r26, 0x02	; 2
    3786:	ec 17       	cp	r30, r28
    3788:	fd 07       	cpc	r31, r29
    378a:	31 f4       	brne	.+12     	; 0x3798 <uxListRemove+0x3e>
    {
        pxList->pxIndex = pxItemToRemove->pxPrevious;
    378c:	84 81       	ldd	r24, Z+4	; 0x04
    378e:	95 81       	ldd	r25, Z+5	; 0x05
    3790:	12 96       	adiw	r26, 0x02	; 2
    3792:	9c 93       	st	X, r25
    3794:	8e 93       	st	-X, r24
    3796:	11 97       	sbiw	r26, 0x01	; 1
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxItemToRemove->pxContainer = NULL;
    3798:	19 86       	std	Y+9, r1	; 0x09
    379a:	18 86       	std	Y+8, r1	; 0x08
    ( pxList->uxNumberOfItems )--;
    379c:	f9 01       	movw	r30, r18
    379e:	80 81       	ld	r24, Z
    37a0:	81 50       	subi	r24, 0x01	; 1
    37a2:	80 83       	st	Z, r24

    return pxList->uxNumberOfItems;
    37a4:	80 81       	ld	r24, Z
}
    37a6:	df 91       	pop	r29
    37a8:	cf 91       	pop	r28
    37aa:	08 95       	ret

000037ac <uxQueueMessagesWaiting>:
    return xReturn;
}
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
{
    37ac:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;

    configASSERT( xQueue );

    taskENTER_CRITICAL();
    37ae:	0f b6       	in	r0, 0x3f	; 63
    37b0:	f8 94       	cli
    37b2:	0f 92       	push	r0
    {
        uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
    37b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
    37b6:	0f 90       	pop	r0
    37b8:	0f be       	out	0x3f, r0	; 63

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    37ba:	08 95       	ret

000037bc <uxQueueSpacesAvailable>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
{
    37bc:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    taskENTER_CRITICAL();
    37be:	0f b6       	in	r0, 0x3f	; 63
    37c0:	f8 94       	cli
    37c2:	0f 92       	push	r0
    {
        uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
    37c4:	92 8d       	ldd	r25, Z+26	; 0x1a
    }
    taskEXIT_CRITICAL();
    37c6:	0f 90       	pop	r0
    37c8:	0f be       	out	0x3f, r0	; 63
    37ca:	83 8d       	ldd	r24, Z+27	; 0x1b

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    37cc:	89 1b       	sub	r24, r25
    37ce:	08 95       	ret

000037d0 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
{
    37d0:	fc 01       	movw	r30, r24
    UBaseType_t uxReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );
    uxReturn = pxQueue->uxMessagesWaiting;
    37d2:	82 8d       	ldd	r24, Z+26	; 0x1a

    return uxReturn;
} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
    37d4:	08 95       	ret

000037d6 <prvIsQueueEmpty>:
    taskEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t * pxQueue )
{
    37d6:	fc 01       	movw	r30, r24
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    37d8:	0f b6       	in	r0, 0x3f	; 63
    37da:	f8 94       	cli
    37dc:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    37de:	82 8d       	ldd	r24, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    37e0:	0f 90       	pop	r0
    37e2:	0f be       	out	0x3f, r0	; 63
    37e4:	90 e0       	ldi	r25, 0x00	; 0
    37e6:	88 23       	and	r24, r24
    37e8:	09 f4       	brne	.+2      	; 0x37ec <prvIsQueueEmpty+0x16>
    37ea:	91 e0       	ldi	r25, 0x01	; 1

    return xReturn;
}
    37ec:	89 2f       	mov	r24, r25
    37ee:	08 95       	ret

000037f0 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
{
    37f0:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
    37f2:	82 8d       	ldd	r24, Z+26	; 0x1a
    37f4:	90 e0       	ldi	r25, 0x00	; 0
    37f6:	88 23       	and	r24, r24
    37f8:	09 f4       	brne	.+2      	; 0x37fc <xQueueIsQueueEmptyFromISR+0xc>
    37fa:	91 e0       	ldi	r25, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    37fc:	89 2f       	mov	r24, r25
    37fe:	08 95       	ret

00003800 <xQueueIsQueueFullFromISR>:
    return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
{
    3800:	fc 01       	movw	r30, r24
    BaseType_t xReturn;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3802:	92 8d       	ldd	r25, Z+26	; 0x1a
    3804:	20 e0       	ldi	r18, 0x00	; 0
    3806:	83 8d       	ldd	r24, Z+27	; 0x1b
    3808:	98 17       	cp	r25, r24
    380a:	09 f4       	brne	.+2      	; 0x380e <xQueueIsQueueFullFromISR+0xe>
    380c:	21 e0       	ldi	r18, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    380e:	82 2f       	mov	r24, r18
    3810:	08 95       	ret

00003812 <vQueueDelete>:

    #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
    {
        /* The queue can only have been allocated dynamically - free it
         * again. */
        vPortFree( pxQueue );
    3812:	0e 94 37 18 	call	0x306e	; 0x306e <vPortFree>
        /* The queue must have been statically allocated, so is not going to be
         * deleted.  Avoid compiler warnings about the unused parameter. */
        ( void ) pxQueue;
    }
    #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
}
    3816:	08 95       	ret

00003818 <prvCopyDataFromQueue>:
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue,
                                  void * const pvBuffer )
{
    3818:	fc 01       	movw	r30, r24
    381a:	56 2f       	mov	r21, r22
    381c:	a7 2f       	mov	r26, r23
    if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    381e:	24 8d       	ldd	r18, Z+28	; 0x1c
    3820:	22 23       	and	r18, r18
    3822:	b9 f0       	breq	.+46     	; 0x3852 <prvCopyDataFromQueue+0x3a>
    {
        pxQueue->u.xQueue.pcReadFrom += pxQueue->uxItemSize;           /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    3824:	86 81       	ldd	r24, Z+6	; 0x06
    3826:	97 81       	ldd	r25, Z+7	; 0x07
    3828:	82 0f       	add	r24, r18
    382a:	91 1d       	adc	r25, r1
    382c:	97 83       	std	Z+7, r25	; 0x07
    382e:	86 83       	std	Z+6, r24	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom >= pxQueue->u.xQueue.pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3830:	24 81       	ldd	r18, Z+4	; 0x04
    3832:	35 81       	ldd	r19, Z+5	; 0x05
    3834:	82 17       	cp	r24, r18
    3836:	93 07       	cpc	r25, r19
    3838:	20 f0       	brcs	.+8      	; 0x3842 <prvCopyDataFromQueue+0x2a>
        {
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead;
    383a:	80 81       	ld	r24, Z
    383c:	91 81       	ldd	r25, Z+1	; 0x01
    383e:	97 83       	std	Z+7, r25	; 0x07
    3840:	86 83       	std	Z+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        ( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.xQueue.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3842:	44 8d       	ldd	r20, Z+28	; 0x1c
    3844:	66 81       	ldd	r22, Z+6	; 0x06
    3846:	77 81       	ldd	r23, Z+7	; 0x07
    3848:	85 2f       	mov	r24, r21
    384a:	9a 2f       	mov	r25, r26
    384c:	50 e0       	ldi	r21, 0x00	; 0
    384e:	0e 94 ab 32 	call	0x6556	; 0x6556 <memcpy>
    3852:	08 95       	ret

00003854 <xQueuePeekFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,
                              void * const pvBuffer )
{
    3854:	0f 93       	push	r16
    3856:	1f 93       	push	r17
    3858:	cf 93       	push	r28
    385a:	df 93       	push	r29
    385c:	ec 01       	movw	r28, r24
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        /* Cannot block in an ISR, so check there is data available. */
        if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    385e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3860:	88 23       	and	r24, r24
    3862:	41 f0       	breq	.+16     	; 0x3874 <xQueuePeekFromISR+0x20>
        {
            traceQUEUE_PEEK_FROM_ISR( pxQueue );

            /* Remember the read position so it can be reset as nothing is
             * actually being removed from the queue. */
            pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3864:	0e 81       	ldd	r16, Y+6	; 0x06
    3866:	1f 81       	ldd	r17, Y+7	; 0x07
            prvCopyDataFromQueue( pxQueue, pvBuffer );
    3868:	ce 01       	movw	r24, r28
    386a:	0e 94 0c 1c 	call	0x3818	; 0x3818 <prvCopyDataFromQueue>
            pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    386e:	1f 83       	std	Y+7, r17	; 0x07
    3870:	0e 83       	std	Y+6, r16	; 0x06
    3872:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    3874:	df 91       	pop	r29
    3876:	cf 91       	pop	r28
    3878:	1f 91       	pop	r17
    387a:	0f 91       	pop	r16
    387c:	08 95       	ret

0000387e <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue,
                                      const void * pvItemToQueue,
                                      const BaseType_t xPosition )
{
    387e:	0f 93       	push	r16
    3880:	1f 93       	push	r17
    3882:	cf 93       	push	r28
    3884:	df 93       	push	r29
    3886:	ec 01       	movw	r28, r24
    3888:	04 2f       	mov	r16, r20
    BaseType_t xReturn = pdFALSE;
    UBaseType_t uxMessagesWaiting;

    /* This function is called from a critical section. */

    uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    388a:	1a 8d       	ldd	r17, Y+26	; 0x1a

    if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
    388c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    388e:	44 23       	and	r20, r20
    3890:	a1 f1       	breq	.+104    	; 0x38fa <prvCopyDataToQueue+0x7c>
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configUSE_MUTEXES */
    }
    else if( xPosition == queueSEND_TO_BACK )
    3892:	00 23       	and	r16, r16
    3894:	b1 f4       	brne	.+44     	; 0x38c2 <prvCopyDataToQueue+0x44>
    {
        ( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 !e9087 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes. */
    3896:	8a 81       	ldd	r24, Y+2	; 0x02
    3898:	9b 81       	ldd	r25, Y+3	; 0x03
    389a:	50 e0       	ldi	r21, 0x00	; 0
    389c:	0e 94 ab 32 	call	0x6556	; 0x6556 <memcpy>
        pxQueue->pcWriteTo += pxQueue->uxItemSize;                                                       /*lint !e9016 Pointer arithmetic on char types ok, especially in this use case where it is the clearest way of conveying intent. */
    38a0:	8c 8d       	ldd	r24, Y+28	; 0x1c
    38a2:	2a 81       	ldd	r18, Y+2	; 0x02
    38a4:	3b 81       	ldd	r19, Y+3	; 0x03
    38a6:	28 0f       	add	r18, r24
    38a8:	31 1d       	adc	r19, r1
    38aa:	3b 83       	std	Y+3, r19	; 0x03
    38ac:	2a 83       	std	Y+2, r18	; 0x02

        if( pxQueue->pcWriteTo >= pxQueue->u.xQueue.pcTail )                                             /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    38ae:	8c 81       	ldd	r24, Y+4	; 0x04
    38b0:	9d 81       	ldd	r25, Y+5	; 0x05
    38b2:	28 17       	cp	r18, r24
    38b4:	39 07       	cpc	r19, r25
    38b6:	08 f1       	brcs	.+66     	; 0x38fa <prvCopyDataToQueue+0x7c>
        {
            pxQueue->pcWriteTo = pxQueue->pcHead;
    38b8:	88 81       	ld	r24, Y
    38ba:	99 81       	ldd	r25, Y+1	; 0x01
    38bc:	9b 83       	std	Y+3, r25	; 0x03
    38be:	8a 83       	std	Y+2, r24	; 0x02
    38c0:	1c c0       	rjmp	.+56     	; 0x38fa <prvCopyDataToQueue+0x7c>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        ( void ) memcpy( ( void * ) pxQueue->u.xQueue.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e9087 !e418 MISRA exception as the casts are only redundant for some ports.  Cast to void required by function signature and safe as no alignment requirement and copy length specified in bytes.  Assert checks null pointer only used when length is 0. */
    38c2:	8e 81       	ldd	r24, Y+6	; 0x06
    38c4:	9f 81       	ldd	r25, Y+7	; 0x07
    38c6:	50 e0       	ldi	r21, 0x00	; 0
    38c8:	0e 94 ab 32 	call	0x6556	; 0x6556 <memcpy>
        pxQueue->u.xQueue.pcReadFrom -= pxQueue->uxItemSize;
    38cc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    38ce:	2e 81       	ldd	r18, Y+6	; 0x06
    38d0:	3f 81       	ldd	r19, Y+7	; 0x07
    38d2:	28 1b       	sub	r18, r24
    38d4:	31 09       	sbc	r19, r1
    38d6:	3f 83       	std	Y+7, r19	; 0x07
    38d8:	2e 83       	std	Y+6, r18	; 0x06

        if( pxQueue->u.xQueue.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
    38da:	88 81       	ld	r24, Y
    38dc:	99 81       	ldd	r25, Y+1	; 0x01
    38de:	28 17       	cp	r18, r24
    38e0:	39 07       	cpc	r19, r25
    38e2:	38 f4       	brcc	.+14     	; 0x38f2 <prvCopyDataToQueue+0x74>
        {
            pxQueue->u.xQueue.pcReadFrom = ( pxQueue->u.xQueue.pcTail - pxQueue->uxItemSize );
    38e4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    38e6:	8c 81       	ldd	r24, Y+4	; 0x04
    38e8:	9d 81       	ldd	r25, Y+5	; 0x05
    38ea:	82 1b       	sub	r24, r18
    38ec:	91 09       	sbc	r25, r1
    38ee:	9f 83       	std	Y+7, r25	; 0x07
    38f0:	8e 83       	std	Y+6, r24	; 0x06
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }

        if( xPosition == queueOVERWRITE )
    38f2:	02 30       	cpi	r16, 0x02	; 2
    38f4:	11 f4       	brne	.+4      	; 0x38fa <prvCopyDataToQueue+0x7c>
        {
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    38f6:	11 11       	cpse	r17, r1
            {
                /* An item is not being added but overwritten, so subtract
                 * one from the recorded number of items in the queue so when
                 * one is added again below the number of recorded items remains
                 * correct. */
                --uxMessagesWaiting;
    38f8:	11 50       	subi	r17, 0x01	; 1
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    38fa:	81 2f       	mov	r24, r17
    38fc:	8f 5f       	subi	r24, 0xFF	; 255
    38fe:	8a 8f       	std	Y+26, r24	; 0x1a

    return xReturn;
}
    3900:	80 e0       	ldi	r24, 0x00	; 0
    3902:	df 91       	pop	r29
    3904:	cf 91       	pop	r28
    3906:	1f 91       	pop	r17
    3908:	0f 91       	pop	r16
    390a:	08 95       	ret

0000390c <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue,
                                 void * const pvBuffer,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    390c:	ef 92       	push	r14
    390e:	ff 92       	push	r15
    3910:	0f 93       	push	r16
    3912:	1f 93       	push	r17
    3914:	cf 93       	push	r28
    3916:	df 93       	push	r29
    3918:	ec 01       	movw	r28, r24
    391a:	7a 01       	movw	r14, r20
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    391c:	1a 8d       	ldd	r17, Y+26	; 0x1a

        /* Cannot block in an ISR, so check there is data available. */
        if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    391e:	11 23       	and	r17, r17
    3920:	11 f4       	brne	.+4      	; 0x3926 <xQueueReceiveFromISR+0x1a>
    3922:	80 e0       	ldi	r24, 0x00	; 0
    3924:	22 c0       	rjmp	.+68     	; 0x396a <xQueueReceiveFromISR+0x5e>
        {
            const int8_t cRxLock = pxQueue->cRxLock;
    3926:	0d 8d       	ldd	r16, Y+29	; 0x1d

            traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

            prvCopyDataFromQueue( pxQueue, pvBuffer );
    3928:	0e 94 0c 1c 	call	0x3818	; 0x3818 <prvCopyDataFromQueue>
            pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    392c:	81 2f       	mov	r24, r17
    392e:	81 50       	subi	r24, 0x01	; 1
    3930:	8a 8f       	std	Y+26, r24	; 0x1a

            /* If the queue is locked the event list will not be modified.
             * Instead update the lock count so the task that unlocks the queue
             * will know that an ISR has removed data while the queue was
             * locked. */
            if( cRxLock == queueUNLOCKED )
    3932:	0f 3f       	cpi	r16, 0xFF	; 255
    3934:	81 f4       	brne	.+32     	; 0x3956 <xQueueReceiveFromISR+0x4a>
            {
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3936:	88 85       	ldd	r24, Y+8	; 0x08
    3938:	88 23       	and	r24, r24
    393a:	b1 f0       	breq	.+44     	; 0x3968 <xQueueReceiveFromISR+0x5c>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    393c:	ce 01       	movw	r24, r28
    393e:	08 96       	adiw	r24, 0x08	; 8
    3940:	0e 94 b8 25 	call	0x4b70	; 0x4b70 <xTaskRemoveFromEventList>
    3944:	88 23       	and	r24, r24
    3946:	81 f0       	breq	.+32     	; 0x3968 <xQueueReceiveFromISR+0x5c>
                    {
                        /* The task waiting has a higher priority than us so
                         * force a context switch. */
                        if( pxHigherPriorityTaskWoken != NULL )
    3948:	e1 14       	cp	r14, r1
    394a:	f1 04       	cpc	r15, r1
    394c:	69 f0       	breq	.+26     	; 0x3968 <xQueueReceiveFromISR+0x5c>
                        {
                            *pxHigherPriorityTaskWoken = pdTRUE;
    394e:	81 e0       	ldi	r24, 0x01	; 1
    3950:	f7 01       	movw	r30, r14
    3952:	80 83       	st	Z, r24
    3954:	0a c0       	rjmp	.+20     	; 0x396a <xQueueReceiveFromISR+0x5e>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was removed while it was locked. */
                prvIncrementQueueRxLock( pxQueue, cRxLock );
    3956:	0e 94 63 25 	call	0x4ac6	; 0x4ac6 <uxTaskGetNumberOfTasks>
    395a:	08 17       	cp	r16, r24
    395c:	28 f4       	brcc	.+10     	; 0x3968 <xQueueReceiveFromISR+0x5c>
    395e:	80 2f       	mov	r24, r16
    3960:	8f 5f       	subi	r24, 0xFF	; 255
    3962:	8d 8f       	std	Y+29, r24	; 0x1d
    3964:	81 e0       	ldi	r24, 0x01	; 1
    3966:	01 c0       	rjmp	.+2      	; 0x396a <xQueueReceiveFromISR+0x5e>
    3968:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    396a:	df 91       	pop	r29
    396c:	cf 91       	pop	r28
    396e:	1f 91       	pop	r17
    3970:	0f 91       	pop	r16
    3972:	ff 90       	pop	r15
    3974:	ef 90       	pop	r14
    3976:	08 95       	ret

00003978 <xQueueGiveFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue,
                              BaseType_t * const pxHigherPriorityTaskWoken )
{
    3978:	ef 92       	push	r14
    397a:	ff 92       	push	r15
    397c:	1f 93       	push	r17
    397e:	cf 93       	push	r28
    3980:	df 93       	push	r29
    3982:	ec 01       	movw	r28, r24
    3984:	7b 01       	movw	r14, r22
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3986:	9a 8d       	ldd	r25, Y+26	; 0x1a

        /* When the queue is used to implement a semaphore no data is ever
         * moved through the queue but it is still valid to see if the queue 'has
         * space'. */
        if( uxMessagesWaiting < pxQueue->uxLength )
    3988:	8b 8d       	ldd	r24, Y+27	; 0x1b
    398a:	98 17       	cp	r25, r24
    398c:	10 f0       	brcs	.+4      	; 0x3992 <xQueueGiveFromISR+0x1a>
    398e:	80 e0       	ldi	r24, 0x00	; 0
    3990:	20 c0       	rjmp	.+64     	; 0x39d2 <xQueueGiveFromISR+0x5a>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    3992:	1e 8d       	ldd	r17, Y+30	; 0x1e
             * holder - and if there is a mutex holder then the mutex cannot be
             * given from an ISR.  As this is the ISR version of the function it
             * can be assumed there is no mutex holder and no need to determine if
             * priority disinheritance is needed.  Simply increase the count of
             * messages (semaphores) available. */
            pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
    3994:	89 2f       	mov	r24, r25
    3996:	8f 5f       	subi	r24, 0xFF	; 255
    3998:	8a 8f       	std	Y+26, r24	; 0x1a

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    399a:	1f 3f       	cpi	r17, 0xFF	; 255
    399c:	81 f4       	brne	.+32     	; 0x39be <xQueueGiveFromISR+0x46>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    399e:	89 89       	ldd	r24, Y+17	; 0x11
    39a0:	88 23       	and	r24, r24
    39a2:	b1 f0       	breq	.+44     	; 0x39d0 <xQueueGiveFromISR+0x58>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    39a4:	ce 01       	movw	r24, r28
    39a6:	41 96       	adiw	r24, 0x11	; 17
    39a8:	0e 94 b8 25 	call	0x4b70	; 0x4b70 <xTaskRemoveFromEventList>
    39ac:	88 23       	and	r24, r24
    39ae:	81 f0       	breq	.+32     	; 0x39d0 <xQueueGiveFromISR+0x58>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    39b0:	e1 14       	cp	r14, r1
    39b2:	f1 04       	cpc	r15, r1
    39b4:	69 f0       	breq	.+26     	; 0x39d0 <xQueueGiveFromISR+0x58>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    39b6:	81 e0       	ldi	r24, 0x01	; 1
    39b8:	f7 01       	movw	r30, r14
    39ba:	80 83       	st	Z, r24
    39bc:	0a c0       	rjmp	.+20     	; 0x39d2 <xQueueGiveFromISR+0x5a>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    39be:	0e 94 63 25 	call	0x4ac6	; 0x4ac6 <uxTaskGetNumberOfTasks>
    39c2:	18 17       	cp	r17, r24
    39c4:	28 f4       	brcc	.+10     	; 0x39d0 <xQueueGiveFromISR+0x58>
    39c6:	81 2f       	mov	r24, r17
    39c8:	8f 5f       	subi	r24, 0xFF	; 255
    39ca:	8e 8f       	std	Y+30, r24	; 0x1e
    39cc:	81 e0       	ldi	r24, 0x01	; 1
    39ce:	01 c0       	rjmp	.+2      	; 0x39d2 <xQueueGiveFromISR+0x5a>
    39d0:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    39d2:	df 91       	pop	r29
    39d4:	cf 91       	pop	r28
    39d6:	1f 91       	pop	r17
    39d8:	ff 90       	pop	r15
    39da:	ef 90       	pop	r14
    39dc:	08 95       	ret

000039de <xQueueGenericSendFromISR>:

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue,
                                     const void * const pvItemToQueue,
                                     BaseType_t * const pxHigherPriorityTaskWoken,
                                     const BaseType_t xCopyPosition )
{
    39de:	ef 92       	push	r14
    39e0:	ff 92       	push	r15
    39e2:	1f 93       	push	r17
    39e4:	cf 93       	push	r28
    39e6:	df 93       	push	r29
    39e8:	ec 01       	movw	r28, r24
    39ea:	7a 01       	movw	r14, r20
     * read, instead return a flag to say whether a context switch is required or
     * not (i.e. has a task with a higher priority than us been woken by this
     * post). */
    uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    39ec:	9a 8d       	ldd	r25, Y+26	; 0x1a
    39ee:	8b 8d       	ldd	r24, Y+27	; 0x1b
    39f0:	98 17       	cp	r25, r24
    39f2:	20 f0       	brcs	.+8      	; 0x39fc <xQueueGenericSendFromISR+0x1e>
    39f4:	22 30       	cpi	r18, 0x02	; 2
    39f6:	11 f0       	breq	.+4      	; 0x39fc <xQueueGenericSendFromISR+0x1e>
    39f8:	80 e0       	ldi	r24, 0x00	; 0
    39fa:	22 c0       	rjmp	.+68     	; 0x3a40 <xQueueGenericSendFromISR+0x62>
        {
            const int8_t cTxLock = pxQueue->cTxLock;
    39fc:	1e 8d       	ldd	r17, Y+30	; 0x1e
            const UBaseType_t uxPreviousMessagesWaiting = pxQueue->uxMessagesWaiting;
    39fe:	8a 8d       	ldd	r24, Y+26	; 0x1a
            /* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
             *  semaphore or mutex.  That means prvCopyDataToQueue() cannot result
             *  in a task disinheriting a priority and prvCopyDataToQueue() can be
             *  called here even though the disinherit function does not check if
             *  the scheduler is suspended before accessing the ready lists. */
            ( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3a00:	ce 01       	movw	r24, r28
    3a02:	42 2f       	mov	r20, r18
    3a04:	0e 94 3f 1c 	call	0x387e	; 0x387e <prvCopyDataToQueue>

            /* The event list is not altered if the queue is locked.  This will
             * be done when the queue is unlocked later. */
            if( cTxLock == queueUNLOCKED )
    3a08:	1f 3f       	cpi	r17, 0xFF	; 255
    3a0a:	81 f4       	brne	.+32     	; 0x3a2c <xQueueGenericSendFromISR+0x4e>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3a0c:	89 89       	ldd	r24, Y+17	; 0x11
    3a0e:	88 23       	and	r24, r24
    3a10:	b1 f0       	breq	.+44     	; 0x3a3e <xQueueGenericSendFromISR+0x60>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3a12:	ce 01       	movw	r24, r28
    3a14:	41 96       	adiw	r24, 0x11	; 17
    3a16:	0e 94 b8 25 	call	0x4b70	; 0x4b70 <xTaskRemoveFromEventList>
    3a1a:	88 23       	and	r24, r24
    3a1c:	81 f0       	breq	.+32     	; 0x3a3e <xQueueGenericSendFromISR+0x60>
                        {
                            /* The task waiting has a higher priority so record that a
                             * context switch is required. */
                            if( pxHigherPriorityTaskWoken != NULL )
    3a1e:	e1 14       	cp	r14, r1
    3a20:	f1 04       	cpc	r15, r1
    3a22:	69 f0       	breq	.+26     	; 0x3a3e <xQueueGenericSendFromISR+0x60>
                            {
                                *pxHigherPriorityTaskWoken = pdTRUE;
    3a24:	81 e0       	ldi	r24, 0x01	; 1
    3a26:	f7 01       	movw	r30, r14
    3a28:	80 83       	st	Z, r24
    3a2a:	0a c0       	rjmp	.+20     	; 0x3a40 <xQueueGenericSendFromISR+0x62>
            }
            else
            {
                /* Increment the lock count so the task that unlocks the queue
                 * knows that data was posted while it was locked. */
                prvIncrementQueueTxLock( pxQueue, cTxLock );
    3a2c:	0e 94 63 25 	call	0x4ac6	; 0x4ac6 <uxTaskGetNumberOfTasks>
    3a30:	18 17       	cp	r17, r24
    3a32:	28 f4       	brcc	.+10     	; 0x3a3e <xQueueGenericSendFromISR+0x60>
    3a34:	81 2f       	mov	r24, r17
    3a36:	8f 5f       	subi	r24, 0xFF	; 255
    3a38:	8e 8f       	std	Y+30, r24	; 0x1e
    3a3a:	81 e0       	ldi	r24, 0x01	; 1
    3a3c:	01 c0       	rjmp	.+2      	; 0x3a40 <xQueueGenericSendFromISR+0x62>
    3a3e:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    3a40:	df 91       	pop	r29
    3a42:	cf 91       	pop	r28
    3a44:	1f 91       	pop	r17
    3a46:	ff 90       	pop	r15
    3a48:	ef 90       	pop	r14
    3a4a:	08 95       	ret

00003a4c <prvUnlockQueue>:
    }
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
    3a4c:	ef 92       	push	r14
    3a4e:	ff 92       	push	r15
    3a50:	1f 93       	push	r17
    3a52:	cf 93       	push	r28
    3a54:	df 93       	push	r29
    3a56:	ec 01       	movw	r28, r24

    /* The lock counts contains the number of extra data items placed or
     * removed from the queue while the queue was locked.  When a queue is
     * locked items can be added or removed, but the event lists cannot be
     * updated. */
    taskENTER_CRITICAL();
    3a58:	0f b6       	in	r0, 0x3f	; 63
    3a5a:	f8 94       	cli
    3a5c:	0f 92       	push	r0
    {
        int8_t cTxLock = pxQueue->cTxLock;
    3a5e:	1e 8d       	ldd	r17, Y+30	; 0x1e

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    3a60:	11 16       	cp	r1, r17
    3a62:	c4 f4       	brge	.+48     	; 0x3a94 <prvUnlockQueue+0x48>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3a64:	89 89       	ldd	r24, Y+17	; 0x11
    3a66:	88 23       	and	r24, r24
    3a68:	a9 f0       	breq	.+42     	; 0x3a94 <prvUnlockQueue+0x48>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3a6a:	0f 2e       	mov	r0, r31
    3a6c:	f1 e1       	ldi	r31, 0x11	; 17
    3a6e:	ef 2e       	mov	r14, r31
    3a70:	ff 24       	eor	r15, r15
    3a72:	f0 2d       	mov	r31, r0
    3a74:	ec 0e       	add	r14, r28
    3a76:	fd 1e       	adc	r15, r29
    3a78:	03 c0       	rjmp	.+6      	; 0x3a80 <prvUnlockQueue+0x34>
            }
            #else /* configUSE_QUEUE_SETS */
            {
                /* Tasks that are removed from the event list will get added to
                 * the pending ready list as the scheduler is still suspended. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3a7a:	89 89       	ldd	r24, Y+17	; 0x11
    3a7c:	88 23       	and	r24, r24
    3a7e:	51 f0       	breq	.+20     	; 0x3a94 <prvUnlockQueue+0x48>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3a80:	c7 01       	movw	r24, r14
    3a82:	0e 94 b8 25 	call	0x4b70	; 0x4b70 <xTaskRemoveFromEventList>
    3a86:	88 23       	and	r24, r24
    3a88:	11 f0       	breq	.+4      	; 0x3a8e <prvUnlockQueue+0x42>
                    {
                        /* The task waiting has a higher priority so record that
                         * a context switch is required. */
                        vTaskMissedYield();
    3a8a:	0e 94 59 27 	call	0x4eb2	; 0x4eb2 <vTaskMissedYield>
                    break;
                }
            }
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
    3a8e:	11 50       	subi	r17, 0x01	; 1
    taskENTER_CRITICAL();
    {
        int8_t cTxLock = pxQueue->cTxLock;

        /* See if data was added to the queue while it was locked. */
        while( cTxLock > queueLOCKED_UNMODIFIED )
    3a90:	11 16       	cp	r1, r17
    3a92:	9c f3       	brlt	.-26     	; 0x3a7a <prvUnlockQueue+0x2e>
            #endif /* configUSE_QUEUE_SETS */

            --cTxLock;
        }

        pxQueue->cTxLock = queueUNLOCKED;
    3a94:	8f ef       	ldi	r24, 0xFF	; 255
    3a96:	8e 8f       	std	Y+30, r24	; 0x1e
    }
    taskEXIT_CRITICAL();
    3a98:	0f 90       	pop	r0
    3a9a:	0f be       	out	0x3f, r0	; 63

    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    3a9c:	0f b6       	in	r0, 0x3f	; 63
    3a9e:	f8 94       	cli
    3aa0:	0f 92       	push	r0
    {
        int8_t cRxLock = pxQueue->cRxLock;
    3aa2:	1d 8d       	ldd	r17, Y+29	; 0x1d

        while( cRxLock > queueLOCKED_UNMODIFIED )
    3aa4:	11 16       	cp	r1, r17
    3aa6:	bc f4       	brge	.+46     	; 0x3ad6 <prvUnlockQueue+0x8a>
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3aa8:	88 85       	ldd	r24, Y+8	; 0x08
    3aaa:	88 23       	and	r24, r24
    3aac:	a1 f0       	breq	.+40     	; 0x3ad6 <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3aae:	ee 24       	eor	r14, r14
    3ab0:	ff 24       	eor	r15, r15
    3ab2:	68 94       	set
    3ab4:	e3 f8       	bld	r14, 3
    3ab6:	ec 0e       	add	r14, r28
    3ab8:	fd 1e       	adc	r15, r29
    3aba:	03 c0       	rjmp	.+6      	; 0x3ac2 <prvUnlockQueue+0x76>
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
        {
            if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3abc:	88 85       	ldd	r24, Y+8	; 0x08
    3abe:	88 23       	and	r24, r24
    3ac0:	51 f0       	breq	.+20     	; 0x3ad6 <prvUnlockQueue+0x8a>
            {
                if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3ac2:	c7 01       	movw	r24, r14
    3ac4:	0e 94 b8 25 	call	0x4b70	; 0x4b70 <xTaskRemoveFromEventList>
    3ac8:	88 23       	and	r24, r24
    3aca:	11 f0       	breq	.+4      	; 0x3ad0 <prvUnlockQueue+0x84>
                {
                    vTaskMissedYield();
    3acc:	0e 94 59 27 	call	0x4eb2	; 0x4eb2 <vTaskMissedYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                --cRxLock;
    3ad0:	11 50       	subi	r17, 0x01	; 1
    /* Do the same for the Rx lock. */
    taskENTER_CRITICAL();
    {
        int8_t cRxLock = pxQueue->cRxLock;

        while( cRxLock > queueLOCKED_UNMODIFIED )
    3ad2:	11 16       	cp	r1, r17
    3ad4:	9c f3       	brlt	.-26     	; 0x3abc <prvUnlockQueue+0x70>
            {
                break;
            }
        }

        pxQueue->cRxLock = queueUNLOCKED;
    3ad6:	8f ef       	ldi	r24, 0xFF	; 255
    3ad8:	8d 8f       	std	Y+29, r24	; 0x1d
    }
    taskEXIT_CRITICAL();
    3ada:	0f 90       	pop	r0
    3adc:	0f be       	out	0x3f, r0	; 63
}
    3ade:	df 91       	pop	r29
    3ae0:	cf 91       	pop	r28
    3ae2:	1f 91       	pop	r17
    3ae4:	ff 90       	pop	r15
    3ae6:	ef 90       	pop	r14
    3ae8:	08 95       	ret

00003aea <xQueuePeek>:
/*-----------------------------------------------------------*/

BaseType_t xQueuePeek( QueueHandle_t xQueue,
                       void * const pvBuffer,
                       TickType_t xTicksToWait )
{
    3aea:	6f 92       	push	r6
    3aec:	7f 92       	push	r7
    3aee:	8f 92       	push	r8
    3af0:	9f 92       	push	r9
    3af2:	af 92       	push	r10
    3af4:	bf 92       	push	r11
    3af6:	cf 92       	push	r12
    3af8:	df 92       	push	r13
    3afa:	ef 92       	push	r14
    3afc:	ff 92       	push	r15
    3afe:	0f 93       	push	r16
    3b00:	1f 93       	push	r17
    3b02:	df 93       	push	r29
    3b04:	cf 93       	push	r28
    3b06:	00 d0       	rcall	.+0      	; 0x3b08 <xQueuePeek+0x1e>
    3b08:	00 d0       	rcall	.+0      	; 0x3b0a <xQueuePeek+0x20>
    3b0a:	0f 92       	push	r0
    3b0c:	cd b7       	in	r28, 0x3d	; 61
    3b0e:	de b7       	in	r29, 0x3e	; 62
    3b10:	7c 01       	movw	r14, r24
    3b12:	3b 01       	movw	r6, r22
    3b14:	5d 83       	std	Y+5, r21	; 0x05
    3b16:	4c 83       	std	Y+4, r20	; 0x04
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3b18:	0f 2e       	mov	r0, r31
    3b1a:	f1 e1       	ldi	r31, 0x11	; 17
    3b1c:	8f 2e       	mov	r8, r31
    3b1e:	99 24       	eor	r9, r9
    3b20:	f0 2d       	mov	r31, r0
    3b22:	88 0e       	add	r8, r24
    3b24:	99 1e       	adc	r9, r25
    3b26:	00 e0       	ldi	r16, 0x00	; 0
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3b28:	6e 01       	movw	r12, r28
    3b2a:	08 94       	sec
    3b2c:	c1 1c       	adc	r12, r1
    3b2e:	d1 1c       	adc	r13, r1
    3b30:	11 e0       	ldi	r17, 0x01	; 1

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3b32:	aa 24       	eor	r10, r10
    3b34:	bb 24       	eor	r11, r11
    3b36:	68 94       	set
    3b38:	a2 f8       	bld	r10, 2
    3b3a:	ac 0e       	add	r10, r28
    3b3c:	bd 1e       	adc	r11, r29
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3b3e:	0f b6       	in	r0, 0x3f	; 63
    3b40:	f8 94       	cli
    3b42:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3b44:	f7 01       	movw	r30, r14
    3b46:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3b48:	88 23       	and	r24, r24
    3b4a:	b9 f0       	breq	.+46     	; 0x3b7a <xQueuePeek+0x90>
            {
                /* Remember the read position so it can be reset after the data
                 * is read from the queue as this function is only peeking the
                 * data, not removing it. */
                pcOriginalReadPosition = pxQueue->u.xQueue.pcReadFrom;
    3b4c:	06 81       	ldd	r16, Z+6	; 0x06
    3b4e:	17 81       	ldd	r17, Z+7	; 0x07

                prvCopyDataFromQueue( pxQueue, pvBuffer );
    3b50:	c7 01       	movw	r24, r14
    3b52:	b3 01       	movw	r22, r6
    3b54:	0e 94 0c 1c 	call	0x3818	; 0x3818 <prvCopyDataFromQueue>
                traceQUEUE_PEEK( pxQueue );

                /* The data is not being removed, so reset the read pointer. */
                pxQueue->u.xQueue.pcReadFrom = pcOriginalReadPosition;
    3b58:	f7 01       	movw	r30, r14
    3b5a:	17 83       	std	Z+7, r17	; 0x07
    3b5c:	06 83       	std	Z+6, r16	; 0x06

                /* The data is being left in the queue, so see if there are
                 * any other tasks waiting for the data. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3b5e:	81 89       	ldd	r24, Z+17	; 0x11
    3b60:	88 23       	and	r24, r24
    3b62:	39 f0       	breq	.+14     	; 0x3b72 <xQueuePeek+0x88>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3b64:	c4 01       	movw	r24, r8
    3b66:	0e 94 b8 25 	call	0x4b70	; 0x4b70 <xTaskRemoveFromEventList>
    3b6a:	88 23       	and	r24, r24
    3b6c:	11 f0       	breq	.+4      	; 0x3b72 <xQueuePeek+0x88>
                    {
                        /* The task waiting has a higher priority than this task. */
                        queueYIELD_IF_USING_PREEMPTION();
    3b6e:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3b72:	0f 90       	pop	r0
    3b74:	0f be       	out	0x3f, r0	; 63
    3b76:	81 e0       	ldi	r24, 0x01	; 1
    3b78:	4e c0       	rjmp	.+156    	; 0x3c16 <xQueuePeek+0x12c>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3b7a:	8c 81       	ldd	r24, Y+4	; 0x04
    3b7c:	9d 81       	ldd	r25, Y+5	; 0x05
    3b7e:	89 2b       	or	r24, r25
    3b80:	21 f4       	brne	.+8      	; 0x3b8a <xQueuePeek+0xa0>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3b82:	0f 90       	pop	r0
    3b84:	0f be       	out	0x3f, r0	; 63
    3b86:	80 e0       	ldi	r24, 0x00	; 0
    3b88:	46 c0       	rjmp	.+140    	; 0x3c16 <xQueuePeek+0x12c>
                    traceQUEUE_PEEK_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    3b8a:	00 23       	and	r16, r16
    3b8c:	21 f4       	brne	.+8      	; 0x3b96 <xQueuePeek+0xac>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure ready to enter the blocked
                     * state. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3b8e:	c6 01       	movw	r24, r12
    3b90:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <vTaskInternalSetTimeOutState>
    3b94:	01 2f       	mov	r16, r17
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3b96:	0f 90       	pop	r0
    3b98:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now that the critical section has been exited. */

        vTaskSuspendAll();
    3b9a:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3b9e:	0f b6       	in	r0, 0x3f	; 63
    3ba0:	f8 94       	cli
    3ba2:	0f 92       	push	r0
    3ba4:	f7 01       	movw	r30, r14
    3ba6:	85 8d       	ldd	r24, Z+29	; 0x1d
    3ba8:	8f 3f       	cpi	r24, 0xFF	; 255
    3baa:	09 f4       	brne	.+2      	; 0x3bae <xQueuePeek+0xc4>
    3bac:	15 8e       	std	Z+29, r1	; 0x1d
    3bae:	f7 01       	movw	r30, r14
    3bb0:	86 8d       	ldd	r24, Z+30	; 0x1e
    3bb2:	8f 3f       	cpi	r24, 0xFF	; 255
    3bb4:	09 f4       	brne	.+2      	; 0x3bb8 <xQueuePeek+0xce>
    3bb6:	16 8e       	std	Z+30, r1	; 0x1e
    3bb8:	0f 90       	pop	r0
    3bba:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3bbc:	c6 01       	movw	r24, r12
    3bbe:	b5 01       	movw	r22, r10
    3bc0:	0e 94 29 27 	call	0x4e52	; 0x4e52 <xTaskCheckForTimeOut>
    3bc4:	88 23       	and	r24, r24
    3bc6:	d9 f4       	brne	.+54     	; 0x3bfe <xQueuePeek+0x114>
        {
            /* Timeout has not expired yet, check to see if there is data in the
            * queue now, and if not enter the Blocked state to wait for data. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3bc8:	c7 01       	movw	r24, r14
    3bca:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <prvIsQueueEmpty>
    3bce:	88 23       	and	r24, r24
    3bd0:	81 f0       	breq	.+32     	; 0x3bf2 <xQueuePeek+0x108>
            {
                traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3bd2:	6c 81       	ldd	r22, Y+4	; 0x04
    3bd4:	7d 81       	ldd	r23, Y+5	; 0x05
    3bd6:	c4 01       	movw	r24, r8
    3bd8:	0e 94 fc 2e 	call	0x5df8	; 0x5df8 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    3bdc:	c7 01       	movw	r24, r14
    3bde:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    3be2:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>
    3be6:	88 23       	and	r24, r24
    3be8:	09 f0       	breq	.+2      	; 0x3bec <xQueuePeek+0x102>
    3bea:	a9 cf       	rjmp	.-174    	; 0x3b3e <xQueuePeek+0x54>
                {
                    portYIELD_WITHIN_API();
    3bec:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
    3bf0:	a6 cf       	rjmp	.-180    	; 0x3b3e <xQueuePeek+0x54>
            }
            else
            {
                /* There is data in the queue now, so don't enter the blocked
                 * state, instead return to try and obtain the data. */
                prvUnlockQueue( pxQueue );
    3bf2:	c7 01       	movw	r24, r14
    3bf4:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3bf8:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>
    3bfc:	a0 cf       	rjmp	.-192    	; 0x3b3e <xQueuePeek+0x54>
        }
        else
        {
            /* The timeout has expired.  If there is still no data in the queue
             * exit, otherwise go back and try to read the data again. */
            prvUnlockQueue( pxQueue );
    3bfe:	c7 01       	movw	r24, r14
    3c00:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3c04:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3c08:	c7 01       	movw	r24, r14
    3c0a:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <prvIsQueueEmpty>
    3c0e:	88 23       	and	r24, r24
    3c10:	09 f4       	brne	.+2      	; 0x3c14 <xQueuePeek+0x12a>
    3c12:	95 cf       	rjmp	.-214    	; 0x3b3e <xQueuePeek+0x54>
    3c14:	80 e0       	ldi	r24, 0x00	; 0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    3c16:	0f 90       	pop	r0
    3c18:	0f 90       	pop	r0
    3c1a:	0f 90       	pop	r0
    3c1c:	0f 90       	pop	r0
    3c1e:	0f 90       	pop	r0
    3c20:	cf 91       	pop	r28
    3c22:	df 91       	pop	r29
    3c24:	1f 91       	pop	r17
    3c26:	0f 91       	pop	r16
    3c28:	ff 90       	pop	r15
    3c2a:	ef 90       	pop	r14
    3c2c:	df 90       	pop	r13
    3c2e:	cf 90       	pop	r12
    3c30:	bf 90       	pop	r11
    3c32:	af 90       	pop	r10
    3c34:	9f 90       	pop	r9
    3c36:	8f 90       	pop	r8
    3c38:	7f 90       	pop	r7
    3c3a:	6f 90       	pop	r6
    3c3c:	08 95       	ret

00003c3e <xQueueSemaphoreTake>:
}
/*-----------------------------------------------------------*/

BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue,
                                TickType_t xTicksToWait )
{
    3c3e:	8f 92       	push	r8
    3c40:	9f 92       	push	r9
    3c42:	af 92       	push	r10
    3c44:	bf 92       	push	r11
    3c46:	cf 92       	push	r12
    3c48:	df 92       	push	r13
    3c4a:	ef 92       	push	r14
    3c4c:	ff 92       	push	r15
    3c4e:	0f 93       	push	r16
    3c50:	1f 93       	push	r17
    3c52:	df 93       	push	r29
    3c54:	cf 93       	push	r28
    3c56:	00 d0       	rcall	.+0      	; 0x3c58 <xQueueSemaphoreTake+0x1a>
    3c58:	00 d0       	rcall	.+0      	; 0x3c5a <xQueueSemaphoreTake+0x1c>
    3c5a:	0f 92       	push	r0
    3c5c:	cd b7       	in	r28, 0x3d	; 61
    3c5e:	de b7       	in	r29, 0x3e	; 62
    3c60:	8c 01       	movw	r16, r24
    3c62:	7d 83       	std	Y+5, r23	; 0x05
    3c64:	6c 83       	std	Y+4, r22	; 0x04
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3c66:	0f 2e       	mov	r0, r31
    3c68:	f1 e1       	ldi	r31, 0x11	; 17
    3c6a:	8f 2e       	mov	r8, r31
    3c6c:	99 24       	eor	r9, r9
    3c6e:	f0 2d       	mov	r31, r0
    3c70:	88 0e       	add	r8, r24
    3c72:	99 1e       	adc	r9, r25
    3c74:	ff 24       	eor	r15, r15
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3c76:	6e 01       	movw	r12, r28
    3c78:	08 94       	sec
    3c7a:	c1 1c       	adc	r12, r1
    3c7c:	d1 1c       	adc	r13, r1
    3c7e:	ee 24       	eor	r14, r14
    3c80:	e3 94       	inc	r14

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3c82:	aa 24       	eor	r10, r10
    3c84:	bb 24       	eor	r11, r11
    3c86:	68 94       	set
    3c88:	a2 f8       	bld	r10, 2
    3c8a:	ac 0e       	add	r10, r28
    3c8c:	bd 1e       	adc	r11, r29
    /*lint -save -e904 This function relaxes the coding standard somewhat to allow return
     * statements within the function itself.  This is done in the interest
     * of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3c8e:	0f b6       	in	r0, 0x3f	; 63
    3c90:	f8 94       	cli
    3c92:	0f 92       	push	r0
        {
            /* Semaphores are queues with an item size of 0, and where the
             * number of messages in the queue is the semaphore's count value. */
            const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
    3c94:	f8 01       	movw	r30, r16
    3c96:	82 8d       	ldd	r24, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxSemaphoreCount > ( UBaseType_t ) 0 )
    3c98:	88 23       	and	r24, r24
    3c9a:	89 f0       	breq	.+34     	; 0x3cbe <xQueueSemaphoreTake+0x80>
            {
                traceQUEUE_RECEIVE( pxQueue );

                /* Semaphores are queues with a data size of zero and where the
                 * messages waiting is the semaphore's count.  Reduce the count. */
                pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
    3c9c:	81 50       	subi	r24, 0x01	; 1
    3c9e:	82 8f       	std	Z+26, r24	; 0x1a
                }
                #endif /* configUSE_MUTEXES */

                /* Check to see if other tasks are blocked waiting to give the
                 * semaphore, and if so, unblock the highest priority such task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3ca0:	80 85       	ldd	r24, Z+8	; 0x08
    3ca2:	88 23       	and	r24, r24
    3ca4:	41 f0       	breq	.+16     	; 0x3cb6 <xQueueSemaphoreTake+0x78>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3ca6:	c8 01       	movw	r24, r16
    3ca8:	08 96       	adiw	r24, 0x08	; 8
    3caa:	0e 94 b8 25 	call	0x4b70	; 0x4b70 <xTaskRemoveFromEventList>
    3cae:	88 23       	and	r24, r24
    3cb0:	11 f0       	breq	.+4      	; 0x3cb6 <xQueueSemaphoreTake+0x78>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    3cb2:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3cb6:	0f 90       	pop	r0
    3cb8:	0f be       	out	0x3f, r0	; 63
    3cba:	81 e0       	ldi	r24, 0x01	; 1
    3cbc:	4e c0       	rjmp	.+156    	; 0x3d5a <xQueueSemaphoreTake+0x11c>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3cbe:	8c 81       	ldd	r24, Y+4	; 0x04
    3cc0:	9d 81       	ldd	r25, Y+5	; 0x05
    3cc2:	89 2b       	or	r24, r25
    3cc4:	21 f4       	brne	.+8      	; 0x3cce <xQueueSemaphoreTake+0x90>
                {
                    /* The semaphore count was 0 and no block time is specified
                     * (or the block time has expired) so exit now. */
                    taskEXIT_CRITICAL();
    3cc6:	0f 90       	pop	r0
    3cc8:	0f be       	out	0x3f, r0	; 63
    3cca:	80 e0       	ldi	r24, 0x00	; 0
    3ccc:	46 c0       	rjmp	.+140    	; 0x3d5a <xQueueSemaphoreTake+0x11c>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    3cce:	ff 20       	and	r15, r15
    3cd0:	21 f4       	brne	.+8      	; 0x3cda <xQueueSemaphoreTake+0x9c>
                {
                    /* The semaphore count was 0 and a block time was specified
                     * so configure the timeout structure ready to block. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3cd2:	c6 01       	movw	r24, r12
    3cd4:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <vTaskInternalSetTimeOutState>
    3cd8:	fe 2c       	mov	r15, r14
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3cda:	0f 90       	pop	r0
    3cdc:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can give to and take from the semaphore
         * now the critical section has been exited. */

        vTaskSuspendAll();
    3cde:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3ce2:	0f b6       	in	r0, 0x3f	; 63
    3ce4:	f8 94       	cli
    3ce6:	0f 92       	push	r0
    3ce8:	f8 01       	movw	r30, r16
    3cea:	85 8d       	ldd	r24, Z+29	; 0x1d
    3cec:	8f 3f       	cpi	r24, 0xFF	; 255
    3cee:	09 f4       	brne	.+2      	; 0x3cf2 <xQueueSemaphoreTake+0xb4>
    3cf0:	15 8e       	std	Z+29, r1	; 0x1d
    3cf2:	f8 01       	movw	r30, r16
    3cf4:	86 8d       	ldd	r24, Z+30	; 0x1e
    3cf6:	8f 3f       	cpi	r24, 0xFF	; 255
    3cf8:	09 f4       	brne	.+2      	; 0x3cfc <xQueueSemaphoreTake+0xbe>
    3cfa:	16 8e       	std	Z+30, r1	; 0x1e
    3cfc:	0f 90       	pop	r0
    3cfe:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3d00:	c6 01       	movw	r24, r12
    3d02:	b5 01       	movw	r22, r10
    3d04:	0e 94 29 27 	call	0x4e52	; 0x4e52 <xTaskCheckForTimeOut>
    3d08:	88 23       	and	r24, r24
    3d0a:	d9 f4       	brne	.+54     	; 0x3d42 <xQueueSemaphoreTake+0x104>
        {
            /* A block time is specified and not expired.  If the semaphore
             * count is 0 then enter the Blocked state to wait for a semaphore to
             * become available.  As semaphores are implemented with queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3d0c:	c8 01       	movw	r24, r16
    3d0e:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <prvIsQueueEmpty>
    3d12:	88 23       	and	r24, r24
    3d14:	81 f0       	breq	.+32     	; 0x3d36 <xQueueSemaphoreTake+0xf8>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* if ( configUSE_MUTEXES == 1 ) */

                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3d16:	6c 81       	ldd	r22, Y+4	; 0x04
    3d18:	7d 81       	ldd	r23, Y+5	; 0x05
    3d1a:	c4 01       	movw	r24, r8
    3d1c:	0e 94 fc 2e 	call	0x5df8	; 0x5df8 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    3d20:	c8 01       	movw	r24, r16
    3d22:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    3d26:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>
    3d2a:	88 23       	and	r24, r24
    3d2c:	09 f0       	breq	.+2      	; 0x3d30 <xQueueSemaphoreTake+0xf2>
    3d2e:	af cf       	rjmp	.-162    	; 0x3c8e <xQueueSemaphoreTake+0x50>
                {
                    portYIELD_WITHIN_API();
    3d30:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
    3d34:	ac cf       	rjmp	.-168    	; 0x3c8e <xQueueSemaphoreTake+0x50>
            }
            else
            {
                /* There was no timeout and the semaphore count was not 0, so
                 * attempt to take the semaphore again. */
                prvUnlockQueue( pxQueue );
    3d36:	c8 01       	movw	r24, r16
    3d38:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3d3c:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>
    3d40:	a6 cf       	rjmp	.-180    	; 0x3c8e <xQueueSemaphoreTake+0x50>
            }
        }
        else
        {
            /* Timed out. */
            prvUnlockQueue( pxQueue );
    3d42:	c8 01       	movw	r24, r16
    3d44:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3d48:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>

            /* If the semaphore count is 0 exit now as the timeout has
             * expired.  Otherwise return to attempt to take the semaphore that is
             * known to be available.  As semaphores are implemented by queues the
             * queue being empty is equivalent to the semaphore count being 0. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3d4c:	c8 01       	movw	r24, r16
    3d4e:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <prvIsQueueEmpty>
    3d52:	88 23       	and	r24, r24
    3d54:	09 f4       	brne	.+2      	; 0x3d58 <xQueueSemaphoreTake+0x11a>
    3d56:	9b cf       	rjmp	.-202    	; 0x3c8e <xQueueSemaphoreTake+0x50>
    3d58:	80 e0       	ldi	r24, 0x00	; 0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    3d5a:	0f 90       	pop	r0
    3d5c:	0f 90       	pop	r0
    3d5e:	0f 90       	pop	r0
    3d60:	0f 90       	pop	r0
    3d62:	0f 90       	pop	r0
    3d64:	cf 91       	pop	r28
    3d66:	df 91       	pop	r29
    3d68:	1f 91       	pop	r17
    3d6a:	0f 91       	pop	r16
    3d6c:	ff 90       	pop	r15
    3d6e:	ef 90       	pop	r14
    3d70:	df 90       	pop	r13
    3d72:	cf 90       	pop	r12
    3d74:	bf 90       	pop	r11
    3d76:	af 90       	pop	r10
    3d78:	9f 90       	pop	r9
    3d7a:	8f 90       	pop	r8
    3d7c:	08 95       	ret

00003d7e <xQueueReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceive( QueueHandle_t xQueue,
                          void * const pvBuffer,
                          TickType_t xTicksToWait )
{
    3d7e:	5f 92       	push	r5
    3d80:	6f 92       	push	r6
    3d82:	7f 92       	push	r7
    3d84:	8f 92       	push	r8
    3d86:	9f 92       	push	r9
    3d88:	af 92       	push	r10
    3d8a:	bf 92       	push	r11
    3d8c:	cf 92       	push	r12
    3d8e:	df 92       	push	r13
    3d90:	ef 92       	push	r14
    3d92:	ff 92       	push	r15
    3d94:	0f 93       	push	r16
    3d96:	1f 93       	push	r17
    3d98:	df 93       	push	r29
    3d9a:	cf 93       	push	r28
    3d9c:	00 d0       	rcall	.+0      	; 0x3d9e <xQueueReceive+0x20>
    3d9e:	00 d0       	rcall	.+0      	; 0x3da0 <xQueueReceive+0x22>
    3da0:	0f 92       	push	r0
    3da2:	cd b7       	in	r28, 0x3d	; 61
    3da4:	de b7       	in	r29, 0x3e	; 62
    3da6:	8c 01       	movw	r16, r24
    3da8:	3b 01       	movw	r6, r22
    3daa:	5d 83       	std	Y+5, r21	; 0x05
    3dac:	4c 83       	std	Y+4, r20	; 0x04
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3dae:	0f 2e       	mov	r0, r31
    3db0:	f1 e1       	ldi	r31, 0x11	; 17
    3db2:	8f 2e       	mov	r8, r31
    3db4:	99 24       	eor	r9, r9
    3db6:	f0 2d       	mov	r31, r0
    3db8:	88 0e       	add	r8, r24
    3dba:	99 1e       	adc	r9, r25
    3dbc:	ee 24       	eor	r14, r14
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3dbe:	6e 01       	movw	r12, r28
    3dc0:	08 94       	sec
    3dc2:	c1 1c       	adc	r12, r1
    3dc4:	d1 1c       	adc	r13, r1
    3dc6:	55 24       	eor	r5, r5
    3dc8:	53 94       	inc	r5

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3dca:	aa 24       	eor	r10, r10
    3dcc:	bb 24       	eor	r11, r11
    3dce:	68 94       	set
    3dd0:	a2 f8       	bld	r10, 2
    3dd2:	ac 0e       	add	r10, r28
    3dd4:	bd 1e       	adc	r11, r29
    /*lint -save -e904  This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3dd6:	0f b6       	in	r0, 0x3f	; 63
    3dd8:	f8 94       	cli
    3dda:	0f 92       	push	r0
        {
            const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
    3ddc:	f8 01       	movw	r30, r16
    3dde:	f2 8c       	ldd	r15, Z+26	; 0x1a

            /* Is there data in the queue now?  To be running the calling task
             * must be the highest priority task wanting to access the queue. */
            if( uxMessagesWaiting > ( UBaseType_t ) 0 )
    3de0:	ff 20       	and	r15, r15
    3de2:	b9 f0       	breq	.+46     	; 0x3e12 <xQueueReceive+0x94>
            {
                /* Data available, remove one item. */
                prvCopyDataFromQueue( pxQueue, pvBuffer );
    3de4:	c8 01       	movw	r24, r16
    3de6:	b3 01       	movw	r22, r6
    3de8:	0e 94 0c 1c 	call	0x3818	; 0x3818 <prvCopyDataFromQueue>
                traceQUEUE_RECEIVE( pxQueue );
                pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
    3dec:	8f 2d       	mov	r24, r15
    3dee:	81 50       	subi	r24, 0x01	; 1
    3df0:	f8 01       	movw	r30, r16
    3df2:	82 8f       	std	Z+26, r24	; 0x1a

                /* There is now space in the queue, were any tasks waiting to
                 * post to the queue?  If so, unblock the highest priority waiting
                 * task. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3df4:	80 85       	ldd	r24, Z+8	; 0x08
    3df6:	88 23       	and	r24, r24
    3df8:	41 f0       	breq	.+16     	; 0x3e0a <xQueueReceive+0x8c>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3dfa:	c8 01       	movw	r24, r16
    3dfc:	08 96       	adiw	r24, 0x08	; 8
    3dfe:	0e 94 b8 25 	call	0x4b70	; 0x4b70 <xTaskRemoveFromEventList>
    3e02:	88 23       	and	r24, r24
    3e04:	11 f0       	breq	.+4      	; 0x3e0a <xQueueReceive+0x8c>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    3e06:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
                else
                {
                    mtCOVERAGE_TEST_MARKER();
                }

                taskEXIT_CRITICAL();
    3e0a:	0f 90       	pop	r0
    3e0c:	0f be       	out	0x3f, r0	; 63
    3e0e:	81 e0       	ldi	r24, 0x01	; 1
    3e10:	4e c0       	rjmp	.+156    	; 0x3eae <xQueueReceive+0x130>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3e12:	8c 81       	ldd	r24, Y+4	; 0x04
    3e14:	9d 81       	ldd	r25, Y+5	; 0x05
    3e16:	89 2b       	or	r24, r25
    3e18:	21 f4       	brne	.+8      	; 0x3e22 <xQueueReceive+0xa4>
                {
                    /* The queue was empty and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3e1a:	0f 90       	pop	r0
    3e1c:	0f be       	out	0x3f, r0	; 63
    3e1e:	80 e0       	ldi	r24, 0x00	; 0
    3e20:	46 c0       	rjmp	.+140    	; 0x3eae <xQueueReceive+0x130>
                    traceQUEUE_RECEIVE_FAILED( pxQueue );
                    return errQUEUE_EMPTY;
                }
                else if( xEntryTimeSet == pdFALSE )
    3e22:	ee 20       	and	r14, r14
    3e24:	21 f4       	brne	.+8      	; 0x3e2e <xQueueReceive+0xb0>
                {
                    /* The queue was empty and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3e26:	c6 01       	movw	r24, r12
    3e28:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <vTaskInternalSetTimeOutState>
    3e2c:	e5 2c       	mov	r14, r5
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3e2e:	0f 90       	pop	r0
    3e30:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    3e32:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3e36:	0f b6       	in	r0, 0x3f	; 63
    3e38:	f8 94       	cli
    3e3a:	0f 92       	push	r0
    3e3c:	f8 01       	movw	r30, r16
    3e3e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e40:	8f 3f       	cpi	r24, 0xFF	; 255
    3e42:	09 f4       	brne	.+2      	; 0x3e46 <xQueueReceive+0xc8>
    3e44:	15 8e       	std	Z+29, r1	; 0x1d
    3e46:	f8 01       	movw	r30, r16
    3e48:	86 8d       	ldd	r24, Z+30	; 0x1e
    3e4a:	8f 3f       	cpi	r24, 0xFF	; 255
    3e4c:	09 f4       	brne	.+2      	; 0x3e50 <xQueueReceive+0xd2>
    3e4e:	16 8e       	std	Z+30, r1	; 0x1e
    3e50:	0f 90       	pop	r0
    3e52:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3e54:	c6 01       	movw	r24, r12
    3e56:	b5 01       	movw	r22, r10
    3e58:	0e 94 29 27 	call	0x4e52	; 0x4e52 <xTaskCheckForTimeOut>
    3e5c:	88 23       	and	r24, r24
    3e5e:	d9 f4       	brne	.+54     	; 0x3e96 <xQueueReceive+0x118>
        {
            /* The timeout has not expired.  If the queue is still empty place
             * the task on the list of tasks waiting to receive from the queue. */
            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3e60:	c8 01       	movw	r24, r16
    3e62:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <prvIsQueueEmpty>
    3e66:	88 23       	and	r24, r24
    3e68:	81 f0       	breq	.+32     	; 0x3e8a <xQueueReceive+0x10c>
            {
                traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3e6a:	6c 81       	ldd	r22, Y+4	; 0x04
    3e6c:	7d 81       	ldd	r23, Y+5	; 0x05
    3e6e:	c4 01       	movw	r24, r8
    3e70:	0e 94 fc 2e 	call	0x5df8	; 0x5df8 <vTaskPlaceOnEventList>
                prvUnlockQueue( pxQueue );
    3e74:	c8 01       	movw	r24, r16
    3e76:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <prvUnlockQueue>

                if( xTaskResumeAll() == pdFALSE )
    3e7a:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>
    3e7e:	88 23       	and	r24, r24
    3e80:	09 f0       	breq	.+2      	; 0x3e84 <xQueueReceive+0x106>
    3e82:	a9 cf       	rjmp	.-174    	; 0x3dd6 <xQueueReceive+0x58>
                {
                    portYIELD_WITHIN_API();
    3e84:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
    3e88:	a6 cf       	rjmp	.-180    	; 0x3dd6 <xQueueReceive+0x58>
            }
            else
            {
                /* The queue contains data again.  Loop back to try and read the
                 * data. */
                prvUnlockQueue( pxQueue );
    3e8a:	c8 01       	movw	r24, r16
    3e8c:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    3e90:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>
    3e94:	a0 cf       	rjmp	.-192    	; 0x3dd6 <xQueueReceive+0x58>
        }
        else
        {
            /* Timed out.  If there is no data in the queue exit, otherwise loop
             * back and attempt to read the data. */
            prvUnlockQueue( pxQueue );
    3e96:	c8 01       	movw	r24, r16
    3e98:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    3e9c:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>

            if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3ea0:	c8 01       	movw	r24, r16
    3ea2:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <prvIsQueueEmpty>
    3ea6:	88 23       	and	r24, r24
    3ea8:	09 f4       	brne	.+2      	; 0x3eac <xQueueReceive+0x12e>
    3eaa:	95 cf       	rjmp	.-214    	; 0x3dd6 <xQueueReceive+0x58>
    3eac:	80 e0       	ldi	r24, 0x00	; 0
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    } /*lint -restore */
}
    3eae:	0f 90       	pop	r0
    3eb0:	0f 90       	pop	r0
    3eb2:	0f 90       	pop	r0
    3eb4:	0f 90       	pop	r0
    3eb6:	0f 90       	pop	r0
    3eb8:	cf 91       	pop	r28
    3eba:	df 91       	pop	r29
    3ebc:	1f 91       	pop	r17
    3ebe:	0f 91       	pop	r16
    3ec0:	ff 90       	pop	r15
    3ec2:	ef 90       	pop	r14
    3ec4:	df 90       	pop	r13
    3ec6:	cf 90       	pop	r12
    3ec8:	bf 90       	pop	r11
    3eca:	af 90       	pop	r10
    3ecc:	9f 90       	pop	r9
    3ece:	8f 90       	pop	r8
    3ed0:	7f 90       	pop	r7
    3ed2:	6f 90       	pop	r6
    3ed4:	5f 90       	pop	r5
    3ed6:	08 95       	ret

00003ed8 <xQueueGenericSend>:

BaseType_t xQueueGenericSend( QueueHandle_t xQueue,
                              const void * const pvItemToQueue,
                              TickType_t xTicksToWait,
                              const BaseType_t xCopyPosition )
{
    3ed8:	5f 92       	push	r5
    3eda:	6f 92       	push	r6
    3edc:	7f 92       	push	r7
    3ede:	8f 92       	push	r8
    3ee0:	9f 92       	push	r9
    3ee2:	af 92       	push	r10
    3ee4:	bf 92       	push	r11
    3ee6:	cf 92       	push	r12
    3ee8:	df 92       	push	r13
    3eea:	ef 92       	push	r14
    3eec:	ff 92       	push	r15
    3eee:	0f 93       	push	r16
    3ef0:	1f 93       	push	r17
    3ef2:	df 93       	push	r29
    3ef4:	cf 93       	push	r28
    3ef6:	00 d0       	rcall	.+0      	; 0x3ef8 <xQueueGenericSend+0x20>
    3ef8:	00 d0       	rcall	.+0      	; 0x3efa <xQueueGenericSend+0x22>
    3efa:	0f 92       	push	r0
    3efc:	cd b7       	in	r28, 0x3d	; 61
    3efe:	de b7       	in	r29, 0x3e	; 62
    3f00:	8c 01       	movw	r16, r24
    3f02:	3b 01       	movw	r6, r22
    3f04:	5d 83       	std	Y+5, r21	; 0x05
    3f06:	4c 83       	std	Y+4, r20	; 0x04
    3f08:	e2 2e       	mov	r14, r18
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3f0a:	aa 24       	eor	r10, r10
    3f0c:	bb 24       	eor	r11, r11
    3f0e:	68 94       	set
    3f10:	a3 f8       	bld	r10, 3
    3f12:	a8 0e       	add	r10, r24
    3f14:	b9 1e       	adc	r11, r25
    3f16:	ff 24       	eor	r15, r15
                }
                else if( xEntryTimeSet == pdFALSE )
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3f18:	6e 01       	movw	r12, r28
    3f1a:	08 94       	sec
    3f1c:	c1 1c       	adc	r12, r1
    3f1e:	d1 1c       	adc	r13, r1
    3f20:	55 24       	eor	r5, r5
    3f22:	53 94       	inc	r5

        vTaskSuspendAll();
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3f24:	88 24       	eor	r8, r8
    3f26:	99 24       	eor	r9, r9
    3f28:	68 94       	set
    3f2a:	82 f8       	bld	r8, 2
    3f2c:	8c 0e       	add	r8, r28
    3f2e:	9d 1e       	adc	r9, r29
    /*lint -save -e904 This function relaxes the coding standard somewhat to
     * allow return statements within the function itself.  This is done in the
     * interest of execution time efficiency. */
    for( ; ; )
    {
        taskENTER_CRITICAL();
    3f30:	0f b6       	in	r0, 0x3f	; 63
    3f32:	f8 94       	cli
    3f34:	0f 92       	push	r0
        {
            /* Is there room on the queue now?  The running task must be the
             * highest priority task wanting to access the queue.  If the head item
             * in the queue is to be overwritten then it does not matter if the
             * queue is full. */
            if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
    3f36:	f8 01       	movw	r30, r16
    3f38:	92 8d       	ldd	r25, Z+26	; 0x1a
    3f3a:	83 8d       	ldd	r24, Z+27	; 0x1b
    3f3c:	98 17       	cp	r25, r24
    3f3e:	18 f0       	brcs	.+6      	; 0x3f46 <xQueueGenericSend+0x6e>
    3f40:	f2 e0       	ldi	r31, 0x02	; 2
    3f42:	ef 16       	cp	r14, r31
    3f44:	d9 f4       	brne	.+54     	; 0x3f7c <xQueueGenericSend+0xa4>
                        }
                    }
                }
                #else /* configUSE_QUEUE_SETS */
                {
                    xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3f46:	c8 01       	movw	r24, r16
    3f48:	b3 01       	movw	r22, r6
    3f4a:	4e 2d       	mov	r20, r14
    3f4c:	0e 94 3f 1c 	call	0x387e	; 0x387e <prvCopyDataToQueue>
    3f50:	98 2f       	mov	r25, r24

                    /* If there was a task waiting for data to arrive on the
                     * queue then unblock it now. */
                    if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3f52:	f8 01       	movw	r30, r16
    3f54:	81 89       	ldd	r24, Z+17	; 0x11
    3f56:	88 23       	and	r24, r24
    3f58:	49 f0       	breq	.+18     	; 0x3f6c <xQueueGenericSend+0x94>
                    {
                        if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3f5a:	c8 01       	movw	r24, r16
    3f5c:	41 96       	adiw	r24, 0x11	; 17
    3f5e:	0e 94 b8 25 	call	0x4b70	; 0x4b70 <xTaskRemoveFromEventList>
    3f62:	88 23       	and	r24, r24
    3f64:	39 f0       	breq	.+14     	; 0x3f74 <xQueueGenericSend+0x9c>
                        {
                            /* The unblocked task has a priority higher than
                             * our own so yield immediately.  Yes it is ok to do
                             * this from within the critical section - the kernel
                             * takes care of that. */
                            queueYIELD_IF_USING_PREEMPTION();
    3f66:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
    3f6a:	04 c0       	rjmp	.+8      	; 0x3f74 <xQueueGenericSend+0x9c>
                        else
                        {
                            mtCOVERAGE_TEST_MARKER();
                        }
                    }
                    else if( xYieldRequired != pdFALSE )
    3f6c:	99 23       	and	r25, r25
    3f6e:	11 f0       	breq	.+4      	; 0x3f74 <xQueueGenericSend+0x9c>
                    {
                        /* This path is a special case that will only get
                         * executed if the task was holding multiple mutexes and
                         * the mutexes were given back in an order that is
                         * different to that in which they were taken. */
                        queueYIELD_IF_USING_PREEMPTION();
    3f70:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
                        mtCOVERAGE_TEST_MARKER();
                    }
                }
                #endif /* configUSE_QUEUE_SETS */

                taskEXIT_CRITICAL();
    3f74:	0f 90       	pop	r0
    3f76:	0f be       	out	0x3f, r0	; 63
    3f78:	81 e0       	ldi	r24, 0x01	; 1
    3f7a:	4e c0       	rjmp	.+156    	; 0x4018 <xQueueGenericSend+0x140>
                return pdPASS;
            }
            else
            {
                if( xTicksToWait == ( TickType_t ) 0 )
    3f7c:	8c 81       	ldd	r24, Y+4	; 0x04
    3f7e:	9d 81       	ldd	r25, Y+5	; 0x05
    3f80:	89 2b       	or	r24, r25
    3f82:	21 f4       	brne	.+8      	; 0x3f8c <xQueueGenericSend+0xb4>
                {
                    /* The queue was full and no block time is specified (or
                     * the block time has expired) so leave now. */
                    taskEXIT_CRITICAL();
    3f84:	0f 90       	pop	r0
    3f86:	0f be       	out	0x3f, r0	; 63
    3f88:	80 e0       	ldi	r24, 0x00	; 0
    3f8a:	46 c0       	rjmp	.+140    	; 0x4018 <xQueueGenericSend+0x140>
                    /* Return to the original privilege level before exiting
                     * the function. */
                    traceQUEUE_SEND_FAILED( pxQueue );
                    return errQUEUE_FULL;
                }
                else if( xEntryTimeSet == pdFALSE )
    3f8c:	ff 20       	and	r15, r15
    3f8e:	21 f4       	brne	.+8      	; 0x3f98 <xQueueGenericSend+0xc0>
                {
                    /* The queue was full and a block time was specified so
                     * configure the timeout structure. */
                    vTaskInternalSetTimeOutState( &xTimeOut );
    3f90:	c6 01       	movw	r24, r12
    3f92:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <vTaskInternalSetTimeOutState>
    3f96:	f5 2c       	mov	r15, r5
                    /* Entry time was already set. */
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        taskEXIT_CRITICAL();
    3f98:	0f 90       	pop	r0
    3f9a:	0f be       	out	0x3f, r0	; 63

        /* Interrupts and other tasks can send to and receive from the queue
         * now the critical section has been exited. */

        vTaskSuspendAll();
    3f9c:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <vTaskSuspendAll>
        prvLockQueue( pxQueue );
    3fa0:	0f b6       	in	r0, 0x3f	; 63
    3fa2:	f8 94       	cli
    3fa4:	0f 92       	push	r0
    3fa6:	f8 01       	movw	r30, r16
    3fa8:	85 8d       	ldd	r24, Z+29	; 0x1d
    3faa:	8f 3f       	cpi	r24, 0xFF	; 255
    3fac:	09 f4       	brne	.+2      	; 0x3fb0 <xQueueGenericSend+0xd8>
    3fae:	15 8e       	std	Z+29, r1	; 0x1d
    3fb0:	f8 01       	movw	r30, r16
    3fb2:	86 8d       	ldd	r24, Z+30	; 0x1e
    3fb4:	8f 3f       	cpi	r24, 0xFF	; 255
    3fb6:	09 f4       	brne	.+2      	; 0x3fba <xQueueGenericSend+0xe2>
    3fb8:	16 8e       	std	Z+30, r1	; 0x1e
    3fba:	0f 90       	pop	r0
    3fbc:	0f be       	out	0x3f, r0	; 63

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3fbe:	c6 01       	movw	r24, r12
    3fc0:	b4 01       	movw	r22, r8
    3fc2:	0e 94 29 27 	call	0x4e52	; 0x4e52 <xTaskCheckForTimeOut>
    3fc6:	88 23       	and	r24, r24
    3fc8:	09 f5       	brne	.+66     	; 0x400c <xQueueGenericSend+0x134>

static BaseType_t prvIsQueueFull( const Queue_t * pxQueue )
{
    BaseType_t xReturn;

    taskENTER_CRITICAL();
    3fca:	0f b6       	in	r0, 0x3f	; 63
    3fcc:	f8 94       	cli
    3fce:	0f 92       	push	r0
    {
        if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    3fd0:	f8 01       	movw	r30, r16
    3fd2:	92 8d       	ldd	r25, Z+26	; 0x1a
        else
        {
            xReturn = pdFALSE;
        }
    }
    taskEXIT_CRITICAL();
    3fd4:	0f 90       	pop	r0
    3fd6:	0f be       	out	0x3f, r0	; 63
        prvLockQueue( pxQueue );

        /* Update the timeout state to see if it has expired yet. */
        if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
        {
            if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3fd8:	f8 01       	movw	r30, r16
    3fda:	83 8d       	ldd	r24, Z+27	; 0x1b
    3fdc:	98 17       	cp	r25, r24
    3fde:	81 f4       	brne	.+32     	; 0x4000 <xQueueGenericSend+0x128>
            {
                traceBLOCKING_ON_QUEUE_SEND( pxQueue );
                vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3fe0:	6c 81       	ldd	r22, Y+4	; 0x04
    3fe2:	7d 81       	ldd	r23, Y+5	; 0x05
    3fe4:	c5 01       	movw	r24, r10
    3fe6:	0e 94 fc 2e 	call	0x5df8	; 0x5df8 <vTaskPlaceOnEventList>
                /* Unlocking the queue means queue events can effect the
                 * event list. It is possible that interrupts occurring now
                 * remove this task from the event list again - but as the
                 * scheduler is suspended the task will go onto the pending
                 * ready list instead of the actual ready list. */
                prvUnlockQueue( pxQueue );
    3fea:	c8 01       	movw	r24, r16
    3fec:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <prvUnlockQueue>
                /* Resuming the scheduler will move tasks from the pending
                 * ready list into the ready list - so it is feasible that this
                 * task is already in the ready list before it yields - in which
                 * case the yield will not cause a context switch unless there
                 * is also a higher priority task in the pending ready list. */
                if( xTaskResumeAll() == pdFALSE )
    3ff0:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>
    3ff4:	88 23       	and	r24, r24
    3ff6:	09 f0       	breq	.+2      	; 0x3ffa <xQueueGenericSend+0x122>
    3ff8:	9b cf       	rjmp	.-202    	; 0x3f30 <xQueueGenericSend+0x58>
                {
                    portYIELD_WITHIN_API();
    3ffa:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
    3ffe:	98 cf       	rjmp	.-208    	; 0x3f30 <xQueueGenericSend+0x58>
                }
            }
            else
            {
                /* Try again. */
                prvUnlockQueue( pxQueue );
    4000:	c8 01       	movw	r24, r16
    4002:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <prvUnlockQueue>
                ( void ) xTaskResumeAll();
    4006:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>
    400a:	92 cf       	rjmp	.-220    	; 0x3f30 <xQueueGenericSend+0x58>
            }
        }
        else
        {
            /* The timeout has expired. */
            prvUnlockQueue( pxQueue );
    400c:	c8 01       	movw	r24, r16
    400e:	0e 94 26 1d 	call	0x3a4c	; 0x3a4c <prvUnlockQueue>
            ( void ) xTaskResumeAll();
    4012:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>
    4016:	80 e0       	ldi	r24, 0x00	; 0

            traceQUEUE_SEND_FAILED( pxQueue );
            return errQUEUE_FULL;
        }
    } /*lint -restore */
}
    4018:	0f 90       	pop	r0
    401a:	0f 90       	pop	r0
    401c:	0f 90       	pop	r0
    401e:	0f 90       	pop	r0
    4020:	0f 90       	pop	r0
    4022:	cf 91       	pop	r28
    4024:	df 91       	pop	r29
    4026:	1f 91       	pop	r17
    4028:	0f 91       	pop	r16
    402a:	ff 90       	pop	r15
    402c:	ef 90       	pop	r14
    402e:	df 90       	pop	r13
    4030:	cf 90       	pop	r12
    4032:	bf 90       	pop	r11
    4034:	af 90       	pop	r10
    4036:	9f 90       	pop	r9
    4038:	8f 90       	pop	r8
    403a:	7f 90       	pop	r7
    403c:	6f 90       	pop	r6
    403e:	5f 90       	pop	r5
    4040:	08 95       	ret

00004042 <xQueueGenericReset>:
    }
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue,
                               BaseType_t xNewQueue )
{
    4042:	cf 93       	push	r28
    4044:	df 93       	push	r29
    4046:	ec 01       	movw	r28, r24
    4048:	e6 2f       	mov	r30, r22
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    404a:	00 97       	sbiw	r24, 0x00	; 0
    404c:	09 f4       	brne	.+2      	; 0x4050 <xQueueGenericReset+0xe>
    404e:	4f c0       	rjmp	.+158    	; 0x40ee <xQueueGenericReset+0xac>
    4050:	2b 8d       	ldd	r18, Y+27	; 0x1b
    4052:	22 23       	and	r18, r18
    4054:	09 f4       	brne	.+2      	; 0x4058 <xQueueGenericReset+0x16>
    4056:	4b c0       	rjmp	.+150    	; 0x40ee <xQueueGenericReset+0xac>
    4058:	3c 8d       	ldd	r19, Y+28	; 0x1c
    405a:	8f ef       	ldi	r24, 0xFF	; 255
    405c:	9f e7       	ldi	r25, 0x7F	; 127
    405e:	62 2f       	mov	r22, r18
    4060:	70 e0       	ldi	r23, 0x00	; 0
    4062:	0e 94 1b 31 	call	0x6236	; 0x6236 <__udivmodhi4>
    4066:	83 2f       	mov	r24, r19
    4068:	90 e0       	ldi	r25, 0x00	; 0
    406a:	68 17       	cp	r22, r24
    406c:	79 07       	cpc	r23, r25
    406e:	08 f4       	brcc	.+2      	; 0x4072 <xQueueGenericReset+0x30>
    4070:	3e c0       	rjmp	.+124    	; 0x40ee <xQueueGenericReset+0xac>
        ( pxQueue->uxLength >= 1U ) &&
        /* Check for multiplication overflow. */
        ( ( SIZE_MAX / pxQueue->uxLength ) >= pxQueue->uxItemSize ) )
    {
        taskENTER_CRITICAL();
    4072:	0f b6       	in	r0, 0x3f	; 63
    4074:	f8 94       	cli
    4076:	0f 92       	push	r0
        {
            pxQueue->u.xQueue.pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    4078:	32 9f       	mul	r19, r18
    407a:	c0 01       	movw	r24, r0
    407c:	11 24       	eor	r1, r1
    407e:	48 81       	ld	r20, Y
    4080:	59 81       	ldd	r21, Y+1	; 0x01
    4082:	84 0f       	add	r24, r20
    4084:	95 1f       	adc	r25, r21
    4086:	9d 83       	std	Y+5, r25	; 0x05
    4088:	8c 83       	std	Y+4, r24	; 0x04
            pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
    408a:	1a 8e       	std	Y+26, r1	; 0x1a
            pxQueue->pcWriteTo = pxQueue->pcHead;
    408c:	5b 83       	std	Y+3, r21	; 0x03
    408e:	4a 83       	std	Y+2, r20	; 0x02
            pxQueue->u.xQueue.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - 1U ) * pxQueue->uxItemSize ); /*lint !e9016 Pointer arithmetic allowed on char types, especially when it assists conveying intent. */
    4090:	2b 8d       	ldd	r18, Y+27	; 0x1b
    4092:	30 e0       	ldi	r19, 0x00	; 0
    4094:	21 50       	subi	r18, 0x01	; 1
    4096:	30 40       	sbci	r19, 0x00	; 0
    4098:	8c 8d       	ldd	r24, Y+28	; 0x1c
    409a:	90 e0       	ldi	r25, 0x00	; 0
    409c:	bc 01       	movw	r22, r24
    409e:	26 9f       	mul	r18, r22
    40a0:	c0 01       	movw	r24, r0
    40a2:	27 9f       	mul	r18, r23
    40a4:	90 0d       	add	r25, r0
    40a6:	36 9f       	mul	r19, r22
    40a8:	90 0d       	add	r25, r0
    40aa:	11 24       	eor	r1, r1
    40ac:	48 0f       	add	r20, r24
    40ae:	59 1f       	adc	r21, r25
    40b0:	5f 83       	std	Y+7, r21	; 0x07
    40b2:	4e 83       	std	Y+6, r20	; 0x06
            pxQueue->cRxLock = queueUNLOCKED;
    40b4:	8f ef       	ldi	r24, 0xFF	; 255
    40b6:	8d 8f       	std	Y+29, r24	; 0x1d
            pxQueue->cTxLock = queueUNLOCKED;
    40b8:	8e 8f       	std	Y+30, r24	; 0x1e

            if( xNewQueue == pdFALSE )
    40ba:	ee 23       	and	r30, r30
    40bc:	61 f4       	brne	.+24     	; 0x40d6 <xQueueGenericReset+0x94>
                /* If there are tasks blocked waiting to read from the queue, then
                 * the tasks will remain blocked as after this function exits the queue
                 * will still be empty.  If there are tasks blocked waiting to write to
                 * the queue, then one should be unblocked as after this function exits
                 * it will be possible to write to it. */
                if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    40be:	88 85       	ldd	r24, Y+8	; 0x08
    40c0:	88 23       	and	r24, r24
    40c2:	89 f0       	breq	.+34     	; 0x40e6 <xQueueGenericReset+0xa4>
                {
                    if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    40c4:	ce 01       	movw	r24, r28
    40c6:	08 96       	adiw	r24, 0x08	; 8
    40c8:	0e 94 b8 25 	call	0x4b70	; 0x4b70 <xTaskRemoveFromEventList>
    40cc:	88 23       	and	r24, r24
    40ce:	59 f0       	breq	.+22     	; 0x40e6 <xQueueGenericReset+0xa4>
                    {
                        queueYIELD_IF_USING_PREEMPTION();
    40d0:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
    40d4:	08 c0       	rjmp	.+16     	; 0x40e6 <xQueueGenericReset+0xa4>
                }
            }
            else
            {
                /* Ensure the event queues start in the correct state. */
                vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    40d6:	ce 01       	movw	r24, r28
    40d8:	08 96       	adiw	r24, 0x08	; 8
    40da:	0e 94 48 1b 	call	0x3690	; 0x3690 <vListInitialise>
                vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    40de:	ce 01       	movw	r24, r28
    40e0:	41 96       	adiw	r24, 0x11	; 17
    40e2:	0e 94 48 1b 	call	0x3690	; 0x3690 <vListInitialise>
            }
        }
        taskEXIT_CRITICAL();
    40e6:	0f 90       	pop	r0
    40e8:	0f be       	out	0x3f, r0	; 63
    40ea:	81 e0       	ldi	r24, 0x01	; 1
    40ec:	01 c0       	rjmp	.+2      	; 0x40f0 <xQueueGenericReset+0xae>
    BaseType_t xReturn = pdPASS;
    Queue_t * const pxQueue = xQueue;

    configASSERT( pxQueue );

    if( ( pxQueue != NULL ) &&
    40ee:	80 e0       	ldi	r24, 0x00	; 0
    configASSERT( xReturn != pdFAIL );

    /* A value is returned for calling semantic consistency with previous
     * versions. */
    return xReturn;
}
    40f0:	df 91       	pop	r29
    40f2:	cf 91       	pop	r28
    40f4:	08 95       	ret

000040f6 <xQueueGenericCreate>:
#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )

    QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength,
                                       const UBaseType_t uxItemSize,
                                       const uint8_t ucQueueType )
    {
    40f6:	0f 93       	push	r16
    40f8:	1f 93       	push	r17
    40fa:	cf 93       	push	r28
    40fc:	df 93       	push	r29
    40fe:	18 2f       	mov	r17, r24
    4100:	06 2f       	mov	r16, r22
        Queue_t * pxNewQueue = NULL;
        size_t xQueueSizeInBytes;
        uint8_t * pucQueueStorage;

        if( ( uxQueueLength > ( UBaseType_t ) 0 ) &&
    4102:	88 23       	and	r24, r24
    4104:	41 f1       	breq	.+80     	; 0x4156 <xQueueGenericCreate+0x60>
    4106:	8f ef       	ldi	r24, 0xFF	; 255
    4108:	9f e7       	ldi	r25, 0x7F	; 127
    410a:	61 2f       	mov	r22, r17
    410c:	70 e0       	ldi	r23, 0x00	; 0
    410e:	0e 94 1b 31 	call	0x6236	; 0x6236 <__udivmodhi4>
    4112:	80 2f       	mov	r24, r16
    4114:	90 e0       	ldi	r25, 0x00	; 0
    4116:	68 17       	cp	r22, r24
    4118:	79 07       	cpc	r23, r25
    411a:	e8 f0       	brcs	.+58     	; 0x4156 <xQueueGenericCreate+0x60>
    411c:	01 9f       	mul	r16, r17
    411e:	c0 01       	movw	r24, r0
    4120:	11 24       	eor	r1, r1
    4122:	2f e7       	ldi	r18, 0x7F	; 127
    4124:	81 3e       	cpi	r24, 0xE1	; 225
    4126:	92 07       	cpc	r25, r18
    4128:	b0 f4       	brcc	.+44     	; 0x4156 <xQueueGenericCreate+0x60>
             * alignment requirements of the Queue_t structure - which in this case
             * is an int8_t *.  Therefore, whenever the stack alignment requirements
             * are greater than or equal to the pointer to char requirements the cast
             * is safe.  In other cases alignment requirements are not strict (one or
             * two bytes). */
            pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); /*lint !e9087 !e9079 see comment above. */
    412a:	4f 96       	adiw	r24, 0x1f	; 31
    412c:	0e 94 48 18 	call	0x3090	; 0x3090 <pvPortMalloc>
    4130:	ec 01       	movw	r28, r24

            if( pxNewQueue != NULL )
    4132:	20 97       	sbiw	r28, 0x00	; 0
    4134:	91 f0       	breq	.+36     	; 0x415a <xQueueGenericCreate+0x64>
{
    /* Remove compiler warnings about unused parameters should
     * configUSE_TRACE_FACILITY not be set to 1. */
    ( void ) ucQueueType;

    if( uxItemSize == ( UBaseType_t ) 0 )
    4136:	00 23       	and	r16, r16
    4138:	19 f4       	brne	.+6      	; 0x4140 <xQueueGenericCreate+0x4a>
    {
        /* No RAM was allocated for the queue storage area, but PC head cannot
         * be set to NULL because NULL is used as a key to say the queue is used as
         * a mutex.  Therefore just set pcHead to point to the queue as a benign
         * value that is known to be within the memory map. */
        pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
    413a:	d9 83       	std	Y+1, r29	; 0x01
    413c:	c8 83       	st	Y, r28
    413e:	04 c0       	rjmp	.+8      	; 0x4148 <xQueueGenericCreate+0x52>
    }
    else
    {
        /* Set the head to the start of the queue storage area. */
        pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
    4140:	ce 01       	movw	r24, r28
    4142:	4f 96       	adiw	r24, 0x1f	; 31
    4144:	99 83       	std	Y+1, r25	; 0x01
    4146:	88 83       	st	Y, r24
    }

    /* Initialise the queue members as described where the queue type is
     * defined. */
    pxNewQueue->uxLength = uxQueueLength;
    4148:	1b 8f       	std	Y+27, r17	; 0x1b
    pxNewQueue->uxItemSize = uxItemSize;
    414a:	0c 8f       	std	Y+28, r16	; 0x1c
    ( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
    414c:	ce 01       	movw	r24, r28
    414e:	61 e0       	ldi	r22, 0x01	; 1
    4150:	0e 94 21 20 	call	0x4042	; 0x4042 <xQueueGenericReset>
    4154:	02 c0       	rjmp	.+4      	; 0x415a <xQueueGenericCreate+0x64>
    4156:	c0 e0       	ldi	r28, 0x00	; 0
    4158:	d0 e0       	ldi	r29, 0x00	; 0
            configASSERT( pxNewQueue );
            mtCOVERAGE_TEST_MARKER();
        }

        return pxNewQueue;
    }
    415a:	8c 2f       	mov	r24, r28
    415c:	9d 2f       	mov	r25, r29
    415e:	df 91       	pop	r29
    4160:	cf 91       	pop	r28
    4162:	1f 91       	pop	r17
    4164:	0f 91       	pop	r16
    4166:	08 95       	ret

00004168 <xStreamBufferSetTriggerLevel>:
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSetTriggerLevel( StreamBufferHandle_t xStreamBuffer,
                                         size_t xTriggerLevel )
{
    4168:	fc 01       	movw	r30, r24
    BaseType_t xReturn;

    configASSERT( pxStreamBuffer );

    /* It is not valid for the trigger level to be 0. */
    if( xTriggerLevel == ( size_t ) 0 )
    416a:	61 15       	cp	r22, r1
    416c:	71 05       	cpc	r23, r1
    416e:	11 f4       	brne	.+4      	; 0x4174 <xStreamBufferSetTriggerLevel+0xc>
    4170:	61 e0       	ldi	r22, 0x01	; 1
    4172:	70 e0       	ldi	r23, 0x00	; 0
        xTriggerLevel = ( size_t ) 1;
    }

    /* The trigger level is the number of bytes that must be in the stream
     * buffer before a task that is waiting for data is unblocked. */
    if( xTriggerLevel < pxStreamBuffer->xLength )
    4174:	84 81       	ldd	r24, Z+4	; 0x04
    4176:	95 81       	ldd	r25, Z+5	; 0x05
    4178:	68 17       	cp	r22, r24
    417a:	79 07       	cpc	r23, r25
    417c:	10 f0       	brcs	.+4      	; 0x4182 <xStreamBufferSetTriggerLevel+0x1a>
    417e:	80 e0       	ldi	r24, 0x00	; 0
    4180:	08 95       	ret
    {
        pxStreamBuffer->xTriggerLevelBytes = xTriggerLevel;
    4182:	77 83       	std	Z+7, r23	; 0x07
    4184:	66 83       	std	Z+6, r22	; 0x06
    4186:	81 e0       	ldi	r24, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    4188:	08 95       	ret

0000418a <xStreamBufferSpacesAvailable>:
/*-----------------------------------------------------------*/

size_t xStreamBufferSpacesAvailable( StreamBufferHandle_t xStreamBuffer )
{
    418a:	fc 01       	movw	r30, r24
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    418c:	a4 81       	ldd	r26, Z+4	; 0x04
    418e:	b5 81       	ldd	r27, Z+5	; 0x05
    /* The code below reads xTail and then xHead.  This is safe if the stream
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
    4190:	20 81       	ld	r18, Z
    4192:	31 81       	ldd	r19, Z+1	; 0x01
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    4194:	40 81       	ld	r20, Z
    4196:	51 81       	ldd	r21, Z+1	; 0x01
        xSpace -= pxStreamBuffer->xHead;
    4198:	62 81       	ldd	r22, Z+2	; 0x02
    419a:	73 81       	ldd	r23, Z+3	; 0x03
    } while( xOriginalTail != pxStreamBuffer->xTail );
    419c:	80 81       	ld	r24, Z
    419e:	91 81       	ldd	r25, Z+1	; 0x01
    41a0:	82 17       	cp	r24, r18
    41a2:	93 07       	cpc	r25, r19
    41a4:	a9 f7       	brne	.-22     	; 0x4190 <xStreamBufferSpacesAvailable+0x6>
     * buffer is updated once between the two reads - but not if the stream buffer
     * is updated more than once between the two reads - hence the loop. */
    do
    {
        xOriginalTail = pxStreamBuffer->xTail;
        xSpace = pxStreamBuffer->xLength + pxStreamBuffer->xTail;
    41a6:	cd 01       	movw	r24, r26
    41a8:	84 0f       	add	r24, r20
    41aa:	95 1f       	adc	r25, r21
        xSpace -= pxStreamBuffer->xHead;
    41ac:	01 97       	sbiw	r24, 0x01	; 1
    } while( xOriginalTail != pxStreamBuffer->xTail );

    xSpace -= ( size_t ) 1;
    41ae:	9c 01       	movw	r18, r24
    41b0:	26 1b       	sub	r18, r22
    41b2:	37 0b       	sbc	r19, r23

    if( xSpace >= pxStreamBuffer->xLength )
    41b4:	2a 17       	cp	r18, r26
    41b6:	3b 07       	cpc	r19, r27
    41b8:	10 f0       	brcs	.+4      	; 0x41be <xStreamBufferSpacesAvailable+0x34>
    {
        xSpace -= pxStreamBuffer->xLength;
    41ba:	2a 1b       	sub	r18, r26
    41bc:	3b 0b       	sbc	r19, r27
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xSpace;
}
    41be:	82 2f       	mov	r24, r18
    41c0:	93 2f       	mov	r25, r19
    41c2:	08 95       	ret

000041c4 <xStreamBufferIsEmpty>:
    return xCount;
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsEmpty( StreamBufferHandle_t xStreamBuffer )
{
    41c4:	fc 01       	movw	r30, r24
    size_t xTail;

    configASSERT( pxStreamBuffer );

    /* True if no bytes are available. */
    xTail = pxStreamBuffer->xTail;
    41c6:	20 81       	ld	r18, Z
    41c8:	31 81       	ldd	r19, Z+1	; 0x01

    if( pxStreamBuffer->xHead == xTail )
    41ca:	82 81       	ldd	r24, Z+2	; 0x02
    41cc:	93 81       	ldd	r25, Z+3	; 0x03
    41ce:	40 e0       	ldi	r20, 0x00	; 0
    41d0:	82 17       	cp	r24, r18
    41d2:	93 07       	cpc	r25, r19
    41d4:	09 f4       	brne	.+2      	; 0x41d8 <xStreamBufferIsEmpty+0x14>
    41d6:	41 e0       	ldi	r20, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    41d8:	84 2f       	mov	r24, r20
    41da:	08 95       	ret

000041dc <xStreamBufferIsFull>:
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferIsFull( StreamBufferHandle_t xStreamBuffer )
{
    41dc:	cf 93       	push	r28
    41de:	df 93       	push	r29
    41e0:	fc 01       	movw	r30, r24

    /* This generic version of the receive function is used by both message
     * buffers, which store discrete messages, and stream buffers, which store a
     * continuous stream of bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    41e2:	86 85       	ldd	r24, Z+14	; 0x0e
    41e4:	80 fd       	sbrc	r24, 0
    41e6:	03 c0       	rjmp	.+6      	; 0x41ee <xStreamBufferIsFull+0x12>
    41e8:	c0 e0       	ldi	r28, 0x00	; 0
    41ea:	d0 e0       	ldi	r29, 0x00	; 0
    41ec:	02 c0       	rjmp	.+4      	; 0x41f2 <xStreamBufferIsFull+0x16>
    41ee:	c2 e0       	ldi	r28, 0x02	; 2
    41f0:	d0 e0       	ldi	r29, 0x00	; 0
    {
        xBytesToStoreMessageLength = 0;
    }

    /* True if the available space equals zero. */
    if( xStreamBufferSpacesAvailable( xStreamBuffer ) <= xBytesToStoreMessageLength )
    41f2:	cf 01       	movw	r24, r30
    41f4:	0e 94 c5 20 	call	0x418a	; 0x418a <xStreamBufferSpacesAvailable>
    41f8:	20 e0       	ldi	r18, 0x00	; 0
    41fa:	c8 17       	cp	r28, r24
    41fc:	d9 07       	cpc	r29, r25
    41fe:	08 f0       	brcs	.+2      	; 0x4202 <xStreamBufferIsFull+0x26>
    4200:	21 e0       	ldi	r18, 0x01	; 1
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    4202:	82 2f       	mov	r24, r18
    4204:	df 91       	pop	r29
    4206:	cf 91       	pop	r28
    4208:	08 95       	ret

0000420a <prvBytesInBuffer>:
    return xTail;
}
/*-----------------------------------------------------------*/

static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
    420a:	fc 01       	movw	r30, r24
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    420c:	44 81       	ldd	r20, Z+4	; 0x04
    420e:	55 81       	ldd	r21, Z+5	; 0x05
    4210:	82 81       	ldd	r24, Z+2	; 0x02
    4212:	93 81       	ldd	r25, Z+3	; 0x03
    xCount -= pxStreamBuffer->xTail;
    4214:	20 81       	ld	r18, Z
    4216:	31 81       	ldd	r19, Z+1	; 0x01
static size_t prvBytesInBuffer( const StreamBuffer_t * const pxStreamBuffer )
{
/* Returns the distance between xTail and xHead. */
    size_t xCount;

    xCount = pxStreamBuffer->xLength + pxStreamBuffer->xHead;
    4218:	84 0f       	add	r24, r20
    421a:	95 1f       	adc	r25, r21
    xCount -= pxStreamBuffer->xTail;
    421c:	bc 01       	movw	r22, r24
    421e:	62 1b       	sub	r22, r18
    4220:	73 0b       	sbc	r23, r19
    4222:	9b 01       	movw	r18, r22

    if( xCount >= pxStreamBuffer->xLength )
    4224:	64 17       	cp	r22, r20
    4226:	75 07       	cpc	r23, r21
    4228:	10 f0       	brcs	.+4      	; 0x422e <prvBytesInBuffer+0x24>
    {
        xCount -= pxStreamBuffer->xLength;
    422a:	24 1b       	sub	r18, r20
    422c:	35 0b       	sbc	r19, r21
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xCount;
}
    422e:	82 2f       	mov	r24, r18
    4230:	93 2f       	mov	r25, r19
    4232:	08 95       	ret

00004234 <xStreamBufferBytesAvailable>:
    const StreamBuffer_t * const pxStreamBuffer = xStreamBuffer;
    size_t xReturn;

    configASSERT( pxStreamBuffer );

    xReturn = prvBytesInBuffer( pxStreamBuffer );
    4234:	0e 94 05 21 	call	0x420a	; 0x420a <prvBytesInBuffer>
    return xReturn;
}
    4238:	08 95       	ret

0000423a <xStreamBufferReceiveCompletedFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReceiveCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                                 BaseType_t * pxHigherPriorityTaskWoken )
{
    423a:	cf 92       	push	r12
    423c:	df 92       	push	r13
    423e:	ef 92       	push	r14
    4240:	ff 92       	push	r15
    4242:	0f 93       	push	r16
    4244:	cf 93       	push	r28
    4246:	df 93       	push	r29
    4248:	ec 01       	movw	r28, r24
    424a:	6b 01       	movw	r12, r22

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxStreamBuffer )->xTaskWaitingToSend != NULL )
    424c:	8a 85       	ldd	r24, Y+10	; 0x0a
    424e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4250:	89 2b       	or	r24, r25
    4252:	11 f4       	brne	.+4      	; 0x4258 <xStreamBufferReceiveCompletedFromISR+0x1e>
    4254:	80 e0       	ldi	r24, 0x00	; 0
    4256:	0f c0       	rjmp	.+30     	; 0x4276 <xStreamBufferReceiveCompletedFromISR+0x3c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToSend,
    4258:	8a 85       	ldd	r24, Y+10	; 0x0a
    425a:	9b 85       	ldd	r25, Y+11	; 0x0b
    425c:	60 e0       	ldi	r22, 0x00	; 0
    425e:	20 e0       	ldi	r18, 0x00	; 0
    4260:	30 e0       	ldi	r19, 0x00	; 0
    4262:	40 e0       	ldi	r20, 0x00	; 0
    4264:	50 e0       	ldi	r21, 0x00	; 0
    4266:	00 e0       	ldi	r16, 0x00	; 0
    4268:	ee 24       	eor	r14, r14
    426a:	ff 24       	eor	r15, r15
    426c:	0e 94 b3 28 	call	0x5166	; 0x5166 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToSend = NULL;
    4270:	1b 86       	std	Y+11, r1	; 0x0b
    4272:	1a 86       	std	Y+10, r1	; 0x0a
    4274:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    4276:	df 91       	pop	r29
    4278:	cf 91       	pop	r28
    427a:	0f 91       	pop	r16
    427c:	ff 90       	pop	r15
    427e:	ef 90       	pop	r14
    4280:	df 90       	pop	r13
    4282:	cf 90       	pop	r12
    4284:	08 95       	ret

00004286 <xStreamBufferSendCompletedFromISR>:
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferSendCompletedFromISR( StreamBufferHandle_t xStreamBuffer,
                                              BaseType_t * pxHigherPriorityTaskWoken )
{
    4286:	cf 92       	push	r12
    4288:	df 92       	push	r13
    428a:	ef 92       	push	r14
    428c:	ff 92       	push	r15
    428e:	0f 93       	push	r16
    4290:	cf 93       	push	r28
    4292:	df 93       	push	r29
    4294:	ec 01       	movw	r28, r24
    4296:	6b 01       	movw	r12, r22

    configASSERT( pxStreamBuffer );

    uxSavedInterruptStatus = ( UBaseType_t ) portSET_INTERRUPT_MASK_FROM_ISR();
    {
        if( ( pxStreamBuffer )->xTaskWaitingToReceive != NULL )
    4298:	88 85       	ldd	r24, Y+8	; 0x08
    429a:	99 85       	ldd	r25, Y+9	; 0x09
    429c:	89 2b       	or	r24, r25
    429e:	11 f4       	brne	.+4      	; 0x42a4 <xStreamBufferSendCompletedFromISR+0x1e>
    42a0:	80 e0       	ldi	r24, 0x00	; 0
    42a2:	0f c0       	rjmp	.+30     	; 0x42c2 <xStreamBufferSendCompletedFromISR+0x3c>
        {
            ( void ) xTaskNotifyFromISR( ( pxStreamBuffer )->xTaskWaitingToReceive,
    42a4:	88 85       	ldd	r24, Y+8	; 0x08
    42a6:	99 85       	ldd	r25, Y+9	; 0x09
    42a8:	60 e0       	ldi	r22, 0x00	; 0
    42aa:	20 e0       	ldi	r18, 0x00	; 0
    42ac:	30 e0       	ldi	r19, 0x00	; 0
    42ae:	40 e0       	ldi	r20, 0x00	; 0
    42b0:	50 e0       	ldi	r21, 0x00	; 0
    42b2:	00 e0       	ldi	r16, 0x00	; 0
    42b4:	ee 24       	eor	r14, r14
    42b6:	ff 24       	eor	r15, r15
    42b8:	0e 94 b3 28 	call	0x5166	; 0x5166 <xTaskGenericNotifyFromISR>
                                         ( uint32_t ) 0,
                                         eNoAction,
                                         pxHigherPriorityTaskWoken );
            ( pxStreamBuffer )->xTaskWaitingToReceive = NULL;
    42bc:	19 86       	std	Y+9, r1	; 0x09
    42be:	18 86       	std	Y+8, r1	; 0x08
    42c0:	81 e0       	ldi	r24, 0x01	; 1
        }
    }
    portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    42c2:	df 91       	pop	r29
    42c4:	cf 91       	pop	r28
    42c6:	0f 91       	pop	r16
    42c8:	ff 90       	pop	r15
    42ca:	ef 90       	pop	r14
    42cc:	df 90       	pop	r13
    42ce:	cf 90       	pop	r12
    42d0:	08 95       	ret

000042d2 <prvReadBytesFromBuffer>:

static size_t prvReadBytesFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                      uint8_t * pucData,
                                      size_t xCount,
                                      size_t xTail )
{
    42d2:	af 92       	push	r10
    42d4:	bf 92       	push	r11
    42d6:	cf 92       	push	r12
    42d8:	df 92       	push	r13
    42da:	ef 92       	push	r14
    42dc:	ff 92       	push	r15
    42de:	0f 93       	push	r16
    42e0:	1f 93       	push	r17
    42e2:	cf 93       	push	r28
    42e4:	df 93       	push	r29
    42e6:	6c 01       	movw	r12, r24
    42e8:	8b 01       	movw	r16, r22
    42ea:	7a 01       	movw	r14, r20
    42ec:	59 01       	movw	r10, r18
    configASSERT( xCount != ( size_t ) 0 );

    /* Calculate the number of bytes that can be read - which may be
     * less than the number wanted if the data wraps around to the start of
     * the buffer. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xTail, xCount );
    42ee:	dc 01       	movw	r26, r24
    42f0:	14 96       	adiw	r26, 0x04	; 4
    42f2:	8d 91       	ld	r24, X+
    42f4:	9c 91       	ld	r25, X
    42f6:	15 97       	sbiw	r26, 0x05	; 5
    42f8:	ec 01       	movw	r28, r24
    42fa:	c2 1b       	sub	r28, r18
    42fc:	d3 0b       	sbc	r29, r19
    42fe:	4c 17       	cp	r20, r28
    4300:	5d 07       	cpc	r21, r29
    4302:	08 f4       	brcc	.+2      	; 0x4306 <prvReadBytesFromBuffer+0x34>
    4304:	ea 01       	movw	r28, r20

    /* Obtain the number of bytes it is possible to obtain in the first
     * read.  Asserts check bounds of read and write. */
    configASSERT( xFirstLength <= xCount );
    configASSERT( ( xTail + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) pucData, ( const void * ) &( pxStreamBuffer->pucBuffer[ xTail ] ), xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4306:	f6 01       	movw	r30, r12
    4308:	24 85       	ldd	r18, Z+12	; 0x0c
    430a:	35 85       	ldd	r19, Z+13	; 0x0d
    430c:	2a 0d       	add	r18, r10
    430e:	3b 1d       	adc	r19, r11
    4310:	80 2f       	mov	r24, r16
    4312:	91 2f       	mov	r25, r17
    4314:	62 2f       	mov	r22, r18
    4316:	73 2f       	mov	r23, r19
    4318:	4c 2f       	mov	r20, r28
    431a:	5d 2f       	mov	r21, r29
    431c:	0e 94 ab 32 	call	0x6556	; 0x6556 <memcpy>

    /* If the total number of wanted bytes is greater than the number
     * that could be read in the first read... */
    if( xCount > xFirstLength )
    4320:	ce 15       	cp	r28, r14
    4322:	df 05       	cpc	r29, r15
    4324:	90 f4       	brcc	.+36     	; 0x434a <prvReadBytesFromBuffer+0x78>
    {
        /* ...then read the remaining bytes from the start of the buffer. */
        ( void ) memcpy( ( void * ) &( pucData[ xFirstLength ] ), ( void * ) ( pxStreamBuffer->pucBuffer ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    4326:	98 01       	movw	r18, r16
    4328:	2c 0f       	add	r18, r28
    432a:	3d 1f       	adc	r19, r29
    432c:	f7 01       	movw	r30, r14
    432e:	ec 1b       	sub	r30, r28
    4330:	fd 0b       	sbc	r31, r29
    4332:	d6 01       	movw	r26, r12
    4334:	1c 96       	adiw	r26, 0x0c	; 12
    4336:	6c 91       	ld	r22, X
    4338:	1c 97       	sbiw	r26, 0x0c	; 12
    433a:	1d 96       	adiw	r26, 0x0d	; 13
    433c:	7c 91       	ld	r23, X
    433e:	82 2f       	mov	r24, r18
    4340:	93 2f       	mov	r25, r19
    4342:	4e 2f       	mov	r20, r30
    4344:	5f 2f       	mov	r21, r31
    4346:	0e 94 ab 32 	call	0x6556	; 0x6556 <memcpy>
    {
        mtCOVERAGE_TEST_MARKER();
    }

    /* Move the tail pointer to effectively remove the data read from the buffer. */
    xTail += xCount;
    434a:	95 01       	movw	r18, r10
    434c:	2e 0d       	add	r18, r14
    434e:	3f 1d       	adc	r19, r15

    if( xTail >= pxStreamBuffer->xLength )
    4350:	f6 01       	movw	r30, r12
    4352:	84 81       	ldd	r24, Z+4	; 0x04
    4354:	95 81       	ldd	r25, Z+5	; 0x05
    4356:	28 17       	cp	r18, r24
    4358:	39 07       	cpc	r19, r25
    435a:	10 f0       	brcs	.+4      	; 0x4360 <prvReadBytesFromBuffer+0x8e>
    {
        xTail -= pxStreamBuffer->xLength;
    435c:	28 1b       	sub	r18, r24
    435e:	39 0b       	sbc	r19, r25
    }

    return xTail;
}
    4360:	82 2f       	mov	r24, r18
    4362:	93 2f       	mov	r25, r19
    4364:	df 91       	pop	r29
    4366:	cf 91       	pop	r28
    4368:	1f 91       	pop	r17
    436a:	0f 91       	pop	r16
    436c:	ff 90       	pop	r15
    436e:	ef 90       	pop	r14
    4370:	df 90       	pop	r13
    4372:	cf 90       	pop	r12
    4374:	bf 90       	pop	r11
    4376:	af 90       	pop	r10
    4378:	08 95       	ret

0000437a <prvReadMessageFromBuffer>:

static size_t prvReadMessageFromBuffer( StreamBuffer_t * pxStreamBuffer,
                                        void * pvRxData,
                                        size_t xBufferLengthBytes,
                                        size_t xBytesAvailable )
{
    437a:	af 92       	push	r10
    437c:	bf 92       	push	r11
    437e:	cf 92       	push	r12
    4380:	df 92       	push	r13
    4382:	ef 92       	push	r14
    4384:	ff 92       	push	r15
    4386:	0f 93       	push	r16
    4388:	1f 93       	push	r17
    438a:	df 93       	push	r29
    438c:	cf 93       	push	r28
    438e:	00 d0       	rcall	.+0      	; 0x4390 <prvReadMessageFromBuffer+0x16>
    4390:	cd b7       	in	r28, 0x3d	; 61
    4392:	de b7       	in	r29, 0x3e	; 62
    4394:	7c 01       	movw	r14, r24
    4396:	5b 01       	movw	r10, r22
    4398:	6a 01       	movw	r12, r20
    439a:	89 01       	movw	r16, r18
    size_t xCount, xNextMessageLength;
    configMESSAGE_BUFFER_LENGTH_TYPE xTempNextMessageLength;
    size_t xNextTail = pxStreamBuffer->xTail;
    439c:	fc 01       	movw	r30, r24
    439e:	20 81       	ld	r18, Z
    43a0:	31 81       	ldd	r19, Z+1	; 0x01

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    43a2:	86 85       	ldd	r24, Z+14	; 0x0e
    43a4:	80 fd       	sbrc	r24, 0
    43a6:	02 c0       	rjmp	.+4      	; 0x43ac <prvReadMessageFromBuffer+0x32>
    43a8:	ca 01       	movw	r24, r20
    43aa:	13 c0       	rjmp	.+38     	; 0x43d2 <prvReadMessageFromBuffer+0x58>
    {
        /* A discrete message is being received.  First receive the length
         * of the message. */
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
    43ac:	c7 01       	movw	r24, r14
    43ae:	be 01       	movw	r22, r28
    43b0:	6f 5f       	subi	r22, 0xFF	; 255
    43b2:	7f 4f       	sbci	r23, 0xFF	; 255
    43b4:	42 e0       	ldi	r20, 0x02	; 2
    43b6:	50 e0       	ldi	r21, 0x00	; 0
    43b8:	0e 94 69 21 	call	0x42d2	; 0x42d2 <prvReadBytesFromBuffer>
    43bc:	9c 01       	movw	r18, r24
        xNextMessageLength = ( size_t ) xTempNextMessageLength;
    43be:	89 81       	ldd	r24, Y+1	; 0x01
    43c0:	9a 81       	ldd	r25, Y+2	; 0x02
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;

        /* Check there is enough space in the buffer provided by the
         * user. */
        if( xNextMessageLength > xBufferLengthBytes )
    43c2:	c8 16       	cp	r12, r24
    43c4:	d9 06       	cpc	r13, r25
    43c6:	18 f4       	brcc	.+6      	; 0x43ce <prvReadMessageFromBuffer+0x54>
    43c8:	00 e0       	ldi	r16, 0x00	; 0
    43ca:	10 e0       	ldi	r17, 0x00	; 0
    43cc:	11 c0       	rjmp	.+34     	; 0x43f0 <prvReadMessageFromBuffer+0x76>
        xNextTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempNextMessageLength, sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextTail );
        xNextMessageLength = ( size_t ) xTempNextMessageLength;

        /* Reduce the number of bytes available by the number of bytes just
         * read out. */
        xBytesAvailable -= sbBYTES_TO_STORE_MESSAGE_LENGTH;
    43ce:	02 50       	subi	r16, 0x02	; 2
    43d0:	10 40       	sbci	r17, 0x00	; 0
         * message), so read as many bytes as possible. */
        xNextMessageLength = xBufferLengthBytes;
    }

    /* Use the minimum of the wanted bytes and the available bytes. */
    xCount = configMIN( xNextMessageLength, xBytesAvailable );
    43d2:	80 17       	cp	r24, r16
    43d4:	91 07       	cpc	r25, r17
    43d6:	08 f4       	brcc	.+2      	; 0x43da <prvReadMessageFromBuffer+0x60>
    43d8:	8c 01       	movw	r16, r24

    if( xCount != ( size_t ) 0 )
    43da:	01 15       	cp	r16, r1
    43dc:	11 05       	cpc	r17, r1
    43de:	41 f0       	breq	.+16     	; 0x43f0 <prvReadMessageFromBuffer+0x76>
    {
        /* Read the actual data and update the tail to mark the data as officially consumed. */
        pxStreamBuffer->xTail = prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) pvRxData, xCount, xNextTail ); /*lint !e9079 Data storage area is implemented as uint8_t array for ease of sizing, indexing and alignment. */
    43e0:	c7 01       	movw	r24, r14
    43e2:	b5 01       	movw	r22, r10
    43e4:	a8 01       	movw	r20, r16
    43e6:	0e 94 69 21 	call	0x42d2	; 0x42d2 <prvReadBytesFromBuffer>
    43ea:	f7 01       	movw	r30, r14
    43ec:	91 83       	std	Z+1, r25	; 0x01
    43ee:	80 83       	st	Z, r24
    }

    return xCount;
}
    43f0:	80 2f       	mov	r24, r16
    43f2:	91 2f       	mov	r25, r17
    43f4:	0f 90       	pop	r0
    43f6:	0f 90       	pop	r0
    43f8:	cf 91       	pop	r28
    43fa:	df 91       	pop	r29
    43fc:	1f 91       	pop	r17
    43fe:	0f 91       	pop	r16
    4400:	ff 90       	pop	r15
    4402:	ef 90       	pop	r14
    4404:	df 90       	pop	r13
    4406:	cf 90       	pop	r12
    4408:	bf 90       	pop	r11
    440a:	af 90       	pop	r10
    440c:	08 95       	ret

0000440e <xStreamBufferReceiveFromISR>:

size_t xStreamBufferReceiveFromISR( StreamBufferHandle_t xStreamBuffer,
                                    void * pvRxData,
                                    size_t xBufferLengthBytes,
                                    BaseType_t * const pxHigherPriorityTaskWoken )
{
    440e:	af 92       	push	r10
    4410:	bf 92       	push	r11
    4412:	cf 92       	push	r12
    4414:	df 92       	push	r13
    4416:	ef 92       	push	r14
    4418:	ff 92       	push	r15
    441a:	0f 93       	push	r16
    441c:	1f 93       	push	r17
    441e:	cf 93       	push	r28
    4420:	df 93       	push	r29
    4422:	5c 01       	movw	r10, r24
    4424:	7b 01       	movw	r14, r22
    4426:	8a 01       	movw	r16, r20
    4428:	69 01       	movw	r12, r18
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    442a:	fc 01       	movw	r30, r24
    442c:	86 85       	ldd	r24, Z+14	; 0x0e
    442e:	80 fd       	sbrc	r24, 0
    4430:	03 c0       	rjmp	.+6      	; 0x4438 <xStreamBufferReceiveFromISR+0x2a>
    4432:	c0 e0       	ldi	r28, 0x00	; 0
    4434:	d0 e0       	ldi	r29, 0x00	; 0
    4436:	02 c0       	rjmp	.+4      	; 0x443c <xStreamBufferReceiveFromISR+0x2e>
    4438:	c2 e0       	ldi	r28, 0x02	; 2
    443a:	d0 e0       	ldi	r29, 0x00	; 0
    else
    {
        xBytesToStoreMessageLength = 0;
    }

    xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    443c:	c5 01       	movw	r24, r10
    443e:	0e 94 05 21 	call	0x420a	; 0x420a <prvBytesInBuffer>
    4442:	9c 01       	movw	r18, r24
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    4444:	c8 17       	cp	r28, r24
    4446:	d9 07       	cpc	r29, r25
    4448:	18 f0       	brcs	.+6      	; 0x4450 <xStreamBufferReceiveFromISR+0x42>
    444a:	c0 e0       	ldi	r28, 0x00	; 0
    444c:	d0 e0       	ldi	r29, 0x00	; 0
    444e:	1c c0       	rjmp	.+56     	; 0x4488 <xStreamBufferReceiveFromISR+0x7a>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    4450:	c5 01       	movw	r24, r10
    4452:	b7 01       	movw	r22, r14
    4454:	a8 01       	movw	r20, r16
    4456:	0e 94 bd 21 	call	0x437a	; 0x437a <prvReadMessageFromBuffer>
    445a:	ec 01       	movw	r28, r24

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    445c:	00 97       	sbiw	r24, 0x00	; 0
    445e:	a1 f0       	breq	.+40     	; 0x4488 <xStreamBufferReceiveFromISR+0x7a>
        {
            prvRECEIVE_COMPLETED_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    4460:	f5 01       	movw	r30, r10
    4462:	82 85       	ldd	r24, Z+10	; 0x0a
    4464:	93 85       	ldd	r25, Z+11	; 0x0b
    4466:	89 2b       	or	r24, r25
    4468:	79 f0       	breq	.+30     	; 0x4488 <xStreamBufferReceiveFromISR+0x7a>
    446a:	82 85       	ldd	r24, Z+10	; 0x0a
    446c:	93 85       	ldd	r25, Z+11	; 0x0b
    446e:	60 e0       	ldi	r22, 0x00	; 0
    4470:	20 e0       	ldi	r18, 0x00	; 0
    4472:	30 e0       	ldi	r19, 0x00	; 0
    4474:	40 e0       	ldi	r20, 0x00	; 0
    4476:	50 e0       	ldi	r21, 0x00	; 0
    4478:	00 e0       	ldi	r16, 0x00	; 0
    447a:	ee 24       	eor	r14, r14
    447c:	ff 24       	eor	r15, r15
    447e:	0e 94 b3 28 	call	0x5166	; 0x5166 <xTaskGenericNotifyFromISR>
    4482:	f5 01       	movw	r30, r10
    4484:	13 86       	std	Z+11, r1	; 0x0b
    4486:	12 86       	std	Z+10, r1	; 0x0a
    }

    traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength );

    return xReceivedLength;
}
    4488:	8c 2f       	mov	r24, r28
    448a:	9d 2f       	mov	r25, r29
    448c:	df 91       	pop	r29
    448e:	cf 91       	pop	r28
    4490:	1f 91       	pop	r17
    4492:	0f 91       	pop	r16
    4494:	ff 90       	pop	r15
    4496:	ef 90       	pop	r14
    4498:	df 90       	pop	r13
    449a:	cf 90       	pop	r12
    449c:	bf 90       	pop	r11
    449e:	af 90       	pop	r10
    44a0:	08 95       	ret

000044a2 <xStreamBufferNextMessageLengthBytes>:
    return xReceivedLength;
}
/*-----------------------------------------------------------*/

size_t xStreamBufferNextMessageLengthBytes( StreamBufferHandle_t xStreamBuffer )
{
    44a2:	0f 93       	push	r16
    44a4:	1f 93       	push	r17
    44a6:	df 93       	push	r29
    44a8:	cf 93       	push	r28
    44aa:	00 d0       	rcall	.+0      	; 0x44ac <xStreamBufferNextMessageLengthBytes+0xa>
    44ac:	cd b7       	in	r28, 0x3d	; 61
    44ae:	de b7       	in	r29, 0x3e	; 62
    44b0:	8c 01       	movw	r16, r24
    configMESSAGE_BUFFER_LENGTH_TYPE xTempReturn;

    configASSERT( pxStreamBuffer );

    /* Ensure the stream buffer is being used as a message buffer. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    44b2:	fc 01       	movw	r30, r24
    44b4:	86 85       	ldd	r24, Z+14	; 0x0e
    44b6:	80 ff       	sbrs	r24, 0
    44b8:	13 c0       	rjmp	.+38     	; 0x44e0 <xStreamBufferNextMessageLengthBytes+0x3e>
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    44ba:	c8 01       	movw	r24, r16
    44bc:	0e 94 05 21 	call	0x420a	; 0x420a <prvBytesInBuffer>

        if( xBytesAvailable > sbBYTES_TO_STORE_MESSAGE_LENGTH )
    44c0:	03 97       	sbiw	r24, 0x03	; 3
    44c2:	70 f0       	brcs	.+28     	; 0x44e0 <xStreamBufferNextMessageLengthBytes+0x3e>
        {
            /* The number of bytes available is greater than the number of bytes
             * required to hold the length of the next message, so another message
             * is available. */
            ( void ) prvReadBytesFromBuffer( pxStreamBuffer, ( uint8_t * ) &xTempReturn, sbBYTES_TO_STORE_MESSAGE_LENGTH, pxStreamBuffer->xTail );
    44c4:	f8 01       	movw	r30, r16
    44c6:	20 81       	ld	r18, Z
    44c8:	31 81       	ldd	r19, Z+1	; 0x01
    44ca:	c8 01       	movw	r24, r16
    44cc:	be 01       	movw	r22, r28
    44ce:	6f 5f       	subi	r22, 0xFF	; 255
    44d0:	7f 4f       	sbci	r23, 0xFF	; 255
    44d2:	42 e0       	ldi	r20, 0x02	; 2
    44d4:	50 e0       	ldi	r21, 0x00	; 0
    44d6:	0e 94 69 21 	call	0x42d2	; 0x42d2 <prvReadBytesFromBuffer>
            xReturn = ( size_t ) xTempReturn;
    44da:	29 81       	ldd	r18, Y+1	; 0x01
    44dc:	3a 81       	ldd	r19, Y+2	; 0x02
    44de:	02 c0       	rjmp	.+4      	; 0x44e4 <xStreamBufferNextMessageLengthBytes+0x42>
    44e0:	20 e0       	ldi	r18, 0x00	; 0
    44e2:	30 e0       	ldi	r19, 0x00	; 0
    {
        xReturn = 0;
    }

    return xReturn;
}
    44e4:	82 2f       	mov	r24, r18
    44e6:	93 2f       	mov	r25, r19
    44e8:	0f 90       	pop	r0
    44ea:	0f 90       	pop	r0
    44ec:	cf 91       	pop	r28
    44ee:	df 91       	pop	r29
    44f0:	1f 91       	pop	r17
    44f2:	0f 91       	pop	r16
    44f4:	08 95       	ret

000044f6 <prvWriteBytesToBuffer>:

static size_t prvWriteBytesToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                     const uint8_t * pucData,
                                     size_t xCount,
                                     size_t xHead )
{
    44f6:	af 92       	push	r10
    44f8:	bf 92       	push	r11
    44fa:	cf 92       	push	r12
    44fc:	df 92       	push	r13
    44fe:	ef 92       	push	r14
    4500:	ff 92       	push	r15
    4502:	0f 93       	push	r16
    4504:	1f 93       	push	r17
    4506:	cf 93       	push	r28
    4508:	df 93       	push	r29
    450a:	6c 01       	movw	r12, r24
    450c:	7b 01       	movw	r14, r22
    450e:	8a 01       	movw	r16, r20
    4510:	59 01       	movw	r10, r18
    configASSERT( xCount > ( size_t ) 0 );

    /* Calculate the number of bytes that can be added in the first write -
     * which may be less than the total number of bytes that need to be added if
     * the buffer will wrap back to the beginning. */
    xFirstLength = configMIN( pxStreamBuffer->xLength - xHead, xCount );
    4512:	dc 01       	movw	r26, r24
    4514:	14 96       	adiw	r26, 0x04	; 4
    4516:	8d 91       	ld	r24, X+
    4518:	9c 91       	ld	r25, X
    451a:	15 97       	sbiw	r26, 0x05	; 5
    451c:	ec 01       	movw	r28, r24
    451e:	c2 1b       	sub	r28, r18
    4520:	d3 0b       	sbc	r29, r19
    4522:	4c 17       	cp	r20, r28
    4524:	5d 07       	cpc	r21, r29
    4526:	08 f4       	brcc	.+2      	; 0x452a <prvWriteBytesToBuffer+0x34>
    4528:	ea 01       	movw	r28, r20

    /* Write as many bytes as can be written in the first write. */
    configASSERT( ( xHead + xFirstLength ) <= pxStreamBuffer->xLength );
    ( void ) memcpy( ( void * ) ( &( pxStreamBuffer->pucBuffer[ xHead ] ) ), ( const void * ) pucData, xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    452a:	f6 01       	movw	r30, r12
    452c:	24 85       	ldd	r18, Z+12	; 0x0c
    452e:	35 85       	ldd	r19, Z+13	; 0x0d
    4530:	2a 0d       	add	r18, r10
    4532:	3b 1d       	adc	r19, r11
    4534:	82 2f       	mov	r24, r18
    4536:	93 2f       	mov	r25, r19
    4538:	6e 2d       	mov	r22, r14
    453a:	7f 2d       	mov	r23, r15
    453c:	4c 2f       	mov	r20, r28
    453e:	5d 2f       	mov	r21, r29
    4540:	0e 94 ab 32 	call	0x6556	; 0x6556 <memcpy>

    /* If the number of bytes written was less than the number that could be
     * written in the first write... */
    if( xCount > xFirstLength )
    4544:	c0 17       	cp	r28, r16
    4546:	d1 07       	cpc	r29, r17
    4548:	90 f4       	brcc	.+36     	; 0x456e <prvWriteBytesToBuffer+0x78>
    {
        /* ...then write the remaining bytes to the start of the buffer. */
        configASSERT( ( xCount - xFirstLength ) <= pxStreamBuffer->xLength );
        ( void ) memcpy( ( void * ) pxStreamBuffer->pucBuffer, ( const void * ) &( pucData[ xFirstLength ] ), xCount - xFirstLength ); /*lint !e9087 memcpy() requires void *. */
    454a:	f8 01       	movw	r30, r16
    454c:	ec 1b       	sub	r30, r28
    454e:	fd 0b       	sbc	r31, r29
    4550:	97 01       	movw	r18, r14
    4552:	2c 0f       	add	r18, r28
    4554:	3d 1f       	adc	r19, r29
    4556:	d6 01       	movw	r26, r12
    4558:	1c 96       	adiw	r26, 0x0c	; 12
    455a:	8c 91       	ld	r24, X
    455c:	1c 97       	sbiw	r26, 0x0c	; 12
    455e:	1d 96       	adiw	r26, 0x0d	; 13
    4560:	9c 91       	ld	r25, X
    4562:	62 2f       	mov	r22, r18
    4564:	73 2f       	mov	r23, r19
    4566:	4e 2f       	mov	r20, r30
    4568:	5f 2f       	mov	r21, r31
    456a:	0e 94 ab 32 	call	0x6556	; 0x6556 <memcpy>
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xHead += xCount;
    456e:	95 01       	movw	r18, r10
    4570:	20 0f       	add	r18, r16
    4572:	31 1f       	adc	r19, r17

    if( xHead >= pxStreamBuffer->xLength )
    4574:	f6 01       	movw	r30, r12
    4576:	84 81       	ldd	r24, Z+4	; 0x04
    4578:	95 81       	ldd	r25, Z+5	; 0x05
    457a:	28 17       	cp	r18, r24
    457c:	39 07       	cpc	r19, r25
    457e:	10 f0       	brcs	.+4      	; 0x4584 <prvWriteBytesToBuffer+0x8e>
    {
        xHead -= pxStreamBuffer->xLength;
    4580:	28 1b       	sub	r18, r24
    4582:	39 0b       	sbc	r19, r25
    {
        mtCOVERAGE_TEST_MARKER();
    }

    return xHead;
}
    4584:	82 2f       	mov	r24, r18
    4586:	93 2f       	mov	r25, r19
    4588:	df 91       	pop	r29
    458a:	cf 91       	pop	r28
    458c:	1f 91       	pop	r17
    458e:	0f 91       	pop	r16
    4590:	ff 90       	pop	r15
    4592:	ef 90       	pop	r14
    4594:	df 90       	pop	r13
    4596:	cf 90       	pop	r12
    4598:	bf 90       	pop	r11
    459a:	af 90       	pop	r10
    459c:	08 95       	ret

0000459e <prvWriteMessageToBuffer>:
static size_t prvWriteMessageToBuffer( StreamBuffer_t * const pxStreamBuffer,
                                       const void * pvTxData,
                                       size_t xDataLengthBytes,
                                       size_t xSpace,
                                       size_t xRequiredSpace )
{
    459e:	af 92       	push	r10
    45a0:	bf 92       	push	r11
    45a2:	cf 92       	push	r12
    45a4:	df 92       	push	r13
    45a6:	ef 92       	push	r14
    45a8:	ff 92       	push	r15
    45aa:	0f 93       	push	r16
    45ac:	1f 93       	push	r17
    45ae:	df 93       	push	r29
    45b0:	cf 93       	push	r28
    45b2:	00 d0       	rcall	.+0      	; 0x45b4 <prvWriteMessageToBuffer+0x16>
    45b4:	cd b7       	in	r28, 0x3d	; 61
    45b6:	de b7       	in	r29, 0x3e	; 62
    45b8:	6c 01       	movw	r12, r24
    45ba:	5b 01       	movw	r10, r22
    45bc:	7a 01       	movw	r14, r20
    size_t xNextHead = pxStreamBuffer->xHead;
    45be:	dc 01       	movw	r26, r24
    45c0:	12 96       	adiw	r26, 0x02	; 2
    45c2:	ed 91       	ld	r30, X+
    45c4:	fc 91       	ld	r31, X
    45c6:	13 97       	sbiw	r26, 0x03	; 3
    configMESSAGE_BUFFER_LENGTH_TYPE xMessageLength;

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    45c8:	1e 96       	adiw	r26, 0x0e	; 14
    45ca:	8c 91       	ld	r24, X
    45cc:	80 ff       	sbrs	r24, 0
    45ce:	13 c0       	rjmp	.+38     	; 0x45f6 <prvWriteMessageToBuffer+0x58>
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;

        /* Ensure the data length given fits within configMESSAGE_BUFFER_LENGTH_TYPE. */
        configASSERT( ( size_t ) xMessageLength == xDataLengthBytes );

        if( xSpace >= xRequiredSpace )
    45d0:	20 17       	cp	r18, r16
    45d2:	31 07       	cpc	r19, r17
    45d4:	18 f4       	brcc	.+6      	; 0x45dc <prvWriteMessageToBuffer+0x3e>
    45d6:	ee 24       	eor	r14, r14
    45d8:	ff 24       	eor	r15, r15
    45da:	1d c0       	rjmp	.+58     	; 0x4616 <prvWriteMessageToBuffer+0x78>
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    {
        /* This is a message buffer, as opposed to a stream buffer. */

        /* Convert xDataLengthBytes to the message length type. */
        xMessageLength = ( configMESSAGE_BUFFER_LENGTH_TYPE ) xDataLengthBytes;
    45dc:	5a 83       	std	Y+2, r21	; 0x02
    45de:	49 83       	std	Y+1, r20	; 0x01
        if( xSpace >= xRequiredSpace )
        {
            /* There is enough space to write both the message length and the message
             * itself into the buffer.  Start by writing the length of the data, the data
             * itself will be written later in this function. */
            xNextHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) &( xMessageLength ), sbBYTES_TO_STORE_MESSAGE_LENGTH, xNextHead );
    45e0:	c6 01       	movw	r24, r12
    45e2:	be 01       	movw	r22, r28
    45e4:	6f 5f       	subi	r22, 0xFF	; 255
    45e6:	7f 4f       	sbci	r23, 0xFF	; 255
    45e8:	42 e0       	ldi	r20, 0x02	; 2
    45ea:	50 e0       	ldi	r21, 0x00	; 0
    45ec:	9f 01       	movw	r18, r30
    45ee:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <prvWriteBytesToBuffer>
    45f2:	fc 01       	movw	r30, r24
    45f4:	04 c0       	rjmp	.+8      	; 0x45fe <prvWriteMessageToBuffer+0x60>
    else
    {
        /* This is a stream buffer, as opposed to a message buffer, so writing a
         * stream of bytes rather than discrete messages.  Plan to write as many
         * bytes as possible. */
        xDataLengthBytes = configMIN( xDataLengthBytes, xSpace );
    45f6:	24 17       	cp	r18, r20
    45f8:	35 07       	cpc	r19, r21
    45fa:	08 f4       	brcc	.+2      	; 0x45fe <prvWriteMessageToBuffer+0x60>
    45fc:	79 01       	movw	r14, r18
    }

    if( xDataLengthBytes != ( size_t ) 0 )
    45fe:	e1 14       	cp	r14, r1
    4600:	f1 04       	cpc	r15, r1
    4602:	49 f0       	breq	.+18     	; 0x4616 <prvWriteMessageToBuffer+0x78>
    {
        /* Write the data to the buffer. */
        pxStreamBuffer->xHead = prvWriteBytesToBuffer( pxStreamBuffer, ( const uint8_t * ) pvTxData, xDataLengthBytes, xNextHead ); /*lint !e9079 Storage buffer is implemented as uint8_t for ease of sizing, alignment and access. */
    4604:	c6 01       	movw	r24, r12
    4606:	b5 01       	movw	r22, r10
    4608:	a7 01       	movw	r20, r14
    460a:	9f 01       	movw	r18, r30
    460c:	0e 94 7b 22 	call	0x44f6	; 0x44f6 <prvWriteBytesToBuffer>
    4610:	f6 01       	movw	r30, r12
    4612:	93 83       	std	Z+3, r25	; 0x03
    4614:	82 83       	std	Z+2, r24	; 0x02
    }

    return xDataLengthBytes;
}
    4616:	8e 2d       	mov	r24, r14
    4618:	9f 2d       	mov	r25, r15
    461a:	0f 90       	pop	r0
    461c:	0f 90       	pop	r0
    461e:	cf 91       	pop	r28
    4620:	df 91       	pop	r29
    4622:	1f 91       	pop	r17
    4624:	0f 91       	pop	r16
    4626:	ff 90       	pop	r15
    4628:	ef 90       	pop	r14
    462a:	df 90       	pop	r13
    462c:	cf 90       	pop	r12
    462e:	bf 90       	pop	r11
    4630:	af 90       	pop	r10
    4632:	08 95       	ret

00004634 <xStreamBufferSendFromISR>:

size_t xStreamBufferSendFromISR( StreamBufferHandle_t xStreamBuffer,
                                 const void * pvTxData,
                                 size_t xDataLengthBytes,
                                 BaseType_t * const pxHigherPriorityTaskWoken )
{
    4634:	af 92       	push	r10
    4636:	bf 92       	push	r11
    4638:	cf 92       	push	r12
    463a:	df 92       	push	r13
    463c:	ef 92       	push	r14
    463e:	ff 92       	push	r15
    4640:	0f 93       	push	r16
    4642:	1f 93       	push	r17
    4644:	cf 93       	push	r28
    4646:	df 93       	push	r29
    4648:	5c 01       	movw	r10, r24
    464a:	7b 01       	movw	r14, r22
    464c:	ea 01       	movw	r28, r20
    464e:	69 01       	movw	r12, r18

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4650:	fc 01       	movw	r30, r24
    4652:	86 85       	ldd	r24, Z+14	; 0x0e
    4654:	80 fd       	sbrc	r24, 0
    4656:	02 c0       	rjmp	.+4      	; 0x465c <xStreamBufferSendFromISR+0x28>
    4658:	8a 01       	movw	r16, r20
    465a:	03 c0       	rjmp	.+6      	; 0x4662 <xStreamBufferSendFromISR+0x2e>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    465c:	8a 01       	movw	r16, r20
    465e:	0e 5f       	subi	r16, 0xFE	; 254
    4660:	1f 4f       	sbci	r17, 0xFF	; 255
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    4662:	c5 01       	movw	r24, r10
    4664:	0e 94 c5 20 	call	0x418a	; 0x418a <xStreamBufferSpacesAvailable>
    4668:	9c 01       	movw	r18, r24
    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    466a:	c5 01       	movw	r24, r10
    466c:	b7 01       	movw	r22, r14
    466e:	ae 01       	movw	r20, r28
    4670:	0e 94 cf 22 	call	0x459e	; 0x459e <prvWriteMessageToBuffer>
    4674:	ec 01       	movw	r28, r24

    if( xReturn > ( size_t ) 0 )
    4676:	00 97       	sbiw	r24, 0x00	; 0
    4678:	e1 f0       	breq	.+56     	; 0x46b2 <xStreamBufferSendFromISR+0x7e>
    {
        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    467a:	c5 01       	movw	r24, r10
    467c:	0e 94 05 21 	call	0x420a	; 0x420a <prvBytesInBuffer>
    4680:	f5 01       	movw	r30, r10
    4682:	26 81       	ldd	r18, Z+6	; 0x06
    4684:	37 81       	ldd	r19, Z+7	; 0x07
    4686:	82 17       	cp	r24, r18
    4688:	93 07       	cpc	r25, r19
    468a:	98 f0       	brcs	.+38     	; 0x46b2 <xStreamBufferSendFromISR+0x7e>
        {
            prvSEND_COMPLETE_FROM_ISR( pxStreamBuffer, pxHigherPriorityTaskWoken );
    468c:	80 85       	ldd	r24, Z+8	; 0x08
    468e:	91 85       	ldd	r25, Z+9	; 0x09
    4690:	89 2b       	or	r24, r25
    4692:	79 f0       	breq	.+30     	; 0x46b2 <xStreamBufferSendFromISR+0x7e>
    4694:	80 85       	ldd	r24, Z+8	; 0x08
    4696:	91 85       	ldd	r25, Z+9	; 0x09
    4698:	60 e0       	ldi	r22, 0x00	; 0
    469a:	20 e0       	ldi	r18, 0x00	; 0
    469c:	30 e0       	ldi	r19, 0x00	; 0
    469e:	40 e0       	ldi	r20, 0x00	; 0
    46a0:	50 e0       	ldi	r21, 0x00	; 0
    46a2:	00 e0       	ldi	r16, 0x00	; 0
    46a4:	ee 24       	eor	r14, r14
    46a6:	ff 24       	eor	r15, r15
    46a8:	0e 94 b3 28 	call	0x5166	; 0x5166 <xTaskGenericNotifyFromISR>
    46ac:	f5 01       	movw	r30, r10
    46ae:	11 86       	std	Z+9, r1	; 0x09
    46b0:	10 86       	std	Z+8, r1	; 0x08
    }

    traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xReturn );

    return xReturn;
}
    46b2:	8c 2f       	mov	r24, r28
    46b4:	9d 2f       	mov	r25, r29
    46b6:	df 91       	pop	r29
    46b8:	cf 91       	pop	r28
    46ba:	1f 91       	pop	r17
    46bc:	0f 91       	pop	r16
    46be:	ff 90       	pop	r15
    46c0:	ef 90       	pop	r14
    46c2:	df 90       	pop	r13
    46c4:	cf 90       	pop	r12
    46c6:	bf 90       	pop	r11
    46c8:	af 90       	pop	r10
    46ca:	08 95       	ret

000046cc <xStreamBufferReceive>:

size_t xStreamBufferReceive( StreamBufferHandle_t xStreamBuffer,
                             void * pvRxData,
                             size_t xBufferLengthBytes,
                             TickType_t xTicksToWait )
{
    46cc:	4f 92       	push	r4
    46ce:	5f 92       	push	r5
    46d0:	6f 92       	push	r6
    46d2:	7f 92       	push	r7
    46d4:	8f 92       	push	r8
    46d6:	9f 92       	push	r9
    46d8:	af 92       	push	r10
    46da:	bf 92       	push	r11
    46dc:	cf 92       	push	r12
    46de:	df 92       	push	r13
    46e0:	ef 92       	push	r14
    46e2:	ff 92       	push	r15
    46e4:	0f 93       	push	r16
    46e6:	1f 93       	push	r17
    46e8:	cf 93       	push	r28
    46ea:	df 93       	push	r29
    46ec:	5c 01       	movw	r10, r24
    46ee:	3b 01       	movw	r6, r22
    46f0:	2a 01       	movw	r4, r20
    46f2:	69 01       	movw	r12, r18
    /* This receive function is used by both message buffers, which store
     * discrete messages, and stream buffers, which store a continuous stream of
     * bytes.  Discrete messages include an additional
     * sbBYTES_TO_STORE_MESSAGE_LENGTH bytes that hold the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    46f4:	fc 01       	movw	r30, r24
    46f6:	86 85       	ldd	r24, Z+14	; 0x0e
    46f8:	80 fd       	sbrc	r24, 0
    46fa:	03 c0       	rjmp	.+6      	; 0x4702 <xStreamBufferReceive+0x36>
    46fc:	88 24       	eor	r8, r8
    46fe:	99 24       	eor	r9, r9
    4700:	04 c0       	rjmp	.+8      	; 0x470a <xStreamBufferReceive+0x3e>
    4702:	88 24       	eor	r8, r8
    4704:	99 24       	eor	r9, r9
    4706:	68 94       	set
    4708:	81 f8       	bld	r8, 1
    else
    {
        xBytesToStoreMessageLength = 0;
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    470a:	c1 14       	cp	r12, r1
    470c:	d1 04       	cpc	r13, r1
    470e:	71 f1       	breq	.+92     	; 0x476c <xStreamBufferReceive+0xa0>
    {
        /* Checking if there is data and clearing the notification state must be
         * performed atomically. */
        taskENTER_CRITICAL();
    4710:	0f b6       	in	r0, 0x3f	; 63
    4712:	f8 94       	cli
    4714:	0f 92       	push	r0
        {
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    4716:	c5 01       	movw	r24, r10
    4718:	0e 94 05 21 	call	0x420a	; 0x420a <prvBytesInBuffer>
    471c:	ec 01       	movw	r28, r24
            /* If this function was invoked by a message buffer read then
             * xBytesToStoreMessageLength holds the number of bytes used to hold
             * the length of the next discrete message.  If this function was
             * invoked by a stream buffer read then xBytesToStoreMessageLength will
             * be 0. */
            if( xBytesAvailable <= xBytesToStoreMessageLength )
    471e:	88 16       	cp	r8, r24
    4720:	99 06       	cpc	r9, r25
    4722:	50 f0       	brcs	.+20     	; 0x4738 <xStreamBufferReceive+0x6c>
            {
                /* Clear notification state as going to wait for data. */
                ( void ) xTaskNotifyStateClear( NULL );
    4724:	80 e0       	ldi	r24, 0x00	; 0
    4726:	90 e0       	ldi	r25, 0x00	; 0
    4728:	60 e0       	ldi	r22, 0x00	; 0
    472a:	0e 94 9d 2a 	call	0x553a	; 0x553a <xTaskGenericNotifyStateClear>

                /* Should only be one reader. */
                configASSERT( pxStreamBuffer->xTaskWaitingToReceive == NULL );
                pxStreamBuffer->xTaskWaitingToReceive = xTaskGetCurrentTaskHandle();
    472e:	0e 94 94 28 	call	0x5128	; 0x5128 <xTaskGetCurrentTaskHandle>
    4732:	f5 01       	movw	r30, r10
    4734:	91 87       	std	Z+9, r25	; 0x09
    4736:	80 87       	std	Z+8, r24	; 0x08
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    4738:	0f 90       	pop	r0
    473a:	0f be       	out	0x3f, r0	; 63

        if( xBytesAvailable <= xBytesToStoreMessageLength )
    473c:	8c 16       	cp	r8, r28
    473e:	9d 06       	cpc	r9, r29
    4740:	f8 f0       	brcs	.+62     	; 0x4780 <xStreamBufferReceive+0xb4>
        {
            /* Wait for data to be available. */
            traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    4742:	80 e0       	ldi	r24, 0x00	; 0
    4744:	40 e0       	ldi	r20, 0x00	; 0
    4746:	50 e0       	ldi	r21, 0x00	; 0
    4748:	60 e0       	ldi	r22, 0x00	; 0
    474a:	70 e0       	ldi	r23, 0x00	; 0
    474c:	00 e0       	ldi	r16, 0x00	; 0
    474e:	10 e0       	ldi	r17, 0x00	; 0
    4750:	20 e0       	ldi	r18, 0x00	; 0
    4752:	30 e0       	ldi	r19, 0x00	; 0
    4754:	ee 24       	eor	r14, r14
    4756:	ff 24       	eor	r15, r15
    4758:	0e 94 2a 2d 	call	0x5a54	; 0x5a54 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToReceive = NULL;
    475c:	f5 01       	movw	r30, r10
    475e:	11 86       	std	Z+9, r1	; 0x09
    4760:	10 86       	std	Z+8, r1	; 0x08

            /* Recheck the data available after blocking. */
            xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    4762:	c5 01       	movw	r24, r10
    4764:	0e 94 05 21 	call	0x420a	; 0x420a <prvBytesInBuffer>
    4768:	ec 01       	movw	r28, r24
    476a:	04 c0       	rjmp	.+8      	; 0x4774 <xStreamBufferReceive+0xa8>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    else
    {
        xBytesAvailable = prvBytesInBuffer( pxStreamBuffer );
    476c:	c5 01       	movw	r24, r10
    476e:	0e 94 05 21 	call	0x420a	; 0x420a <prvBytesInBuffer>
    4772:	ec 01       	movw	r28, r24
    /* Whether receiving a discrete message (where xBytesToStoreMessageLength
     * holds the number of bytes used to store the message length) or a stream of
     * bytes (where xBytesToStoreMessageLength is zero), the number of bytes
     * available must be greater than xBytesToStoreMessageLength to be able to
     * read bytes from the buffer. */
    if( xBytesAvailable > xBytesToStoreMessageLength )
    4774:	8c 16       	cp	r8, r28
    4776:	9d 06       	cpc	r9, r29
    4778:	18 f0       	brcs	.+6      	; 0x4780 <xStreamBufferReceive+0xb4>
    477a:	c0 e0       	ldi	r28, 0x00	; 0
    477c:	d0 e0       	ldi	r29, 0x00	; 0
    477e:	21 c0       	rjmp	.+66     	; 0x47c2 <xStreamBufferReceive+0xf6>
    {
        xReceivedLength = prvReadMessageFromBuffer( pxStreamBuffer, pvRxData, xBufferLengthBytes, xBytesAvailable );
    4780:	c5 01       	movw	r24, r10
    4782:	b3 01       	movw	r22, r6
    4784:	a2 01       	movw	r20, r4
    4786:	9e 01       	movw	r18, r28
    4788:	0e 94 bd 21 	call	0x437a	; 0x437a <prvReadMessageFromBuffer>
    478c:	ec 01       	movw	r28, r24

        /* Was a task waiting for space in the buffer? */
        if( xReceivedLength != ( size_t ) 0 )
    478e:	00 97       	sbiw	r24, 0x00	; 0
    4790:	c1 f0       	breq	.+48     	; 0x47c2 <xStreamBufferReceive+0xf6>
        {
            traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength );
            prvRECEIVE_COMPLETED( xStreamBuffer );
    4792:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <vTaskSuspendAll>
    4796:	f5 01       	movw	r30, r10
    4798:	82 85       	ldd	r24, Z+10	; 0x0a
    479a:	93 85       	ldd	r25, Z+11	; 0x0b
    479c:	89 2b       	or	r24, r25
    479e:	79 f0       	breq	.+30     	; 0x47be <xStreamBufferReceive+0xf2>
    47a0:	82 85       	ldd	r24, Z+10	; 0x0a
    47a2:	93 85       	ldd	r25, Z+11	; 0x0b
    47a4:	60 e0       	ldi	r22, 0x00	; 0
    47a6:	20 e0       	ldi	r18, 0x00	; 0
    47a8:	30 e0       	ldi	r19, 0x00	; 0
    47aa:	40 e0       	ldi	r20, 0x00	; 0
    47ac:	50 e0       	ldi	r21, 0x00	; 0
    47ae:	00 e0       	ldi	r16, 0x00	; 0
    47b0:	ee 24       	eor	r14, r14
    47b2:	ff 24       	eor	r15, r15
    47b4:	0e 94 01 2b 	call	0x5602	; 0x5602 <xTaskGenericNotify>
    47b8:	f5 01       	movw	r30, r10
    47ba:	13 86       	std	Z+11, r1	; 0x0b
    47bc:	12 86       	std	Z+10, r1	; 0x0a
    47be:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>
        traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer );
        mtCOVERAGE_TEST_MARKER();
    }

    return xReceivedLength;
}
    47c2:	8c 2f       	mov	r24, r28
    47c4:	9d 2f       	mov	r25, r29
    47c6:	df 91       	pop	r29
    47c8:	cf 91       	pop	r28
    47ca:	1f 91       	pop	r17
    47cc:	0f 91       	pop	r16
    47ce:	ff 90       	pop	r15
    47d0:	ef 90       	pop	r14
    47d2:	df 90       	pop	r13
    47d4:	cf 90       	pop	r12
    47d6:	bf 90       	pop	r11
    47d8:	af 90       	pop	r10
    47da:	9f 90       	pop	r9
    47dc:	8f 90       	pop	r8
    47de:	7f 90       	pop	r7
    47e0:	6f 90       	pop	r6
    47e2:	5f 90       	pop	r5
    47e4:	4f 90       	pop	r4
    47e6:	08 95       	ret

000047e8 <xStreamBufferSend>:

size_t xStreamBufferSend( StreamBufferHandle_t xStreamBuffer,
                          const void * pvTxData,
                          size_t xDataLengthBytes,
                          TickType_t xTicksToWait )
{
    47e8:	2f 92       	push	r2
    47ea:	3f 92       	push	r3
    47ec:	4f 92       	push	r4
    47ee:	5f 92       	push	r5
    47f0:	6f 92       	push	r6
    47f2:	7f 92       	push	r7
    47f4:	8f 92       	push	r8
    47f6:	9f 92       	push	r9
    47f8:	af 92       	push	r10
    47fa:	bf 92       	push	r11
    47fc:	cf 92       	push	r12
    47fe:	df 92       	push	r13
    4800:	ef 92       	push	r14
    4802:	ff 92       	push	r15
    4804:	0f 93       	push	r16
    4806:	1f 93       	push	r17
    4808:	df 93       	push	r29
    480a:	cf 93       	push	r28
    480c:	cd b7       	in	r28, 0x3d	; 61
    480e:	de b7       	in	r29, 0x3e	; 62
    4810:	27 97       	sbiw	r28, 0x07	; 7
    4812:	0f b6       	in	r0, 0x3f	; 63
    4814:	f8 94       	cli
    4816:	de bf       	out	0x3e, r29	; 62
    4818:	0f be       	out	0x3f, r0	; 63
    481a:	cd bf       	out	0x3d, r28	; 61
    481c:	5c 01       	movw	r10, r24
    481e:	7f 83       	std	Y+7, r23	; 0x07
    4820:	6e 83       	std	Y+6, r22	; 0x06
    4822:	2a 01       	movw	r4, r20
    4824:	3d 83       	std	Y+5, r19	; 0x05
    4826:	2c 83       	std	Y+4, r18	; 0x04
    configASSERT( pvTxData );
    configASSERT( pxStreamBuffer );

    /* The maximum amount of space a stream buffer will ever report is its length
     * minus 1. */
    xMaxReportedSpace = pxStreamBuffer->xLength - ( size_t ) 1;
    4828:	fc 01       	movw	r30, r24
    482a:	84 81       	ldd	r24, Z+4	; 0x04
    482c:	95 81       	ldd	r25, Z+5	; 0x05
    482e:	9c 01       	movw	r18, r24
    4830:	21 50       	subi	r18, 0x01	; 1
    4832:	30 40       	sbci	r19, 0x00	; 0

    /* This send function is used to write to both message buffers and stream
     * buffers.  If this is a message buffer then the space needed must be
     * increased by the amount of bytes needed to store the length of the
     * message. */
    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_MESSAGE_BUFFER ) != ( uint8_t ) 0 )
    4834:	86 85       	ldd	r24, Z+14	; 0x0e
    4836:	80 ff       	sbrs	r24, 0
    4838:	0c c0       	rjmp	.+24     	; 0x4852 <xStreamBufferSend+0x6a>
    {
        xRequiredSpace += sbBYTES_TO_STORE_MESSAGE_LENGTH;
    483a:	66 24       	eor	r6, r6
    483c:	77 24       	eor	r7, r7
    483e:	68 94       	set
    4840:	61 f8       	bld	r6, 1
    4842:	64 0e       	add	r6, r20
    4844:	75 1e       	adc	r7, r21
        /* Overflow? */
        configASSERT( xRequiredSpace > xDataLengthBytes );

        /* If this is a message buffer then it must be possible to write the
         * whole message. */
        if( xRequiredSpace > xMaxReportedSpace )
    4846:	26 15       	cp	r18, r6
    4848:	37 05       	cpc	r19, r7
    484a:	40 f4       	brcc	.+16     	; 0x485c <xStreamBufferSend+0x74>
        {
            /* The message would not fit even if the entire buffer was empty,
             * so don't wait for space. */
            xTicksToWait = ( TickType_t ) 0;
    484c:	1d 82       	std	Y+5, r1	; 0x05
    484e:	1c 82       	std	Y+4, r1	; 0x04
    4850:	48 c0       	rjmp	.+144    	; 0x48e2 <xStreamBufferSend+0xfa>
    4852:	3a 01       	movw	r6, r20
    4854:	24 17       	cp	r18, r20
    4856:	35 07       	cpc	r19, r21
    4858:	08 f4       	brcc	.+2      	; 0x485c <xStreamBufferSend+0x74>
    485a:	39 01       	movw	r6, r18
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }

    if( xTicksToWait != ( TickType_t ) 0 )
    485c:	8c 81       	ldd	r24, Y+4	; 0x04
    485e:	9d 81       	ldd	r25, Y+5	; 0x05
    4860:	89 2b       	or	r24, r25
    4862:	09 f4       	brne	.+2      	; 0x4866 <xStreamBufferSend+0x7e>
    4864:	3e c0       	rjmp	.+124    	; 0x48e2 <xStreamBufferSend+0xfa>
    {
        vTaskSetTimeOutState( &xTimeOut );
    4866:	ce 01       	movw	r24, r28
    4868:	01 96       	adiw	r24, 0x01	; 1
    486a:	0e 94 0e 27 	call	0x4e1c	; 0x4e1c <vTaskSetTimeOutState>
            taskEXIT_CRITICAL();

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
            pxStreamBuffer->xTaskWaitingToSend = NULL;
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    486e:	1e 01       	movw	r2, r28
    4870:	08 94       	sec
    4872:	21 1c       	adc	r2, r1
    4874:	31 1c       	adc	r3, r1

        do
        {
            /* Wait until the required number of bytes are free in the message
             * buffer. */
            taskENTER_CRITICAL();
    4876:	0f b6       	in	r0, 0x3f	; 63
    4878:	f8 94       	cli
    487a:	0f 92       	push	r0
            {
                xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    487c:	c5 01       	movw	r24, r10
    487e:	0e 94 c5 20 	call	0x418a	; 0x418a <xStreamBufferSpacesAvailable>
    4882:	4c 01       	movw	r8, r24

                if( xSpace < xRequiredSpace )
    4884:	86 15       	cp	r24, r6
    4886:	97 05       	cpc	r25, r7
    4888:	40 f5       	brcc	.+80     	; 0x48da <xStreamBufferSend+0xf2>
                {
                    /* Clear notification state as going to wait for space. */
                    ( void ) xTaskNotifyStateClear( NULL );
    488a:	80 e0       	ldi	r24, 0x00	; 0
    488c:	90 e0       	ldi	r25, 0x00	; 0
    488e:	60 e0       	ldi	r22, 0x00	; 0
    4890:	0e 94 9d 2a 	call	0x553a	; 0x553a <xTaskGenericNotifyStateClear>

                    /* Should only be one writer. */
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
    4894:	0e 94 94 28 	call	0x5128	; 0x5128 <xTaskGetCurrentTaskHandle>
    4898:	f5 01       	movw	r30, r10
    489a:	93 87       	std	Z+11, r25	; 0x0b
    489c:	82 87       	std	Z+10, r24	; 0x0a
                {
                    taskEXIT_CRITICAL();
                    break;
                }
            }
            taskEXIT_CRITICAL();
    489e:	0f 90       	pop	r0
    48a0:	0f be       	out	0x3f, r0	; 63

            traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer );
            ( void ) xTaskNotifyWait( ( uint32_t ) 0, ( uint32_t ) 0, NULL, xTicksToWait );
    48a2:	cc 80       	ldd	r12, Y+4	; 0x04
    48a4:	dd 80       	ldd	r13, Y+5	; 0x05
    48a6:	80 e0       	ldi	r24, 0x00	; 0
    48a8:	40 e0       	ldi	r20, 0x00	; 0
    48aa:	50 e0       	ldi	r21, 0x00	; 0
    48ac:	60 e0       	ldi	r22, 0x00	; 0
    48ae:	70 e0       	ldi	r23, 0x00	; 0
    48b0:	00 e0       	ldi	r16, 0x00	; 0
    48b2:	10 e0       	ldi	r17, 0x00	; 0
    48b4:	20 e0       	ldi	r18, 0x00	; 0
    48b6:	30 e0       	ldi	r19, 0x00	; 0
    48b8:	ee 24       	eor	r14, r14
    48ba:	ff 24       	eor	r15, r15
    48bc:	0e 94 2a 2d 	call	0x5a54	; 0x5a54 <xTaskGenericNotifyWait>
            pxStreamBuffer->xTaskWaitingToSend = NULL;
    48c0:	f5 01       	movw	r30, r10
    48c2:	13 86       	std	Z+11, r1	; 0x0b
    48c4:	12 86       	std	Z+10, r1	; 0x0a
        } while( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE );
    48c6:	c1 01       	movw	r24, r2
    48c8:	be 01       	movw	r22, r28
    48ca:	6c 5f       	subi	r22, 0xFC	; 252
    48cc:	7f 4f       	sbci	r23, 0xFF	; 255
    48ce:	0e 94 29 27 	call	0x4e52	; 0x4e52 <xTaskCheckForTimeOut>
    48d2:	88 23       	and	r24, r24
    48d4:	81 f2       	breq	.-96     	; 0x4876 <xStreamBufferSend+0x8e>
    48d6:	c4 01       	movw	r24, r8
    48d8:	02 c0       	rjmp	.+4      	; 0x48de <xStreamBufferSend+0xf6>
                    configASSERT( pxStreamBuffer->xTaskWaitingToSend == NULL );
                    pxStreamBuffer->xTaskWaitingToSend = xTaskGetCurrentTaskHandle();
                }
                else
                {
                    taskEXIT_CRITICAL();
    48da:	0f 90       	pop	r0
    48dc:	0f be       	out	0x3f, r0	; 63
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    if( xSpace == ( size_t ) 0 )
    48de:	89 2b       	or	r24, r25
    48e0:	21 f4       	brne	.+8      	; 0x48ea <xStreamBufferSend+0x102>
    {
        xSpace = xStreamBufferSpacesAvailable( pxStreamBuffer );
    48e2:	c5 01       	movw	r24, r10
    48e4:	0e 94 c5 20 	call	0x418a	; 0x418a <xStreamBufferSpacesAvailable>
    48e8:	4c 01       	movw	r8, r24
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    xReturn = prvWriteMessageToBuffer( pxStreamBuffer, pvTxData, xDataLengthBytes, xSpace, xRequiredSpace );
    48ea:	c5 01       	movw	r24, r10
    48ec:	6e 81       	ldd	r22, Y+6	; 0x06
    48ee:	7f 81       	ldd	r23, Y+7	; 0x07
    48f0:	a2 01       	movw	r20, r4
    48f2:	94 01       	movw	r18, r8
    48f4:	83 01       	movw	r16, r6
    48f6:	0e 94 cf 22 	call	0x459e	; 0x459e <prvWriteMessageToBuffer>
    48fa:	6c 01       	movw	r12, r24

    if( xReturn > ( size_t ) 0 )
    48fc:	00 97       	sbiw	r24, 0x00	; 0
    48fe:	09 f1       	breq	.+66     	; 0x4942 <xStreamBufferSend+0x15a>
    {
        traceSTREAM_BUFFER_SEND( xStreamBuffer, xReturn );

        /* Was a task waiting for the data? */
        if( prvBytesInBuffer( pxStreamBuffer ) >= pxStreamBuffer->xTriggerLevelBytes )
    4900:	c5 01       	movw	r24, r10
    4902:	0e 94 05 21 	call	0x420a	; 0x420a <prvBytesInBuffer>
    4906:	f5 01       	movw	r30, r10
    4908:	26 81       	ldd	r18, Z+6	; 0x06
    490a:	37 81       	ldd	r19, Z+7	; 0x07
    490c:	82 17       	cp	r24, r18
    490e:	93 07       	cpc	r25, r19
    4910:	c0 f0       	brcs	.+48     	; 0x4942 <xStreamBufferSend+0x15a>
        {
            prvSEND_COMPLETED( pxStreamBuffer );
    4912:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <vTaskSuspendAll>
    4916:	f5 01       	movw	r30, r10
    4918:	80 85       	ldd	r24, Z+8	; 0x08
    491a:	91 85       	ldd	r25, Z+9	; 0x09
    491c:	89 2b       	or	r24, r25
    491e:	79 f0       	breq	.+30     	; 0x493e <xStreamBufferSend+0x156>
    4920:	80 85       	ldd	r24, Z+8	; 0x08
    4922:	91 85       	ldd	r25, Z+9	; 0x09
    4924:	60 e0       	ldi	r22, 0x00	; 0
    4926:	20 e0       	ldi	r18, 0x00	; 0
    4928:	30 e0       	ldi	r19, 0x00	; 0
    492a:	40 e0       	ldi	r20, 0x00	; 0
    492c:	50 e0       	ldi	r21, 0x00	; 0
    492e:	00 e0       	ldi	r16, 0x00	; 0
    4930:	ee 24       	eor	r14, r14
    4932:	ff 24       	eor	r15, r15
    4934:	0e 94 01 2b 	call	0x5602	; 0x5602 <xTaskGenericNotify>
    4938:	f5 01       	movw	r30, r10
    493a:	11 86       	std	Z+9, r1	; 0x09
    493c:	10 86       	std	Z+8, r1	; 0x08
    493e:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>
        mtCOVERAGE_TEST_MARKER();
        traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer );
    }

    return xReturn;
}
    4942:	8c 2d       	mov	r24, r12
    4944:	9d 2d       	mov	r25, r13
    4946:	27 96       	adiw	r28, 0x07	; 7
    4948:	0f b6       	in	r0, 0x3f	; 63
    494a:	f8 94       	cli
    494c:	de bf       	out	0x3e, r29	; 62
    494e:	0f be       	out	0x3f, r0	; 63
    4950:	cd bf       	out	0x3d, r28	; 61
    4952:	cf 91       	pop	r28
    4954:	df 91       	pop	r29
    4956:	1f 91       	pop	r17
    4958:	0f 91       	pop	r16
    495a:	ff 90       	pop	r15
    495c:	ef 90       	pop	r14
    495e:	df 90       	pop	r13
    4960:	cf 90       	pop	r12
    4962:	bf 90       	pop	r11
    4964:	af 90       	pop	r10
    4966:	9f 90       	pop	r9
    4968:	8f 90       	pop	r8
    496a:	7f 90       	pop	r7
    496c:	6f 90       	pop	r6
    496e:	5f 90       	pop	r5
    4970:	4f 90       	pop	r4
    4972:	3f 90       	pop	r3
    4974:	2f 90       	pop	r2
    4976:	08 95       	ret

00004978 <prvInitialiseNewStreamBuffer>:
                                          size_t xBufferSizeBytes,
                                          size_t xTriggerLevelBytes,
                                          uint8_t ucFlags,
                                          StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                          StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
{
    4978:	0f 93       	push	r16
    497a:	fc 01       	movw	r30, r24
        const BaseType_t xWriteValue = 0x55;
        configASSERT( memset( pucBuffer, ( int ) xWriteValue, xBufferSizeBytes ) == pucBuffer );
    } /*lint !e529 !e438 xWriteValue is only used if configASSERT() is defined. */
    #endif

    ( void ) memset( ( void * ) pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) ); /*lint !e9087 memset() requires void *. */
    497c:	8f e0       	ldi	r24, 0x0F	; 15
    497e:	df 01       	movw	r26, r30
    4980:	1d 92       	st	X+, r1
    4982:	8a 95       	dec	r24
    4984:	e9 f7       	brne	.-6      	; 0x4980 <prvInitialiseNewStreamBuffer+0x8>
    pxStreamBuffer->pucBuffer = pucBuffer;
    4986:	75 87       	std	Z+13, r23	; 0x0d
    4988:	64 87       	std	Z+12, r22	; 0x0c
    pxStreamBuffer->xLength = xBufferSizeBytes;
    498a:	55 83       	std	Z+5, r21	; 0x05
    498c:	44 83       	std	Z+4, r20	; 0x04
    pxStreamBuffer->xTriggerLevelBytes = xTriggerLevelBytes;
    498e:	37 83       	std	Z+7, r19	; 0x07
    4990:	26 83       	std	Z+6, r18	; 0x06
    pxStreamBuffer->ucFlags = ucFlags;
    4992:	06 87       	std	Z+14, r16	; 0x0e
    {
        ( void ) pxSendCompletedCallback;
        ( void ) pxReceiveCompletedCallback;
    }
    #endif
}
    4994:	0f 91       	pop	r16
    4996:	08 95       	ret

00004998 <xStreamBufferReset>:
    }
}
/*-----------------------------------------------------------*/

BaseType_t xStreamBufferReset( StreamBufferHandle_t xStreamBuffer )
{
    4998:	cf 92       	push	r12
    499a:	df 92       	push	r13
    499c:	ef 92       	push	r14
    499e:	ff 92       	push	r15
    49a0:	0f 93       	push	r16
    49a2:	fc 01       	movw	r30, r24
        uxStreamBufferNumber = pxStreamBuffer->uxStreamBufferNumber;
    }
    #endif

    /* Can only reset a message buffer if there are no tasks blocked on it. */
    taskENTER_CRITICAL();
    49a4:	0f b6       	in	r0, 0x3f	; 63
    49a6:	f8 94       	cli
    49a8:	0f 92       	push	r0
    {
        if( ( pxStreamBuffer->xTaskWaitingToReceive == NULL ) && ( pxStreamBuffer->xTaskWaitingToSend == NULL ) )
    49aa:	80 85       	ldd	r24, Z+8	; 0x08
    49ac:	91 85       	ldd	r25, Z+9	; 0x09
    49ae:	89 2b       	or	r24, r25
    49b0:	a1 f4       	brne	.+40     	; 0x49da <xStreamBufferReset+0x42>
    49b2:	82 85       	ldd	r24, Z+10	; 0x0a
    49b4:	93 85       	ldd	r25, Z+11	; 0x0b
    49b6:	89 2b       	or	r24, r25
    49b8:	81 f4       	brne	.+32     	; 0x49da <xStreamBufferReset+0x42>
                pxSendCallback = pxStreamBuffer->pxSendCompletedCallback;
                pxReceiveCallback = pxStreamBuffer->pxReceiveCompletedCallback;
            }
            #endif

            prvInitialiseNewStreamBuffer( pxStreamBuffer,
    49ba:	64 85       	ldd	r22, Z+12	; 0x0c
    49bc:	75 85       	ldd	r23, Z+13	; 0x0d
    49be:	44 81       	ldd	r20, Z+4	; 0x04
    49c0:	55 81       	ldd	r21, Z+5	; 0x05
    49c2:	26 81       	ldd	r18, Z+6	; 0x06
    49c4:	37 81       	ldd	r19, Z+7	; 0x07
    49c6:	cf 01       	movw	r24, r30
    49c8:	06 85       	ldd	r16, Z+14	; 0x0e
    49ca:	ee 24       	eor	r14, r14
    49cc:	ff 24       	eor	r15, r15
    49ce:	cc 24       	eor	r12, r12
    49d0:	dd 24       	eor	r13, r13
    49d2:	0e 94 bc 24 	call	0x4978	; 0x4978 <prvInitialiseNewStreamBuffer>
    49d6:	81 e0       	ldi	r24, 0x01	; 1
    49d8:	01 c0       	rjmp	.+2      	; 0x49dc <xStreamBufferReset+0x44>
    49da:	80 e0       	ldi	r24, 0x00	; 0
            traceSTREAM_BUFFER_RESET( xStreamBuffer );

            xReturn = pdPASS;
        }
    }
    taskEXIT_CRITICAL();
    49dc:	0f 90       	pop	r0
    49de:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    49e0:	0f 91       	pop	r16
    49e2:	ff 90       	pop	r15
    49e4:	ef 90       	pop	r14
    49e6:	df 90       	pop	r13
    49e8:	cf 90       	pop	r12
    49ea:	08 95       	ret

000049ec <vStreamBufferDelete>:
    }
#endif /* ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
/*-----------------------------------------------------------*/

void vStreamBufferDelete( StreamBufferHandle_t xStreamBuffer )
{
    49ec:	fc 01       	movw	r30, r24

    configASSERT( pxStreamBuffer );

    traceSTREAM_BUFFER_DELETE( xStreamBuffer );

    if( ( pxStreamBuffer->ucFlags & sbFLAGS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) pdFALSE )
    49ee:	86 85       	ldd	r24, Z+14	; 0x0e
    49f0:	81 fd       	sbrc	r24, 1
    49f2:	04 c0       	rjmp	.+8      	; 0x49fc <vStreamBufferDelete+0x10>
    {
        #if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
        {
            /* Both the structure and the buffer were allocated using a single call
            * to pvPortMalloc(), hence only one call to vPortFree() is required. */
            vPortFree( ( void * ) pxStreamBuffer ); /*lint !e9087 Standard free() semantics require void *, plus pxStreamBuffer was allocated by pvPortMalloc(). */
    49f4:	cf 01       	movw	r24, r30
    49f6:	0e 94 37 18 	call	0x306e	; 0x306e <vPortFree>
    49fa:	08 95       	ret
    }
    else
    {
        /* The structure and buffer were not allocated dynamically and cannot be
         * freed - just scrub the structure so future use will assert. */
        ( void ) memset( pxStreamBuffer, 0x00, sizeof( StreamBuffer_t ) );
    49fc:	8f e0       	ldi	r24, 0x0F	; 15
    49fe:	df 01       	movw	r26, r30
    4a00:	1d 92       	st	X+, r1
    4a02:	8a 95       	dec	r24
    4a04:	e9 f7       	brne	.-6      	; 0x4a00 <vStreamBufferDelete+0x14>
    4a06:	08 95       	ret

00004a08 <xStreamBufferGenericCreate>:
    StreamBufferHandle_t xStreamBufferGenericCreate( size_t xBufferSizeBytes,
                                                     size_t xTriggerLevelBytes,
                                                     BaseType_t xIsMessageBuffer,
                                                     StreamBufferCallbackFunction_t pxSendCompletedCallback,
                                                     StreamBufferCallbackFunction_t pxReceiveCompletedCallback )
    {
    4a08:	7f 92       	push	r7
    4a0a:	8f 92       	push	r8
    4a0c:	9f 92       	push	r9
    4a0e:	af 92       	push	r10
    4a10:	bf 92       	push	r11
    4a12:	cf 92       	push	r12
    4a14:	df 92       	push	r13
    4a16:	ef 92       	push	r14
    4a18:	ff 92       	push	r15
    4a1a:	0f 93       	push	r16
    4a1c:	1f 93       	push	r17
    4a1e:	cf 93       	push	r28
    4a20:	df 93       	push	r29
    4a22:	7c 01       	movw	r14, r24
    4a24:	6b 01       	movw	r12, r22
    4a26:	74 2e       	mov	r7, r20
    4a28:	59 01       	movw	r10, r18
    4a2a:	48 01       	movw	r8, r16

        configASSERT( xTriggerLevelBytes <= xBufferSizeBytes );

        /* A trigger level of 0 would cause a waiting task to unblock even when
         * the buffer was empty. */
        if( xTriggerLevelBytes == ( size_t ) 0 )
    4a2c:	61 15       	cp	r22, r1
    4a2e:	71 05       	cpc	r23, r1
    4a30:	19 f4       	brne	.+6      	; 0x4a38 <xStreamBufferGenericCreate+0x30>
    4a32:	cc 24       	eor	r12, r12
    4a34:	dd 24       	eor	r13, r13
    4a36:	c3 94       	inc	r12
         * and the buffer follows immediately after.  The requested size is
         * incremented so the free space is returned as the user would expect -
         * this is a quirk of the implementation that means otherwise the free
         * space would be reported as one byte smaller than would be logically
         * expected. */
        if( xBufferSizeBytes < ( xBufferSizeBytes + 1 + sizeof( StreamBuffer_t ) ) )
    4a38:	c7 01       	movw	r24, r14
    4a3a:	40 96       	adiw	r24, 0x10	; 16
    4a3c:	e8 16       	cp	r14, r24
    4a3e:	f9 06       	cpc	r15, r25
    4a40:	18 f0       	brcs	.+6      	; 0x4a48 <xStreamBufferGenericCreate+0x40>
    4a42:	c0 e0       	ldi	r28, 0x00	; 0
    4a44:	d0 e0       	ldi	r29, 0x00	; 0
    4a46:	16 c0       	rjmp	.+44     	; 0x4a74 <xStreamBufferGenericCreate+0x6c>
        {
            xBufferSizeBytes++;
            pucAllocatedMemory = ( uint8_t * ) pvPortMalloc( xBufferSizeBytes + sizeof( StreamBuffer_t ) ); /*lint !e9079 malloc() only returns void*. */
    4a48:	0e 94 48 18 	call	0x3090	; 0x3090 <pvPortMalloc>
    4a4c:	ec 01       	movw	r28, r24
        else
        {
            pucAllocatedMemory = NULL;
        }

        if( pucAllocatedMemory != NULL )
    4a4e:	20 97       	sbiw	r28, 0x00	; 0
    4a50:	89 f0       	breq	.+34     	; 0x4a74 <xStreamBufferGenericCreate+0x6c>
        {
            prvInitialiseNewStreamBuffer( ( StreamBuffer_t * ) pucAllocatedMemory,       /* Structure at the start of the allocated memory. */ /*lint !e9087 Safe cast as allocated memory is aligned. */ /*lint !e826 Area is not too small and alignment is guaranteed provided malloc() behaves as expected and returns aligned buffer. */
    4a52:	be 01       	movw	r22, r28
    4a54:	61 5f       	subi	r22, 0xF1	; 241
    4a56:	7f 4f       	sbci	r23, 0xFF	; 255
    4a58:	a7 01       	movw	r20, r14
    4a5a:	4f 5f       	subi	r20, 0xFF	; 255
    4a5c:	5f 4f       	sbci	r21, 0xFF	; 255
    4a5e:	00 e0       	ldi	r16, 0x00	; 0
    4a60:	81 e0       	ldi	r24, 0x01	; 1
    4a62:	78 16       	cp	r7, r24
    4a64:	09 f4       	brne	.+2      	; 0x4a68 <xStreamBufferGenericCreate+0x60>
    4a66:	01 e0       	ldi	r16, 0x01	; 1
    4a68:	ce 01       	movw	r24, r28
    4a6a:	96 01       	movw	r18, r12
    4a6c:	75 01       	movw	r14, r10
    4a6e:	64 01       	movw	r12, r8
    4a70:	0e 94 bc 24 	call	0x4978	; 0x4978 <prvInitialiseNewStreamBuffer>
        {
            traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer );
        }

        return ( StreamBufferHandle_t ) pucAllocatedMemory; /*lint !e9087 !e826 Safe cast as allocated memory is aligned. */
    }
    4a74:	8c 2f       	mov	r24, r28
    4a76:	9d 2f       	mov	r25, r29
    4a78:	df 91       	pop	r29
    4a7a:	cf 91       	pop	r28
    4a7c:	1f 91       	pop	r17
    4a7e:	0f 91       	pop	r16
    4a80:	ff 90       	pop	r15
    4a82:	ef 90       	pop	r14
    4a84:	df 90       	pop	r13
    4a86:	cf 90       	pop	r12
    4a88:	bf 90       	pop	r11
    4a8a:	af 90       	pop	r10
    4a8c:	9f 90       	pop	r9
    4a8e:	8f 90       	pop	r8
    4a90:	7f 90       	pop	r7
    4a92:	08 95       	ret

00004a94 <vTaskSuspendAll>:
     * do not otherwise exhibit real time behaviour. */
    portSOFTWARE_BARRIER();

    /* The scheduler is suspended if uxSchedulerSuspended is non-zero.  An increment
     * is used to allow calls to vTaskSuspendAll() to nest. */
    ++uxSchedulerSuspended;
    4a94:	80 91 bb 07 	lds	r24, 0x07BB
    4a98:	8f 5f       	subi	r24, 0xFF	; 255
    4a9a:	80 93 bb 07 	sts	0x07BB, r24

    /* Enforces ordering for ports and optimised compilers that may otherwise place
     * the above increment elsewhere. */
    portMEMORY_BARRIER();
}
    4a9e:	08 95       	ret

00004aa0 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
    TickType_t xTicks;

    /* Critical section required if running on a 16 bit processor. */
    portTICK_TYPE_ENTER_CRITICAL();
    4aa0:	0f b6       	in	r0, 0x3f	; 63
    4aa2:	f8 94       	cli
    4aa4:	0f 92       	push	r0
    {
        xTicks = xTickCount;
    4aa6:	20 91 be 07 	lds	r18, 0x07BE
    4aaa:	30 91 bf 07 	lds	r19, 0x07BF
    }
    portTICK_TYPE_EXIT_CRITICAL();
    4aae:	0f 90       	pop	r0
    4ab0:	0f be       	out	0x3f, r0	; 63

    return xTicks;
}
    4ab2:	82 2f       	mov	r24, r18
    4ab4:	93 2f       	mov	r25, r19
    4ab6:	08 95       	ret

00004ab8 <xTaskGetTickCountFromISR>:
     * link: https://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html */
    portASSERT_IF_INTERRUPT_PRIORITY_INVALID();

    uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
    {
        xReturn = xTickCount;
    4ab8:	20 91 be 07 	lds	r18, 0x07BE
    4abc:	30 91 bf 07 	lds	r19, 0x07BF
    }
    portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

    return xReturn;
}
    4ac0:	82 2f       	mov	r24, r18
    4ac2:	93 2f       	mov	r25, r19
    4ac4:	08 95       	ret

00004ac6 <uxTaskGetNumberOfTasks>:

UBaseType_t uxTaskGetNumberOfTasks( void )
{
    /* A critical section is not required because the variables are of type
     * BaseType_t. */
    return uxCurrentNumberOfTasks;
    4ac6:	80 91 c5 07 	lds	r24, 0x07C5
}
    4aca:	08 95       	ret

00004acc <pcTaskGetName>:
{
    TCB_t * pxTCB;

    /* If null is passed in here then the name of the calling task is being
     * queried. */
    pxTCB = prvGetTCBFromHandle( xTaskToQuery );
    4acc:	00 97       	sbiw	r24, 0x00	; 0
    4ace:	21 f4       	brne	.+8      	; 0x4ad8 <pcTaskGetName+0xc>
    4ad0:	80 91 b9 07 	lds	r24, 0x07B9
    4ad4:	90 91 ba 07 	lds	r25, 0x07BA
    4ad8:	9c 01       	movw	r18, r24
    4ada:	27 5e       	subi	r18, 0xE7	; 231
    4adc:	3f 4f       	sbci	r19, 0xFF	; 255
    configASSERT( pxTCB );
    return &( pxTCB->pcTaskName[ 0 ] );
}
    4ade:	82 2f       	mov	r24, r18
    4ae0:	93 2f       	mov	r25, r19
    4ae2:	08 95       	ret

00004ae4 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    4ae4:	80 91 bb 07 	lds	r24, 0x07BB
    4ae8:	88 23       	and	r24, r24
    4aea:	21 f0       	breq	.+8      	; 0x4af4 <vTaskSwitchContext+0x10>
    {
        /* The scheduler is currently suspended - do not allow a context
         * switch. */
        xYieldPending = pdTRUE;
    4aec:	81 e0       	ldi	r24, 0x01	; 1
    4aee:	80 93 bd 07 	sts	0x07BD, r24
    4af2:	08 95       	ret
    }
    else
    {
        xYieldPending = pdFALSE;
    4af4:	10 92 bd 07 	sts	0x07BD, r1
        }
        #endif

        /* Select a new task to run using either the generic C or port
         * optimised asm code. */
        taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4af8:	20 91 bc 07 	lds	r18, 0x07BC
    4afc:	89 e0       	ldi	r24, 0x09	; 9
    4afe:	28 9f       	mul	r18, r24
    4b00:	c0 01       	movw	r24, r0
    4b02:	11 24       	eor	r1, r1
    4b04:	dc 01       	movw	r26, r24
    4b06:	a5 53       	subi	r26, 0x35	; 53
    4b08:	b8 4f       	sbci	r27, 0xF8	; 248
    4b0a:	8c 91       	ld	r24, X
    4b0c:	88 23       	and	r24, r24
    4b0e:	69 f4       	brne	.+26     	; 0x4b2a <vTaskSwitchContext+0x46>
    4b10:	39 e0       	ldi	r19, 0x09	; 9
    4b12:	4b ec       	ldi	r20, 0xCB	; 203
    4b14:	57 e0       	ldi	r21, 0x07	; 7
    4b16:	21 50       	subi	r18, 0x01	; 1
    4b18:	23 9f       	mul	r18, r19
    4b1a:	c0 01       	movw	r24, r0
    4b1c:	11 24       	eor	r1, r1
    4b1e:	da 01       	movw	r26, r20
    4b20:	a8 0f       	add	r26, r24
    4b22:	b9 1f       	adc	r27, r25
    4b24:	8c 91       	ld	r24, X
    4b26:	88 23       	and	r24, r24
    4b28:	b1 f3       	breq	.-20     	; 0x4b16 <vTaskSwitchContext+0x32>
    4b2a:	11 96       	adiw	r26, 0x01	; 1
    4b2c:	ed 91       	ld	r30, X+
    4b2e:	fc 91       	ld	r31, X
    4b30:	12 97       	sbiw	r26, 0x02	; 2
    4b32:	02 80       	ldd	r0, Z+2	; 0x02
    4b34:	f3 81       	ldd	r31, Z+3	; 0x03
    4b36:	e0 2d       	mov	r30, r0
    4b38:	12 96       	adiw	r26, 0x02	; 2
    4b3a:	fc 93       	st	X, r31
    4b3c:	ee 93       	st	-X, r30
    4b3e:	11 97       	sbiw	r26, 0x01	; 1
    4b40:	cd 01       	movw	r24, r26
    4b42:	03 96       	adiw	r24, 0x03	; 3
    4b44:	e8 17       	cp	r30, r24
    4b46:	f9 07       	cpc	r31, r25
    4b48:	31 f4       	brne	.+12     	; 0x4b56 <vTaskSwitchContext+0x72>
    4b4a:	82 81       	ldd	r24, Z+2	; 0x02
    4b4c:	93 81       	ldd	r25, Z+3	; 0x03
    4b4e:	12 96       	adiw	r26, 0x02	; 2
    4b50:	9c 93       	st	X, r25
    4b52:	8e 93       	st	-X, r24
    4b54:	11 97       	sbiw	r26, 0x01	; 1
    4b56:	11 96       	adiw	r26, 0x01	; 1
    4b58:	ed 91       	ld	r30, X+
    4b5a:	fc 91       	ld	r31, X
    4b5c:	12 97       	sbiw	r26, 0x02	; 2
    4b5e:	86 81       	ldd	r24, Z+6	; 0x06
    4b60:	97 81       	ldd	r25, Z+7	; 0x07
    4b62:	90 93 ba 07 	sts	0x07BA, r25
    4b66:	80 93 b9 07 	sts	0x07B9, r24
    4b6a:	20 93 bc 07 	sts	0x07BC, r18
    4b6e:	08 95       	ret

00004b70 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    4b70:	cf 93       	push	r28
    4b72:	df 93       	push	r29
     * get called - the lock count on the queue will get modified instead.  This
     * means exclusive access to the event list is guaranteed here.
     *
     * This function assumes that a check has already been made to ensure that
     * pxEventList is not empty. */
    pxUnblockedTCB = listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4b74:	dc 01       	movw	r26, r24
    4b76:	15 96       	adiw	r26, 0x05	; 5
    4b78:	ed 91       	ld	r30, X+
    4b7a:	fc 91       	ld	r31, X
    4b7c:	16 97       	sbiw	r26, 0x06	; 6
    4b7e:	c6 81       	ldd	r28, Z+6	; 0x06
    4b80:	d7 81       	ldd	r29, Z+7	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( &( pxUnblockedTCB->xEventListItem ) );
    4b82:	2c 89       	ldd	r18, Y+20	; 0x14
    4b84:	3d 89       	ldd	r19, Y+21	; 0x15
    4b86:	ae 85       	ldd	r26, Y+14	; 0x0e
    4b88:	bf 85       	ldd	r27, Y+15	; 0x0f
    4b8a:	88 89       	ldd	r24, Y+16	; 0x10
    4b8c:	99 89       	ldd	r25, Y+17	; 0x11
    4b8e:	15 96       	adiw	r26, 0x05	; 5
    4b90:	9c 93       	st	X, r25
    4b92:	8e 93       	st	-X, r24
    4b94:	14 97       	sbiw	r26, 0x04	; 4
    4b96:	e8 89       	ldd	r30, Y+16	; 0x10
    4b98:	f9 89       	ldd	r31, Y+17	; 0x11
    4b9a:	b3 83       	std	Z+3, r27	; 0x03
    4b9c:	a2 83       	std	Z+2, r26	; 0x02
    4b9e:	ae 01       	movw	r20, r28
    4ba0:	44 5f       	subi	r20, 0xF4	; 244
    4ba2:	5f 4f       	sbci	r21, 0xFF	; 255
    4ba4:	f9 01       	movw	r30, r18
    4ba6:	81 81       	ldd	r24, Z+1	; 0x01
    4ba8:	92 81       	ldd	r25, Z+2	; 0x02
    4baa:	84 17       	cp	r24, r20
    4bac:	95 07       	cpc	r25, r21
    4bae:	21 f4       	brne	.+8      	; 0x4bb8 <xTaskRemoveFromEventList+0x48>
    4bb0:	88 89       	ldd	r24, Y+16	; 0x10
    4bb2:	99 89       	ldd	r25, Y+17	; 0x11
    4bb4:	92 83       	std	Z+2, r25	; 0x02
    4bb6:	81 83       	std	Z+1, r24	; 0x01
    4bb8:	1d 8a       	std	Y+21, r1	; 0x15
    4bba:	1c 8a       	std	Y+20, r1	; 0x14
    4bbc:	d9 01       	movw	r26, r18
    4bbe:	8c 91       	ld	r24, X
    4bc0:	81 50       	subi	r24, 0x01	; 1
    4bc2:	8c 93       	st	X, r24

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4bc4:	80 91 bb 07 	lds	r24, 0x07BB
    4bc8:	88 23       	and	r24, r24
    4bca:	09 f0       	breq	.+2      	; 0x4bce <xTaskRemoveFromEventList+0x5e>
    4bcc:	59 c0       	rjmp	.+178    	; 0x4c80 <xTaskRemoveFromEventList+0x110>
    {
        listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4bce:	2a 85       	ldd	r18, Y+10	; 0x0a
    4bd0:	3b 85       	ldd	r19, Y+11	; 0x0b
    4bd2:	ac 81       	ldd	r26, Y+4	; 0x04
    4bd4:	bd 81       	ldd	r27, Y+5	; 0x05
    4bd6:	8e 81       	ldd	r24, Y+6	; 0x06
    4bd8:	9f 81       	ldd	r25, Y+7	; 0x07
    4bda:	15 96       	adiw	r26, 0x05	; 5
    4bdc:	9c 93       	st	X, r25
    4bde:	8e 93       	st	-X, r24
    4be0:	14 97       	sbiw	r26, 0x04	; 4
    4be2:	ee 81       	ldd	r30, Y+6	; 0x06
    4be4:	ff 81       	ldd	r31, Y+7	; 0x07
    4be6:	b3 83       	std	Z+3, r27	; 0x03
    4be8:	a2 83       	std	Z+2, r26	; 0x02
    4bea:	be 01       	movw	r22, r28
    4bec:	6e 5f       	subi	r22, 0xFE	; 254
    4bee:	7f 4f       	sbci	r23, 0xFF	; 255
    4bf0:	f9 01       	movw	r30, r18
    4bf2:	81 81       	ldd	r24, Z+1	; 0x01
    4bf4:	92 81       	ldd	r25, Z+2	; 0x02
    4bf6:	86 17       	cp	r24, r22
    4bf8:	97 07       	cpc	r25, r23
    4bfa:	21 f4       	brne	.+8      	; 0x4c04 <xTaskRemoveFromEventList+0x94>
    4bfc:	8e 81       	ldd	r24, Y+6	; 0x06
    4bfe:	9f 81       	ldd	r25, Y+7	; 0x07
    4c00:	92 83       	std	Z+2, r25	; 0x02
    4c02:	81 83       	std	Z+1, r24	; 0x01
    4c04:	1b 86       	std	Y+11, r1	; 0x0b
    4c06:	1a 86       	std	Y+10, r1	; 0x0a
    4c08:	d9 01       	movw	r26, r18
    4c0a:	8c 91       	ld	r24, X
    4c0c:	81 50       	subi	r24, 0x01	; 1
    4c0e:	8c 93       	st	X, r24
        prvAddTaskToReadyList( pxUnblockedTCB );
    4c10:	2e 89       	ldd	r18, Y+22	; 0x16
    4c12:	80 91 bc 07 	lds	r24, 0x07BC
    4c16:	82 17       	cp	r24, r18
    4c18:	10 f4       	brcc	.+4      	; 0x4c1e <xTaskRemoveFromEventList+0xae>
    4c1a:	20 93 bc 07 	sts	0x07BC, r18
    4c1e:	30 e0       	ldi	r19, 0x00	; 0
    4c20:	c9 01       	movw	r24, r18
    4c22:	88 0f       	add	r24, r24
    4c24:	99 1f       	adc	r25, r25
    4c26:	88 0f       	add	r24, r24
    4c28:	99 1f       	adc	r25, r25
    4c2a:	88 0f       	add	r24, r24
    4c2c:	99 1f       	adc	r25, r25
    4c2e:	82 0f       	add	r24, r18
    4c30:	93 1f       	adc	r25, r19
    4c32:	4b ec       	ldi	r20, 0xCB	; 203
    4c34:	57 e0       	ldi	r21, 0x07	; 7
    4c36:	fa 01       	movw	r30, r20
    4c38:	e8 0f       	add	r30, r24
    4c3a:	f9 1f       	adc	r31, r25
    4c3c:	a1 81       	ldd	r26, Z+1	; 0x01
    4c3e:	b2 81       	ldd	r27, Z+2	; 0x02
    4c40:	bd 83       	std	Y+5, r27	; 0x05
    4c42:	ac 83       	std	Y+4, r26	; 0x04
    4c44:	14 96       	adiw	r26, 0x04	; 4
    4c46:	8d 91       	ld	r24, X+
    4c48:	9c 91       	ld	r25, X
    4c4a:	15 97       	sbiw	r26, 0x05	; 5
    4c4c:	9f 83       	std	Y+7, r25	; 0x07
    4c4e:	8e 83       	std	Y+6, r24	; 0x06
    4c50:	14 96       	adiw	r26, 0x04	; 4
    4c52:	ed 91       	ld	r30, X+
    4c54:	fc 91       	ld	r31, X
    4c56:	15 97       	sbiw	r26, 0x05	; 5
    4c58:	73 83       	std	Z+3, r23	; 0x03
    4c5a:	62 83       	std	Z+2, r22	; 0x02
    4c5c:	15 96       	adiw	r26, 0x05	; 5
    4c5e:	7c 93       	st	X, r23
    4c60:	6e 93       	st	-X, r22
    4c62:	14 97       	sbiw	r26, 0x04	; 4
    4c64:	8e 89       	ldd	r24, Y+22	; 0x16
    4c66:	29 e0       	ldi	r18, 0x09	; 9
    4c68:	82 9f       	mul	r24, r18
    4c6a:	c0 01       	movw	r24, r0
    4c6c:	11 24       	eor	r1, r1
    4c6e:	48 0f       	add	r20, r24
    4c70:	59 1f       	adc	r21, r25
    4c72:	5b 87       	std	Y+11, r21	; 0x0b
    4c74:	4a 87       	std	Y+10, r20	; 0x0a
    4c76:	fa 01       	movw	r30, r20
    4c78:	80 81       	ld	r24, Z
    4c7a:	8f 5f       	subi	r24, 0xFF	; 255
    4c7c:	80 83       	st	Z, r24
    4c7e:	1f c0       	rjmp	.+62     	; 0x4cbe <xTaskRemoveFromEventList+0x14e>
    }
    else
    {
        /* The delayed and ready lists cannot be accessed, so hold this task
         * pending until the scheduler is resumed. */
        listINSERT_END( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4c80:	26 e0       	ldi	r18, 0x06	; 6
    4c82:	38 e0       	ldi	r19, 0x08	; 8
    4c84:	f9 01       	movw	r30, r18
    4c86:	a0 81       	ld	r26, Z
    4c88:	b1 81       	ldd	r27, Z+1	; 0x01
    4c8a:	bf 87       	std	Y+15, r27	; 0x0f
    4c8c:	ae 87       	std	Y+14, r26	; 0x0e
    4c8e:	14 96       	adiw	r26, 0x04	; 4
    4c90:	8d 91       	ld	r24, X+
    4c92:	9c 91       	ld	r25, X
    4c94:	15 97       	sbiw	r26, 0x05	; 5
    4c96:	99 8b       	std	Y+17, r25	; 0x11
    4c98:	88 8b       	std	Y+16, r24	; 0x10
    4c9a:	14 96       	adiw	r26, 0x04	; 4
    4c9c:	ed 91       	ld	r30, X+
    4c9e:	fc 91       	ld	r31, X
    4ca0:	15 97       	sbiw	r26, 0x05	; 5
    4ca2:	53 83       	std	Z+3, r21	; 0x03
    4ca4:	42 83       	std	Z+2, r20	; 0x02
    4ca6:	15 96       	adiw	r26, 0x05	; 5
    4ca8:	5c 93       	st	X, r21
    4caa:	4e 93       	st	-X, r20
    4cac:	14 97       	sbiw	r26, 0x04	; 4
    4cae:	21 50       	subi	r18, 0x01	; 1
    4cb0:	30 40       	sbci	r19, 0x00	; 0
    4cb2:	3d 8b       	std	Y+21, r19	; 0x15
    4cb4:	2c 8b       	std	Y+20, r18	; 0x14
    4cb6:	d9 01       	movw	r26, r18
    4cb8:	8c 91       	ld	r24, X
    4cba:	8f 5f       	subi	r24, 0xFF	; 255
    4cbc:	8c 93       	st	X, r24
    }

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4cbe:	e0 91 b9 07 	lds	r30, 0x07B9
    4cc2:	f0 91 ba 07 	lds	r31, 0x07BA
    4cc6:	9e 89       	ldd	r25, Y+22	; 0x16
    4cc8:	86 89       	ldd	r24, Z+22	; 0x16
    4cca:	89 17       	cp	r24, r25
    4ccc:	10 f0       	brcs	.+4      	; 0x4cd2 <xTaskRemoveFromEventList+0x162>
    4cce:	80 e0       	ldi	r24, 0x00	; 0
    4cd0:	03 c0       	rjmp	.+6      	; 0x4cd8 <xTaskRemoveFromEventList+0x168>
         * it should force a context switch now. */
        xReturn = pdTRUE;

        /* Mark that a yield is pending in case the user is not using the
         * "xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
        xYieldPending = pdTRUE;
    4cd2:	81 e0       	ldi	r24, 0x01	; 1
    4cd4:	80 93 bd 07 	sts	0x07BD, r24
    {
        xReturn = pdFALSE;
    }

    return xReturn;
}
    4cd8:	df 91       	pop	r29
    4cda:	cf 91       	pop	r28
    4cdc:	08 95       	ret

00004cde <vTaskRemoveFromUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem,
                                        const TickType_t xItemValue )
{
    4cde:	0f 93       	push	r16
    4ce0:	1f 93       	push	r17
    4ce2:	cf 93       	push	r28
    4ce4:	df 93       	push	r29
    4ce6:	ec 01       	movw	r28, r24
    /* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
     * the event flags implementation. */
    configASSERT( uxSchedulerSuspended != pdFALSE );

    /* Store the new item value in the event list. */
    listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    4ce8:	70 68       	ori	r23, 0x80	; 128
    4cea:	79 83       	std	Y+1, r23	; 0x01
    4cec:	68 83       	st	Y, r22

    /* Remove the event list form the event flag.  Interrupts do not access
     * event flags. */
    pxUnblockedTCB = listGET_LIST_ITEM_OWNER( pxEventListItem ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4cee:	6e 81       	ldd	r22, Y+6	; 0x06
    4cf0:	7f 81       	ldd	r23, Y+7	; 0x07
    configASSERT( pxUnblockedTCB );
    listREMOVE_ITEM( pxEventListItem );
    4cf2:	28 85       	ldd	r18, Y+8	; 0x08
    4cf4:	39 85       	ldd	r19, Y+9	; 0x09
    4cf6:	aa 81       	ldd	r26, Y+2	; 0x02
    4cf8:	bb 81       	ldd	r27, Y+3	; 0x03
    4cfa:	8c 81       	ldd	r24, Y+4	; 0x04
    4cfc:	9d 81       	ldd	r25, Y+5	; 0x05
    4cfe:	15 96       	adiw	r26, 0x05	; 5
    4d00:	9c 93       	st	X, r25
    4d02:	8e 93       	st	-X, r24
    4d04:	14 97       	sbiw	r26, 0x04	; 4
    4d06:	ec 81       	ldd	r30, Y+4	; 0x04
    4d08:	fd 81       	ldd	r31, Y+5	; 0x05
    4d0a:	b3 83       	std	Z+3, r27	; 0x03
    4d0c:	a2 83       	std	Z+2, r26	; 0x02
    4d0e:	d9 01       	movw	r26, r18
    4d10:	11 96       	adiw	r26, 0x01	; 1
    4d12:	ed 91       	ld	r30, X+
    4d14:	fc 91       	ld	r31, X
    4d16:	12 97       	sbiw	r26, 0x02	; 2
    4d18:	ec 17       	cp	r30, r28
    4d1a:	fd 07       	cpc	r31, r29
    4d1c:	31 f4       	brne	.+12     	; 0x4d2a <vTaskRemoveFromUnorderedEventList+0x4c>
    4d1e:	84 81       	ldd	r24, Z+4	; 0x04
    4d20:	95 81       	ldd	r25, Z+5	; 0x05
    4d22:	12 96       	adiw	r26, 0x02	; 2
    4d24:	9c 93       	st	X, r25
    4d26:	8e 93       	st	-X, r24
    4d28:	11 97       	sbiw	r26, 0x01	; 1
    4d2a:	19 86       	std	Y+9, r1	; 0x09
    4d2c:	18 86       	std	Y+8, r1	; 0x08
    4d2e:	f9 01       	movw	r30, r18
    4d30:	80 81       	ld	r24, Z
    4d32:	81 50       	subi	r24, 0x01	; 1
    4d34:	80 83       	st	Z, r24
    #endif

    /* Remove the task from the delayed list and add it to the ready list.  The
     * scheduler is suspended so interrupts will not be accessing the ready
     * lists. */
    listREMOVE_ITEM( &( pxUnblockedTCB->xStateListItem ) );
    4d36:	db 01       	movw	r26, r22
    4d38:	1a 96       	adiw	r26, 0x0a	; 10
    4d3a:	cd 91       	ld	r28, X+
    4d3c:	dc 91       	ld	r29, X
    4d3e:	1b 97       	sbiw	r26, 0x0b	; 11
    4d40:	14 96       	adiw	r26, 0x04	; 4
    4d42:	0d 90       	ld	r0, X+
    4d44:	bc 91       	ld	r27, X
    4d46:	a0 2d       	mov	r26, r0
    4d48:	fb 01       	movw	r30, r22
    4d4a:	86 81       	ldd	r24, Z+6	; 0x06
    4d4c:	97 81       	ldd	r25, Z+7	; 0x07
    4d4e:	15 96       	adiw	r26, 0x05	; 5
    4d50:	9c 93       	st	X, r25
    4d52:	8e 93       	st	-X, r24
    4d54:	14 97       	sbiw	r26, 0x04	; 4
    4d56:	86 81       	ldd	r24, Z+6	; 0x06
    4d58:	97 81       	ldd	r25, Z+7	; 0x07
    4d5a:	fc 01       	movw	r30, r24
    4d5c:	b3 83       	std	Z+3, r27	; 0x03
    4d5e:	a2 83       	std	Z+2, r26	; 0x02
    4d60:	8b 01       	movw	r16, r22
    4d62:	0e 5f       	subi	r16, 0xFE	; 254
    4d64:	1f 4f       	sbci	r17, 0xFF	; 255
    4d66:	89 81       	ldd	r24, Y+1	; 0x01
    4d68:	9a 81       	ldd	r25, Y+2	; 0x02
    4d6a:	80 17       	cp	r24, r16
    4d6c:	91 07       	cpc	r25, r17
    4d6e:	11 f4       	brne	.+4      	; 0x4d74 <vTaskRemoveFromUnorderedEventList+0x96>
    4d70:	fa 83       	std	Y+2, r31	; 0x02
    4d72:	e9 83       	std	Y+1, r30	; 0x01
    4d74:	fb 01       	movw	r30, r22
    4d76:	13 86       	std	Z+11, r1	; 0x0b
    4d78:	12 86       	std	Z+10, r1	; 0x0a
    4d7a:	88 81       	ld	r24, Y
    4d7c:	81 50       	subi	r24, 0x01	; 1
    4d7e:	88 83       	st	Y, r24
    prvAddTaskToReadyList( pxUnblockedTCB );
    4d80:	26 89       	ldd	r18, Z+22	; 0x16
    4d82:	80 91 bc 07 	lds	r24, 0x07BC
    4d86:	82 17       	cp	r24, r18
    4d88:	10 f4       	brcc	.+4      	; 0x4d8e <vTaskRemoveFromUnorderedEventList+0xb0>
    4d8a:	20 93 bc 07 	sts	0x07BC, r18
    4d8e:	30 e0       	ldi	r19, 0x00	; 0
    4d90:	c9 01       	movw	r24, r18
    4d92:	88 0f       	add	r24, r24
    4d94:	99 1f       	adc	r25, r25
    4d96:	88 0f       	add	r24, r24
    4d98:	99 1f       	adc	r25, r25
    4d9a:	88 0f       	add	r24, r24
    4d9c:	99 1f       	adc	r25, r25
    4d9e:	82 0f       	add	r24, r18
    4da0:	93 1f       	adc	r25, r19
    4da2:	4b ec       	ldi	r20, 0xCB	; 203
    4da4:	57 e0       	ldi	r21, 0x07	; 7
    4da6:	fa 01       	movw	r30, r20
    4da8:	e8 0f       	add	r30, r24
    4daa:	f9 1f       	adc	r31, r25
    4dac:	a1 81       	ldd	r26, Z+1	; 0x01
    4dae:	b2 81       	ldd	r27, Z+2	; 0x02
    4db0:	fb 01       	movw	r30, r22
    4db2:	b5 83       	std	Z+5, r27	; 0x05
    4db4:	a4 83       	std	Z+4, r26	; 0x04
    4db6:	14 96       	adiw	r26, 0x04	; 4
    4db8:	8d 91       	ld	r24, X+
    4dba:	9c 91       	ld	r25, X
    4dbc:	15 97       	sbiw	r26, 0x05	; 5
    4dbe:	97 83       	std	Z+7, r25	; 0x07
    4dc0:	86 83       	std	Z+6, r24	; 0x06
    4dc2:	14 96       	adiw	r26, 0x04	; 4
    4dc4:	ed 91       	ld	r30, X+
    4dc6:	fc 91       	ld	r31, X
    4dc8:	15 97       	sbiw	r26, 0x05	; 5
    4dca:	13 83       	std	Z+3, r17	; 0x03
    4dcc:	02 83       	std	Z+2, r16	; 0x02
    4dce:	15 96       	adiw	r26, 0x05	; 5
    4dd0:	1c 93       	st	X, r17
    4dd2:	0e 93       	st	-X, r16
    4dd4:	14 97       	sbiw	r26, 0x04	; 4
    4dd6:	db 01       	movw	r26, r22
    4dd8:	56 96       	adiw	r26, 0x16	; 22
    4dda:	8c 91       	ld	r24, X
    4ddc:	56 97       	sbiw	r26, 0x16	; 22
    4dde:	29 e0       	ldi	r18, 0x09	; 9
    4de0:	82 9f       	mul	r24, r18
    4de2:	c0 01       	movw	r24, r0
    4de4:	11 24       	eor	r1, r1
    4de6:	48 0f       	add	r20, r24
    4de8:	59 1f       	adc	r21, r25
    4dea:	1b 96       	adiw	r26, 0x0b	; 11
    4dec:	5c 93       	st	X, r21
    4dee:	4e 93       	st	-X, r20
    4df0:	1a 97       	sbiw	r26, 0x0a	; 10
    4df2:	fa 01       	movw	r30, r20
    4df4:	80 81       	ld	r24, Z
    4df6:	8f 5f       	subi	r24, 0xFF	; 255
    4df8:	80 83       	st	Z, r24

    if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    4dfa:	e0 91 b9 07 	lds	r30, 0x07B9
    4dfe:	f0 91 ba 07 	lds	r31, 0x07BA
    4e02:	56 96       	adiw	r26, 0x16	; 22
    4e04:	9c 91       	ld	r25, X
    4e06:	86 89       	ldd	r24, Z+22	; 0x16
    4e08:	89 17       	cp	r24, r25
    4e0a:	18 f4       	brcc	.+6      	; 0x4e12 <vTaskRemoveFromUnorderedEventList+0x134>
    {
        /* The unblocked task has a priority above that of the calling task, so
         * a context switch is required.  This function is called with the
         * scheduler suspended so xYieldPending is set so the context switch
         * occurs immediately that the scheduler is resumed (unsuspended). */
        xYieldPending = pdTRUE;
    4e0c:	81 e0       	ldi	r24, 0x01	; 1
    4e0e:	80 93 bd 07 	sts	0x07BD, r24
    }
}
    4e12:	df 91       	pop	r29
    4e14:	cf 91       	pop	r28
    4e16:	1f 91       	pop	r17
    4e18:	0f 91       	pop	r16
    4e1a:	08 95       	ret

00004e1c <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4e1c:	fc 01       	movw	r30, r24
    configASSERT( pxTimeOut );
    taskENTER_CRITICAL();
    4e1e:	0f b6       	in	r0, 0x3f	; 63
    4e20:	f8 94       	cli
    4e22:	0f 92       	push	r0
    {
        pxTimeOut->xOverflowCount = xNumOfOverflows;
    4e24:	80 91 c2 07 	lds	r24, 0x07C2
    4e28:	80 83       	st	Z, r24
        pxTimeOut->xTimeOnEntering = xTickCount;
    4e2a:	80 91 be 07 	lds	r24, 0x07BE
    4e2e:	90 91 bf 07 	lds	r25, 0x07BF
    4e32:	92 83       	std	Z+2, r25	; 0x02
    4e34:	81 83       	std	Z+1, r24	; 0x01
    }
    taskEXIT_CRITICAL();
    4e36:	0f 90       	pop	r0
    4e38:	0f be       	out	0x3f, r0	; 63
}
    4e3a:	08 95       	ret

00004e3c <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
    4e3c:	fc 01       	movw	r30, r24
    /* For internal use only as it does not use a critical section. */
    pxTimeOut->xOverflowCount = xNumOfOverflows;
    4e3e:	80 91 c2 07 	lds	r24, 0x07C2
    4e42:	80 83       	st	Z, r24
    pxTimeOut->xTimeOnEntering = xTickCount;
    4e44:	80 91 be 07 	lds	r24, 0x07BE
    4e48:	90 91 bf 07 	lds	r25, 0x07BF
    4e4c:	92 83       	std	Z+2, r25	; 0x02
    4e4e:	81 83       	std	Z+1, r24	; 0x01
}
    4e50:	08 95       	ret

00004e52 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut,
                                 TickType_t * const pxTicksToWait )
{
    4e52:	fc 01       	movw	r30, r24
    4e54:	db 01       	movw	r26, r22
    BaseType_t xReturn;

    configASSERT( pxTimeOut );
    configASSERT( pxTicksToWait );

    taskENTER_CRITICAL();
    4e56:	0f b6       	in	r0, 0x3f	; 63
    4e58:	f8 94       	cli
    4e5a:	0f 92       	push	r0
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
    4e5c:	40 91 be 07 	lds	r20, 0x07BE
    4e60:	50 91 bf 07 	lds	r21, 0x07BF
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4e64:	21 81       	ldd	r18, Z+1	; 0x01
    4e66:	32 81       	ldd	r19, Z+2	; 0x02
                xReturn = pdFALSE;
            }
            else
        #endif

        if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    4e68:	90 91 c2 07 	lds	r25, 0x07C2
    4e6c:	80 81       	ld	r24, Z
    4e6e:	89 17       	cp	r24, r25
    4e70:	39 f0       	breq	.+14     	; 0x4e80 <xTaskCheckForTimeOut+0x2e>
    4e72:	42 17       	cp	r20, r18
    4e74:	53 07       	cpc	r21, r19
    4e76:	20 f0       	brcs	.+8      	; 0x4e80 <xTaskCheckForTimeOut+0x2e>
             * vTaskSetTimeout() was called, but has also overflowed since
             * vTaskSetTimeOut() was called.  It must have wrapped all the way
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
    4e78:	1d 92       	st	X+, r1
    4e7a:	1c 92       	st	X, r1
    4e7c:	81 e0       	ldi	r24, 0x01	; 1
    4e7e:	16 c0       	rjmp	.+44     	; 0x4eac <xTaskCheckForTimeOut+0x5a>

    taskENTER_CRITICAL();
    {
        /* Minor optimisation.  The tick count cannot change in this block. */
        const TickType_t xConstTickCount = xTickCount;
        const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    4e80:	ca 01       	movw	r24, r20
    4e82:	82 1b       	sub	r24, r18
    4e84:	93 0b       	sbc	r25, r19
    4e86:	9c 01       	movw	r18, r24
             * around and gone past again. This passed since vTaskSetTimeout()
             * was called. */
            xReturn = pdTRUE;
            *pxTicksToWait = ( TickType_t ) 0;
        }
        else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    4e88:	8d 91       	ld	r24, X+
    4e8a:	9c 91       	ld	r25, X
    4e8c:	11 97       	sbiw	r26, 0x01	; 1
    4e8e:	28 17       	cp	r18, r24
    4e90:	39 07       	cpc	r19, r25
    4e92:	48 f4       	brcc	.+18     	; 0x4ea6 <xTaskCheckForTimeOut+0x54>
        {
            /* Not a genuine timeout. Adjust parameters for time remaining. */
            *pxTicksToWait -= xElapsedTime;
    4e94:	82 1b       	sub	r24, r18
    4e96:	93 0b       	sbc	r25, r19
    4e98:	8d 93       	st	X+, r24
    4e9a:	9c 93       	st	X, r25
            vTaskInternalSetTimeOutState( pxTimeOut );
    4e9c:	cf 01       	movw	r24, r30
    4e9e:	0e 94 1e 27 	call	0x4e3c	; 0x4e3c <vTaskInternalSetTimeOutState>
    4ea2:	80 e0       	ldi	r24, 0x00	; 0
    4ea4:	03 c0       	rjmp	.+6      	; 0x4eac <xTaskCheckForTimeOut+0x5a>
            xReturn = pdFALSE;
        }
        else
        {
            *pxTicksToWait = ( TickType_t ) 0;
    4ea6:	1d 92       	st	X+, r1
    4ea8:	1c 92       	st	X, r1
    4eaa:	81 e0       	ldi	r24, 0x01	; 1
            xReturn = pdTRUE;
        }
    }
    taskEXIT_CRITICAL();
    4eac:	0f 90       	pop	r0
    4eae:	0f be       	out	0x3f, r0	; 63

    return xReturn;
}
    4eb0:	08 95       	ret

00004eb2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    xYieldPending = pdTRUE;
    4eb2:	81 e0       	ldi	r24, 0x01	; 1
    4eb4:	80 93 bd 07 	sts	0x07BD, r24
}
    4eb8:	08 95       	ret

00004eba <prvResetNextTaskUnblockTime>:
#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
    if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4eba:	e0 91 01 08 	lds	r30, 0x0801
    4ebe:	f0 91 02 08 	lds	r31, 0x0802
    4ec2:	80 81       	ld	r24, Z
    4ec4:	88 23       	and	r24, r24
    4ec6:	39 f4       	brne	.+14     	; 0x4ed6 <prvResetNextTaskUnblockTime+0x1c>
    {
        /* The new current delayed list is empty.  Set xNextTaskUnblockTime to
         * the maximum possible value so it is  extremely unlikely that the
         * if( xTickCount >= xNextTaskUnblockTime ) test will pass until
         * there is an item in the delayed list. */
        xNextTaskUnblockTime = portMAX_DELAY;
    4ec8:	8f ef       	ldi	r24, 0xFF	; 255
    4eca:	9f ef       	ldi	r25, 0xFF	; 255
    4ecc:	90 93 c1 07 	sts	0x07C1, r25
    4ed0:	80 93 c0 07 	sts	0x07C0, r24
    4ed4:	08 95       	ret
    {
        /* The new current delayed list is not empty, get the value of
         * the item at the head of the delayed list.  This is the time at
         * which the task at the head of the delayed list should be removed
         * from the Blocked state. */
        xNextTaskUnblockTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxDelayedTaskList );
    4ed6:	e0 91 01 08 	lds	r30, 0x0801
    4eda:	f0 91 02 08 	lds	r31, 0x0802
    4ede:	05 80       	ldd	r0, Z+5	; 0x05
    4ee0:	f6 81       	ldd	r31, Z+6	; 0x06
    4ee2:	e0 2d       	mov	r30, r0
    4ee4:	80 81       	ld	r24, Z
    4ee6:	91 81       	ldd	r25, Z+1	; 0x01
    4ee8:	90 93 c1 07 	sts	0x07C1, r25
    4eec:	80 93 c0 07 	sts	0x07C0, r24
    4ef0:	08 95       	ret

00004ef2 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
    4ef2:	bf 92       	push	r11
    4ef4:	cf 92       	push	r12
    4ef6:	df 92       	push	r13
    4ef8:	ef 92       	push	r14
    4efa:	ff 92       	push	r15
    4efc:	0f 93       	push	r16
    4efe:	1f 93       	push	r17
    4f00:	cf 93       	push	r28
    4f02:	df 93       	push	r29
    /* Called by the portable layer each time a tick interrupt occurs.
     * Increments the tick then checks to see if the new tick value will cause any
     * tasks to be unblocked. */
    traceTASK_INCREMENT_TICK( xTickCount );

    if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    4f04:	80 91 bb 07 	lds	r24, 0x07BB
    4f08:	88 23       	and	r24, r24
    4f0a:	09 f0       	breq	.+2      	; 0x4f0e <xTaskIncrementTick+0x1c>
    4f0c:	f8 c0       	rjmp	.+496    	; 0x50fe <xTaskIncrementTick+0x20c>
    {
        /* Minor optimisation.  The tick count cannot change in this
         * block. */
        const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
    4f0e:	80 91 be 07 	lds	r24, 0x07BE
    4f12:	90 91 bf 07 	lds	r25, 0x07BF
    4f16:	8c 01       	movw	r16, r24
    4f18:	0f 5f       	subi	r16, 0xFF	; 255
    4f1a:	1f 4f       	sbci	r17, 0xFF	; 255

        /* Increment the RTOS tick, switching the delayed and overflowed
         * delayed lists if it wraps to 0. */
        xTickCount = xConstTickCount;
    4f1c:	10 93 bf 07 	sts	0x07BF, r17
    4f20:	00 93 be 07 	sts	0x07BE, r16

        if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
    4f24:	01 15       	cp	r16, r1
    4f26:	11 05       	cpc	r17, r1
    4f28:	b9 f4       	brne	.+46     	; 0x4f58 <xTaskIncrementTick+0x66>
        {
            taskSWITCH_DELAYED_LISTS();
    4f2a:	80 91 01 08 	lds	r24, 0x0801
    4f2e:	90 91 02 08 	lds	r25, 0x0802
    4f32:	20 91 03 08 	lds	r18, 0x0803
    4f36:	30 91 04 08 	lds	r19, 0x0804
    4f3a:	30 93 02 08 	sts	0x0802, r19
    4f3e:	20 93 01 08 	sts	0x0801, r18
    4f42:	90 93 04 08 	sts	0x0804, r25
    4f46:	80 93 03 08 	sts	0x0803, r24
    4f4a:	80 91 c2 07 	lds	r24, 0x07C2
    4f4e:	8f 5f       	subi	r24, 0xFF	; 255
    4f50:	80 93 c2 07 	sts	0x07C2, r24
    4f54:	0e 94 5d 27 	call	0x4eba	; 0x4eba <prvResetNextTaskUnblockTime>

        /* See if this tick has made a timeout expire.  Tasks are stored in
         * the  queue in the order of their wake time - meaning once one task
         * has been found whose block time has not expired there is no need to
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
    4f58:	80 91 c0 07 	lds	r24, 0x07C0
    4f5c:	90 91 c1 07 	lds	r25, 0x07C1
    4f60:	08 17       	cp	r16, r24
    4f62:	19 07       	cpc	r17, r25
    4f64:	08 f4       	brcc	.+2      	; 0x4f68 <xTaskIncrementTick+0x76>
    4f66:	b3 c0       	rjmp	.+358    	; 0x50ce <xTaskIncrementTick+0x1dc>
    4f68:	dd 24       	eor	r13, r13
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    4f6a:	0f 2e       	mov	r0, r31
    4f6c:	fb ec       	ldi	r31, 0xCB	; 203
    4f6e:	ef 2e       	mov	r14, r31
    4f70:	f7 e0       	ldi	r31, 0x07	; 7
    4f72:	ff 2e       	mov	r15, r31
    4f74:	f0 2d       	mov	r31, r0
    4f76:	0f 2e       	mov	r0, r31
    4f78:	f9 e0       	ldi	r31, 0x09	; 9
    4f7a:	cf 2e       	mov	r12, r31
    4f7c:	f0 2d       	mov	r31, r0
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    4f7e:	bb 24       	eor	r11, r11
    4f80:	b3 94       	inc	r11
         * look any further down the list. */
        if( xConstTickCount >= xNextTaskUnblockTime )
        {
            for( ; ; )
            {
                if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4f82:	e0 91 01 08 	lds	r30, 0x0801
    4f86:	f0 91 02 08 	lds	r31, 0x0802
    4f8a:	80 81       	ld	r24, Z
    4f8c:	88 23       	and	r24, r24
    4f8e:	39 f4       	brne	.+14     	; 0x4f9e <xTaskIncrementTick+0xac>
                    /* The delayed list is empty.  Set xNextTaskUnblockTime
                     * to the maximum possible value so it is extremely
                     * unlikely that the
                     * if( xTickCount >= xNextTaskUnblockTime ) test will pass
                     * next time through. */
                    xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    4f90:	8f ef       	ldi	r24, 0xFF	; 255
    4f92:	9f ef       	ldi	r25, 0xFF	; 255
    4f94:	90 93 c1 07 	sts	0x07C1, r25
    4f98:	80 93 c0 07 	sts	0x07C0, r24
    4f9c:	99 c0       	rjmp	.+306    	; 0x50d0 <xTaskIncrementTick+0x1de>
                {
                    /* The delayed list is not empty, get the value of the
                     * item at the head of the delayed list.  This is the time
                     * at which the task at the head of the delayed list must
                     * be removed from the Blocked state. */
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    4f9e:	e0 91 01 08 	lds	r30, 0x0801
    4fa2:	f0 91 02 08 	lds	r31, 0x0802
    4fa6:	05 80       	ldd	r0, Z+5	; 0x05
    4fa8:	f6 81       	ldd	r31, Z+6	; 0x06
    4faa:	e0 2d       	mov	r30, r0
    4fac:	c6 81       	ldd	r28, Z+6	; 0x06
    4fae:	d7 81       	ldd	r29, Z+7	; 0x07
                    xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
    4fb0:	8a 81       	ldd	r24, Y+2	; 0x02
    4fb2:	9b 81       	ldd	r25, Y+3	; 0x03

                    if( xConstTickCount < xItemValue )
    4fb4:	08 17       	cp	r16, r24
    4fb6:	19 07       	cpc	r17, r25
    4fb8:	28 f4       	brcc	.+10     	; 0x4fc4 <xTaskIncrementTick+0xd2>
                        /* It is not time to unblock this item yet, but the
                         * item value is the time at which the task at the head
                         * of the blocked list must be removed from the Blocked
                         * state -  so record the item value in
                         * xNextTaskUnblockTime. */
                        xNextTaskUnblockTime = xItemValue;
    4fba:	90 93 c1 07 	sts	0x07C1, r25
    4fbe:	80 93 c0 07 	sts	0x07C0, r24
    4fc2:	86 c0       	rjmp	.+268    	; 0x50d0 <xTaskIncrementTick+0x1de>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* It is time to remove the item from the Blocked state. */
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    4fc4:	2a 85       	ldd	r18, Y+10	; 0x0a
    4fc6:	3b 85       	ldd	r19, Y+11	; 0x0b
    4fc8:	ac 81       	ldd	r26, Y+4	; 0x04
    4fca:	bd 81       	ldd	r27, Y+5	; 0x05
    4fcc:	8e 81       	ldd	r24, Y+6	; 0x06
    4fce:	9f 81       	ldd	r25, Y+7	; 0x07
    4fd0:	15 96       	adiw	r26, 0x05	; 5
    4fd2:	9c 93       	st	X, r25
    4fd4:	8e 93       	st	-X, r24
    4fd6:	14 97       	sbiw	r26, 0x04	; 4
    4fd8:	ee 81       	ldd	r30, Y+6	; 0x06
    4fda:	ff 81       	ldd	r31, Y+7	; 0x07
    4fdc:	b3 83       	std	Z+3, r27	; 0x03
    4fde:	a2 83       	std	Z+2, r26	; 0x02
    4fe0:	be 01       	movw	r22, r28
    4fe2:	6e 5f       	subi	r22, 0xFE	; 254
    4fe4:	7f 4f       	sbci	r23, 0xFF	; 255
    4fe6:	f9 01       	movw	r30, r18
    4fe8:	81 81       	ldd	r24, Z+1	; 0x01
    4fea:	92 81       	ldd	r25, Z+2	; 0x02
    4fec:	86 17       	cp	r24, r22
    4fee:	97 07       	cpc	r25, r23
    4ff0:	21 f4       	brne	.+8      	; 0x4ffa <xTaskIncrementTick+0x108>
    4ff2:	8e 81       	ldd	r24, Y+6	; 0x06
    4ff4:	9f 81       	ldd	r25, Y+7	; 0x07
    4ff6:	92 83       	std	Z+2, r25	; 0x02
    4ff8:	81 83       	std	Z+1, r24	; 0x01
    4ffa:	1b 86       	std	Y+11, r1	; 0x0b
    4ffc:	1a 86       	std	Y+10, r1	; 0x0a
    4ffe:	f9 01       	movw	r30, r18
    5000:	80 81       	ld	r24, Z
    5002:	81 50       	subi	r24, 0x01	; 1
    5004:	80 83       	st	Z, r24

                    /* Is the task waiting on an event also?  If so remove
                     * it from the event list. */
                    if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5006:	4c 89       	ldd	r20, Y+20	; 0x14
    5008:	5d 89       	ldd	r21, Y+21	; 0x15
    500a:	41 15       	cp	r20, r1
    500c:	51 05       	cpc	r21, r1
    500e:	f9 f0       	breq	.+62     	; 0x504e <xTaskIncrementTick+0x15c>
                    {
                        listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    5010:	ae 85       	ldd	r26, Y+14	; 0x0e
    5012:	bf 85       	ldd	r27, Y+15	; 0x0f
    5014:	88 89       	ldd	r24, Y+16	; 0x10
    5016:	99 89       	ldd	r25, Y+17	; 0x11
    5018:	15 96       	adiw	r26, 0x05	; 5
    501a:	9c 93       	st	X, r25
    501c:	8e 93       	st	-X, r24
    501e:	14 97       	sbiw	r26, 0x04	; 4
    5020:	e8 89       	ldd	r30, Y+16	; 0x10
    5022:	f9 89       	ldd	r31, Y+17	; 0x11
    5024:	b3 83       	std	Z+3, r27	; 0x03
    5026:	a2 83       	std	Z+2, r26	; 0x02
    5028:	9e 01       	movw	r18, r28
    502a:	24 5f       	subi	r18, 0xF4	; 244
    502c:	3f 4f       	sbci	r19, 0xFF	; 255
    502e:	fa 01       	movw	r30, r20
    5030:	81 81       	ldd	r24, Z+1	; 0x01
    5032:	92 81       	ldd	r25, Z+2	; 0x02
    5034:	82 17       	cp	r24, r18
    5036:	93 07       	cpc	r25, r19
    5038:	21 f4       	brne	.+8      	; 0x5042 <xTaskIncrementTick+0x150>
    503a:	88 89       	ldd	r24, Y+16	; 0x10
    503c:	99 89       	ldd	r25, Y+17	; 0x11
    503e:	92 83       	std	Z+2, r25	; 0x02
    5040:	81 83       	std	Z+1, r24	; 0x01
    5042:	1d 8a       	std	Y+21, r1	; 0x15
    5044:	1c 8a       	std	Y+20, r1	; 0x14
    5046:	fa 01       	movw	r30, r20
    5048:	80 81       	ld	r24, Z
    504a:	81 50       	subi	r24, 0x01	; 1
    504c:	80 83       	st	Z, r24
                        mtCOVERAGE_TEST_MARKER();
                    }

                    /* Place the unblocked task into the appropriate ready
                     * list. */
                    prvAddTaskToReadyList( pxTCB );
    504e:	9e 89       	ldd	r25, Y+22	; 0x16
    5050:	80 91 bc 07 	lds	r24, 0x07BC
    5054:	89 17       	cp	r24, r25
    5056:	10 f4       	brcc	.+4      	; 0x505c <xTaskIncrementTick+0x16a>
    5058:	90 93 bc 07 	sts	0x07BC, r25
    505c:	2e 89       	ldd	r18, Y+22	; 0x16
    505e:	30 e0       	ldi	r19, 0x00	; 0
    5060:	c9 01       	movw	r24, r18
    5062:	88 0f       	add	r24, r24
    5064:	99 1f       	adc	r25, r25
    5066:	88 0f       	add	r24, r24
    5068:	99 1f       	adc	r25, r25
    506a:	88 0f       	add	r24, r24
    506c:	99 1f       	adc	r25, r25
    506e:	82 0f       	add	r24, r18
    5070:	93 1f       	adc	r25, r19
    5072:	f7 01       	movw	r30, r14
    5074:	e8 0f       	add	r30, r24
    5076:	f9 1f       	adc	r31, r25
    5078:	a1 81       	ldd	r26, Z+1	; 0x01
    507a:	b2 81       	ldd	r27, Z+2	; 0x02
    507c:	bd 83       	std	Y+5, r27	; 0x05
    507e:	ac 83       	std	Y+4, r26	; 0x04
    5080:	14 96       	adiw	r26, 0x04	; 4
    5082:	8d 91       	ld	r24, X+
    5084:	9c 91       	ld	r25, X
    5086:	15 97       	sbiw	r26, 0x05	; 5
    5088:	9f 83       	std	Y+7, r25	; 0x07
    508a:	8e 83       	std	Y+6, r24	; 0x06
    508c:	14 96       	adiw	r26, 0x04	; 4
    508e:	ed 91       	ld	r30, X+
    5090:	fc 91       	ld	r31, X
    5092:	15 97       	sbiw	r26, 0x05	; 5
    5094:	73 83       	std	Z+3, r23	; 0x03
    5096:	62 83       	std	Z+2, r22	; 0x02
    5098:	15 96       	adiw	r26, 0x05	; 5
    509a:	7c 93       	st	X, r23
    509c:	6e 93       	st	-X, r22
    509e:	14 97       	sbiw	r26, 0x04	; 4
    50a0:	8e 89       	ldd	r24, Y+22	; 0x16
    50a2:	8c 9d       	mul	r24, r12
    50a4:	c0 01       	movw	r24, r0
    50a6:	11 24       	eor	r1, r1
    50a8:	f7 01       	movw	r30, r14
    50aa:	e8 0f       	add	r30, r24
    50ac:	f9 1f       	adc	r31, r25
    50ae:	fb 87       	std	Y+11, r31	; 0x0b
    50b0:	ea 87       	std	Y+10, r30	; 0x0a
    50b2:	80 81       	ld	r24, Z
    50b4:	8f 5f       	subi	r24, 0xFF	; 255
    50b6:	80 83       	st	Z, r24
                         * task.
                         * The case of equal priority tasks sharing
                         * processing time (which happens when both
                         * preemption and time slicing are on) is
                         * handled below.*/
                        if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    50b8:	e0 91 b9 07 	lds	r30, 0x07B9
    50bc:	f0 91 ba 07 	lds	r31, 0x07BA
    50c0:	9e 89       	ldd	r25, Y+22	; 0x16
    50c2:	86 89       	ldd	r24, Z+22	; 0x16
    50c4:	89 17       	cp	r24, r25
    50c6:	08 f0       	brcs	.+2      	; 0x50ca <xTaskIncrementTick+0x1d8>
    50c8:	5c cf       	rjmp	.-328    	; 0x4f82 <xTaskIncrementTick+0x90>
    50ca:	db 2c       	mov	r13, r11
    50cc:	5a cf       	rjmp	.-332    	; 0x4f82 <xTaskIncrementTick+0x90>
    50ce:	dd 24       	eor	r13, r13
        /* Tasks of equal priority to the currently running task will share
         * processing time (time slice) if preemption is on, and the application
         * writer has not explicitly turned time slicing off. */
        #if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
        {
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
    50d0:	e0 91 b9 07 	lds	r30, 0x07B9
    50d4:	f0 91 ba 07 	lds	r31, 0x07BA
    50d8:	e6 89       	ldd	r30, Z+22	; 0x16
    50da:	89 e0       	ldi	r24, 0x09	; 9
    50dc:	e8 9f       	mul	r30, r24
    50de:	f0 01       	movw	r30, r0
    50e0:	11 24       	eor	r1, r1
    50e2:	e5 53       	subi	r30, 0x35	; 53
    50e4:	f8 4f       	sbci	r31, 0xF8	; 248
    50e6:	80 81       	ld	r24, Z
    50e8:	82 30       	cpi	r24, 0x02	; 2
    50ea:	10 f0       	brcs	.+4      	; 0x50f0 <xTaskIncrementTick+0x1fe>
    50ec:	dd 24       	eor	r13, r13
    50ee:	d3 94       	inc	r13
        }
        #endif /* configUSE_TICK_HOOK */

        #if ( configUSE_PREEMPTION == 1 )
        {
            if( xYieldPending != pdFALSE )
    50f0:	80 91 bd 07 	lds	r24, 0x07BD
    50f4:	88 23       	and	r24, r24
    50f6:	69 f0       	breq	.+26     	; 0x5112 <xTaskIncrementTick+0x220>
    50f8:	dd 24       	eor	r13, r13
    50fa:	d3 94       	inc	r13
    50fc:	0a c0       	rjmp	.+20     	; 0x5112 <xTaskIncrementTick+0x220>
        }
        #endif /* configUSE_PREEMPTION */
    }
    else
    {
        ++xPendedTicks;
    50fe:	80 91 c3 07 	lds	r24, 0x07C3
    5102:	90 91 c4 07 	lds	r25, 0x07C4
    5106:	01 96       	adiw	r24, 0x01	; 1
    5108:	90 93 c4 07 	sts	0x07C4, r25
    510c:	80 93 c3 07 	sts	0x07C3, r24
    5110:	dd 24       	eor	r13, r13
        }
        #endif
    }

    return xSwitchRequired;
}
    5112:	8d 2d       	mov	r24, r13
    5114:	df 91       	pop	r29
    5116:	cf 91       	pop	r28
    5118:	1f 91       	pop	r17
    511a:	0f 91       	pop	r16
    511c:	ff 90       	pop	r15
    511e:	ef 90       	pop	r14
    5120:	df 90       	pop	r13
    5122:	cf 90       	pop	r12
    5124:	bf 90       	pop	r11
    5126:	08 95       	ret

00005128 <xTaskGetCurrentTaskHandle>:
        TaskHandle_t xReturn;

        /* A critical section is not required as this is not called from
         * an interrupt and the current TCB will always be the same for any
         * individual execution thread. */
        xReturn = pxCurrentTCB;
    5128:	20 91 b9 07 	lds	r18, 0x07B9
    512c:	30 91 ba 07 	lds	r19, 0x07BA

        return xReturn;
    }
    5130:	82 2f       	mov	r24, r18
    5132:	93 2f       	mov	r25, r19
    5134:	08 95       	ret

00005136 <uxTaskResetEventItemValue>:

TickType_t uxTaskResetEventItemValue( void )
{
    TickType_t uxReturn;

    uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
    5136:	e0 91 b9 07 	lds	r30, 0x07B9
    513a:	f0 91 ba 07 	lds	r31, 0x07BA
    513e:	84 85       	ldd	r24, Z+12	; 0x0c
    5140:	95 85       	ldd	r25, Z+13	; 0x0d

    /* Reset the event list item to its normal value - so it can be used with
     * queues and semaphores. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    5142:	a0 91 b9 07 	lds	r26, 0x07B9
    5146:	b0 91 ba 07 	lds	r27, 0x07BA
    514a:	e0 91 b9 07 	lds	r30, 0x07B9
    514e:	f0 91 ba 07 	lds	r31, 0x07BA
    5152:	46 89       	ldd	r20, Z+22	; 0x16
    5154:	24 e0       	ldi	r18, 0x04	; 4
    5156:	30 e0       	ldi	r19, 0x00	; 0
    5158:	24 1b       	sub	r18, r20
    515a:	31 09       	sbc	r19, r1
    515c:	1d 96       	adiw	r26, 0x0d	; 13
    515e:	3c 93       	st	X, r19
    5160:	2e 93       	st	-X, r18
    5162:	1c 97       	sbiw	r26, 0x0c	; 12

    return uxReturn;
}
    5164:	08 95       	ret

00005166 <xTaskGenericNotifyFromISR>:
                                          UBaseType_t uxIndexToNotify,
                                          uint32_t ulValue,
                                          eNotifyAction eAction,
                                          uint32_t * pulPreviousNotificationValue,
                                          BaseType_t * pxHigherPriorityTaskWoken )
    {
    5166:	af 92       	push	r10
    5168:	bf 92       	push	r11
    516a:	cf 92       	push	r12
    516c:	df 92       	push	r13
    516e:	ef 92       	push	r14
    5170:	ff 92       	push	r15
    5172:	0f 93       	push	r16
    5174:	1f 93       	push	r17
    5176:	cf 93       	push	r28
    5178:	df 93       	push	r29
    517a:	5c 01       	movw	r10, r24
    517c:	e7 01       	movw	r28, r14
    517e:	76 01       	movw	r14, r12

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            if( pulPreviousNotificationValue != NULL )
    5180:	20 97       	sbiw	r28, 0x00	; 0
    5182:	91 f0       	breq	.+36     	; 0x51a8 <xTaskGenericNotifyFromISR+0x42>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    5184:	86 2f       	mov	r24, r22
    5186:	90 e0       	ldi	r25, 0x00	; 0
    5188:	88 0f       	add	r24, r24
    518a:	99 1f       	adc	r25, r25
    518c:	88 0f       	add	r24, r24
    518e:	99 1f       	adc	r25, r25
    5190:	f5 01       	movw	r30, r10
    5192:	e8 0f       	add	r30, r24
    5194:	f9 1f       	adc	r31, r25
    5196:	b1 96       	adiw	r30, 0x21	; 33
    5198:	80 81       	ld	r24, Z
    519a:	91 81       	ldd	r25, Z+1	; 0x01
    519c:	a2 81       	ldd	r26, Z+2	; 0x02
    519e:	b3 81       	ldd	r27, Z+3	; 0x03
    51a0:	88 83       	st	Y, r24
    51a2:	99 83       	std	Y+1, r25	; 0x01
    51a4:	aa 83       	std	Y+2, r26	; 0x02
    51a6:	bb 83       	std	Y+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    51a8:	70 e0       	ldi	r23, 0x00	; 0
    51aa:	f5 01       	movw	r30, r10
    51ac:	e6 0f       	add	r30, r22
    51ae:	f7 1f       	adc	r31, r23
    51b0:	b5 96       	adiw	r30, 0x25	; 37
    51b2:	10 81       	ld	r17, Z
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    51b4:	82 e0       	ldi	r24, 0x02	; 2
    51b6:	80 83       	st	Z, r24

            switch( eAction )
    51b8:	02 30       	cpi	r16, 0x02	; 2
    51ba:	11 f1       	breq	.+68     	; 0x5200 <xTaskGenericNotifyFromISR+0x9a>
    51bc:	03 30       	cpi	r16, 0x03	; 3
    51be:	20 f4       	brcc	.+8      	; 0x51c8 <xTaskGenericNotifyFromISR+0x62>
    51c0:	01 30       	cpi	r16, 0x01	; 1
    51c2:	09 f0       	breq	.+2      	; 0x51c6 <xTaskGenericNotifyFromISR+0x60>
    51c4:	51 c0       	rjmp	.+162    	; 0x5268 <xTaskGenericNotifyFromISR+0x102>
    51c6:	06 c0       	rjmp	.+12     	; 0x51d4 <xTaskGenericNotifyFromISR+0x6e>
    51c8:	03 30       	cpi	r16, 0x03	; 3
    51ca:	79 f1       	breq	.+94     	; 0x522a <xTaskGenericNotifyFromISR+0xc4>
    51cc:	04 30       	cpi	r16, 0x04	; 4
    51ce:	09 f0       	breq	.+2      	; 0x51d2 <xTaskGenericNotifyFromISR+0x6c>
    51d0:	4b c0       	rjmp	.+150    	; 0x5268 <xTaskGenericNotifyFromISR+0x102>
    51d2:	39 c0       	rjmp	.+114    	; 0x5246 <xTaskGenericNotifyFromISR+0xe0>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    51d4:	cb 01       	movw	r24, r22
    51d6:	88 0f       	add	r24, r24
    51d8:	99 1f       	adc	r25, r25
    51da:	88 0f       	add	r24, r24
    51dc:	99 1f       	adc	r25, r25
    51de:	f5 01       	movw	r30, r10
    51e0:	e8 0f       	add	r30, r24
    51e2:	f9 1f       	adc	r31, r25
    51e4:	b1 96       	adiw	r30, 0x21	; 33
    51e6:	80 81       	ld	r24, Z
    51e8:	91 81       	ldd	r25, Z+1	; 0x01
    51ea:	a2 81       	ldd	r26, Z+2	; 0x02
    51ec:	b3 81       	ldd	r27, Z+3	; 0x03
    51ee:	82 2b       	or	r24, r18
    51f0:	93 2b       	or	r25, r19
    51f2:	a4 2b       	or	r26, r20
    51f4:	b5 2b       	or	r27, r21
    51f6:	80 83       	st	Z, r24
    51f8:	91 83       	std	Z+1, r25	; 0x01
    51fa:	a2 83       	std	Z+2, r26	; 0x02
    51fc:	b3 83       	std	Z+3, r27	; 0x03
    51fe:	34 c0       	rjmp	.+104    	; 0x5268 <xTaskGenericNotifyFromISR+0x102>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    5200:	cb 01       	movw	r24, r22
    5202:	88 0f       	add	r24, r24
    5204:	99 1f       	adc	r25, r25
    5206:	88 0f       	add	r24, r24
    5208:	99 1f       	adc	r25, r25
    520a:	f5 01       	movw	r30, r10
    520c:	e8 0f       	add	r30, r24
    520e:	f9 1f       	adc	r31, r25
    5210:	b1 96       	adiw	r30, 0x21	; 33
    5212:	80 81       	ld	r24, Z
    5214:	91 81       	ldd	r25, Z+1	; 0x01
    5216:	a2 81       	ldd	r26, Z+2	; 0x02
    5218:	b3 81       	ldd	r27, Z+3	; 0x03
    521a:	01 96       	adiw	r24, 0x01	; 1
    521c:	a1 1d       	adc	r26, r1
    521e:	b1 1d       	adc	r27, r1
    5220:	80 83       	st	Z, r24
    5222:	91 83       	std	Z+1, r25	; 0x01
    5224:	a2 83       	std	Z+2, r26	; 0x02
    5226:	b3 83       	std	Z+3, r27	; 0x03
    5228:	1f c0       	rjmp	.+62     	; 0x5268 <xTaskGenericNotifyFromISR+0x102>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    522a:	cb 01       	movw	r24, r22
    522c:	88 0f       	add	r24, r24
    522e:	99 1f       	adc	r25, r25
    5230:	88 0f       	add	r24, r24
    5232:	99 1f       	adc	r25, r25
    5234:	f5 01       	movw	r30, r10
    5236:	e8 0f       	add	r30, r24
    5238:	f9 1f       	adc	r31, r25
    523a:	b1 96       	adiw	r30, 0x21	; 33
    523c:	20 83       	st	Z, r18
    523e:	31 83       	std	Z+1, r19	; 0x01
    5240:	42 83       	std	Z+2, r20	; 0x02
    5242:	53 83       	std	Z+3, r21	; 0x03
    5244:	11 c0       	rjmp	.+34     	; 0x5268 <xTaskGenericNotifyFromISR+0x102>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    5246:	12 30       	cpi	r17, 0x02	; 2
    5248:	11 f4       	brne	.+4      	; 0x524e <xTaskGenericNotifyFromISR+0xe8>
    524a:	80 e0       	ldi	r24, 0x00	; 0
    524c:	b2 c0       	rjmp	.+356    	; 0x53b2 <xTaskGenericNotifyFromISR+0x24c>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    524e:	cb 01       	movw	r24, r22
    5250:	88 0f       	add	r24, r24
    5252:	99 1f       	adc	r25, r25
    5254:	88 0f       	add	r24, r24
    5256:	99 1f       	adc	r25, r25
    5258:	f5 01       	movw	r30, r10
    525a:	e8 0f       	add	r30, r24
    525c:	f9 1f       	adc	r31, r25
    525e:	b1 96       	adiw	r30, 0x21	; 33
    5260:	20 83       	st	Z, r18
    5262:	31 83       	std	Z+1, r19	; 0x01
    5264:	42 83       	std	Z+2, r20	; 0x02
    5266:	53 83       	std	Z+3, r21	; 0x03

            traceTASK_NOTIFY_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5268:	11 30       	cpi	r17, 0x01	; 1
    526a:	09 f0       	breq	.+2      	; 0x526e <xTaskGenericNotifyFromISR+0x108>
    526c:	a1 c0       	rjmp	.+322    	; 0x53b0 <xTaskGenericNotifyFromISR+0x24a>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    526e:	80 91 bb 07 	lds	r24, 0x07BB
    5272:	88 23       	and	r24, r24
    5274:	09 f0       	breq	.+2      	; 0x5278 <xTaskGenericNotifyFromISR+0x112>
    5276:	63 c0       	rjmp	.+198    	; 0x533e <xTaskGenericNotifyFromISR+0x1d8>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5278:	d5 01       	movw	r26, r10
    527a:	1a 96       	adiw	r26, 0x0a	; 10
    527c:	cd 91       	ld	r28, X+
    527e:	dc 91       	ld	r29, X
    5280:	1b 97       	sbiw	r26, 0x0b	; 11
    5282:	14 96       	adiw	r26, 0x04	; 4
    5284:	0d 90       	ld	r0, X+
    5286:	bc 91       	ld	r27, X
    5288:	a0 2d       	mov	r26, r0
    528a:	f5 01       	movw	r30, r10
    528c:	86 81       	ldd	r24, Z+6	; 0x06
    528e:	97 81       	ldd	r25, Z+7	; 0x07
    5290:	15 96       	adiw	r26, 0x05	; 5
    5292:	9c 93       	st	X, r25
    5294:	8e 93       	st	-X, r24
    5296:	14 97       	sbiw	r26, 0x04	; 4
    5298:	86 81       	ldd	r24, Z+6	; 0x06
    529a:	97 81       	ldd	r25, Z+7	; 0x07
    529c:	fc 01       	movw	r30, r24
    529e:	b3 83       	std	Z+3, r27	; 0x03
    52a0:	a2 83       	std	Z+2, r26	; 0x02
    52a2:	b5 01       	movw	r22, r10
    52a4:	6e 5f       	subi	r22, 0xFE	; 254
    52a6:	7f 4f       	sbci	r23, 0xFF	; 255
    52a8:	89 81       	ldd	r24, Y+1	; 0x01
    52aa:	9a 81       	ldd	r25, Y+2	; 0x02
    52ac:	86 17       	cp	r24, r22
    52ae:	97 07       	cpc	r25, r23
    52b0:	11 f4       	brne	.+4      	; 0x52b6 <xTaskGenericNotifyFromISR+0x150>
    52b2:	fa 83       	std	Y+2, r31	; 0x02
    52b4:	e9 83       	std	Y+1, r30	; 0x01
    52b6:	f5 01       	movw	r30, r10
    52b8:	13 86       	std	Z+11, r1	; 0x0b
    52ba:	12 86       	std	Z+10, r1	; 0x0a
    52bc:	88 81       	ld	r24, Y
    52be:	81 50       	subi	r24, 0x01	; 1
    52c0:	88 83       	st	Y, r24
                    prvAddTaskToReadyList( pxTCB );
    52c2:	26 89       	ldd	r18, Z+22	; 0x16
    52c4:	80 91 bc 07 	lds	r24, 0x07BC
    52c8:	82 17       	cp	r24, r18
    52ca:	10 f4       	brcc	.+4      	; 0x52d0 <xTaskGenericNotifyFromISR+0x16a>
    52cc:	20 93 bc 07 	sts	0x07BC, r18
    52d0:	30 e0       	ldi	r19, 0x00	; 0
    52d2:	c9 01       	movw	r24, r18
    52d4:	88 0f       	add	r24, r24
    52d6:	99 1f       	adc	r25, r25
    52d8:	88 0f       	add	r24, r24
    52da:	99 1f       	adc	r25, r25
    52dc:	88 0f       	add	r24, r24
    52de:	99 1f       	adc	r25, r25
    52e0:	82 0f       	add	r24, r18
    52e2:	93 1f       	adc	r25, r19
    52e4:	4b ec       	ldi	r20, 0xCB	; 203
    52e6:	57 e0       	ldi	r21, 0x07	; 7
    52e8:	fa 01       	movw	r30, r20
    52ea:	e8 0f       	add	r30, r24
    52ec:	f9 1f       	adc	r31, r25
    52ee:	a1 81       	ldd	r26, Z+1	; 0x01
    52f0:	b2 81       	ldd	r27, Z+2	; 0x02
    52f2:	f5 01       	movw	r30, r10
    52f4:	b5 83       	std	Z+5, r27	; 0x05
    52f6:	a4 83       	std	Z+4, r26	; 0x04
    52f8:	14 96       	adiw	r26, 0x04	; 4
    52fa:	8d 91       	ld	r24, X+
    52fc:	9c 91       	ld	r25, X
    52fe:	15 97       	sbiw	r26, 0x05	; 5
    5300:	97 83       	std	Z+7, r25	; 0x07
    5302:	86 83       	std	Z+6, r24	; 0x06
    5304:	14 96       	adiw	r26, 0x04	; 4
    5306:	ed 91       	ld	r30, X+
    5308:	fc 91       	ld	r31, X
    530a:	15 97       	sbiw	r26, 0x05	; 5
    530c:	73 83       	std	Z+3, r23	; 0x03
    530e:	62 83       	std	Z+2, r22	; 0x02
    5310:	15 96       	adiw	r26, 0x05	; 5
    5312:	7c 93       	st	X, r23
    5314:	6e 93       	st	-X, r22
    5316:	14 97       	sbiw	r26, 0x04	; 4
    5318:	d5 01       	movw	r26, r10
    531a:	56 96       	adiw	r26, 0x16	; 22
    531c:	8c 91       	ld	r24, X
    531e:	56 97       	sbiw	r26, 0x16	; 22
    5320:	29 e0       	ldi	r18, 0x09	; 9
    5322:	82 9f       	mul	r24, r18
    5324:	c0 01       	movw	r24, r0
    5326:	11 24       	eor	r1, r1
    5328:	48 0f       	add	r20, r24
    532a:	59 1f       	adc	r21, r25
    532c:	1b 96       	adiw	r26, 0x0b	; 11
    532e:	5c 93       	st	X, r21
    5330:	4e 93       	st	-X, r20
    5332:	1a 97       	sbiw	r26, 0x0a	; 10
    5334:	fa 01       	movw	r30, r20
    5336:	80 81       	ld	r24, Z
    5338:	8f 5f       	subi	r24, 0xFF	; 255
    533a:	80 83       	st	Z, r24
    533c:	25 c0       	rjmp	.+74     	; 0x5388 <xTaskGenericNotifyFromISR+0x222>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    533e:	26 e0       	ldi	r18, 0x06	; 6
    5340:	38 e0       	ldi	r19, 0x08	; 8
    5342:	f9 01       	movw	r30, r18
    5344:	a0 81       	ld	r26, Z
    5346:	b1 81       	ldd	r27, Z+1	; 0x01
    5348:	f5 01       	movw	r30, r10
    534a:	b7 87       	std	Z+15, r27	; 0x0f
    534c:	a6 87       	std	Z+14, r26	; 0x0e
    534e:	14 96       	adiw	r26, 0x04	; 4
    5350:	8d 91       	ld	r24, X+
    5352:	9c 91       	ld	r25, X
    5354:	15 97       	sbiw	r26, 0x05	; 5
    5356:	91 8b       	std	Z+17, r25	; 0x11
    5358:	80 8b       	std	Z+16, r24	; 0x10
    535a:	c5 01       	movw	r24, r10
    535c:	0c 96       	adiw	r24, 0x0c	; 12
    535e:	14 96       	adiw	r26, 0x04	; 4
    5360:	ed 91       	ld	r30, X+
    5362:	fc 91       	ld	r31, X
    5364:	15 97       	sbiw	r26, 0x05	; 5
    5366:	93 83       	std	Z+3, r25	; 0x03
    5368:	82 83       	std	Z+2, r24	; 0x02
    536a:	15 96       	adiw	r26, 0x05	; 5
    536c:	9c 93       	st	X, r25
    536e:	8e 93       	st	-X, r24
    5370:	14 97       	sbiw	r26, 0x04	; 4
    5372:	21 50       	subi	r18, 0x01	; 1
    5374:	30 40       	sbci	r19, 0x00	; 0
    5376:	d5 01       	movw	r26, r10
    5378:	55 96       	adiw	r26, 0x15	; 21
    537a:	3c 93       	st	X, r19
    537c:	2e 93       	st	-X, r18
    537e:	54 97       	sbiw	r26, 0x14	; 20
    5380:	f9 01       	movw	r30, r18
    5382:	80 81       	ld	r24, Z
    5384:	8f 5f       	subi	r24, 0xFF	; 255
    5386:	80 83       	st	Z, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    5388:	e0 91 b9 07 	lds	r30, 0x07B9
    538c:	f0 91 ba 07 	lds	r31, 0x07BA
    5390:	d5 01       	movw	r26, r10
    5392:	56 96       	adiw	r26, 0x16	; 22
    5394:	9c 91       	ld	r25, X
    5396:	86 89       	ldd	r24, Z+22	; 0x16
    5398:	89 17       	cp	r24, r25
    539a:	50 f4       	brcc	.+20     	; 0x53b0 <xTaskGenericNotifyFromISR+0x24a>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    539c:	e1 14       	cp	r14, r1
    539e:	f1 04       	cpc	r15, r1
    53a0:	19 f0       	breq	.+6      	; 0x53a8 <xTaskGenericNotifyFromISR+0x242>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    53a2:	81 e0       	ldi	r24, 0x01	; 1
    53a4:	f7 01       	movw	r30, r14
    53a6:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter to an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    53a8:	81 e0       	ldi	r24, 0x01	; 1
    53aa:	80 93 bd 07 	sts	0x07BD, r24
    53ae:	01 c0       	rjmp	.+2      	; 0x53b2 <xTaskGenericNotifyFromISR+0x24c>
    53b0:	81 e0       	ldi	r24, 0x01	; 1
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

        return xReturn;
    }
    53b2:	df 91       	pop	r29
    53b4:	cf 91       	pop	r28
    53b6:	1f 91       	pop	r17
    53b8:	0f 91       	pop	r16
    53ba:	ff 90       	pop	r15
    53bc:	ef 90       	pop	r14
    53be:	df 90       	pop	r13
    53c0:	cf 90       	pop	r12
    53c2:	bf 90       	pop	r11
    53c4:	af 90       	pop	r10
    53c6:	08 95       	ret

000053c8 <vTaskGenericNotifyGiveFromISR>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    void vTaskGenericNotifyGiveFromISR( TaskHandle_t xTaskToNotify,
                                        UBaseType_t uxIndexToNotify,
                                        BaseType_t * pxHigherPriorityTaskWoken )
    {
    53c8:	0f 93       	push	r16
    53ca:	1f 93       	push	r17
    53cc:	cf 93       	push	r28
    53ce:	df 93       	push	r29
    53d0:	ec 01       	movw	r28, r24
    53d2:	8a 01       	movw	r16, r20

        pxTCB = xTaskToNotify;

        uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
        {
            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    53d4:	70 e0       	ldi	r23, 0x00	; 0
    53d6:	fc 01       	movw	r30, r24
    53d8:	e6 0f       	add	r30, r22
    53da:	f7 1f       	adc	r31, r23
    53dc:	b5 96       	adiw	r30, 0x25	; 37
    53de:	20 81       	ld	r18, Z
            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    53e0:	82 e0       	ldi	r24, 0x02	; 2
    53e2:	80 83       	st	Z, r24

            /* 'Giving' is equivalent to incrementing a count in a counting
             * semaphore. */
            ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    53e4:	66 0f       	add	r22, r22
    53e6:	77 1f       	adc	r23, r23
    53e8:	66 0f       	add	r22, r22
    53ea:	77 1f       	adc	r23, r23
    53ec:	fe 01       	movw	r30, r28
    53ee:	e6 0f       	add	r30, r22
    53f0:	f7 1f       	adc	r31, r23
    53f2:	b1 96       	adiw	r30, 0x21	; 33
    53f4:	80 81       	ld	r24, Z
    53f6:	91 81       	ldd	r25, Z+1	; 0x01
    53f8:	a2 81       	ldd	r26, Z+2	; 0x02
    53fa:	b3 81       	ldd	r27, Z+3	; 0x03
    53fc:	01 96       	adiw	r24, 0x01	; 1
    53fe:	a1 1d       	adc	r26, r1
    5400:	b1 1d       	adc	r27, r1
    5402:	80 83       	st	Z, r24
    5404:	91 83       	std	Z+1, r25	; 0x01
    5406:	a2 83       	std	Z+2, r26	; 0x02
    5408:	b3 83       	std	Z+3, r27	; 0x03

            traceTASK_NOTIFY_GIVE_FROM_ISR( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    540a:	21 30       	cpi	r18, 0x01	; 1
    540c:	09 f0       	breq	.+2      	; 0x5410 <vTaskGenericNotifyGiveFromISR+0x48>
    540e:	90 c0       	rjmp	.+288    	; 0x5530 <vTaskGenericNotifyGiveFromISR+0x168>
            {
                /* The task should not have been on an event list. */
                configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

                if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5410:	80 91 bb 07 	lds	r24, 0x07BB
    5414:	88 23       	and	r24, r24
    5416:	09 f0       	breq	.+2      	; 0x541a <vTaskGenericNotifyGiveFromISR+0x52>
    5418:	59 c0       	rjmp	.+178    	; 0x54cc <vTaskGenericNotifyGiveFromISR+0x104>
                {
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    541a:	2a 85       	ldd	r18, Y+10	; 0x0a
    541c:	3b 85       	ldd	r19, Y+11	; 0x0b
    541e:	ac 81       	ldd	r26, Y+4	; 0x04
    5420:	bd 81       	ldd	r27, Y+5	; 0x05
    5422:	8e 81       	ldd	r24, Y+6	; 0x06
    5424:	9f 81       	ldd	r25, Y+7	; 0x07
    5426:	15 96       	adiw	r26, 0x05	; 5
    5428:	9c 93       	st	X, r25
    542a:	8e 93       	st	-X, r24
    542c:	14 97       	sbiw	r26, 0x04	; 4
    542e:	ee 81       	ldd	r30, Y+6	; 0x06
    5430:	ff 81       	ldd	r31, Y+7	; 0x07
    5432:	b3 83       	std	Z+3, r27	; 0x03
    5434:	a2 83       	std	Z+2, r26	; 0x02
    5436:	be 01       	movw	r22, r28
    5438:	6e 5f       	subi	r22, 0xFE	; 254
    543a:	7f 4f       	sbci	r23, 0xFF	; 255
    543c:	f9 01       	movw	r30, r18
    543e:	81 81       	ldd	r24, Z+1	; 0x01
    5440:	92 81       	ldd	r25, Z+2	; 0x02
    5442:	86 17       	cp	r24, r22
    5444:	97 07       	cpc	r25, r23
    5446:	21 f4       	brne	.+8      	; 0x5450 <vTaskGenericNotifyGiveFromISR+0x88>
    5448:	8e 81       	ldd	r24, Y+6	; 0x06
    544a:	9f 81       	ldd	r25, Y+7	; 0x07
    544c:	92 83       	std	Z+2, r25	; 0x02
    544e:	81 83       	std	Z+1, r24	; 0x01
    5450:	1b 86       	std	Y+11, r1	; 0x0b
    5452:	1a 86       	std	Y+10, r1	; 0x0a
    5454:	f9 01       	movw	r30, r18
    5456:	80 81       	ld	r24, Z
    5458:	81 50       	subi	r24, 0x01	; 1
    545a:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    545c:	2e 89       	ldd	r18, Y+22	; 0x16
    545e:	80 91 bc 07 	lds	r24, 0x07BC
    5462:	82 17       	cp	r24, r18
    5464:	10 f4       	brcc	.+4      	; 0x546a <vTaskGenericNotifyGiveFromISR+0xa2>
    5466:	20 93 bc 07 	sts	0x07BC, r18
    546a:	30 e0       	ldi	r19, 0x00	; 0
    546c:	c9 01       	movw	r24, r18
    546e:	88 0f       	add	r24, r24
    5470:	99 1f       	adc	r25, r25
    5472:	88 0f       	add	r24, r24
    5474:	99 1f       	adc	r25, r25
    5476:	88 0f       	add	r24, r24
    5478:	99 1f       	adc	r25, r25
    547a:	82 0f       	add	r24, r18
    547c:	93 1f       	adc	r25, r19
    547e:	4b ec       	ldi	r20, 0xCB	; 203
    5480:	57 e0       	ldi	r21, 0x07	; 7
    5482:	fa 01       	movw	r30, r20
    5484:	e8 0f       	add	r30, r24
    5486:	f9 1f       	adc	r31, r25
    5488:	a1 81       	ldd	r26, Z+1	; 0x01
    548a:	b2 81       	ldd	r27, Z+2	; 0x02
    548c:	bd 83       	std	Y+5, r27	; 0x05
    548e:	ac 83       	std	Y+4, r26	; 0x04
    5490:	14 96       	adiw	r26, 0x04	; 4
    5492:	8d 91       	ld	r24, X+
    5494:	9c 91       	ld	r25, X
    5496:	15 97       	sbiw	r26, 0x05	; 5
    5498:	9f 83       	std	Y+7, r25	; 0x07
    549a:	8e 83       	std	Y+6, r24	; 0x06
    549c:	14 96       	adiw	r26, 0x04	; 4
    549e:	ed 91       	ld	r30, X+
    54a0:	fc 91       	ld	r31, X
    54a2:	15 97       	sbiw	r26, 0x05	; 5
    54a4:	73 83       	std	Z+3, r23	; 0x03
    54a6:	62 83       	std	Z+2, r22	; 0x02
    54a8:	15 96       	adiw	r26, 0x05	; 5
    54aa:	7c 93       	st	X, r23
    54ac:	6e 93       	st	-X, r22
    54ae:	14 97       	sbiw	r26, 0x04	; 4
    54b0:	8e 89       	ldd	r24, Y+22	; 0x16
    54b2:	29 e0       	ldi	r18, 0x09	; 9
    54b4:	82 9f       	mul	r24, r18
    54b6:	c0 01       	movw	r24, r0
    54b8:	11 24       	eor	r1, r1
    54ba:	48 0f       	add	r20, r24
    54bc:	59 1f       	adc	r21, r25
    54be:	5b 87       	std	Y+11, r21	; 0x0b
    54c0:	4a 87       	std	Y+10, r20	; 0x0a
    54c2:	fa 01       	movw	r30, r20
    54c4:	80 81       	ld	r24, Z
    54c6:	8f 5f       	subi	r24, 0xFF	; 255
    54c8:	80 83       	st	Z, r24
    54ca:	21 c0       	rjmp	.+66     	; 0x550e <vTaskGenericNotifyGiveFromISR+0x146>
                }
                else
                {
                    /* The delayed and ready lists cannot be accessed, so hold
                     * this task pending until the scheduler is resumed. */
                    listINSERT_END( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    54cc:	26 e0       	ldi	r18, 0x06	; 6
    54ce:	38 e0       	ldi	r19, 0x08	; 8
    54d0:	f9 01       	movw	r30, r18
    54d2:	a0 81       	ld	r26, Z
    54d4:	b1 81       	ldd	r27, Z+1	; 0x01
    54d6:	bf 87       	std	Y+15, r27	; 0x0f
    54d8:	ae 87       	std	Y+14, r26	; 0x0e
    54da:	14 96       	adiw	r26, 0x04	; 4
    54dc:	8d 91       	ld	r24, X+
    54de:	9c 91       	ld	r25, X
    54e0:	15 97       	sbiw	r26, 0x05	; 5
    54e2:	99 8b       	std	Y+17, r25	; 0x11
    54e4:	88 8b       	std	Y+16, r24	; 0x10
    54e6:	ce 01       	movw	r24, r28
    54e8:	0c 96       	adiw	r24, 0x0c	; 12
    54ea:	14 96       	adiw	r26, 0x04	; 4
    54ec:	ed 91       	ld	r30, X+
    54ee:	fc 91       	ld	r31, X
    54f0:	15 97       	sbiw	r26, 0x05	; 5
    54f2:	93 83       	std	Z+3, r25	; 0x03
    54f4:	82 83       	std	Z+2, r24	; 0x02
    54f6:	15 96       	adiw	r26, 0x05	; 5
    54f8:	9c 93       	st	X, r25
    54fa:	8e 93       	st	-X, r24
    54fc:	14 97       	sbiw	r26, 0x04	; 4
    54fe:	21 50       	subi	r18, 0x01	; 1
    5500:	30 40       	sbci	r19, 0x00	; 0
    5502:	3d 8b       	std	Y+21, r19	; 0x15
    5504:	2c 8b       	std	Y+20, r18	; 0x14
    5506:	f9 01       	movw	r30, r18
    5508:	80 81       	ld	r24, Z
    550a:	8f 5f       	subi	r24, 0xFF	; 255
    550c:	80 83       	st	Z, r24
                }

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    550e:	e0 91 b9 07 	lds	r30, 0x07B9
    5512:	f0 91 ba 07 	lds	r31, 0x07BA
    5516:	9e 89       	ldd	r25, Y+22	; 0x16
    5518:	86 89       	ldd	r24, Z+22	; 0x16
    551a:	89 17       	cp	r24, r25
    551c:	48 f4       	brcc	.+18     	; 0x5530 <vTaskGenericNotifyGiveFromISR+0x168>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    if( pxHigherPriorityTaskWoken != NULL )
    551e:	01 15       	cp	r16, r1
    5520:	11 05       	cpc	r17, r1
    5522:	19 f0       	breq	.+6      	; 0x552a <vTaskGenericNotifyGiveFromISR+0x162>
                    {
                        *pxHigherPriorityTaskWoken = pdTRUE;
    5524:	81 e0       	ldi	r24, 0x01	; 1
    5526:	f8 01       	movw	r30, r16
    5528:	80 83       	st	Z, r24
                    }

                    /* Mark that a yield is pending in case the user is not
                     * using the "xHigherPriorityTaskWoken" parameter in an ISR
                     * safe FreeRTOS function. */
                    xYieldPending = pdTRUE;
    552a:	81 e0       	ldi	r24, 0x01	; 1
    552c:	80 93 bd 07 	sts	0x07BD, r24
                    mtCOVERAGE_TEST_MARKER();
                }
            }
        }
        portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
    }
    5530:	df 91       	pop	r29
    5532:	cf 91       	pop	r28
    5534:	1f 91       	pop	r17
    5536:	0f 91       	pop	r16
    5538:	08 95       	ret

0000553a <xTaskGenericNotifyStateClear>:

#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    BaseType_t xTaskGenericNotifyStateClear( TaskHandle_t xTask,
                                             UBaseType_t uxIndexToClear )
    {
    553a:	26 2f       	mov	r18, r22

        configASSERT( uxIndexToClear < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    553c:	00 97       	sbiw	r24, 0x00	; 0
    553e:	11 f0       	breq	.+4      	; 0x5544 <xTaskGenericNotifyStateClear+0xa>
    5540:	bc 01       	movw	r22, r24
    5542:	04 c0       	rjmp	.+8      	; 0x554c <xTaskGenericNotifyStateClear+0x12>
    5544:	60 91 b9 07 	lds	r22, 0x07B9
    5548:	70 91 ba 07 	lds	r23, 0x07BA

        taskENTER_CRITICAL();
    554c:	0f b6       	in	r0, 0x3f	; 63
    554e:	f8 94       	cli
    5550:	0f 92       	push	r0
        {
            if( pxTCB->ucNotifyState[ uxIndexToClear ] == taskNOTIFICATION_RECEIVED )
    5552:	30 e0       	ldi	r19, 0x00	; 0
    5554:	fb 01       	movw	r30, r22
    5556:	e2 0f       	add	r30, r18
    5558:	f3 1f       	adc	r31, r19
    555a:	b5 96       	adiw	r30, 0x25	; 37
    555c:	80 81       	ld	r24, Z
    555e:	82 30       	cpi	r24, 0x02	; 2
    5560:	11 f0       	breq	.+4      	; 0x5566 <xTaskGenericNotifyStateClear+0x2c>
    5562:	80 e0       	ldi	r24, 0x00	; 0
    5564:	06 c0       	rjmp	.+12     	; 0x5572 <xTaskGenericNotifyStateClear+0x38>
            {
                pxTCB->ucNotifyState[ uxIndexToClear ] = taskNOT_WAITING_NOTIFICATION;
    5566:	fb 01       	movw	r30, r22
    5568:	e2 0f       	add	r30, r18
    556a:	f3 1f       	adc	r31, r19
    556c:	b5 96       	adiw	r30, 0x25	; 37
    556e:	10 82       	st	Z, r1
    5570:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                xReturn = pdFAIL;
            }
        }
        taskEXIT_CRITICAL();
    5572:	0f 90       	pop	r0
    5574:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    5576:	08 95       	ret

00005578 <ulTaskGenericNotifyValueClear>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyValueClear( TaskHandle_t xTask,
                                            UBaseType_t uxIndexToClear,
                                            uint32_t ulBitsToClear )
    {
    5578:	af 92       	push	r10
    557a:	bf 92       	push	r11
    557c:	cf 92       	push	r12
    557e:	df 92       	push	r13
    5580:	ef 92       	push	r14
    5582:	ff 92       	push	r15
    5584:	0f 93       	push	r16
    5586:	1f 93       	push	r17
    5588:	e6 2f       	mov	r30, r22
    558a:	59 01       	movw	r10, r18
    558c:	6a 01       	movw	r12, r20
        TCB_t * pxTCB;
        uint32_t ulReturn;

        /* If null is passed in here then it is the calling task that is having
         * its notification state cleared. */
        pxTCB = prvGetTCBFromHandle( xTask );
    558e:	00 97       	sbiw	r24, 0x00	; 0
    5590:	11 f0       	breq	.+4      	; 0x5596 <ulTaskGenericNotifyValueClear+0x1e>
    5592:	bc 01       	movw	r22, r24
    5594:	04 c0       	rjmp	.+8      	; 0x559e <ulTaskGenericNotifyValueClear+0x26>
    5596:	60 91 b9 07 	lds	r22, 0x07B9
    559a:	70 91 ba 07 	lds	r23, 0x07BA

        taskENTER_CRITICAL();
    559e:	0f b6       	in	r0, 0x3f	; 63
    55a0:	f8 94       	cli
    55a2:	0f 92       	push	r0
        {
            /* Return the notification as it was before the bits were cleared,
             * then clear the bit mask. */
            ulReturn = pxTCB->ulNotifiedValue[ uxIndexToClear ];
    55a4:	8e 2f       	mov	r24, r30
    55a6:	90 e0       	ldi	r25, 0x00	; 0
    55a8:	88 0f       	add	r24, r24
    55aa:	99 1f       	adc	r25, r25
    55ac:	88 0f       	add	r24, r24
    55ae:	99 1f       	adc	r25, r25
    55b0:	fb 01       	movw	r30, r22
    55b2:	e8 0f       	add	r30, r24
    55b4:	f9 1f       	adc	r31, r25
    55b6:	b1 96       	adiw	r30, 0x21	; 33
    55b8:	20 81       	ld	r18, Z
    55ba:	31 81       	ldd	r19, Z+1	; 0x01
    55bc:	42 81       	ldd	r20, Z+2	; 0x02
    55be:	53 81       	ldd	r21, Z+3	; 0x03
            pxTCB->ulNotifiedValue[ uxIndexToClear ] &= ~ulBitsToClear;
    55c0:	e0 80       	ld	r14, Z
    55c2:	f1 80       	ldd	r15, Z+1	; 0x01
    55c4:	02 81       	ldd	r16, Z+2	; 0x02
    55c6:	13 81       	ldd	r17, Z+3	; 0x03
    55c8:	d6 01       	movw	r26, r12
    55ca:	c5 01       	movw	r24, r10
    55cc:	80 95       	com	r24
    55ce:	90 95       	com	r25
    55d0:	a0 95       	com	r26
    55d2:	b0 95       	com	r27
    55d4:	8e 21       	and	r24, r14
    55d6:	9f 21       	and	r25, r15
    55d8:	a0 23       	and	r26, r16
    55da:	b1 23       	and	r27, r17
    55dc:	80 83       	st	Z, r24
    55de:	91 83       	std	Z+1, r25	; 0x01
    55e0:	a2 83       	std	Z+2, r26	; 0x02
    55e2:	b3 83       	std	Z+3, r27	; 0x03
        }
        taskEXIT_CRITICAL();
    55e4:	0f 90       	pop	r0
    55e6:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    55e8:	62 2f       	mov	r22, r18
    55ea:	73 2f       	mov	r23, r19
    55ec:	84 2f       	mov	r24, r20
    55ee:	95 2f       	mov	r25, r21
    55f0:	1f 91       	pop	r17
    55f2:	0f 91       	pop	r16
    55f4:	ff 90       	pop	r15
    55f6:	ef 90       	pop	r14
    55f8:	df 90       	pop	r13
    55fa:	cf 90       	pop	r12
    55fc:	bf 90       	pop	r11
    55fe:	af 90       	pop	r10
    5600:	08 95       	ret

00005602 <xTaskGenericNotify>:
    BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify,
                                   UBaseType_t uxIndexToNotify,
                                   uint32_t ulValue,
                                   eNotifyAction eAction,
                                   uint32_t * pulPreviousNotificationValue )
    {
    5602:	ef 92       	push	r14
    5604:	ff 92       	push	r15
    5606:	0f 93       	push	r16
    5608:	1f 93       	push	r17
    560a:	cf 93       	push	r28
    560c:	df 93       	push	r29
    560e:	ec 01       	movw	r28, r24

        configASSERT( uxIndexToNotify < configTASK_NOTIFICATION_ARRAY_ENTRIES );
        configASSERT( xTaskToNotify );
        pxTCB = xTaskToNotify;

        taskENTER_CRITICAL();
    5610:	0f b6       	in	r0, 0x3f	; 63
    5612:	f8 94       	cli
    5614:	0f 92       	push	r0
        {
            if( pulPreviousNotificationValue != NULL )
    5616:	e1 14       	cp	r14, r1
    5618:	f1 04       	cpc	r15, r1
    561a:	99 f0       	breq	.+38     	; 0x5642 <xTaskGenericNotify+0x40>
            {
                *pulPreviousNotificationValue = pxTCB->ulNotifiedValue[ uxIndexToNotify ];
    561c:	86 2f       	mov	r24, r22
    561e:	90 e0       	ldi	r25, 0x00	; 0
    5620:	88 0f       	add	r24, r24
    5622:	99 1f       	adc	r25, r25
    5624:	88 0f       	add	r24, r24
    5626:	99 1f       	adc	r25, r25
    5628:	fe 01       	movw	r30, r28
    562a:	e8 0f       	add	r30, r24
    562c:	f9 1f       	adc	r31, r25
    562e:	b1 96       	adiw	r30, 0x21	; 33
    5630:	80 81       	ld	r24, Z
    5632:	91 81       	ldd	r25, Z+1	; 0x01
    5634:	a2 81       	ldd	r26, Z+2	; 0x02
    5636:	b3 81       	ldd	r27, Z+3	; 0x03
    5638:	f7 01       	movw	r30, r14
    563a:	80 83       	st	Z, r24
    563c:	91 83       	std	Z+1, r25	; 0x01
    563e:	a2 83       	std	Z+2, r26	; 0x02
    5640:	b3 83       	std	Z+3, r27	; 0x03
            }

            ucOriginalNotifyState = pxTCB->ucNotifyState[ uxIndexToNotify ];
    5642:	70 e0       	ldi	r23, 0x00	; 0
    5644:	fe 01       	movw	r30, r28
    5646:	e6 0f       	add	r30, r22
    5648:	f7 1f       	adc	r31, r23
    564a:	b5 96       	adiw	r30, 0x25	; 37
    564c:	10 81       	ld	r17, Z

            pxTCB->ucNotifyState[ uxIndexToNotify ] = taskNOTIFICATION_RECEIVED;
    564e:	82 e0       	ldi	r24, 0x02	; 2
    5650:	80 83       	st	Z, r24

            switch( eAction )
    5652:	02 30       	cpi	r16, 0x02	; 2
    5654:	11 f1       	breq	.+68     	; 0x569a <xTaskGenericNotify+0x98>
    5656:	03 30       	cpi	r16, 0x03	; 3
    5658:	20 f4       	brcc	.+8      	; 0x5662 <xTaskGenericNotify+0x60>
    565a:	01 30       	cpi	r16, 0x01	; 1
    565c:	09 f0       	breq	.+2      	; 0x5660 <xTaskGenericNotify+0x5e>
    565e:	51 c0       	rjmp	.+162    	; 0x5702 <xTaskGenericNotify+0x100>
    5660:	06 c0       	rjmp	.+12     	; 0x566e <xTaskGenericNotify+0x6c>
    5662:	03 30       	cpi	r16, 0x03	; 3
    5664:	79 f1       	breq	.+94     	; 0x56c4 <xTaskGenericNotify+0xc2>
    5666:	04 30       	cpi	r16, 0x04	; 4
    5668:	09 f0       	breq	.+2      	; 0x566c <xTaskGenericNotify+0x6a>
    566a:	4b c0       	rjmp	.+150    	; 0x5702 <xTaskGenericNotify+0x100>
    566c:	39 c0       	rjmp	.+114    	; 0x56e0 <xTaskGenericNotify+0xde>
            {
                case eSetBits:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] |= ulValue;
    566e:	cb 01       	movw	r24, r22
    5670:	88 0f       	add	r24, r24
    5672:	99 1f       	adc	r25, r25
    5674:	88 0f       	add	r24, r24
    5676:	99 1f       	adc	r25, r25
    5678:	fe 01       	movw	r30, r28
    567a:	e8 0f       	add	r30, r24
    567c:	f9 1f       	adc	r31, r25
    567e:	b1 96       	adiw	r30, 0x21	; 33
    5680:	80 81       	ld	r24, Z
    5682:	91 81       	ldd	r25, Z+1	; 0x01
    5684:	a2 81       	ldd	r26, Z+2	; 0x02
    5686:	b3 81       	ldd	r27, Z+3	; 0x03
    5688:	82 2b       	or	r24, r18
    568a:	93 2b       	or	r25, r19
    568c:	a4 2b       	or	r26, r20
    568e:	b5 2b       	or	r27, r21
    5690:	80 83       	st	Z, r24
    5692:	91 83       	std	Z+1, r25	; 0x01
    5694:	a2 83       	std	Z+2, r26	; 0x02
    5696:	b3 83       	std	Z+3, r27	; 0x03
    5698:	34 c0       	rjmp	.+104    	; 0x5702 <xTaskGenericNotify+0x100>
                    break;

                case eIncrement:
                    ( pxTCB->ulNotifiedValue[ uxIndexToNotify ] )++;
    569a:	cb 01       	movw	r24, r22
    569c:	88 0f       	add	r24, r24
    569e:	99 1f       	adc	r25, r25
    56a0:	88 0f       	add	r24, r24
    56a2:	99 1f       	adc	r25, r25
    56a4:	fe 01       	movw	r30, r28
    56a6:	e8 0f       	add	r30, r24
    56a8:	f9 1f       	adc	r31, r25
    56aa:	b1 96       	adiw	r30, 0x21	; 33
    56ac:	80 81       	ld	r24, Z
    56ae:	91 81       	ldd	r25, Z+1	; 0x01
    56b0:	a2 81       	ldd	r26, Z+2	; 0x02
    56b2:	b3 81       	ldd	r27, Z+3	; 0x03
    56b4:	01 96       	adiw	r24, 0x01	; 1
    56b6:	a1 1d       	adc	r26, r1
    56b8:	b1 1d       	adc	r27, r1
    56ba:	80 83       	st	Z, r24
    56bc:	91 83       	std	Z+1, r25	; 0x01
    56be:	a2 83       	std	Z+2, r26	; 0x02
    56c0:	b3 83       	std	Z+3, r27	; 0x03
    56c2:	1f c0       	rjmp	.+62     	; 0x5702 <xTaskGenericNotify+0x100>
                    break;

                case eSetValueWithOverwrite:
                    pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    56c4:	cb 01       	movw	r24, r22
    56c6:	88 0f       	add	r24, r24
    56c8:	99 1f       	adc	r25, r25
    56ca:	88 0f       	add	r24, r24
    56cc:	99 1f       	adc	r25, r25
    56ce:	fe 01       	movw	r30, r28
    56d0:	e8 0f       	add	r30, r24
    56d2:	f9 1f       	adc	r31, r25
    56d4:	b1 96       	adiw	r30, 0x21	; 33
    56d6:	20 83       	st	Z, r18
    56d8:	31 83       	std	Z+1, r19	; 0x01
    56da:	42 83       	std	Z+2, r20	; 0x02
    56dc:	53 83       	std	Z+3, r21	; 0x03
    56de:	11 c0       	rjmp	.+34     	; 0x5702 <xTaskGenericNotify+0x100>
                    break;

                case eSetValueWithoutOverwrite:

                    if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
    56e0:	12 30       	cpi	r17, 0x02	; 2
    56e2:	11 f4       	brne	.+4      	; 0x56e8 <xTaskGenericNotify+0xe6>
    56e4:	80 e0       	ldi	r24, 0x00	; 0
    56e6:	76 c0       	rjmp	.+236    	; 0x57d4 <xTaskGenericNotify+0x1d2>
                    {
                        pxTCB->ulNotifiedValue[ uxIndexToNotify ] = ulValue;
    56e8:	cb 01       	movw	r24, r22
    56ea:	88 0f       	add	r24, r24
    56ec:	99 1f       	adc	r25, r25
    56ee:	88 0f       	add	r24, r24
    56f0:	99 1f       	adc	r25, r25
    56f2:	fe 01       	movw	r30, r28
    56f4:	e8 0f       	add	r30, r24
    56f6:	f9 1f       	adc	r31, r25
    56f8:	b1 96       	adiw	r30, 0x21	; 33
    56fa:	20 83       	st	Z, r18
    56fc:	31 83       	std	Z+1, r19	; 0x01
    56fe:	42 83       	std	Z+2, r20	; 0x02
    5700:	53 83       	std	Z+3, r21	; 0x03

            traceTASK_NOTIFY( uxIndexToNotify );

            /* If the task is in the blocked state specifically to wait for a
             * notification then unblock it now. */
            if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
    5702:	11 30       	cpi	r17, 0x01	; 1
    5704:	09 f0       	breq	.+2      	; 0x5708 <xTaskGenericNotify+0x106>
    5706:	65 c0       	rjmp	.+202    	; 0x57d2 <xTaskGenericNotify+0x1d0>
            {
                listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    5708:	2a 85       	ldd	r18, Y+10	; 0x0a
    570a:	3b 85       	ldd	r19, Y+11	; 0x0b
    570c:	ac 81       	ldd	r26, Y+4	; 0x04
    570e:	bd 81       	ldd	r27, Y+5	; 0x05
    5710:	8e 81       	ldd	r24, Y+6	; 0x06
    5712:	9f 81       	ldd	r25, Y+7	; 0x07
    5714:	15 96       	adiw	r26, 0x05	; 5
    5716:	9c 93       	st	X, r25
    5718:	8e 93       	st	-X, r24
    571a:	14 97       	sbiw	r26, 0x04	; 4
    571c:	ee 81       	ldd	r30, Y+6	; 0x06
    571e:	ff 81       	ldd	r31, Y+7	; 0x07
    5720:	b3 83       	std	Z+3, r27	; 0x03
    5722:	a2 83       	std	Z+2, r26	; 0x02
    5724:	be 01       	movw	r22, r28
    5726:	6e 5f       	subi	r22, 0xFE	; 254
    5728:	7f 4f       	sbci	r23, 0xFF	; 255
    572a:	f9 01       	movw	r30, r18
    572c:	81 81       	ldd	r24, Z+1	; 0x01
    572e:	92 81       	ldd	r25, Z+2	; 0x02
    5730:	86 17       	cp	r24, r22
    5732:	97 07       	cpc	r25, r23
    5734:	21 f4       	brne	.+8      	; 0x573e <xTaskGenericNotify+0x13c>
    5736:	8e 81       	ldd	r24, Y+6	; 0x06
    5738:	9f 81       	ldd	r25, Y+7	; 0x07
    573a:	92 83       	std	Z+2, r25	; 0x02
    573c:	81 83       	std	Z+1, r24	; 0x01
    573e:	1b 86       	std	Y+11, r1	; 0x0b
    5740:	1a 86       	std	Y+10, r1	; 0x0a
    5742:	f9 01       	movw	r30, r18
    5744:	80 81       	ld	r24, Z
    5746:	81 50       	subi	r24, 0x01	; 1
    5748:	80 83       	st	Z, r24
                prvAddTaskToReadyList( pxTCB );
    574a:	9e 89       	ldd	r25, Y+22	; 0x16
    574c:	80 91 bc 07 	lds	r24, 0x07BC
    5750:	89 17       	cp	r24, r25
    5752:	10 f4       	brcc	.+4      	; 0x5758 <xTaskGenericNotify+0x156>
    5754:	90 93 bc 07 	sts	0x07BC, r25
    5758:	8e 89       	ldd	r24, Y+22	; 0x16
    575a:	90 e0       	ldi	r25, 0x00	; 0
    575c:	9c 01       	movw	r18, r24
    575e:	22 0f       	add	r18, r18
    5760:	33 1f       	adc	r19, r19
    5762:	22 0f       	add	r18, r18
    5764:	33 1f       	adc	r19, r19
    5766:	22 0f       	add	r18, r18
    5768:	33 1f       	adc	r19, r19
    576a:	28 0f       	add	r18, r24
    576c:	39 1f       	adc	r19, r25
    576e:	4b ec       	ldi	r20, 0xCB	; 203
    5770:	57 e0       	ldi	r21, 0x07	; 7
    5772:	fa 01       	movw	r30, r20
    5774:	e2 0f       	add	r30, r18
    5776:	f3 1f       	adc	r31, r19
    5778:	a1 81       	ldd	r26, Z+1	; 0x01
    577a:	b2 81       	ldd	r27, Z+2	; 0x02
    577c:	bd 83       	std	Y+5, r27	; 0x05
    577e:	ac 83       	std	Y+4, r26	; 0x04
    5780:	14 96       	adiw	r26, 0x04	; 4
    5782:	8d 91       	ld	r24, X+
    5784:	9c 91       	ld	r25, X
    5786:	15 97       	sbiw	r26, 0x05	; 5
    5788:	9f 83       	std	Y+7, r25	; 0x07
    578a:	8e 83       	std	Y+6, r24	; 0x06
    578c:	14 96       	adiw	r26, 0x04	; 4
    578e:	ed 91       	ld	r30, X+
    5790:	fc 91       	ld	r31, X
    5792:	15 97       	sbiw	r26, 0x05	; 5
    5794:	73 83       	std	Z+3, r23	; 0x03
    5796:	62 83       	std	Z+2, r22	; 0x02
    5798:	15 96       	adiw	r26, 0x05	; 5
    579a:	7c 93       	st	X, r23
    579c:	6e 93       	st	-X, r22
    579e:	14 97       	sbiw	r26, 0x04	; 4
    57a0:	8e 89       	ldd	r24, Y+22	; 0x16
    57a2:	29 e0       	ldi	r18, 0x09	; 9
    57a4:	82 9f       	mul	r24, r18
    57a6:	c0 01       	movw	r24, r0
    57a8:	11 24       	eor	r1, r1
    57aa:	48 0f       	add	r20, r24
    57ac:	59 1f       	adc	r21, r25
    57ae:	5b 87       	std	Y+11, r21	; 0x0b
    57b0:	4a 87       	std	Y+10, r20	; 0x0a
    57b2:	fa 01       	movw	r30, r20
    57b4:	80 81       	ld	r24, Z
    57b6:	8f 5f       	subi	r24, 0xFF	; 255
    57b8:	80 83       	st	Z, r24
                     * earliest possible time. */
                    prvResetNextTaskUnblockTime();
                }
                #endif

                if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    57ba:	e0 91 b9 07 	lds	r30, 0x07B9
    57be:	f0 91 ba 07 	lds	r31, 0x07BA
    57c2:	9e 89       	ldd	r25, Y+22	; 0x16
    57c4:	86 89       	ldd	r24, Z+22	; 0x16
    57c6:	89 17       	cp	r24, r25
    57c8:	20 f4       	brcc	.+8      	; 0x57d2 <xTaskGenericNotify+0x1d0>
                {
                    /* The notified task has a priority above the currently
                     * executing task so a yield is required. */
                    taskYIELD_IF_USING_PREEMPTION();
    57ca:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
    57ce:	81 e0       	ldi	r24, 0x01	; 1
    57d0:	01 c0       	rjmp	.+2      	; 0x57d4 <xTaskGenericNotify+0x1d2>
    57d2:	81 e0       	ldi	r24, 0x01	; 1
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    57d4:	0f 90       	pop	r0
    57d6:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    57d8:	df 91       	pop	r29
    57da:	cf 91       	pop	r28
    57dc:	1f 91       	pop	r17
    57de:	0f 91       	pop	r16
    57e0:	ff 90       	pop	r15
    57e2:	ef 90       	pop	r14
    57e4:	08 95       	ret

000057e6 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    57e6:	ef 92       	push	r14
    57e8:	ff 92       	push	r15
    57ea:	0f 93       	push	r16
    57ec:	1f 93       	push	r17
    57ee:	cf 93       	push	r28
    57f0:	df 93       	push	r29
    /* It is possible that an ISR caused a task to be removed from an event
     * list while the scheduler was suspended.  If this was the case then the
     * removed task will have been added to the xPendingReadyList.  Once the
     * scheduler has been resumed it is safe to move all the pending ready
     * tasks from this list into their appropriate ready list. */
    taskENTER_CRITICAL();
    57f2:	0f b6       	in	r0, 0x3f	; 63
    57f4:	f8 94       	cli
    57f6:	0f 92       	push	r0
    {
        --uxSchedulerSuspended;
    57f8:	80 91 bb 07 	lds	r24, 0x07BB
    57fc:	81 50       	subi	r24, 0x01	; 1
    57fe:	80 93 bb 07 	sts	0x07BB, r24

        if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    5802:	80 91 bb 07 	lds	r24, 0x07BB
    5806:	88 23       	and	r24, r24
    5808:	09 f0       	breq	.+2      	; 0x580c <xTaskResumeAll+0x26>
    580a:	bd c0       	rjmp	.+378    	; 0x5986 <xTaskResumeAll+0x1a0>
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    580c:	80 91 c5 07 	lds	r24, 0x07C5
    5810:	88 23       	and	r24, r24
    5812:	09 f4       	brne	.+2      	; 0x5816 <xTaskResumeAll+0x30>
    5814:	b8 c0       	rjmp	.+368    	; 0x5986 <xTaskResumeAll+0x1a0>
    5816:	c0 e0       	ldi	r28, 0x00	; 0
    5818:	d0 e0       	ldi	r29, 0x00	; 0
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    581a:	05 e0       	ldi	r16, 0x05	; 5
    581c:	18 e0       	ldi	r17, 0x08	; 8
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
                    prvAddTaskToReadyList( pxTCB );
    581e:	6b ec       	ldi	r22, 0xCB	; 203
    5820:	77 e0       	ldi	r23, 0x07	; 7
    5822:	0f 2e       	mov	r0, r31
    5824:	f9 e0       	ldi	r31, 0x09	; 9
    5826:	ff 2e       	mov	r15, r31
    5828:	f0 2d       	mov	r31, r0

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
                    {
                        xYieldPending = pdTRUE;
    582a:	ee 24       	eor	r14, r14
    582c:	e3 94       	inc	r14
    582e:	87 c0       	rjmp	.+270    	; 0x593e <xTaskResumeAll+0x158>
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
                {
                    pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5830:	e0 91 0a 08 	lds	r30, 0x080A
    5834:	f0 91 0b 08 	lds	r31, 0x080B
    5838:	c6 81       	ldd	r28, Z+6	; 0x06
    583a:	d7 81       	ldd	r29, Z+7	; 0x07
                    listREMOVE_ITEM( &( pxTCB->xEventListItem ) );
    583c:	4c 89       	ldd	r20, Y+20	; 0x14
    583e:	5d 89       	ldd	r21, Y+21	; 0x15
    5840:	ae 85       	ldd	r26, Y+14	; 0x0e
    5842:	bf 85       	ldd	r27, Y+15	; 0x0f
    5844:	88 89       	ldd	r24, Y+16	; 0x10
    5846:	99 89       	ldd	r25, Y+17	; 0x11
    5848:	15 96       	adiw	r26, 0x05	; 5
    584a:	9c 93       	st	X, r25
    584c:	8e 93       	st	-X, r24
    584e:	14 97       	sbiw	r26, 0x04	; 4
    5850:	e8 89       	ldd	r30, Y+16	; 0x10
    5852:	f9 89       	ldd	r31, Y+17	; 0x11
    5854:	b3 83       	std	Z+3, r27	; 0x03
    5856:	a2 83       	std	Z+2, r26	; 0x02
    5858:	9e 01       	movw	r18, r28
    585a:	24 5f       	subi	r18, 0xF4	; 244
    585c:	3f 4f       	sbci	r19, 0xFF	; 255
    585e:	fa 01       	movw	r30, r20
    5860:	81 81       	ldd	r24, Z+1	; 0x01
    5862:	92 81       	ldd	r25, Z+2	; 0x02
    5864:	82 17       	cp	r24, r18
    5866:	93 07       	cpc	r25, r19
    5868:	21 f4       	brne	.+8      	; 0x5872 <xTaskResumeAll+0x8c>
    586a:	88 89       	ldd	r24, Y+16	; 0x10
    586c:	99 89       	ldd	r25, Y+17	; 0x11
    586e:	92 83       	std	Z+2, r25	; 0x02
    5870:	81 83       	std	Z+1, r24	; 0x01
    5872:	1d 8a       	std	Y+21, r1	; 0x15
    5874:	1c 8a       	std	Y+20, r1	; 0x14
    5876:	fa 01       	movw	r30, r20
    5878:	80 81       	ld	r24, Z
    587a:	81 50       	subi	r24, 0x01	; 1
    587c:	80 83       	st	Z, r24
                    portMEMORY_BARRIER();
                    listREMOVE_ITEM( &( pxTCB->xStateListItem ) );
    587e:	2a 85       	ldd	r18, Y+10	; 0x0a
    5880:	3b 85       	ldd	r19, Y+11	; 0x0b
    5882:	ac 81       	ldd	r26, Y+4	; 0x04
    5884:	bd 81       	ldd	r27, Y+5	; 0x05
    5886:	8e 81       	ldd	r24, Y+6	; 0x06
    5888:	9f 81       	ldd	r25, Y+7	; 0x07
    588a:	15 96       	adiw	r26, 0x05	; 5
    588c:	9c 93       	st	X, r25
    588e:	8e 93       	st	-X, r24
    5890:	14 97       	sbiw	r26, 0x04	; 4
    5892:	ee 81       	ldd	r30, Y+6	; 0x06
    5894:	ff 81       	ldd	r31, Y+7	; 0x07
    5896:	b3 83       	std	Z+3, r27	; 0x03
    5898:	a2 83       	std	Z+2, r26	; 0x02
    589a:	ae 01       	movw	r20, r28
    589c:	4e 5f       	subi	r20, 0xFE	; 254
    589e:	5f 4f       	sbci	r21, 0xFF	; 255
    58a0:	f9 01       	movw	r30, r18
    58a2:	81 81       	ldd	r24, Z+1	; 0x01
    58a4:	92 81       	ldd	r25, Z+2	; 0x02
    58a6:	84 17       	cp	r24, r20
    58a8:	95 07       	cpc	r25, r21
    58aa:	21 f4       	brne	.+8      	; 0x58b4 <xTaskResumeAll+0xce>
    58ac:	8e 81       	ldd	r24, Y+6	; 0x06
    58ae:	9f 81       	ldd	r25, Y+7	; 0x07
    58b0:	92 83       	std	Z+2, r25	; 0x02
    58b2:	81 83       	std	Z+1, r24	; 0x01
    58b4:	1b 86       	std	Y+11, r1	; 0x0b
    58b6:	1a 86       	std	Y+10, r1	; 0x0a
    58b8:	f9 01       	movw	r30, r18
    58ba:	80 81       	ld	r24, Z
    58bc:	81 50       	subi	r24, 0x01	; 1
    58be:	80 83       	st	Z, r24
                    prvAddTaskToReadyList( pxTCB );
    58c0:	9e 89       	ldd	r25, Y+22	; 0x16
    58c2:	80 91 bc 07 	lds	r24, 0x07BC
    58c6:	89 17       	cp	r24, r25
    58c8:	10 f4       	brcc	.+4      	; 0x58ce <xTaskResumeAll+0xe8>
    58ca:	90 93 bc 07 	sts	0x07BC, r25
    58ce:	2e 89       	ldd	r18, Y+22	; 0x16
    58d0:	30 e0       	ldi	r19, 0x00	; 0
    58d2:	c9 01       	movw	r24, r18
    58d4:	88 0f       	add	r24, r24
    58d6:	99 1f       	adc	r25, r25
    58d8:	88 0f       	add	r24, r24
    58da:	99 1f       	adc	r25, r25
    58dc:	88 0f       	add	r24, r24
    58de:	99 1f       	adc	r25, r25
    58e0:	82 0f       	add	r24, r18
    58e2:	93 1f       	adc	r25, r19
    58e4:	fb 01       	movw	r30, r22
    58e6:	e8 0f       	add	r30, r24
    58e8:	f9 1f       	adc	r31, r25
    58ea:	a1 81       	ldd	r26, Z+1	; 0x01
    58ec:	b2 81       	ldd	r27, Z+2	; 0x02
    58ee:	bd 83       	std	Y+5, r27	; 0x05
    58f0:	ac 83       	std	Y+4, r26	; 0x04
    58f2:	14 96       	adiw	r26, 0x04	; 4
    58f4:	8d 91       	ld	r24, X+
    58f6:	9c 91       	ld	r25, X
    58f8:	15 97       	sbiw	r26, 0x05	; 5
    58fa:	9f 83       	std	Y+7, r25	; 0x07
    58fc:	8e 83       	std	Y+6, r24	; 0x06
    58fe:	14 96       	adiw	r26, 0x04	; 4
    5900:	ed 91       	ld	r30, X+
    5902:	fc 91       	ld	r31, X
    5904:	15 97       	sbiw	r26, 0x05	; 5
    5906:	53 83       	std	Z+3, r21	; 0x03
    5908:	42 83       	std	Z+2, r20	; 0x02
    590a:	15 96       	adiw	r26, 0x05	; 5
    590c:	5c 93       	st	X, r21
    590e:	4e 93       	st	-X, r20
    5910:	14 97       	sbiw	r26, 0x04	; 4
    5912:	8e 89       	ldd	r24, Y+22	; 0x16
    5914:	8f 9d       	mul	r24, r15
    5916:	c0 01       	movw	r24, r0
    5918:	11 24       	eor	r1, r1
    591a:	fb 01       	movw	r30, r22
    591c:	e8 0f       	add	r30, r24
    591e:	f9 1f       	adc	r31, r25
    5920:	fb 87       	std	Y+11, r31	; 0x0b
    5922:	ea 87       	std	Y+10, r30	; 0x0a
    5924:	80 81       	ld	r24, Z
    5926:	8f 5f       	subi	r24, 0xFF	; 255
    5928:	80 83       	st	Z, r24

                    /* If the moved task has a priority higher than or equal to
                     * the current task then a yield must be performed. */
                    if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    592a:	e0 91 b9 07 	lds	r30, 0x07B9
    592e:	f0 91 ba 07 	lds	r31, 0x07BA
    5932:	9e 89       	ldd	r25, Y+22	; 0x16
    5934:	86 89       	ldd	r24, Z+22	; 0x16
    5936:	98 17       	cp	r25, r24
    5938:	10 f0       	brcs	.+4      	; 0x593e <xTaskResumeAll+0x158>
                    {
                        xYieldPending = pdTRUE;
    593a:	e0 92 bd 07 	sts	0x07BD, r14
        {
            if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
            {
                /* Move any readied tasks from the pending list into the
                 * appropriate ready list. */
                while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    593e:	f8 01       	movw	r30, r16
    5940:	80 81       	ld	r24, Z
    5942:	88 23       	and	r24, r24
    5944:	09 f0       	breq	.+2      	; 0x5948 <xTaskResumeAll+0x162>
    5946:	74 cf       	rjmp	.-280    	; 0x5830 <xTaskResumeAll+0x4a>
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( pxTCB != NULL )
    5948:	cd 2b       	or	r28, r29
    594a:	11 f0       	breq	.+4      	; 0x5950 <xTaskResumeAll+0x16a>
                     * which may have prevented the next unblock time from being
                     * re-calculated, in which case re-calculate it now.  Mainly
                     * important for low power tickless implementations, where
                     * this can prevent an unnecessary exit from low power
                     * state. */
                    prvResetNextTaskUnblockTime();
    594c:	0e 94 5d 27 	call	0x4eba	; 0x4eba <prvResetNextTaskUnblockTime>
                /* If any ticks occurred while the scheduler was suspended then
                 * they should be processed now.  This ensures the tick count does
                 * not  slip, and that any delayed tasks are resumed at the correct
                 * time. */
                {
                    TickType_t xPendedCounts = xPendedTicks; /* Non-volatile copy. */
    5950:	c0 91 c3 07 	lds	r28, 0x07C3
    5954:	d0 91 c4 07 	lds	r29, 0x07C4

                    if( xPendedCounts > ( TickType_t ) 0U )
    5958:	20 97       	sbiw	r28, 0x00	; 0
    595a:	69 f0       	breq	.+26     	; 0x5976 <xTaskResumeAll+0x190>
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
                            {
                                xYieldPending = pdTRUE;
    595c:	11 e0       	ldi	r17, 0x01	; 1

                    if( xPendedCounts > ( TickType_t ) 0U )
                    {
                        do
                        {
                            if( xTaskIncrementTick() != pdFALSE )
    595e:	0e 94 79 27 	call	0x4ef2	; 0x4ef2 <xTaskIncrementTick>
    5962:	88 23       	and	r24, r24
    5964:	11 f0       	breq	.+4      	; 0x596a <xTaskResumeAll+0x184>
                            {
                                xYieldPending = pdTRUE;
    5966:	10 93 bd 07 	sts	0x07BD, r17
                            else
                            {
                                mtCOVERAGE_TEST_MARKER();
                            }

                            --xPendedCounts;
    596a:	21 97       	sbiw	r28, 0x01	; 1
                        } while( xPendedCounts > ( TickType_t ) 0U );
    596c:	c1 f7       	brne	.-16     	; 0x595e <xTaskResumeAll+0x178>

                        xPendedTicks = 0;
    596e:	10 92 c4 07 	sts	0x07C4, r1
    5972:	10 92 c3 07 	sts	0x07C3, r1
                    {
                        mtCOVERAGE_TEST_MARKER();
                    }
                }

                if( xYieldPending != pdFALSE )
    5976:	80 91 bd 07 	lds	r24, 0x07BD
    597a:	88 23       	and	r24, r24
    597c:	21 f0       	breq	.+8      	; 0x5986 <xTaskResumeAll+0x1a0>
                    #if ( configUSE_PREEMPTION != 0 )
                    {
                        xAlreadyYielded = pdTRUE;
                    }
                    #endif
                    taskYIELD_IF_USING_PREEMPTION();
    597e:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
    5982:	81 e0       	ldi	r24, 0x01	; 1
    5984:	01 c0       	rjmp	.+2      	; 0x5988 <xTaskResumeAll+0x1a2>
    5986:	80 e0       	ldi	r24, 0x00	; 0
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    taskEXIT_CRITICAL();
    5988:	0f 90       	pop	r0
    598a:	0f be       	out	0x3f, r0	; 63

    return xAlreadyYielded;
}
    598c:	df 91       	pop	r29
    598e:	cf 91       	pop	r28
    5990:	1f 91       	pop	r17
    5992:	0f 91       	pop	r16
    5994:	ff 90       	pop	r15
    5996:	ef 90       	pop	r14
    5998:	08 95       	ret

0000599a <xTaskCatchUpTicks>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskCatchUpTicks( TickType_t xTicksToCatchUp )
{
    599a:	0f 93       	push	r16
    599c:	1f 93       	push	r17
    599e:	8c 01       	movw	r16, r24
     * relies on xPendedTicks being wound down to 0 in xTaskResumeAll(). */
    configASSERT( uxSchedulerSuspended == 0 );

    /* Use xPendedTicks to mimic xTicksToCatchUp number of ticks occurring when
     * the scheduler is suspended so the ticks are executed in xTaskResumeAll(). */
    vTaskSuspendAll();
    59a0:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <vTaskSuspendAll>

    /* Prevent the tick interrupt modifying xPendedTicks simultaneously. */
    taskENTER_CRITICAL();
    59a4:	0f b6       	in	r0, 0x3f	; 63
    59a6:	f8 94       	cli
    59a8:	0f 92       	push	r0
    {
        xPendedTicks += xTicksToCatchUp;
    59aa:	80 91 c3 07 	lds	r24, 0x07C3
    59ae:	90 91 c4 07 	lds	r25, 0x07C4
    59b2:	08 0f       	add	r16, r24
    59b4:	19 1f       	adc	r17, r25
    59b6:	10 93 c4 07 	sts	0x07C4, r17
    59ba:	00 93 c3 07 	sts	0x07C3, r16
    }
    taskEXIT_CRITICAL();
    59be:	0f 90       	pop	r0
    59c0:	0f be       	out	0x3f, r0	; 63
    xYieldOccurred = xTaskResumeAll();
    59c2:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>

    return xYieldOccurred;
}
    59c6:	1f 91       	pop	r17
    59c8:	0f 91       	pop	r16
    59ca:	08 95       	ret

000059cc <prvAddCurrentTaskToDelayedList>:
#endif /* if ( ( configGENERATE_RUN_TIME_STATS == 1 ) && ( INCLUDE_xTaskGetIdleTaskHandle == 1 ) ) */
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait,
                                            const BaseType_t xCanBlockIndefinitely )
{
    59cc:	ef 92       	push	r14
    59ce:	ff 92       	push	r15
    59d0:	0f 93       	push	r16
    59d2:	1f 93       	push	r17
    59d4:	7c 01       	movw	r14, r24
    TickType_t xTimeToWake;
    const TickType_t xConstTickCount = xTickCount;
    59d6:	00 91 be 07 	lds	r16, 0x07BE
    59da:	10 91 bf 07 	lds	r17, 0x07BF
    }
    #endif

    /* Remove the task from the ready list before adding it to the blocked list
     * as the same list item is used for both lists. */
    if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    59de:	80 91 b9 07 	lds	r24, 0x07B9
    59e2:	90 91 ba 07 	lds	r25, 0x07BA
    59e6:	02 96       	adiw	r24, 0x02	; 2
    59e8:	0e 94 ad 1b 	call	0x375a	; 0x375a <uxListRemove>
    #else /* INCLUDE_vTaskSuspend */
    {
        /* Calculate the time at which the task should be woken if the event
         * does not occur.  This may overflow but this doesn't matter, the kernel
         * will manage it correctly. */
        xTimeToWake = xConstTickCount + xTicksToWait;
    59ec:	e0 0e       	add	r14, r16
    59ee:	f1 1e       	adc	r15, r17

        /* The list item will be inserted in wake time order. */
        listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
    59f0:	e0 91 b9 07 	lds	r30, 0x07B9
    59f4:	f0 91 ba 07 	lds	r31, 0x07BA
    59f8:	f3 82       	std	Z+3, r15	; 0x03
    59fa:	e2 82       	std	Z+2, r14	; 0x02

        if( xTimeToWake < xConstTickCount )
    59fc:	e0 16       	cp	r14, r16
    59fe:	f1 06       	cpc	r15, r17
    5a00:	68 f4       	brcc	.+26     	; 0x5a1c <prvAddCurrentTaskToDelayedList+0x50>
        {
            /* Wake time has overflowed.  Place this item in the overflow list. */
            vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5a02:	80 91 03 08 	lds	r24, 0x0803
    5a06:	90 91 04 08 	lds	r25, 0x0804
    5a0a:	60 91 b9 07 	lds	r22, 0x07B9
    5a0e:	70 91 ba 07 	lds	r23, 0x07BA
    5a12:	6e 5f       	subi	r22, 0xFE	; 254
    5a14:	7f 4f       	sbci	r23, 0xFF	; 255
    5a16:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <vListInsert>
    5a1a:	17 c0       	rjmp	.+46     	; 0x5a4a <prvAddCurrentTaskToDelayedList+0x7e>
        }
        else
        {
            /* The wake time has not overflowed, so the current block list is used. */
            vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
    5a1c:	80 91 01 08 	lds	r24, 0x0801
    5a20:	90 91 02 08 	lds	r25, 0x0802
    5a24:	60 91 b9 07 	lds	r22, 0x07B9
    5a28:	70 91 ba 07 	lds	r23, 0x07BA
    5a2c:	6e 5f       	subi	r22, 0xFE	; 254
    5a2e:	7f 4f       	sbci	r23, 0xFF	; 255
    5a30:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <vListInsert>

            /* If the task entering the blocked state was placed at the head of the
             * list of blocked tasks then xNextTaskUnblockTime needs to be updated
             * too. */
            if( xTimeToWake < xNextTaskUnblockTime )
    5a34:	80 91 c0 07 	lds	r24, 0x07C0
    5a38:	90 91 c1 07 	lds	r25, 0x07C1
    5a3c:	e8 16       	cp	r14, r24
    5a3e:	f9 06       	cpc	r15, r25
    5a40:	20 f4       	brcc	.+8      	; 0x5a4a <prvAddCurrentTaskToDelayedList+0x7e>
            {
                xNextTaskUnblockTime = xTimeToWake;
    5a42:	f0 92 c1 07 	sts	0x07C1, r15
    5a46:	e0 92 c0 07 	sts	0x07C0, r14

        /* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
        ( void ) xCanBlockIndefinitely;
    }
    #endif /* INCLUDE_vTaskSuspend */
}
    5a4a:	1f 91       	pop	r17
    5a4c:	0f 91       	pop	r16
    5a4e:	ff 90       	pop	r15
    5a50:	ef 90       	pop	r14
    5a52:	08 95       	ret

00005a54 <xTaskGenericNotifyWait>:
    BaseType_t xTaskGenericNotifyWait( UBaseType_t uxIndexToWait,
                                       uint32_t ulBitsToClearOnEntry,
                                       uint32_t ulBitsToClearOnExit,
                                       uint32_t * pulNotificationValue,
                                       TickType_t xTicksToWait )
    {
    5a54:	4f 92       	push	r4
    5a56:	5f 92       	push	r5
    5a58:	6f 92       	push	r6
    5a5a:	7f 92       	push	r7
    5a5c:	8f 92       	push	r8
    5a5e:	9f 92       	push	r9
    5a60:	af 92       	push	r10
    5a62:	bf 92       	push	r11
    5a64:	cf 92       	push	r12
    5a66:	df 92       	push	r13
    5a68:	ef 92       	push	r14
    5a6a:	ff 92       	push	r15
    5a6c:	0f 93       	push	r16
    5a6e:	1f 93       	push	r17
    5a70:	cf 93       	push	r28
    5a72:	df 93       	push	r29
    5a74:	4a 01       	movw	r8, r20
    5a76:	5b 01       	movw	r10, r22
    5a78:	28 01       	movw	r4, r16
    5a7a:	39 01       	movw	r6, r18
    5a7c:	e7 01       	movw	r28, r14
        BaseType_t xReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    5a7e:	0f b6       	in	r0, 0x3f	; 63
    5a80:	f8 94       	cli
    5a82:	0f 92       	push	r0
        {
            /* Only block if a notification is not already pending. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5a84:	e0 91 b9 07 	lds	r30, 0x07B9
    5a88:	f0 91 ba 07 	lds	r31, 0x07BA
    5a8c:	e8 2e       	mov	r14, r24
    5a8e:	ff 24       	eor	r15, r15
    5a90:	ee 0d       	add	r30, r14
    5a92:	ff 1d       	adc	r31, r15
    5a94:	b5 96       	adiw	r30, 0x25	; 37
    5a96:	80 81       	ld	r24, Z
    5a98:	82 30       	cpi	r24, 0x02	; 2
    5a9a:	81 f1       	breq	.+96     	; 0x5afc <xTaskGenericNotifyWait+0xa8>
            {
                /* Clear bits in the task's notification value as bits may get
                 * set  by the notifying task or interrupt.  This can be used to
                 * clear the value to zero. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnEntry;
    5a9c:	e0 91 b9 07 	lds	r30, 0x07B9
    5aa0:	f0 91 ba 07 	lds	r31, 0x07BA
    5aa4:	c7 01       	movw	r24, r14
    5aa6:	88 0f       	add	r24, r24
    5aa8:	99 1f       	adc	r25, r25
    5aaa:	88 0f       	add	r24, r24
    5aac:	99 1f       	adc	r25, r25
    5aae:	e8 0f       	add	r30, r24
    5ab0:	f9 1f       	adc	r31, r25
    5ab2:	b1 96       	adiw	r30, 0x21	; 33
    5ab4:	20 81       	ld	r18, Z
    5ab6:	31 81       	ldd	r19, Z+1	; 0x01
    5ab8:	42 81       	ldd	r20, Z+2	; 0x02
    5aba:	53 81       	ldd	r21, Z+3	; 0x03
    5abc:	d5 01       	movw	r26, r10
    5abe:	c4 01       	movw	r24, r8
    5ac0:	80 95       	com	r24
    5ac2:	90 95       	com	r25
    5ac4:	a0 95       	com	r26
    5ac6:	b0 95       	com	r27
    5ac8:	82 23       	and	r24, r18
    5aca:	93 23       	and	r25, r19
    5acc:	a4 23       	and	r26, r20
    5ace:	b5 23       	and	r27, r21
    5ad0:	80 83       	st	Z, r24
    5ad2:	91 83       	std	Z+1, r25	; 0x01
    5ad4:	a2 83       	std	Z+2, r26	; 0x02
    5ad6:	b3 83       	std	Z+3, r27	; 0x03

                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    5ad8:	e0 91 b9 07 	lds	r30, 0x07B9
    5adc:	f0 91 ba 07 	lds	r31, 0x07BA
    5ae0:	ee 0d       	add	r30, r14
    5ae2:	ff 1d       	adc	r31, r15
    5ae4:	b5 96       	adiw	r30, 0x25	; 37
    5ae6:	81 e0       	ldi	r24, 0x01	; 1
    5ae8:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    5aea:	c1 14       	cp	r12, r1
    5aec:	d1 04       	cpc	r13, r1
    5aee:	31 f0       	breq	.+12     	; 0x5afc <xTaskGenericNotifyWait+0xa8>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5af0:	c6 01       	movw	r24, r12
    5af2:	61 e0       	ldi	r22, 0x01	; 1
    5af4:	0e 94 e6 2c 	call	0x59cc	; 0x59cc <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    5af8:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5afc:	0f 90       	pop	r0
    5afe:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    5b00:	0f b6       	in	r0, 0x3f	; 63
    5b02:	f8 94       	cli
    5b04:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_WAIT( uxIndexToWait );

            if( pulNotificationValue != NULL )
    5b06:	20 97       	sbiw	r28, 0x00	; 0
    5b08:	a1 f0       	breq	.+40     	; 0x5b32 <xTaskGenericNotifyWait+0xde>
            {
                /* Output the current notification value, which may or may not
                 * have changed. */
                *pulNotificationValue = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    5b0a:	e0 91 b9 07 	lds	r30, 0x07B9
    5b0e:	f0 91 ba 07 	lds	r31, 0x07BA
    5b12:	c7 01       	movw	r24, r14
    5b14:	88 0f       	add	r24, r24
    5b16:	99 1f       	adc	r25, r25
    5b18:	88 0f       	add	r24, r24
    5b1a:	99 1f       	adc	r25, r25
    5b1c:	e8 0f       	add	r30, r24
    5b1e:	f9 1f       	adc	r31, r25
    5b20:	b1 96       	adiw	r30, 0x21	; 33
    5b22:	80 81       	ld	r24, Z
    5b24:	91 81       	ldd	r25, Z+1	; 0x01
    5b26:	a2 81       	ldd	r26, Z+2	; 0x02
    5b28:	b3 81       	ldd	r27, Z+3	; 0x03
    5b2a:	88 83       	st	Y, r24
    5b2c:	99 83       	std	Y+1, r25	; 0x01
    5b2e:	aa 83       	std	Y+2, r26	; 0x02
    5b30:	bb 83       	std	Y+3, r27	; 0x03

            /* If ucNotifyValue is set then either the task never entered the
             * blocked state (because a notification was already pending) or the
             * task unblocked because of a notification.  Otherwise the task
             * unblocked because of a timeout. */
            if( pxCurrentTCB->ucNotifyState[ uxIndexToWait ] != taskNOTIFICATION_RECEIVED )
    5b32:	e0 91 b9 07 	lds	r30, 0x07B9
    5b36:	f0 91 ba 07 	lds	r31, 0x07BA
    5b3a:	ee 0d       	add	r30, r14
    5b3c:	ff 1d       	adc	r31, r15
    5b3e:	b5 96       	adiw	r30, 0x25	; 37
    5b40:	80 81       	ld	r24, Z
    5b42:	82 30       	cpi	r24, 0x02	; 2
    5b44:	11 f0       	breq	.+4      	; 0x5b4a <xTaskGenericNotifyWait+0xf6>
    5b46:	80 e0       	ldi	r24, 0x00	; 0
    5b48:	1f c0       	rjmp	.+62     	; 0x5b88 <xTaskGenericNotifyWait+0x134>
            }
            else
            {
                /* A notification was already pending or a notification was
                 * received while the task was waiting. */
                pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] &= ~ulBitsToClearOnExit;
    5b4a:	e0 91 b9 07 	lds	r30, 0x07B9
    5b4e:	f0 91 ba 07 	lds	r31, 0x07BA
    5b52:	c7 01       	movw	r24, r14
    5b54:	88 0f       	add	r24, r24
    5b56:	99 1f       	adc	r25, r25
    5b58:	88 0f       	add	r24, r24
    5b5a:	99 1f       	adc	r25, r25
    5b5c:	e8 0f       	add	r30, r24
    5b5e:	f9 1f       	adc	r31, r25
    5b60:	b1 96       	adiw	r30, 0x21	; 33
    5b62:	20 81       	ld	r18, Z
    5b64:	31 81       	ldd	r19, Z+1	; 0x01
    5b66:	42 81       	ldd	r20, Z+2	; 0x02
    5b68:	53 81       	ldd	r21, Z+3	; 0x03
    5b6a:	d3 01       	movw	r26, r6
    5b6c:	c2 01       	movw	r24, r4
    5b6e:	80 95       	com	r24
    5b70:	90 95       	com	r25
    5b72:	a0 95       	com	r26
    5b74:	b0 95       	com	r27
    5b76:	82 23       	and	r24, r18
    5b78:	93 23       	and	r25, r19
    5b7a:	a4 23       	and	r26, r20
    5b7c:	b5 23       	and	r27, r21
    5b7e:	80 83       	st	Z, r24
    5b80:	91 83       	std	Z+1, r25	; 0x01
    5b82:	a2 83       	std	Z+2, r26	; 0x02
    5b84:	b3 83       	std	Z+3, r27	; 0x03
    5b86:	81 e0       	ldi	r24, 0x01	; 1
                xReturn = pdTRUE;
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    5b88:	e0 91 b9 07 	lds	r30, 0x07B9
    5b8c:	f0 91 ba 07 	lds	r31, 0x07BA
    5b90:	ee 0d       	add	r30, r14
    5b92:	ff 1d       	adc	r31, r15
    5b94:	b5 96       	adiw	r30, 0x25	; 37
    5b96:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    5b98:	0f 90       	pop	r0
    5b9a:	0f be       	out	0x3f, r0	; 63

        return xReturn;
    }
    5b9c:	df 91       	pop	r29
    5b9e:	cf 91       	pop	r28
    5ba0:	1f 91       	pop	r17
    5ba2:	0f 91       	pop	r16
    5ba4:	ff 90       	pop	r15
    5ba6:	ef 90       	pop	r14
    5ba8:	df 90       	pop	r13
    5baa:	cf 90       	pop	r12
    5bac:	bf 90       	pop	r11
    5bae:	af 90       	pop	r10
    5bb0:	9f 90       	pop	r9
    5bb2:	8f 90       	pop	r8
    5bb4:	7f 90       	pop	r7
    5bb6:	6f 90       	pop	r6
    5bb8:	5f 90       	pop	r5
    5bba:	4f 90       	pop	r4
    5bbc:	08 95       	ret

00005bbe <ulTaskGenericNotifyTake>:
#if ( configUSE_TASK_NOTIFICATIONS == 1 )

    uint32_t ulTaskGenericNotifyTake( UBaseType_t uxIndexToWait,
                                      BaseType_t xClearCountOnExit,
                                      TickType_t xTicksToWait )
    {
    5bbe:	df 92       	push	r13
    5bc0:	ef 92       	push	r14
    5bc2:	ff 92       	push	r15
    5bc4:	0f 93       	push	r16
    5bc6:	1f 93       	push	r17
    5bc8:	cf 93       	push	r28
    5bca:	df 93       	push	r29
    5bcc:	d6 2e       	mov	r13, r22
        uint32_t ulReturn;

        configASSERT( uxIndexToWait < configTASK_NOTIFICATION_ARRAY_ENTRIES );

        taskENTER_CRITICAL();
    5bce:	0f b6       	in	r0, 0x3f	; 63
    5bd0:	f8 94       	cli
    5bd2:	0f 92       	push	r0
        {
            /* Only block if the notification count is not already non-zero. */
            if( pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] == 0UL )
    5bd4:	e0 91 b9 07 	lds	r30, 0x07B9
    5bd8:	f0 91 ba 07 	lds	r31, 0x07BA
    5bdc:	c8 2f       	mov	r28, r24
    5bde:	d0 e0       	ldi	r29, 0x00	; 0
    5be0:	ce 01       	movw	r24, r28
    5be2:	88 0f       	add	r24, r24
    5be4:	99 1f       	adc	r25, r25
    5be6:	88 0f       	add	r24, r24
    5be8:	99 1f       	adc	r25, r25
    5bea:	e8 0f       	add	r30, r24
    5bec:	f9 1f       	adc	r31, r25
    5bee:	b1 96       	adiw	r30, 0x21	; 33
    5bf0:	80 81       	ld	r24, Z
    5bf2:	91 81       	ldd	r25, Z+1	; 0x01
    5bf4:	a2 81       	ldd	r26, Z+2	; 0x02
    5bf6:	b3 81       	ldd	r27, Z+3	; 0x03
    5bf8:	00 97       	sbiw	r24, 0x00	; 0
    5bfa:	a1 05       	cpc	r26, r1
    5bfc:	b1 05       	cpc	r27, r1
    5bfe:	91 f4       	brne	.+36     	; 0x5c24 <ulTaskGenericNotifyTake+0x66>
            {
                /* Mark this task as waiting for a notification. */
                pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskWAITING_NOTIFICATION;
    5c00:	e0 91 b9 07 	lds	r30, 0x07B9
    5c04:	f0 91 ba 07 	lds	r31, 0x07BA
    5c08:	ec 0f       	add	r30, r28
    5c0a:	fd 1f       	adc	r31, r29
    5c0c:	b5 96       	adiw	r30, 0x25	; 37
    5c0e:	81 e0       	ldi	r24, 0x01	; 1
    5c10:	80 83       	st	Z, r24

                if( xTicksToWait > ( TickType_t ) 0 )
    5c12:	41 15       	cp	r20, r1
    5c14:	51 05       	cpc	r21, r1
    5c16:	31 f0       	breq	.+12     	; 0x5c24 <ulTaskGenericNotifyTake+0x66>
                {
                    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5c18:	ca 01       	movw	r24, r20
    5c1a:	61 e0       	ldi	r22, 0x01	; 1
    5c1c:	0e 94 e6 2c 	call	0x59cc	; 0x59cc <prvAddCurrentTaskToDelayedList>

                    /* All ports are written to allow a yield in a critical
                     * section (some will yield immediately, others wait until the
                     * critical section exits) - but it is not something that
                     * application code should ever do. */
                    portYIELD_WITHIN_API();
    5c20:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        taskEXIT_CRITICAL();
    5c24:	0f 90       	pop	r0
    5c26:	0f be       	out	0x3f, r0	; 63

        taskENTER_CRITICAL();
    5c28:	0f b6       	in	r0, 0x3f	; 63
    5c2a:	f8 94       	cli
    5c2c:	0f 92       	push	r0
        {
            traceTASK_NOTIFY_TAKE( uxIndexToWait );
            ulReturn = pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ];
    5c2e:	e0 91 b9 07 	lds	r30, 0x07B9
    5c32:	f0 91 ba 07 	lds	r31, 0x07BA
    5c36:	ce 01       	movw	r24, r28
    5c38:	88 0f       	add	r24, r24
    5c3a:	99 1f       	adc	r25, r25
    5c3c:	88 0f       	add	r24, r24
    5c3e:	99 1f       	adc	r25, r25
    5c40:	e8 0f       	add	r30, r24
    5c42:	f9 1f       	adc	r31, r25
    5c44:	b1 96       	adiw	r30, 0x21	; 33
    5c46:	e0 80       	ld	r14, Z
    5c48:	f1 80       	ldd	r15, Z+1	; 0x01
    5c4a:	02 81       	ldd	r16, Z+2	; 0x02
    5c4c:	13 81       	ldd	r17, Z+3	; 0x03

            if( ulReturn != 0UL )
    5c4e:	e1 14       	cp	r14, r1
    5c50:	f1 04       	cpc	r15, r1
    5c52:	01 05       	cpc	r16, r1
    5c54:	11 05       	cpc	r17, r1
    5c56:	49 f1       	breq	.+82     	; 0x5caa <ulTaskGenericNotifyTake+0xec>
            {
                if( xClearCountOnExit != pdFALSE )
    5c58:	dd 20       	and	r13, r13
    5c5a:	89 f0       	breq	.+34     	; 0x5c7e <ulTaskGenericNotifyTake+0xc0>
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = 0UL;
    5c5c:	e0 91 b9 07 	lds	r30, 0x07B9
    5c60:	f0 91 ba 07 	lds	r31, 0x07BA
    5c64:	ce 01       	movw	r24, r28
    5c66:	88 0f       	add	r24, r24
    5c68:	99 1f       	adc	r25, r25
    5c6a:	88 0f       	add	r24, r24
    5c6c:	99 1f       	adc	r25, r25
    5c6e:	e8 0f       	add	r30, r24
    5c70:	f9 1f       	adc	r31, r25
    5c72:	b1 96       	adiw	r30, 0x21	; 33
    5c74:	10 82       	st	Z, r1
    5c76:	11 82       	std	Z+1, r1	; 0x01
    5c78:	12 82       	std	Z+2, r1	; 0x02
    5c7a:	13 82       	std	Z+3, r1	; 0x03
    5c7c:	16 c0       	rjmp	.+44     	; 0x5caa <ulTaskGenericNotifyTake+0xec>
                }
                else
                {
                    pxCurrentTCB->ulNotifiedValue[ uxIndexToWait ] = ulReturn - ( uint32_t ) 1;
    5c7e:	e0 91 b9 07 	lds	r30, 0x07B9
    5c82:	f0 91 ba 07 	lds	r31, 0x07BA
    5c86:	a8 01       	movw	r20, r16
    5c88:	97 01       	movw	r18, r14
    5c8a:	21 50       	subi	r18, 0x01	; 1
    5c8c:	30 40       	sbci	r19, 0x00	; 0
    5c8e:	40 40       	sbci	r20, 0x00	; 0
    5c90:	50 40       	sbci	r21, 0x00	; 0
    5c92:	ce 01       	movw	r24, r28
    5c94:	88 0f       	add	r24, r24
    5c96:	99 1f       	adc	r25, r25
    5c98:	88 0f       	add	r24, r24
    5c9a:	99 1f       	adc	r25, r25
    5c9c:	e8 0f       	add	r30, r24
    5c9e:	f9 1f       	adc	r31, r25
    5ca0:	b1 96       	adiw	r30, 0x21	; 33
    5ca2:	20 83       	st	Z, r18
    5ca4:	31 83       	std	Z+1, r19	; 0x01
    5ca6:	42 83       	std	Z+2, r20	; 0x02
    5ca8:	53 83       	std	Z+3, r21	; 0x03
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }

            pxCurrentTCB->ucNotifyState[ uxIndexToWait ] = taskNOT_WAITING_NOTIFICATION;
    5caa:	e0 91 b9 07 	lds	r30, 0x07B9
    5cae:	f0 91 ba 07 	lds	r31, 0x07BA
    5cb2:	ec 0f       	add	r30, r28
    5cb4:	fd 1f       	adc	r31, r29
    5cb6:	b5 96       	adiw	r30, 0x25	; 37
    5cb8:	10 82       	st	Z, r1
        }
        taskEXIT_CRITICAL();
    5cba:	0f 90       	pop	r0
    5cbc:	0f be       	out	0x3f, r0	; 63

        return ulReturn;
    }
    5cbe:	6e 2d       	mov	r22, r14
    5cc0:	7f 2d       	mov	r23, r15
    5cc2:	80 2f       	mov	r24, r16
    5cc4:	91 2f       	mov	r25, r17
    5cc6:	df 91       	pop	r29
    5cc8:	cf 91       	pop	r28
    5cca:	1f 91       	pop	r17
    5ccc:	0f 91       	pop	r16
    5cce:	ff 90       	pop	r15
    5cd0:	ef 90       	pop	r14
    5cd2:	df 90       	pop	r13
    5cd4:	08 95       	ret

00005cd6 <vTaskPlaceOnUnorderedEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnUnorderedEventList( List_t * pxEventList,
                                     const TickType_t xItemValue,
                                     const TickType_t xTicksToWait )
{
    5cd6:	0f 93       	push	r16
    5cd8:	1f 93       	push	r17
    5cda:	8c 01       	movw	r16, r24
    5cdc:	ca 01       	movw	r24, r20
    configASSERT( uxSchedulerSuspended != 0 );

    /* Store the item value in the event list item.  It is safe to access the
     * event list item here as interrupts won't access the event list item of a
     * task that is not in the Blocked state. */
    listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
    5cde:	e0 91 b9 07 	lds	r30, 0x07B9
    5ce2:	f0 91 ba 07 	lds	r31, 0x07BA
    5ce6:	70 68       	ori	r23, 0x80	; 128
    5ce8:	75 87       	std	Z+13, r23	; 0x0d
    5cea:	64 87       	std	Z+12, r22	; 0x0c
    /* Place the event list item of the TCB at the end of the appropriate event
     * list.  It is safe to access the event list here because it is part of an
     * event group implementation - and interrupts don't access event groups
     * directly (instead they access them indirectly by pending function calls to
     * the task level). */
    listINSERT_END( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5cec:	f8 01       	movw	r30, r16
    5cee:	a1 81       	ldd	r26, Z+1	; 0x01
    5cf0:	b2 81       	ldd	r27, Z+2	; 0x02
    5cf2:	e0 91 b9 07 	lds	r30, 0x07B9
    5cf6:	f0 91 ba 07 	lds	r31, 0x07BA
    5cfa:	b7 87       	std	Z+15, r27	; 0x0f
    5cfc:	a6 87       	std	Z+14, r26	; 0x0e
    5cfe:	e0 91 b9 07 	lds	r30, 0x07B9
    5d02:	f0 91 ba 07 	lds	r31, 0x07BA
    5d06:	14 96       	adiw	r26, 0x04	; 4
    5d08:	2d 91       	ld	r18, X+
    5d0a:	3c 91       	ld	r19, X
    5d0c:	15 97       	sbiw	r26, 0x05	; 5
    5d0e:	31 8b       	std	Z+17, r19	; 0x11
    5d10:	20 8b       	std	Z+16, r18	; 0x10
    5d12:	20 91 b9 07 	lds	r18, 0x07B9
    5d16:	30 91 ba 07 	lds	r19, 0x07BA
    5d1a:	14 96       	adiw	r26, 0x04	; 4
    5d1c:	ed 91       	ld	r30, X+
    5d1e:	fc 91       	ld	r31, X
    5d20:	15 97       	sbiw	r26, 0x05	; 5
    5d22:	24 5f       	subi	r18, 0xF4	; 244
    5d24:	3f 4f       	sbci	r19, 0xFF	; 255
    5d26:	33 83       	std	Z+3, r19	; 0x03
    5d28:	22 83       	std	Z+2, r18	; 0x02
    5d2a:	20 91 b9 07 	lds	r18, 0x07B9
    5d2e:	30 91 ba 07 	lds	r19, 0x07BA
    5d32:	24 5f       	subi	r18, 0xF4	; 244
    5d34:	3f 4f       	sbci	r19, 0xFF	; 255
    5d36:	15 96       	adiw	r26, 0x05	; 5
    5d38:	3c 93       	st	X, r19
    5d3a:	2e 93       	st	-X, r18
    5d3c:	14 97       	sbiw	r26, 0x04	; 4
    5d3e:	e0 91 b9 07 	lds	r30, 0x07B9
    5d42:	f0 91 ba 07 	lds	r31, 0x07BA
    5d46:	15 8b       	std	Z+21, r17	; 0x15
    5d48:	04 8b       	std	Z+20, r16	; 0x14
    5d4a:	f8 01       	movw	r30, r16
    5d4c:	20 81       	ld	r18, Z
    5d4e:	2f 5f       	subi	r18, 0xFF	; 255
    5d50:	20 83       	st	Z, r18

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5d52:	61 e0       	ldi	r22, 0x01	; 1
    5d54:	0e 94 e6 2c 	call	0x59cc	; 0x59cc <prvAddCurrentTaskToDelayedList>
}
    5d58:	1f 91       	pop	r17
    5d5a:	0f 91       	pop	r16
    5d5c:	08 95       	ret

00005d5e <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

    void vTaskDelay( const TickType_t xTicksToDelay )
    {
    5d5e:	cf 93       	push	r28
    5d60:	df 93       	push	r29
    5d62:	ec 01       	movw	r28, r24
        BaseType_t xAlreadyYielded = pdFALSE;

        /* A delay time of zero just forces a reschedule. */
        if( xTicksToDelay > ( TickType_t ) 0U )
    5d64:	00 97       	sbiw	r24, 0x00	; 0
    5d66:	51 f0       	breq	.+20     	; 0x5d7c <vTaskDelay+0x1e>
        {
            configASSERT( uxSchedulerSuspended == 0 );
            vTaskSuspendAll();
    5d68:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <vTaskSuspendAll>
                 * list or removed from the blocked list until the scheduler
                 * is resumed.
                 *
                 * This task cannot be in an event list as it is the currently
                 * executing task. */
                prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
    5d6c:	ce 01       	movw	r24, r28
    5d6e:	60 e0       	ldi	r22, 0x00	; 0
    5d70:	0e 94 e6 2c 	call	0x59cc	; 0x59cc <prvAddCurrentTaskToDelayedList>
            }
            xAlreadyYielded = xTaskResumeAll();
    5d74:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>
            mtCOVERAGE_TEST_MARKER();
        }

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    5d78:	88 23       	and	r24, r24
    5d7a:	11 f4       	brne	.+4      	; 0x5d80 <vTaskDelay+0x22>
        {
            portYIELD_WITHIN_API();
    5d7c:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
        }
        else
        {
            mtCOVERAGE_TEST_MARKER();
        }
    }
    5d80:	df 91       	pop	r29
    5d82:	cf 91       	pop	r28
    5d84:	08 95       	ret

00005d86 <xTaskDelayUntil>:

#if ( INCLUDE_xTaskDelayUntil == 1 )

    BaseType_t xTaskDelayUntil( TickType_t * const pxPreviousWakeTime,
                                const TickType_t xTimeIncrement )
    {
    5d86:	0f 93       	push	r16
    5d88:	1f 93       	push	r17
    5d8a:	cf 93       	push	r28
    5d8c:	df 93       	push	r29
    5d8e:	ec 01       	movw	r28, r24
    5d90:	8b 01       	movw	r16, r22

        configASSERT( pxPreviousWakeTime );
        configASSERT( ( xTimeIncrement > 0U ) );
        configASSERT( uxSchedulerSuspended == 0 );

        vTaskSuspendAll();
    5d92:	0e 94 4a 25 	call	0x4a94	; 0x4a94 <vTaskSuspendAll>
        {
            /* Minor optimisation.  The tick count cannot change in this
             * block. */
            const TickType_t xConstTickCount = xTickCount;
    5d96:	40 91 be 07 	lds	r20, 0x07BE
    5d9a:	50 91 bf 07 	lds	r21, 0x07BF

            /* Generate the tick time at which the task wants to wake. */
            xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    5d9e:	28 81       	ld	r18, Y
    5da0:	39 81       	ldd	r19, Y+1	; 0x01
    5da2:	c8 01       	movw	r24, r16
    5da4:	82 0f       	add	r24, r18
    5da6:	93 1f       	adc	r25, r19

            if( xConstTickCount < *pxPreviousWakeTime )
    5da8:	42 17       	cp	r20, r18
    5daa:	53 07       	cpc	r21, r19
    5dac:	38 f4       	brcc	.+14     	; 0x5dbc <xTaskDelayUntil+0x36>
                /* The tick count has overflowed since this function was
                 * lasted called.  In this case the only time we should ever
                 * actually delay is if the wake time has also  overflowed,
                 * and the wake time is greater than the tick time.  When this
                 * is the case it is as if neither time had overflowed. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
    5dae:	82 17       	cp	r24, r18
    5db0:	93 07       	cpc	r25, r19
    5db2:	50 f4       	brcc	.+20     	; 0x5dc8 <xTaskDelayUntil+0x42>
    5db4:	48 17       	cp	r20, r24
    5db6:	59 07       	cpc	r21, r25
    5db8:	b0 f0       	brcs	.+44     	; 0x5de6 <xTaskDelayUntil+0x60>
    5dba:	06 c0       	rjmp	.+12     	; 0x5dc8 <xTaskDelayUntil+0x42>
            else
            {
                /* The tick time has not overflowed.  In this case we will
                 * delay if either the wake time has overflowed, and/or the
                 * tick time is less than the wake time. */
                if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
    5dbc:	82 17       	cp	r24, r18
    5dbe:	93 07       	cpc	r25, r19
    5dc0:	90 f0       	brcs	.+36     	; 0x5de6 <xTaskDelayUntil+0x60>
    5dc2:	48 17       	cp	r20, r24
    5dc4:	59 07       	cpc	r21, r25
    5dc6:	78 f0       	brcs	.+30     	; 0x5de6 <xTaskDelayUntil+0x60>
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    5dc8:	99 83       	std	Y+1, r25	; 0x01
    5dca:	88 83       	st	Y, r24
    5dcc:	00 e0       	ldi	r16, 0x00	; 0
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
        xAlreadyYielded = xTaskResumeAll();
    5dce:	0e 94 f3 2b 	call	0x57e6	; 0x57e6 <xTaskResumeAll>

        /* Force a reschedule if xTaskResumeAll has not already done so, we may
         * have put ourselves to sleep. */
        if( xAlreadyYielded == pdFALSE )
    5dd2:	88 23       	and	r24, r24
    5dd4:	11 f4       	brne	.+4      	; 0x5dda <xTaskDelayUntil+0x54>
        {
            portYIELD_WITHIN_API();
    5dd6:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
        {
            mtCOVERAGE_TEST_MARKER();
        }

        return xShouldDelay;
    }
    5dda:	80 2f       	mov	r24, r16
    5ddc:	df 91       	pop	r29
    5dde:	cf 91       	pop	r28
    5de0:	1f 91       	pop	r17
    5de2:	0f 91       	pop	r16
    5de4:	08 95       	ret
                    mtCOVERAGE_TEST_MARKER();
                }
            }

            /* Update the wake time ready for the next call. */
            *pxPreviousWakeTime = xTimeToWake;
    5de6:	99 83       	std	Y+1, r25	; 0x01
    5de8:	88 83       	st	Y, r24
            {
                traceTASK_DELAY_UNTIL( xTimeToWake );

                /* prvAddCurrentTaskToDelayedList() needs the block time, not
                 * the time to wake, so subtract the current tick count. */
                prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
    5dea:	84 1b       	sub	r24, r20
    5dec:	95 0b       	sbc	r25, r21
    5dee:	60 e0       	ldi	r22, 0x00	; 0
    5df0:	0e 94 e6 2c 	call	0x59cc	; 0x59cc <prvAddCurrentTaskToDelayedList>
    5df4:	01 e0       	ldi	r16, 0x01	; 1
    5df6:	eb cf       	rjmp	.-42     	; 0x5dce <xTaskDelayUntil+0x48>

00005df8 <vTaskPlaceOnEventList>:
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList,
                            const TickType_t xTicksToWait )
{
    5df8:	0f 93       	push	r16
    5dfa:	1f 93       	push	r17
    5dfc:	8b 01       	movw	r16, r22
     *      xItemValue = ( configMAX_PRIORITIES - uxPriority )
     * Therefore, the event list is sorted in descending priority order.
     *
     * The queue that contains the event list is locked, preventing
     * simultaneous access from interrupts. */
    vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    5dfe:	60 91 b9 07 	lds	r22, 0x07B9
    5e02:	70 91 ba 07 	lds	r23, 0x07BA
    5e06:	64 5f       	subi	r22, 0xF4	; 244
    5e08:	7f 4f       	sbci	r23, 0xFF	; 255
    5e0a:	0e 94 7b 1b 	call	0x36f6	; 0x36f6 <vListInsert>

    prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
    5e0e:	c8 01       	movw	r24, r16
    5e10:	61 e0       	ldi	r22, 0x01	; 1
    5e12:	0e 94 e6 2c 	call	0x59cc	; 0x59cc <prvAddCurrentTaskToDelayedList>
}
    5e16:	1f 91       	pop	r17
    5e18:	0f 91       	pop	r16
    5e1a:	08 95       	ret

00005e1c <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
    /* Stop the scheduler interrupts and call the portable scheduler end
     * routine so the original ISRs can be restored if necessary.  The port
     * layer must ensure interrupts enable  bit is left in the correct state. */
    portDISABLE_INTERRUPTS();
    5e1c:	f8 94       	cli
    xSchedulerRunning = pdFALSE;
    5e1e:	10 92 c6 07 	sts	0x07C6, r1
    vPortEndScheduler();
    5e22:	0e 94 c7 18 	call	0x318e	; 0x318e <vPortEndScheduler>
}
    5e26:	08 95       	ret

00005e28 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    static void prvDeleteTCB( TCB_t * pxTCB )
    {
    5e28:	0f 93       	push	r16
    5e2a:	1f 93       	push	r17
    5e2c:	8c 01       	movw	r16, r24

        #if ( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
        {
            /* The task can only have been allocated dynamically - free both
             * the stack and TCB. */
            vPortFreeStack( pxTCB->pxStack );
    5e2e:	fc 01       	movw	r30, r24
    5e30:	87 89       	ldd	r24, Z+23	; 0x17
    5e32:	90 8d       	ldd	r25, Z+24	; 0x18
    5e34:	0e 94 37 18 	call	0x306e	; 0x306e <vPortFree>
            vPortFree( pxTCB );
    5e38:	c8 01       	movw	r24, r16
    5e3a:	0e 94 37 18 	call	0x306e	; 0x306e <vPortFree>
                configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB );
                mtCOVERAGE_TEST_MARKER();
            }
        }
        #endif /* configSUPPORT_DYNAMIC_ALLOCATION */
    }
    5e3e:	1f 91       	pop	r17
    5e40:	0f 91       	pop	r16
    5e42:	08 95       	ret

00005e44 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5e44:	0f 93       	push	r16
    5e46:	1f 93       	push	r17
    5e48:	cf 93       	push	r28
    5e4a:	df 93       	push	r29
             *
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains more than one task
             * then a task other than the idle task is ready to execute. */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    5e4c:	cb ec       	ldi	r28, 0xCB	; 203
    5e4e:	d7 e0       	ldi	r29, 0x07	; 7
    5e50:	1c c0       	rjmp	.+56     	; 0x5e8a <prvIdleTask+0x46>

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
        {
            taskENTER_CRITICAL();
    5e52:	0f b6       	in	r0, 0x3f	; 63
    5e54:	f8 94       	cli
    5e56:	0f 92       	push	r0
            {
                pxTCB = listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    5e58:	e0 91 13 08 	lds	r30, 0x0813
    5e5c:	f0 91 14 08 	lds	r31, 0x0814
    5e60:	06 81       	ldd	r16, Z+6	; 0x06
    5e62:	17 81       	ldd	r17, Z+7	; 0x07
                ( void ) uxListRemove( &( pxTCB->xStateListItem ) );
    5e64:	c8 01       	movw	r24, r16
    5e66:	02 96       	adiw	r24, 0x02	; 2
    5e68:	0e 94 ad 1b 	call	0x375a	; 0x375a <uxListRemove>
                --uxCurrentNumberOfTasks;
    5e6c:	80 91 c5 07 	lds	r24, 0x07C5
    5e70:	81 50       	subi	r24, 0x01	; 1
    5e72:	80 93 c5 07 	sts	0x07C5, r24
                --uxDeletedTasksWaitingCleanUp;
    5e76:	80 91 c9 07 	lds	r24, 0x07C9
    5e7a:	81 50       	subi	r24, 0x01	; 1
    5e7c:	80 93 c9 07 	sts	0x07C9, r24
            }
            taskEXIT_CRITICAL();
    5e80:	0f 90       	pop	r0
    5e82:	0f be       	out	0x3f, r0	; 63

            prvDeleteTCB( pxTCB );
    5e84:	c8 01       	movw	r24, r16
    5e86:	0e 94 14 2f 	call	0x5e28	; 0x5e28 <prvDeleteTCB>
    {
        TCB_t * pxTCB;

        /* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
         * being called too often in the idle task. */
        while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
    5e8a:	80 91 c9 07 	lds	r24, 0x07C9
    5e8e:	88 23       	and	r24, r24
    5e90:	01 f7       	brne	.-64     	; 0x5e52 <prvIdleTask+0xe>
             *
             * A critical region is not required here as we are just reading from
             * the list, and an occasional incorrect value will not matter.  If
             * the ready list at the idle priority contains more than one task
             * then a task other than the idle task is ready to execute. */
            if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    5e92:	88 81       	ld	r24, Y
    5e94:	82 30       	cpi	r24, 0x02	; 2
    5e96:	c8 f3       	brcs	.-14     	; 0x5e8a <prvIdleTask+0x46>
            {
                taskYIELD();
    5e98:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
    5e9c:	f6 cf       	rjmp	.-20     	; 0x5e8a <prvIdleTask+0x46>

00005e9e <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

    void vTaskDelete( TaskHandle_t xTaskToDelete )
    {
    5e9e:	0f 93       	push	r16
    5ea0:	1f 93       	push	r17
    5ea2:	cf 93       	push	r28
    5ea4:	df 93       	push	r29
        TCB_t * pxTCB;

        taskENTER_CRITICAL();
    5ea6:	0f b6       	in	r0, 0x3f	; 63
    5ea8:	f8 94       	cli
    5eaa:	0f 92       	push	r0
        {
            /* If null is passed in here then it is the calling task that is
             * being deleted. */
            pxTCB = prvGetTCBFromHandle( xTaskToDelete );
    5eac:	00 97       	sbiw	r24, 0x00	; 0
    5eae:	11 f0       	breq	.+4      	; 0x5eb4 <vTaskDelete+0x16>
    5eb0:	ec 01       	movw	r28, r24
    5eb2:	04 c0       	rjmp	.+8      	; 0x5ebc <vTaskDelete+0x1e>
    5eb4:	c0 91 b9 07 	lds	r28, 0x07B9
    5eb8:	d0 91 ba 07 	lds	r29, 0x07BA

            /* Remove task from the ready/delayed list. */
            if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
    5ebc:	8e 01       	movw	r16, r28
    5ebe:	0e 5f       	subi	r16, 0xFE	; 254
    5ec0:	1f 4f       	sbci	r17, 0xFF	; 255
    5ec2:	c8 01       	movw	r24, r16
    5ec4:	0e 94 ad 1b 	call	0x375a	; 0x375a <uxListRemove>
            {
                mtCOVERAGE_TEST_MARKER();
            }

            /* Is the task waiting on an event also? */
            if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
    5ec8:	8c 89       	ldd	r24, Y+20	; 0x14
    5eca:	9d 89       	ldd	r25, Y+21	; 0x15
    5ecc:	89 2b       	or	r24, r25
    5ece:	21 f0       	breq	.+8      	; 0x5ed8 <vTaskDelete+0x3a>
            {
                ( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    5ed0:	ce 01       	movw	r24, r28
    5ed2:	0c 96       	adiw	r24, 0x0c	; 12
    5ed4:	0e 94 ad 1b 	call	0x375a	; 0x375a <uxListRemove>

            /* Increment the uxTaskNumber also so kernel aware debuggers can
             * detect that the task lists need re-generating.  This is done before
             * portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
             * not return. */
            uxTaskNumber++;
    5ed8:	80 91 ca 07 	lds	r24, 0x07CA
    5edc:	8f 5f       	subi	r24, 0xFF	; 255
    5ede:	80 93 ca 07 	sts	0x07CA, r24

            if( pxTCB == pxCurrentTCB )
    5ee2:	80 91 b9 07 	lds	r24, 0x07B9
    5ee6:	90 91 ba 07 	lds	r25, 0x07BA
    5eea:	c8 17       	cp	r28, r24
    5eec:	d9 07       	cpc	r29, r25
    5eee:	59 f4       	brne	.+22     	; 0x5f06 <vTaskDelete+0x68>
                /* A task is deleting itself.  This cannot complete within the
                 * task itself, as a context switch to another task is required.
                 * Place the task in the termination list.  The idle task will
                 * check the termination list and free up any memory allocated by
                 * the scheduler for the TCB and stack of the deleted task. */
                vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
    5ef0:	8e e0       	ldi	r24, 0x0E	; 14
    5ef2:	98 e0       	ldi	r25, 0x08	; 8
    5ef4:	b8 01       	movw	r22, r16
    5ef6:	0e 94 5c 1b 	call	0x36b8	; 0x36b8 <vListInsertEnd>

                /* Increment the ucTasksDeleted variable so the idle task knows
                 * there is a task that has been deleted and that it should therefore
                 * check the xTasksWaitingTermination list. */
                ++uxDeletedTasksWaitingCleanUp;
    5efa:	80 91 c9 07 	lds	r24, 0x07C9
    5efe:	8f 5f       	subi	r24, 0xFF	; 255
    5f00:	80 93 c9 07 	sts	0x07C9, r24
    5f04:	07 c0       	rjmp	.+14     	; 0x5f14 <vTaskDelete+0x76>
                 * required. */
                portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
            }
            else
            {
                --uxCurrentNumberOfTasks;
    5f06:	80 91 c5 07 	lds	r24, 0x07C5
    5f0a:	81 50       	subi	r24, 0x01	; 1
    5f0c:	80 93 c5 07 	sts	0x07C5, r24
                traceTASK_DELETE( pxTCB );

                /* Reset the next expected unblock time in case it referred to
                 * the task that has just been deleted. */
                prvResetNextTaskUnblockTime();
    5f10:	0e 94 5d 27 	call	0x4eba	; 0x4eba <prvResetNextTaskUnblockTime>
            }
        }
        taskEXIT_CRITICAL();
    5f14:	0f 90       	pop	r0
    5f16:	0f be       	out	0x3f, r0	; 63

        /* If the task is not deleting itself, call prvDeleteTCB from outside of
         * critical section. If a task deletes itself, prvDeleteTCB is called
         * from prvCheckTasksWaitingTermination which is called from Idle task. */
        if( pxTCB != pxCurrentTCB )
    5f18:	80 91 b9 07 	lds	r24, 0x07B9
    5f1c:	90 91 ba 07 	lds	r25, 0x07BA
    5f20:	c8 17       	cp	r28, r24
    5f22:	d9 07       	cpc	r29, r25
    5f24:	19 f0       	breq	.+6      	; 0x5f2c <vTaskDelete+0x8e>
        {
            prvDeleteTCB( pxTCB );
    5f26:	ce 01       	movw	r24, r28
    5f28:	0e 94 14 2f 	call	0x5e28	; 0x5e28 <prvDeleteTCB>
        }

        /* Force a reschedule if it is the currently running task that has just
         * been deleted. */
        if( xSchedulerRunning != pdFALSE )
    5f2c:	80 91 c6 07 	lds	r24, 0x07C6
    5f30:	88 23       	and	r24, r24
    5f32:	49 f0       	breq	.+18     	; 0x5f46 <vTaskDelete+0xa8>
        {
            if( pxTCB == pxCurrentTCB )
    5f34:	80 91 b9 07 	lds	r24, 0x07B9
    5f38:	90 91 ba 07 	lds	r25, 0x07BA
    5f3c:	c8 17       	cp	r28, r24
    5f3e:	d9 07       	cpc	r29, r25
    5f40:	11 f4       	brne	.+4      	; 0x5f46 <vTaskDelete+0xa8>
            {
                configASSERT( uxSchedulerSuspended == 0 );
                portYIELD_WITHIN_API();
    5f42:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
            else
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }
    }
    5f46:	df 91       	pop	r29
    5f48:	cf 91       	pop	r28
    5f4a:	1f 91       	pop	r17
    5f4c:	0f 91       	pop	r16
    5f4e:	08 95       	ret

00005f50 <xTaskCreate>:
                            const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
                            const configSTACK_DEPTH_TYPE usStackDepth,
                            void * const pvParameters,
                            UBaseType_t uxPriority,
                            TaskHandle_t * const pxCreatedTask )
    {
    5f50:	4f 92       	push	r4
    5f52:	5f 92       	push	r5
    5f54:	6f 92       	push	r6
    5f56:	7f 92       	push	r7
    5f58:	8f 92       	push	r8
    5f5a:	9f 92       	push	r9
    5f5c:	af 92       	push	r10
    5f5e:	bf 92       	push	r11
    5f60:	cf 92       	push	r12
    5f62:	df 92       	push	r13
    5f64:	ef 92       	push	r14
    5f66:	ff 92       	push	r15
    5f68:	0f 93       	push	r16
    5f6a:	1f 93       	push	r17
    5f6c:	cf 93       	push	r28
    5f6e:	df 93       	push	r29
    5f70:	2c 01       	movw	r4, r24
    5f72:	6b 01       	movw	r12, r22
    5f74:	5a 01       	movw	r10, r20
    5f76:	39 01       	movw	r6, r18
    5f78:	47 01       	movw	r8, r14
        #else /* portSTACK_GROWTH */
        {
            StackType_t * pxStack;

            /* Allocate space for the stack used by the task being created. */
            pxStack = pvPortMallocStack( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack and this allocation is the stack. */
    5f7a:	ca 01       	movw	r24, r20
    5f7c:	0e 94 48 18 	call	0x3090	; 0x3090 <pvPortMalloc>
    5f80:	7c 01       	movw	r14, r24

            if( pxStack != NULL )
    5f82:	e1 14       	cp	r14, r1
    5f84:	f1 04       	cpc	r15, r1
    5f86:	11 f4       	brne	.+4      	; 0x5f8c <xTaskCreate+0x3c>
    5f88:	8f ef       	ldi	r24, 0xFF	; 255
    5f8a:	f9 c0       	rjmp	.+498    	; 0x617e <xTaskCreate+0x22e>
            {
                /* Allocate space for the TCB. */
                pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of TCB_t is always a pointer to the task's stack. */
    5f8c:	86 e2       	ldi	r24, 0x26	; 38
    5f8e:	90 e0       	ldi	r25, 0x00	; 0
    5f90:	0e 94 48 18 	call	0x3090	; 0x3090 <pvPortMalloc>
    5f94:	ec 01       	movw	r28, r24

                if( pxNewTCB != NULL )
    5f96:	20 97       	sbiw	r28, 0x00	; 0
    5f98:	59 f0       	breq	.+22     	; 0x5fb0 <xTaskCreate+0x60>
                {
                    memset( ( void * ) pxNewTCB, 0x00, sizeof( TCB_t ) );
    5f9a:	86 e2       	ldi	r24, 0x26	; 38
    5f9c:	fe 01       	movw	r30, r28
    5f9e:	11 92       	st	Z+, r1
    5fa0:	8a 95       	dec	r24
    5fa2:	e9 f7       	brne	.-6      	; 0x5f9e <xTaskCreate+0x4e>

                    /* Store the stack location in the TCB. */
                    pxNewTCB->pxStack = pxStack;
    5fa4:	f8 8e       	std	Y+24, r15	; 0x18
    5fa6:	ef 8a       	std	Y+23, r14	; 0x17
        pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
    }
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    5fa8:	c1 14       	cp	r12, r1
    5faa:	d1 04       	cpc	r13, r1
    5fac:	31 f4       	brne	.+12     	; 0x5fba <xTaskCreate+0x6a>
    5fae:	15 c0       	rjmp	.+42     	; 0x5fda <xTaskCreate+0x8a>
                }
                else
                {
                    /* The stack cannot be used as the TCB was not created.  Free
                     * it again. */
                    vPortFreeStack( pxStack );
    5fb0:	c7 01       	movw	r24, r14
    5fb2:	0e 94 37 18 	call	0x306e	; 0x306e <vPortFree>
    5fb6:	8f ef       	ldi	r24, 0xFF	; 255
    5fb8:	e2 c0       	rjmp	.+452    	; 0x617e <xTaskCreate+0x22e>
    5fba:	f6 01       	movw	r30, r12
    5fbc:	de 01       	movw	r26, r28
    5fbe:	90 e0       	ldi	r25, 0x00	; 0
    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
        {
            pxNewTCB->pcTaskName[ x ] = pcName[ x ];
    5fc0:	80 81       	ld	r24, Z
    5fc2:	59 96       	adiw	r26, 0x19	; 25
    5fc4:	8c 93       	st	X, r24
    5fc6:	59 97       	sbiw	r26, 0x19	; 25

            /* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
             * configMAX_TASK_NAME_LEN characters just in case the memory after the
             * string is not accessible (extremely unlikely). */
            if( pcName[ x ] == ( char ) 0x00 )
    5fc8:	80 81       	ld	r24, Z
    5fca:	88 23       	and	r24, r24
    5fcc:	29 f0       	breq	.+10     	; 0x5fd8 <xTaskCreate+0x88>
    #endif /* portSTACK_GROWTH */

    /* Store the task name in the TCB. */
    if( pcName != NULL )
    {
        for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
    5fce:	9f 5f       	subi	r25, 0xFF	; 255
    5fd0:	31 96       	adiw	r30, 0x01	; 1
    5fd2:	11 96       	adiw	r26, 0x01	; 1
    5fd4:	98 30       	cpi	r25, 0x08	; 8
    5fd6:	a1 f7       	brne	.-24     	; 0x5fc0 <xTaskCreate+0x70>
            }
        }

        /* Ensure the name string is terminated in the case that the string length
         * was greater or equal to configMAX_TASK_NAME_LEN. */
        pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
    5fd8:	18 a2       	std	Y+32, r1	; 0x20
    5fda:	04 30       	cpi	r16, 0x04	; 4
    5fdc:	08 f0       	brcs	.+2      	; 0x5fe0 <xTaskCreate+0x90>
    5fde:	03 e0       	ldi	r16, 0x03	; 3
    else
    {
        mtCOVERAGE_TEST_MARKER();
    }

    pxNewTCB->uxPriority = uxPriority;
    5fe0:	0e 8b       	std	Y+22, r16	; 0x16
    {
        pxNewTCB->uxBasePriority = uxPriority;
    }
    #endif /* configUSE_MUTEXES */

    vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
    5fe2:	cc 24       	eor	r12, r12
    5fe4:	dd 24       	eor	r13, r13
    5fe6:	68 94       	set
    5fe8:	c1 f8       	bld	r12, 1
    5fea:	cc 0e       	add	r12, r28
    5fec:	dd 1e       	adc	r13, r29
    5fee:	c6 01       	movw	r24, r12
    5ff0:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <vListInitialiseItem>
    vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
    5ff4:	ce 01       	movw	r24, r28
    5ff6:	0c 96       	adiw	r24, 0x0c	; 12
    5ff8:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <vListInitialiseItem>

    /* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
     * back to  the containing TCB from a generic item in a list. */
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
    5ffc:	d9 87       	std	Y+9, r29	; 0x09
    5ffe:	c8 87       	std	Y+8, r28	; 0x08

    /* Event lists are always in priority order. */
    listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    6000:	84 e0       	ldi	r24, 0x04	; 4
    6002:	90 e0       	ldi	r25, 0x00	; 0
    6004:	80 1b       	sub	r24, r16
    6006:	91 09       	sbc	r25, r1
    6008:	9d 87       	std	Y+13, r25	; 0x0d
    600a:	8c 87       	std	Y+12, r24	; 0x0c
    listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
    600c:	db 8b       	std	Y+19, r29	; 0x13
    600e:	ca 8b       	std	Y+18, r28	; 0x12
            }
            #endif /* portSTACK_GROWTH */
        }
        #else /* portHAS_STACK_OVERFLOW_CHECKING */
        {
            pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    6010:	c5 01       	movw	r24, r10
    6012:	01 97       	sbiw	r24, 0x01	; 1
    6014:	8e 0d       	add	r24, r14
    6016:	9f 1d       	adc	r25, r15
    6018:	b2 01       	movw	r22, r4
    601a:	a3 01       	movw	r20, r6
    601c:	0e 94 7e 18 	call	0x30fc	; 0x30fc <pxPortInitialiseStack>
    6020:	99 83       	std	Y+1, r25	; 0x01
    6022:	88 83       	st	Y, r24
        }
        #endif /* portHAS_STACK_OVERFLOW_CHECKING */
    }
    #endif /* portUSING_MPU_WRAPPERS */

    if( pxCreatedTask != NULL )
    6024:	81 14       	cp	r8, r1
    6026:	91 04       	cpc	r9, r1
    6028:	19 f0       	breq	.+6      	; 0x6030 <xTaskCreate+0xe0>
    {
        /* Pass the handle out in an anonymous way.  The handle can be used to
         * change the created task's priority, delete the created task, etc.*/
        *pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
    602a:	f4 01       	movw	r30, r8
    602c:	d1 83       	std	Z+1, r29	; 0x01
    602e:	c0 83       	st	Z, r28

static void prvAddNewTaskToReadyList( TCB_t * pxNewTCB )
{
    /* Ensure interrupts don't access the task lists while the lists are being
     * updated. */
    taskENTER_CRITICAL();
    6030:	0f b6       	in	r0, 0x3f	; 63
    6032:	f8 94       	cli
    6034:	0f 92       	push	r0
    {
        uxCurrentNumberOfTasks++;
    6036:	80 91 c5 07 	lds	r24, 0x07C5
    603a:	8f 5f       	subi	r24, 0xFF	; 255
    603c:	80 93 c5 07 	sts	0x07C5, r24

        if( pxCurrentTCB == NULL )
    6040:	80 91 b9 07 	lds	r24, 0x07B9
    6044:	90 91 ba 07 	lds	r25, 0x07BA
    6048:	89 2b       	or	r24, r25
    604a:	c9 f5       	brne	.+114    	; 0x60be <xTaskCreate+0x16e>
        {
            /* There are no other tasks, or all the other tasks are in
             * the suspended state - make this the current task. */
            pxCurrentTCB = pxNewTCB;
    604c:	d0 93 ba 07 	sts	0x07BA, r29
    6050:	c0 93 b9 07 	sts	0x07B9, r28

            if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
    6054:	80 91 c5 07 	lds	r24, 0x07C5
    6058:	81 30       	cpi	r24, 0x01	; 1
    605a:	09 f0       	breq	.+2      	; 0x605e <xTaskCreate+0x10e>
    605c:	40 c0       	rjmp	.+128    	; 0x60de <xTaskCreate+0x18e>
{
    UBaseType_t uxPriority;

    for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
    {
        vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
    605e:	0b ec       	ldi	r16, 0xCB	; 203
    6060:	17 e0       	ldi	r17, 0x07	; 7
    6062:	c8 01       	movw	r24, r16
    6064:	0e 94 48 1b 	call	0x3690	; 0x3690 <vListInitialise>
    6068:	c8 01       	movw	r24, r16
    606a:	09 96       	adiw	r24, 0x09	; 9
    606c:	0e 94 48 1b 	call	0x3690	; 0x3690 <vListInitialise>
    6070:	c8 01       	movw	r24, r16
    6072:	42 96       	adiw	r24, 0x12	; 18
    6074:	0e 94 48 1b 	call	0x3690	; 0x3690 <vListInitialise>
    6078:	c8 01       	movw	r24, r16
    607a:	4b 96       	adiw	r24, 0x1b	; 27
    607c:	0e 94 48 1b 	call	0x3690	; 0x3690 <vListInitialise>
    }

    vListInitialise( &xDelayedTaskList1 );
    6080:	0f 2e       	mov	r0, r31
    6082:	ff ee       	ldi	r31, 0xEF	; 239
    6084:	ef 2e       	mov	r14, r31
    6086:	f7 e0       	ldi	r31, 0x07	; 7
    6088:	ff 2e       	mov	r15, r31
    608a:	f0 2d       	mov	r31, r0
    608c:	c7 01       	movw	r24, r14
    608e:	0e 94 48 1b 	call	0x3690	; 0x3690 <vListInitialise>
    vListInitialise( &xDelayedTaskList2 );
    6092:	08 ef       	ldi	r16, 0xF8	; 248
    6094:	17 e0       	ldi	r17, 0x07	; 7
    6096:	c8 01       	movw	r24, r16
    6098:	0e 94 48 1b 	call	0x3690	; 0x3690 <vListInitialise>
    vListInitialise( &xPendingReadyList );
    609c:	85 e0       	ldi	r24, 0x05	; 5
    609e:	98 e0       	ldi	r25, 0x08	; 8
    60a0:	0e 94 48 1b 	call	0x3690	; 0x3690 <vListInitialise>

    #if ( INCLUDE_vTaskDelete == 1 )
    {
        vListInitialise( &xTasksWaitingTermination );
    60a4:	8e e0       	ldi	r24, 0x0E	; 14
    60a6:	98 e0       	ldi	r25, 0x08	; 8
    60a8:	0e 94 48 1b 	call	0x3690	; 0x3690 <vListInitialise>
    }
    #endif /* INCLUDE_vTaskSuspend */

    /* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
     * using list2. */
    pxDelayedTaskList = &xDelayedTaskList1;
    60ac:	f0 92 02 08 	sts	0x0802, r15
    60b0:	e0 92 01 08 	sts	0x0801, r14
    pxOverflowDelayedTaskList = &xDelayedTaskList2;
    60b4:	10 93 04 08 	sts	0x0804, r17
    60b8:	00 93 03 08 	sts	0x0803, r16
    60bc:	10 c0       	rjmp	.+32     	; 0x60de <xTaskCreate+0x18e>
        else
        {
            /* If the scheduler is not already running, make this task the
             * current task if it is the highest priority task to be created
             * so far. */
            if( xSchedulerRunning == pdFALSE )
    60be:	80 91 c6 07 	lds	r24, 0x07C6
    60c2:	88 23       	and	r24, r24
    60c4:	61 f4       	brne	.+24     	; 0x60de <xTaskCreate+0x18e>
            {
                if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
    60c6:	e0 91 b9 07 	lds	r30, 0x07B9
    60ca:	f0 91 ba 07 	lds	r31, 0x07BA
    60ce:	96 89       	ldd	r25, Z+22	; 0x16
    60d0:	8e 89       	ldd	r24, Y+22	; 0x16
    60d2:	89 17       	cp	r24, r25
    60d4:	20 f0       	brcs	.+8      	; 0x60de <xTaskCreate+0x18e>
                {
                    pxCurrentTCB = pxNewTCB;
    60d6:	d0 93 ba 07 	sts	0x07BA, r29
    60da:	c0 93 b9 07 	sts	0x07B9, r28
            {
                mtCOVERAGE_TEST_MARKER();
            }
        }

        uxTaskNumber++;
    60de:	80 91 ca 07 	lds	r24, 0x07CA
    60e2:	8f 5f       	subi	r24, 0xFF	; 255
    60e4:	80 93 ca 07 	sts	0x07CA, r24
            pxNewTCB->uxTCBNumber = uxTaskNumber;
        }
        #endif /* configUSE_TRACE_FACILITY */
        traceTASK_CREATE( pxNewTCB );

        prvAddTaskToReadyList( pxNewTCB );
    60e8:	9e 89       	ldd	r25, Y+22	; 0x16
    60ea:	80 91 bc 07 	lds	r24, 0x07BC
    60ee:	89 17       	cp	r24, r25
    60f0:	10 f4       	brcc	.+4      	; 0x60f6 <xTaskCreate+0x1a6>
    60f2:	90 93 bc 07 	sts	0x07BC, r25
    60f6:	8e 89       	ldd	r24, Y+22	; 0x16
    60f8:	90 e0       	ldi	r25, 0x00	; 0
    60fa:	9c 01       	movw	r18, r24
    60fc:	22 0f       	add	r18, r18
    60fe:	33 1f       	adc	r19, r19
    6100:	22 0f       	add	r18, r18
    6102:	33 1f       	adc	r19, r19
    6104:	22 0f       	add	r18, r18
    6106:	33 1f       	adc	r19, r19
    6108:	28 0f       	add	r18, r24
    610a:	39 1f       	adc	r19, r25
    610c:	4b ec       	ldi	r20, 0xCB	; 203
    610e:	57 e0       	ldi	r21, 0x07	; 7
    6110:	fa 01       	movw	r30, r20
    6112:	e2 0f       	add	r30, r18
    6114:	f3 1f       	adc	r31, r19
    6116:	a1 81       	ldd	r26, Z+1	; 0x01
    6118:	b2 81       	ldd	r27, Z+2	; 0x02
    611a:	bd 83       	std	Y+5, r27	; 0x05
    611c:	ac 83       	std	Y+4, r26	; 0x04
    611e:	14 96       	adiw	r26, 0x04	; 4
    6120:	8d 91       	ld	r24, X+
    6122:	9c 91       	ld	r25, X
    6124:	15 97       	sbiw	r26, 0x05	; 5
    6126:	9f 83       	std	Y+7, r25	; 0x07
    6128:	8e 83       	std	Y+6, r24	; 0x06
    612a:	14 96       	adiw	r26, 0x04	; 4
    612c:	ed 91       	ld	r30, X+
    612e:	fc 91       	ld	r31, X
    6130:	15 97       	sbiw	r26, 0x05	; 5
    6132:	d3 82       	std	Z+3, r13	; 0x03
    6134:	c2 82       	std	Z+2, r12	; 0x02
    6136:	15 96       	adiw	r26, 0x05	; 5
    6138:	dc 92       	st	X, r13
    613a:	ce 92       	st	-X, r12
    613c:	14 97       	sbiw	r26, 0x04	; 4
    613e:	8e 89       	ldd	r24, Y+22	; 0x16
    6140:	29 e0       	ldi	r18, 0x09	; 9
    6142:	82 9f       	mul	r24, r18
    6144:	c0 01       	movw	r24, r0
    6146:	11 24       	eor	r1, r1
    6148:	48 0f       	add	r20, r24
    614a:	59 1f       	adc	r21, r25
    614c:	5b 87       	std	Y+11, r21	; 0x0b
    614e:	4a 87       	std	Y+10, r20	; 0x0a
    6150:	fa 01       	movw	r30, r20
    6152:	80 81       	ld	r24, Z
    6154:	8f 5f       	subi	r24, 0xFF	; 255
    6156:	80 83       	st	Z, r24

        portSETUP_TCB( pxNewTCB );
    }
    taskEXIT_CRITICAL();
    6158:	0f 90       	pop	r0
    615a:	0f be       	out	0x3f, r0	; 63

    if( xSchedulerRunning != pdFALSE )
    615c:	80 91 c6 07 	lds	r24, 0x07C6
    6160:	88 23       	and	r24, r24
    6162:	61 f0       	breq	.+24     	; 0x617c <xTaskCreate+0x22c>
    {
        /* If the created task is of a higher priority than the current task
         * then it should run now. */
        if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
    6164:	e0 91 b9 07 	lds	r30, 0x07B9
    6168:	f0 91 ba 07 	lds	r31, 0x07BA
    616c:	96 89       	ldd	r25, Z+22	; 0x16
    616e:	8e 89       	ldd	r24, Y+22	; 0x16
    6170:	98 17       	cp	r25, r24
    6172:	20 f4       	brcc	.+8      	; 0x617c <xTaskCreate+0x22c>
        {
            taskYIELD_IF_USING_PREEMPTION();
    6174:	0e 94 5f 19 	call	0x32be	; 0x32be <vPortYield>
    6178:	81 e0       	ldi	r24, 0x01	; 1
    617a:	01 c0       	rjmp	.+2      	; 0x617e <xTaskCreate+0x22e>
    617c:	81 e0       	ldi	r24, 0x01	; 1
        {
            xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
        }

        return xReturn;
    }
    617e:	df 91       	pop	r29
    6180:	cf 91       	pop	r28
    6182:	1f 91       	pop	r17
    6184:	0f 91       	pop	r16
    6186:	ff 90       	pop	r15
    6188:	ef 90       	pop	r14
    618a:	df 90       	pop	r13
    618c:	cf 90       	pop	r12
    618e:	bf 90       	pop	r11
    6190:	af 90       	pop	r10
    6192:	9f 90       	pop	r9
    6194:	8f 90       	pop	r8
    6196:	7f 90       	pop	r7
    6198:	6f 90       	pop	r6
    619a:	5f 90       	pop	r5
    619c:	4f 90       	pop	r4
    619e:	08 95       	ret

000061a0 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
    61a0:	ef 92       	push	r14
    61a2:	ff 92       	push	r15
    61a4:	0f 93       	push	r16
        }
    }
    #else /* if ( configSUPPORT_STATIC_ALLOCATION == 1 ) */
    {
        /* The Idle task is being created using dynamically allocated RAM. */
        xReturn = xTaskCreate( prvIdleTask,
    61a6:	82 e2       	ldi	r24, 0x22	; 34
    61a8:	9f e2       	ldi	r25, 0x2F	; 47
    61aa:	63 e6       	ldi	r22, 0x63	; 99
    61ac:	70 e0       	ldi	r23, 0x00	; 0
    61ae:	45 e5       	ldi	r20, 0x55	; 85
    61b0:	50 e0       	ldi	r21, 0x00	; 0
    61b2:	20 e0       	ldi	r18, 0x00	; 0
    61b4:	30 e0       	ldi	r19, 0x00	; 0
    61b6:	00 e0       	ldi	r16, 0x00	; 0
    61b8:	0f 2e       	mov	r0, r31
    61ba:	f7 ec       	ldi	r31, 0xC7	; 199
    61bc:	ef 2e       	mov	r14, r31
    61be:	f7 e0       	ldi	r31, 0x07	; 7
    61c0:	ff 2e       	mov	r15, r31
    61c2:	f0 2d       	mov	r31, r0
    61c4:	0e 94 a8 2f 	call	0x5f50	; 0x5f50 <xTaskCreate>
            mtCOVERAGE_TEST_MARKER();
        }
    }
    #endif /* configUSE_TIMERS */

    if( xReturn == pdPASS )
    61c8:	81 30       	cpi	r24, 0x01	; 1
    61ca:	81 f4       	brne	.+32     	; 0x61ec <vTaskStartScheduler+0x4c>
        /* Interrupts are turned off here, to ensure a tick does not occur
         * before or during the call to xPortStartScheduler().  The stacks of
         * the created tasks contain a status word with interrupts switched on
         * so interrupts will automatically get re-enabled when the first task
         * starts to run. */
        portDISABLE_INTERRUPTS();
    61cc:	f8 94       	cli
             * block specific to the task that will run first. */
            configSET_TLS_BLOCK( pxCurrentTCB->xTLSBlock );
        }
        #endif

        xNextTaskUnblockTime = portMAX_DELAY;
    61ce:	8f ef       	ldi	r24, 0xFF	; 255
    61d0:	9f ef       	ldi	r25, 0xFF	; 255
    61d2:	90 93 c1 07 	sts	0x07C1, r25
    61d6:	80 93 c0 07 	sts	0x07C0, r24
        xSchedulerRunning = pdTRUE;
    61da:	81 e0       	ldi	r24, 0x01	; 1
    61dc:	80 93 c6 07 	sts	0x07C6, r24
        xTickCount = ( TickType_t ) configINITIAL_TICK_COUNT;
    61e0:	10 92 bf 07 	sts	0x07BF, r1
    61e4:	10 92 be 07 	sts	0x07BE, r1

        traceTASK_SWITCHED_IN();

        /* Setting up the timer tick is hardware specific and thus in the
         * portable interface. */
        xPortStartScheduler();
    61e8:	0e 94 c8 18 	call	0x3190	; 0x3190 <xPortStartScheduler>
     * meaning xIdleTaskHandle is not used anywhere else. */
    ( void ) xIdleTaskHandle;

    /* OpenOCD makes use of uxTopUsedPriority for thread debugging. Prevent uxTopUsedPriority
     * from getting optimized out as it is no longer used by the kernel. */
    ( void ) uxTopUsedPriority;
    61ec:	80 91 a1 01 	lds	r24, 0x01A1
}
    61f0:	0f 91       	pop	r16
    61f2:	ff 90       	pop	r15
    61f4:	ef 90       	pop	r14
    61f6:	08 95       	ret

000061f8 <__mulsi3>:
    61f8:	62 9f       	mul	r22, r18
    61fa:	d0 01       	movw	r26, r0
    61fc:	73 9f       	mul	r23, r19
    61fe:	f0 01       	movw	r30, r0
    6200:	82 9f       	mul	r24, r18
    6202:	e0 0d       	add	r30, r0
    6204:	f1 1d       	adc	r31, r1
    6206:	64 9f       	mul	r22, r20
    6208:	e0 0d       	add	r30, r0
    620a:	f1 1d       	adc	r31, r1
    620c:	92 9f       	mul	r25, r18
    620e:	f0 0d       	add	r31, r0
    6210:	83 9f       	mul	r24, r19
    6212:	f0 0d       	add	r31, r0
    6214:	74 9f       	mul	r23, r20
    6216:	f0 0d       	add	r31, r0
    6218:	65 9f       	mul	r22, r21
    621a:	f0 0d       	add	r31, r0
    621c:	99 27       	eor	r25, r25
    621e:	72 9f       	mul	r23, r18
    6220:	b0 0d       	add	r27, r0
    6222:	e1 1d       	adc	r30, r1
    6224:	f9 1f       	adc	r31, r25
    6226:	63 9f       	mul	r22, r19
    6228:	b0 0d       	add	r27, r0
    622a:	e1 1d       	adc	r30, r1
    622c:	f9 1f       	adc	r31, r25
    622e:	bd 01       	movw	r22, r26
    6230:	cf 01       	movw	r24, r30
    6232:	11 24       	eor	r1, r1
    6234:	08 95       	ret

00006236 <__udivmodhi4>:
    6236:	aa 1b       	sub	r26, r26
    6238:	bb 1b       	sub	r27, r27
    623a:	51 e1       	ldi	r21, 0x11	; 17
    623c:	07 c0       	rjmp	.+14     	; 0x624c <__udivmodhi4_ep>

0000623e <__udivmodhi4_loop>:
    623e:	aa 1f       	adc	r26, r26
    6240:	bb 1f       	adc	r27, r27
    6242:	a6 17       	cp	r26, r22
    6244:	b7 07       	cpc	r27, r23
    6246:	10 f0       	brcs	.+4      	; 0x624c <__udivmodhi4_ep>
    6248:	a6 1b       	sub	r26, r22
    624a:	b7 0b       	sbc	r27, r23

0000624c <__udivmodhi4_ep>:
    624c:	88 1f       	adc	r24, r24
    624e:	99 1f       	adc	r25, r25
    6250:	5a 95       	dec	r21
    6252:	a9 f7       	brne	.-22     	; 0x623e <__udivmodhi4_loop>
    6254:	80 95       	com	r24
    6256:	90 95       	com	r25
    6258:	bc 01       	movw	r22, r24
    625a:	cd 01       	movw	r24, r26
    625c:	08 95       	ret

0000625e <__udivmodsi4>:
    625e:	a1 e2       	ldi	r26, 0x21	; 33
    6260:	1a 2e       	mov	r1, r26
    6262:	aa 1b       	sub	r26, r26
    6264:	bb 1b       	sub	r27, r27
    6266:	fd 01       	movw	r30, r26
    6268:	0d c0       	rjmp	.+26     	; 0x6284 <__udivmodsi4_ep>

0000626a <__udivmodsi4_loop>:
    626a:	aa 1f       	adc	r26, r26
    626c:	bb 1f       	adc	r27, r27
    626e:	ee 1f       	adc	r30, r30
    6270:	ff 1f       	adc	r31, r31
    6272:	a2 17       	cp	r26, r18
    6274:	b3 07       	cpc	r27, r19
    6276:	e4 07       	cpc	r30, r20
    6278:	f5 07       	cpc	r31, r21
    627a:	20 f0       	brcs	.+8      	; 0x6284 <__udivmodsi4_ep>
    627c:	a2 1b       	sub	r26, r18
    627e:	b3 0b       	sbc	r27, r19
    6280:	e4 0b       	sbc	r30, r20
    6282:	f5 0b       	sbc	r31, r21

00006284 <__udivmodsi4_ep>:
    6284:	66 1f       	adc	r22, r22
    6286:	77 1f       	adc	r23, r23
    6288:	88 1f       	adc	r24, r24
    628a:	99 1f       	adc	r25, r25
    628c:	1a 94       	dec	r1
    628e:	69 f7       	brne	.-38     	; 0x626a <__udivmodsi4_loop>
    6290:	60 95       	com	r22
    6292:	70 95       	com	r23
    6294:	80 95       	com	r24
    6296:	90 95       	com	r25
    6298:	9b 01       	movw	r18, r22
    629a:	ac 01       	movw	r20, r24
    629c:	bd 01       	movw	r22, r26
    629e:	cf 01       	movw	r24, r30
    62a0:	08 95       	ret

000062a2 <__prologue_saves__>:
    62a2:	2f 92       	push	r2
    62a4:	3f 92       	push	r3
    62a6:	4f 92       	push	r4
    62a8:	5f 92       	push	r5
    62aa:	6f 92       	push	r6
    62ac:	7f 92       	push	r7
    62ae:	8f 92       	push	r8
    62b0:	9f 92       	push	r9
    62b2:	af 92       	push	r10
    62b4:	bf 92       	push	r11
    62b6:	cf 92       	push	r12
    62b8:	df 92       	push	r13
    62ba:	ef 92       	push	r14
    62bc:	ff 92       	push	r15
    62be:	0f 93       	push	r16
    62c0:	1f 93       	push	r17
    62c2:	cf 93       	push	r28
    62c4:	df 93       	push	r29
    62c6:	cd b7       	in	r28, 0x3d	; 61
    62c8:	de b7       	in	r29, 0x3e	; 62
    62ca:	ca 1b       	sub	r28, r26
    62cc:	db 0b       	sbc	r29, r27
    62ce:	0f b6       	in	r0, 0x3f	; 63
    62d0:	f8 94       	cli
    62d2:	de bf       	out	0x3e, r29	; 62
    62d4:	0f be       	out	0x3f, r0	; 63
    62d6:	cd bf       	out	0x3d, r28	; 61
    62d8:	09 94       	ijmp

000062da <__epilogue_restores__>:
    62da:	2a 88       	ldd	r2, Y+18	; 0x12
    62dc:	39 88       	ldd	r3, Y+17	; 0x11
    62de:	48 88       	ldd	r4, Y+16	; 0x10
    62e0:	5f 84       	ldd	r5, Y+15	; 0x0f
    62e2:	6e 84       	ldd	r6, Y+14	; 0x0e
    62e4:	7d 84       	ldd	r7, Y+13	; 0x0d
    62e6:	8c 84       	ldd	r8, Y+12	; 0x0c
    62e8:	9b 84       	ldd	r9, Y+11	; 0x0b
    62ea:	aa 84       	ldd	r10, Y+10	; 0x0a
    62ec:	b9 84       	ldd	r11, Y+9	; 0x09
    62ee:	c8 84       	ldd	r12, Y+8	; 0x08
    62f0:	df 80       	ldd	r13, Y+7	; 0x07
    62f2:	ee 80       	ldd	r14, Y+6	; 0x06
    62f4:	fd 80       	ldd	r15, Y+5	; 0x05
    62f6:	0c 81       	ldd	r16, Y+4	; 0x04
    62f8:	1b 81       	ldd	r17, Y+3	; 0x03
    62fa:	aa 81       	ldd	r26, Y+2	; 0x02
    62fc:	b9 81       	ldd	r27, Y+1	; 0x01
    62fe:	ce 0f       	add	r28, r30
    6300:	d1 1d       	adc	r29, r1
    6302:	0f b6       	in	r0, 0x3f	; 63
    6304:	f8 94       	cli
    6306:	de bf       	out	0x3e, r29	; 62
    6308:	0f be       	out	0x3f, r0	; 63
    630a:	cd bf       	out	0x3d, r28	; 61
    630c:	ed 01       	movw	r28, r26
    630e:	08 95       	ret

00006310 <malloc>:
    6310:	cf 93       	push	r28
    6312:	df 93       	push	r29
    6314:	bc 01       	movw	r22, r24
    6316:	82 30       	cpi	r24, 0x02	; 2
    6318:	91 05       	cpc	r25, r1
    631a:	10 f4       	brcc	.+4      	; 0x6320 <malloc+0x10>
    631c:	62 e0       	ldi	r22, 0x02	; 2
    631e:	70 e0       	ldi	r23, 0x00	; 0
    6320:	a0 91 51 08 	lds	r26, 0x0851
    6324:	b0 91 52 08 	lds	r27, 0x0852
    6328:	ed 01       	movw	r28, r26
    632a:	e0 e0       	ldi	r30, 0x00	; 0
    632c:	f0 e0       	ldi	r31, 0x00	; 0
    632e:	40 e0       	ldi	r20, 0x00	; 0
    6330:	50 e0       	ldi	r21, 0x00	; 0
    6332:	21 c0       	rjmp	.+66     	; 0x6376 <malloc+0x66>
    6334:	88 81       	ld	r24, Y
    6336:	99 81       	ldd	r25, Y+1	; 0x01
    6338:	86 17       	cp	r24, r22
    633a:	97 07       	cpc	r25, r23
    633c:	69 f4       	brne	.+26     	; 0x6358 <malloc+0x48>
    633e:	8a 81       	ldd	r24, Y+2	; 0x02
    6340:	9b 81       	ldd	r25, Y+3	; 0x03
    6342:	30 97       	sbiw	r30, 0x00	; 0
    6344:	19 f0       	breq	.+6      	; 0x634c <malloc+0x3c>
    6346:	93 83       	std	Z+3, r25	; 0x03
    6348:	82 83       	std	Z+2, r24	; 0x02
    634a:	04 c0       	rjmp	.+8      	; 0x6354 <malloc+0x44>
    634c:	90 93 52 08 	sts	0x0852, r25
    6350:	80 93 51 08 	sts	0x0851, r24
    6354:	fe 01       	movw	r30, r28
    6356:	34 c0       	rjmp	.+104    	; 0x63c0 <malloc+0xb0>
    6358:	68 17       	cp	r22, r24
    635a:	79 07       	cpc	r23, r25
    635c:	38 f4       	brcc	.+14     	; 0x636c <malloc+0x5c>
    635e:	41 15       	cp	r20, r1
    6360:	51 05       	cpc	r21, r1
    6362:	19 f0       	breq	.+6      	; 0x636a <malloc+0x5a>
    6364:	84 17       	cp	r24, r20
    6366:	95 07       	cpc	r25, r21
    6368:	08 f4       	brcc	.+2      	; 0x636c <malloc+0x5c>
    636a:	ac 01       	movw	r20, r24
    636c:	fe 01       	movw	r30, r28
    636e:	8a 81       	ldd	r24, Y+2	; 0x02
    6370:	9b 81       	ldd	r25, Y+3	; 0x03
    6372:	9c 01       	movw	r18, r24
    6374:	e9 01       	movw	r28, r18
    6376:	20 97       	sbiw	r28, 0x00	; 0
    6378:	e9 f6       	brne	.-70     	; 0x6334 <malloc+0x24>
    637a:	41 15       	cp	r20, r1
    637c:	51 05       	cpc	r21, r1
    637e:	a9 f1       	breq	.+106    	; 0x63ea <malloc+0xda>
    6380:	ca 01       	movw	r24, r20
    6382:	86 1b       	sub	r24, r22
    6384:	97 0b       	sbc	r25, r23
    6386:	04 97       	sbiw	r24, 0x04	; 4
    6388:	08 f4       	brcc	.+2      	; 0x638c <malloc+0x7c>
    638a:	ba 01       	movw	r22, r20
    638c:	e0 e0       	ldi	r30, 0x00	; 0
    638e:	f0 e0       	ldi	r31, 0x00	; 0
    6390:	2a c0       	rjmp	.+84     	; 0x63e6 <malloc+0xd6>
    6392:	8d 91       	ld	r24, X+
    6394:	9c 91       	ld	r25, X
    6396:	11 97       	sbiw	r26, 0x01	; 1
    6398:	84 17       	cp	r24, r20
    639a:	95 07       	cpc	r25, r21
    639c:	f9 f4       	brne	.+62     	; 0x63dc <malloc+0xcc>
    639e:	64 17       	cp	r22, r20
    63a0:	75 07       	cpc	r23, r21
    63a2:	81 f4       	brne	.+32     	; 0x63c4 <malloc+0xb4>
    63a4:	12 96       	adiw	r26, 0x02	; 2
    63a6:	8d 91       	ld	r24, X+
    63a8:	9c 91       	ld	r25, X
    63aa:	13 97       	sbiw	r26, 0x03	; 3
    63ac:	30 97       	sbiw	r30, 0x00	; 0
    63ae:	19 f0       	breq	.+6      	; 0x63b6 <malloc+0xa6>
    63b0:	93 83       	std	Z+3, r25	; 0x03
    63b2:	82 83       	std	Z+2, r24	; 0x02
    63b4:	04 c0       	rjmp	.+8      	; 0x63be <malloc+0xae>
    63b6:	90 93 52 08 	sts	0x0852, r25
    63ba:	80 93 51 08 	sts	0x0851, r24
    63be:	fd 01       	movw	r30, r26
    63c0:	32 96       	adiw	r30, 0x02	; 2
    63c2:	4f c0       	rjmp	.+158    	; 0x6462 <malloc+0x152>
    63c4:	ca 01       	movw	r24, r20
    63c6:	86 1b       	sub	r24, r22
    63c8:	97 0b       	sbc	r25, r23
    63ca:	fd 01       	movw	r30, r26
    63cc:	e8 0f       	add	r30, r24
    63ce:	f9 1f       	adc	r31, r25
    63d0:	61 93       	st	Z+, r22
    63d2:	71 93       	st	Z+, r23
    63d4:	02 97       	sbiw	r24, 0x02	; 2
    63d6:	8d 93       	st	X+, r24
    63d8:	9c 93       	st	X, r25
    63da:	43 c0       	rjmp	.+134    	; 0x6462 <malloc+0x152>
    63dc:	fd 01       	movw	r30, r26
    63de:	82 81       	ldd	r24, Z+2	; 0x02
    63e0:	93 81       	ldd	r25, Z+3	; 0x03
    63e2:	9c 01       	movw	r18, r24
    63e4:	d9 01       	movw	r26, r18
    63e6:	10 97       	sbiw	r26, 0x00	; 0
    63e8:	a1 f6       	brne	.-88     	; 0x6392 <malloc+0x82>
    63ea:	80 91 4f 08 	lds	r24, 0x084F
    63ee:	90 91 50 08 	lds	r25, 0x0850
    63f2:	89 2b       	or	r24, r25
    63f4:	41 f4       	brne	.+16     	; 0x6406 <malloc+0xf6>
    63f6:	80 91 72 01 	lds	r24, 0x0172
    63fa:	90 91 73 01 	lds	r25, 0x0173
    63fe:	90 93 50 08 	sts	0x0850, r25
    6402:	80 93 4f 08 	sts	0x084F, r24
    6406:	40 91 74 01 	lds	r20, 0x0174
    640a:	50 91 75 01 	lds	r21, 0x0175
    640e:	41 15       	cp	r20, r1
    6410:	51 05       	cpc	r21, r1
    6412:	41 f4       	brne	.+16     	; 0x6424 <malloc+0x114>
    6414:	4d b7       	in	r20, 0x3d	; 61
    6416:	5e b7       	in	r21, 0x3e	; 62
    6418:	80 91 70 01 	lds	r24, 0x0170
    641c:	90 91 71 01 	lds	r25, 0x0171
    6420:	48 1b       	sub	r20, r24
    6422:	59 0b       	sbc	r21, r25
    6424:	20 91 4f 08 	lds	r18, 0x084F
    6428:	30 91 50 08 	lds	r19, 0x0850
    642c:	24 17       	cp	r18, r20
    642e:	35 07       	cpc	r19, r21
    6430:	b0 f4       	brcc	.+44     	; 0x645e <malloc+0x14e>
    6432:	ca 01       	movw	r24, r20
    6434:	82 1b       	sub	r24, r18
    6436:	93 0b       	sbc	r25, r19
    6438:	86 17       	cp	r24, r22
    643a:	97 07       	cpc	r25, r23
    643c:	80 f0       	brcs	.+32     	; 0x645e <malloc+0x14e>
    643e:	ab 01       	movw	r20, r22
    6440:	4e 5f       	subi	r20, 0xFE	; 254
    6442:	5f 4f       	sbci	r21, 0xFF	; 255
    6444:	84 17       	cp	r24, r20
    6446:	95 07       	cpc	r25, r21
    6448:	50 f0       	brcs	.+20     	; 0x645e <malloc+0x14e>
    644a:	42 0f       	add	r20, r18
    644c:	53 1f       	adc	r21, r19
    644e:	50 93 50 08 	sts	0x0850, r21
    6452:	40 93 4f 08 	sts	0x084F, r20
    6456:	f9 01       	movw	r30, r18
    6458:	61 93       	st	Z+, r22
    645a:	71 93       	st	Z+, r23
    645c:	02 c0       	rjmp	.+4      	; 0x6462 <malloc+0x152>
    645e:	e0 e0       	ldi	r30, 0x00	; 0
    6460:	f0 e0       	ldi	r31, 0x00	; 0
    6462:	cf 01       	movw	r24, r30
    6464:	df 91       	pop	r29
    6466:	cf 91       	pop	r28
    6468:	08 95       	ret

0000646a <free>:
    646a:	cf 93       	push	r28
    646c:	df 93       	push	r29
    646e:	00 97       	sbiw	r24, 0x00	; 0
    6470:	09 f4       	brne	.+2      	; 0x6474 <free+0xa>
    6472:	50 c0       	rjmp	.+160    	; 0x6514 <free+0xaa>
    6474:	ec 01       	movw	r28, r24
    6476:	22 97       	sbiw	r28, 0x02	; 2
    6478:	1b 82       	std	Y+3, r1	; 0x03
    647a:	1a 82       	std	Y+2, r1	; 0x02
    647c:	a0 91 51 08 	lds	r26, 0x0851
    6480:	b0 91 52 08 	lds	r27, 0x0852
    6484:	10 97       	sbiw	r26, 0x00	; 0
    6486:	09 f1       	breq	.+66     	; 0x64ca <free+0x60>
    6488:	40 e0       	ldi	r20, 0x00	; 0
    648a:	50 e0       	ldi	r21, 0x00	; 0
    648c:	ac 17       	cp	r26, r28
    648e:	bd 07       	cpc	r27, r29
    6490:	08 f1       	brcs	.+66     	; 0x64d4 <free+0x6a>
    6492:	bb 83       	std	Y+3, r27	; 0x03
    6494:	aa 83       	std	Y+2, r26	; 0x02
    6496:	fe 01       	movw	r30, r28
    6498:	21 91       	ld	r18, Z+
    649a:	31 91       	ld	r19, Z+
    649c:	e2 0f       	add	r30, r18
    649e:	f3 1f       	adc	r31, r19
    64a0:	ae 17       	cp	r26, r30
    64a2:	bf 07       	cpc	r27, r31
    64a4:	79 f4       	brne	.+30     	; 0x64c4 <free+0x5a>
    64a6:	8d 91       	ld	r24, X+
    64a8:	9c 91       	ld	r25, X
    64aa:	11 97       	sbiw	r26, 0x01	; 1
    64ac:	28 0f       	add	r18, r24
    64ae:	39 1f       	adc	r19, r25
    64b0:	2e 5f       	subi	r18, 0xFE	; 254
    64b2:	3f 4f       	sbci	r19, 0xFF	; 255
    64b4:	39 83       	std	Y+1, r19	; 0x01
    64b6:	28 83       	st	Y, r18
    64b8:	12 96       	adiw	r26, 0x02	; 2
    64ba:	8d 91       	ld	r24, X+
    64bc:	9c 91       	ld	r25, X
    64be:	13 97       	sbiw	r26, 0x03	; 3
    64c0:	9b 83       	std	Y+3, r25	; 0x03
    64c2:	8a 83       	std	Y+2, r24	; 0x02
    64c4:	41 15       	cp	r20, r1
    64c6:	51 05       	cpc	r21, r1
    64c8:	71 f4       	brne	.+28     	; 0x64e6 <free+0x7c>
    64ca:	d0 93 52 08 	sts	0x0852, r29
    64ce:	c0 93 51 08 	sts	0x0851, r28
    64d2:	20 c0       	rjmp	.+64     	; 0x6514 <free+0xaa>
    64d4:	12 96       	adiw	r26, 0x02	; 2
    64d6:	8d 91       	ld	r24, X+
    64d8:	9c 91       	ld	r25, X
    64da:	13 97       	sbiw	r26, 0x03	; 3
    64dc:	ad 01       	movw	r20, r26
    64de:	00 97       	sbiw	r24, 0x00	; 0
    64e0:	11 f0       	breq	.+4      	; 0x64e6 <free+0x7c>
    64e2:	dc 01       	movw	r26, r24
    64e4:	d3 cf       	rjmp	.-90     	; 0x648c <free+0x22>
    64e6:	fa 01       	movw	r30, r20
    64e8:	d3 83       	std	Z+3, r29	; 0x03
    64ea:	c2 83       	std	Z+2, r28	; 0x02
    64ec:	21 91       	ld	r18, Z+
    64ee:	31 91       	ld	r19, Z+
    64f0:	e2 0f       	add	r30, r18
    64f2:	f3 1f       	adc	r31, r19
    64f4:	ce 17       	cp	r28, r30
    64f6:	df 07       	cpc	r29, r31
    64f8:	69 f4       	brne	.+26     	; 0x6514 <free+0xaa>
    64fa:	88 81       	ld	r24, Y
    64fc:	99 81       	ldd	r25, Y+1	; 0x01
    64fe:	28 0f       	add	r18, r24
    6500:	39 1f       	adc	r19, r25
    6502:	2e 5f       	subi	r18, 0xFE	; 254
    6504:	3f 4f       	sbci	r19, 0xFF	; 255
    6506:	fa 01       	movw	r30, r20
    6508:	31 83       	std	Z+1, r19	; 0x01
    650a:	20 83       	st	Z, r18
    650c:	8a 81       	ldd	r24, Y+2	; 0x02
    650e:	9b 81       	ldd	r25, Y+3	; 0x03
    6510:	93 83       	std	Z+3, r25	; 0x03
    6512:	82 83       	std	Z+2, r24	; 0x02
    6514:	df 91       	pop	r29
    6516:	cf 91       	pop	r28
    6518:	08 95       	ret

0000651a <atoi>:
    651a:	fc 01       	movw	r30, r24
    651c:	88 27       	eor	r24, r24
    651e:	99 27       	eor	r25, r25
    6520:	e8 94       	clt
    6522:	21 91       	ld	r18, Z+
    6524:	20 32       	cpi	r18, 0x20	; 32
    6526:	e9 f3       	breq	.-6      	; 0x6522 <atoi+0x8>
    6528:	29 30       	cpi	r18, 0x09	; 9
    652a:	10 f0       	brcs	.+4      	; 0x6530 <atoi+0x16>
    652c:	2e 30       	cpi	r18, 0x0E	; 14
    652e:	c8 f3       	brcs	.-14     	; 0x6522 <atoi+0x8>
    6530:	2b 32       	cpi	r18, 0x2B	; 43
    6532:	41 f0       	breq	.+16     	; 0x6544 <atoi+0x2a>
    6534:	2d 32       	cpi	r18, 0x2D	; 45
    6536:	39 f4       	brne	.+14     	; 0x6546 <atoi+0x2c>
    6538:	68 94       	set
    653a:	04 c0       	rjmp	.+8      	; 0x6544 <atoi+0x2a>
    653c:	0e 94 b4 32 	call	0x6568	; 0x6568 <__mulhi_const_10>
    6540:	82 0f       	add	r24, r18
    6542:	91 1d       	adc	r25, r1
    6544:	21 91       	ld	r18, Z+
    6546:	20 53       	subi	r18, 0x30	; 48
    6548:	2a 30       	cpi	r18, 0x0A	; 10
    654a:	c0 f3       	brcs	.-16     	; 0x653c <atoi+0x22>
    654c:	1e f4       	brtc	.+6      	; 0x6554 <atoi+0x3a>
    654e:	90 95       	com	r25
    6550:	81 95       	neg	r24
    6552:	9f 4f       	sbci	r25, 0xFF	; 255
    6554:	08 95       	ret

00006556 <memcpy>:
    6556:	fb 01       	movw	r30, r22
    6558:	dc 01       	movw	r26, r24
    655a:	02 c0       	rjmp	.+4      	; 0x6560 <memcpy+0xa>
    655c:	01 90       	ld	r0, Z+
    655e:	0d 92       	st	X+, r0
    6560:	41 50       	subi	r20, 0x01	; 1
    6562:	50 40       	sbci	r21, 0x00	; 0
    6564:	d8 f7       	brcc	.-10     	; 0x655c <memcpy+0x6>
    6566:	08 95       	ret

00006568 <__mulhi_const_10>:
    6568:	7a e0       	ldi	r23, 0x0A	; 10
    656a:	97 9f       	mul	r25, r23
    656c:	90 2d       	mov	r25, r0
    656e:	87 9f       	mul	r24, r23
    6570:	80 2d       	mov	r24, r0
    6572:	91 0d       	add	r25, r1
    6574:	11 24       	eor	r1, r1
    6576:	08 95       	ret

00006578 <snprintf>:
    6578:	ae e0       	ldi	r26, 0x0E	; 14
    657a:	b0 e0       	ldi	r27, 0x00	; 0
    657c:	e2 ec       	ldi	r30, 0xC2	; 194
    657e:	f2 e3       	ldi	r31, 0x32	; 50
    6580:	0c 94 5f 31 	jmp	0x62be	; 0x62be <__prologue_saves__+0x1c>
    6584:	0d 89       	ldd	r16, Y+21	; 0x15
    6586:	1e 89       	ldd	r17, Y+22	; 0x16
    6588:	8f 89       	ldd	r24, Y+23	; 0x17
    658a:	98 8d       	ldd	r25, Y+24	; 0x18
    658c:	97 ff       	sbrs	r25, 7
    658e:	02 c0       	rjmp	.+4      	; 0x6594 <snprintf+0x1c>
    6590:	80 e0       	ldi	r24, 0x00	; 0
    6592:	90 e8       	ldi	r25, 0x80	; 128
    6594:	01 97       	sbiw	r24, 0x01	; 1
    6596:	9e 83       	std	Y+6, r25	; 0x06
    6598:	8d 83       	std	Y+5, r24	; 0x05
    659a:	1a 83       	std	Y+2, r17	; 0x02
    659c:	09 83       	std	Y+1, r16	; 0x01
    659e:	86 e0       	ldi	r24, 0x06	; 6
    65a0:	8c 83       	std	Y+4, r24	; 0x04
    65a2:	9e 01       	movw	r18, r28
    65a4:	25 5e       	subi	r18, 0xE5	; 229
    65a6:	3f 4f       	sbci	r19, 0xFF	; 255
    65a8:	ce 01       	movw	r24, r28
    65aa:	01 96       	adiw	r24, 0x01	; 1
    65ac:	69 8d       	ldd	r22, Y+25	; 0x19
    65ae:	7a 8d       	ldd	r23, Y+26	; 0x1a
    65b0:	a9 01       	movw	r20, r18
    65b2:	0e 94 ed 32 	call	0x65da	; 0x65da <vfprintf>
    65b6:	4d 81       	ldd	r20, Y+5	; 0x05
    65b8:	5e 81       	ldd	r21, Y+6	; 0x06
    65ba:	57 fd       	sbrc	r21, 7
    65bc:	0a c0       	rjmp	.+20     	; 0x65d2 <snprintf+0x5a>
    65be:	2f 81       	ldd	r18, Y+7	; 0x07
    65c0:	38 85       	ldd	r19, Y+8	; 0x08
    65c2:	42 17       	cp	r20, r18
    65c4:	53 07       	cpc	r21, r19
    65c6:	0c f4       	brge	.+2      	; 0x65ca <snprintf+0x52>
    65c8:	9a 01       	movw	r18, r20
    65ca:	02 0f       	add	r16, r18
    65cc:	13 1f       	adc	r17, r19
    65ce:	f8 01       	movw	r30, r16
    65d0:	10 82       	st	Z, r1
    65d2:	2e 96       	adiw	r28, 0x0e	; 14
    65d4:	e4 e0       	ldi	r30, 0x04	; 4
    65d6:	0c 94 7b 31 	jmp	0x62f6	; 0x62f6 <__epilogue_restores__+0x1c>

000065da <vfprintf>:
    65da:	ab e0       	ldi	r26, 0x0B	; 11
    65dc:	b0 e0       	ldi	r27, 0x00	; 0
    65de:	e3 ef       	ldi	r30, 0xF3	; 243
    65e0:	f2 e3       	ldi	r31, 0x32	; 50
    65e2:	0c 94 51 31 	jmp	0x62a2	; 0x62a2 <__prologue_saves__>
    65e6:	3c 01       	movw	r6, r24
    65e8:	2b 01       	movw	r4, r22
    65ea:	5a 01       	movw	r10, r20
    65ec:	fc 01       	movw	r30, r24
    65ee:	17 82       	std	Z+7, r1	; 0x07
    65f0:	16 82       	std	Z+6, r1	; 0x06
    65f2:	83 81       	ldd	r24, Z+3	; 0x03
    65f4:	81 fd       	sbrc	r24, 1
    65f6:	03 c0       	rjmp	.+6      	; 0x65fe <vfprintf+0x24>
    65f8:	6f ef       	ldi	r22, 0xFF	; 255
    65fa:	7f ef       	ldi	r23, 0xFF	; 255
    65fc:	c6 c1       	rjmp	.+908    	; 0x698a <vfprintf+0x3b0>
    65fe:	9a e0       	ldi	r25, 0x0A	; 10
    6600:	89 2e       	mov	r8, r25
    6602:	1e 01       	movw	r2, r28
    6604:	08 94       	sec
    6606:	21 1c       	adc	r2, r1
    6608:	31 1c       	adc	r3, r1
    660a:	f3 01       	movw	r30, r6
    660c:	23 81       	ldd	r18, Z+3	; 0x03
    660e:	f2 01       	movw	r30, r4
    6610:	23 fd       	sbrc	r18, 3
    6612:	85 91       	lpm	r24, Z+
    6614:	23 ff       	sbrs	r18, 3
    6616:	81 91       	ld	r24, Z+
    6618:	2f 01       	movw	r4, r30
    661a:	88 23       	and	r24, r24
    661c:	09 f4       	brne	.+2      	; 0x6620 <vfprintf+0x46>
    661e:	b2 c1       	rjmp	.+868    	; 0x6984 <vfprintf+0x3aa>
    6620:	85 32       	cpi	r24, 0x25	; 37
    6622:	39 f4       	brne	.+14     	; 0x6632 <vfprintf+0x58>
    6624:	23 fd       	sbrc	r18, 3
    6626:	85 91       	lpm	r24, Z+
    6628:	23 ff       	sbrs	r18, 3
    662a:	81 91       	ld	r24, Z+
    662c:	2f 01       	movw	r4, r30
    662e:	85 32       	cpi	r24, 0x25	; 37
    6630:	29 f4       	brne	.+10     	; 0x663c <vfprintf+0x62>
    6632:	90 e0       	ldi	r25, 0x00	; 0
    6634:	b3 01       	movw	r22, r6
    6636:	0e 94 e0 34 	call	0x69c0	; 0x69c0 <fputc>
    663a:	e7 cf       	rjmp	.-50     	; 0x660a <vfprintf+0x30>
    663c:	98 2f       	mov	r25, r24
    663e:	ff 24       	eor	r15, r15
    6640:	ee 24       	eor	r14, r14
    6642:	99 24       	eor	r9, r9
    6644:	ff e1       	ldi	r31, 0x1F	; 31
    6646:	ff 15       	cp	r31, r15
    6648:	d0 f0       	brcs	.+52     	; 0x667e <vfprintf+0xa4>
    664a:	9b 32       	cpi	r25, 0x2B	; 43
    664c:	69 f0       	breq	.+26     	; 0x6668 <vfprintf+0x8e>
    664e:	9c 32       	cpi	r25, 0x2C	; 44
    6650:	28 f4       	brcc	.+10     	; 0x665c <vfprintf+0x82>
    6652:	90 32       	cpi	r25, 0x20	; 32
    6654:	59 f0       	breq	.+22     	; 0x666c <vfprintf+0x92>
    6656:	93 32       	cpi	r25, 0x23	; 35
    6658:	91 f4       	brne	.+36     	; 0x667e <vfprintf+0xa4>
    665a:	0e c0       	rjmp	.+28     	; 0x6678 <vfprintf+0x9e>
    665c:	9d 32       	cpi	r25, 0x2D	; 45
    665e:	49 f0       	breq	.+18     	; 0x6672 <vfprintf+0x98>
    6660:	90 33       	cpi	r25, 0x30	; 48
    6662:	69 f4       	brne	.+26     	; 0x667e <vfprintf+0xa4>
    6664:	41 e0       	ldi	r20, 0x01	; 1
    6666:	24 c0       	rjmp	.+72     	; 0x66b0 <vfprintf+0xd6>
    6668:	52 e0       	ldi	r21, 0x02	; 2
    666a:	f5 2a       	or	r15, r21
    666c:	84 e0       	ldi	r24, 0x04	; 4
    666e:	f8 2a       	or	r15, r24
    6670:	28 c0       	rjmp	.+80     	; 0x66c2 <vfprintf+0xe8>
    6672:	98 e0       	ldi	r25, 0x08	; 8
    6674:	f9 2a       	or	r15, r25
    6676:	25 c0       	rjmp	.+74     	; 0x66c2 <vfprintf+0xe8>
    6678:	e0 e1       	ldi	r30, 0x10	; 16
    667a:	fe 2a       	or	r15, r30
    667c:	22 c0       	rjmp	.+68     	; 0x66c2 <vfprintf+0xe8>
    667e:	f7 fc       	sbrc	r15, 7
    6680:	29 c0       	rjmp	.+82     	; 0x66d4 <vfprintf+0xfa>
    6682:	89 2f       	mov	r24, r25
    6684:	80 53       	subi	r24, 0x30	; 48
    6686:	8a 30       	cpi	r24, 0x0A	; 10
    6688:	70 f4       	brcc	.+28     	; 0x66a6 <vfprintf+0xcc>
    668a:	f6 fe       	sbrs	r15, 6
    668c:	05 c0       	rjmp	.+10     	; 0x6698 <vfprintf+0xbe>
    668e:	98 9c       	mul	r9, r8
    6690:	90 2c       	mov	r9, r0
    6692:	11 24       	eor	r1, r1
    6694:	98 0e       	add	r9, r24
    6696:	15 c0       	rjmp	.+42     	; 0x66c2 <vfprintf+0xe8>
    6698:	e8 9c       	mul	r14, r8
    669a:	e0 2c       	mov	r14, r0
    669c:	11 24       	eor	r1, r1
    669e:	e8 0e       	add	r14, r24
    66a0:	f0 e2       	ldi	r31, 0x20	; 32
    66a2:	ff 2a       	or	r15, r31
    66a4:	0e c0       	rjmp	.+28     	; 0x66c2 <vfprintf+0xe8>
    66a6:	9e 32       	cpi	r25, 0x2E	; 46
    66a8:	29 f4       	brne	.+10     	; 0x66b4 <vfprintf+0xda>
    66aa:	f6 fc       	sbrc	r15, 6
    66ac:	6b c1       	rjmp	.+726    	; 0x6984 <vfprintf+0x3aa>
    66ae:	40 e4       	ldi	r20, 0x40	; 64
    66b0:	f4 2a       	or	r15, r20
    66b2:	07 c0       	rjmp	.+14     	; 0x66c2 <vfprintf+0xe8>
    66b4:	9c 36       	cpi	r25, 0x6C	; 108
    66b6:	19 f4       	brne	.+6      	; 0x66be <vfprintf+0xe4>
    66b8:	50 e8       	ldi	r21, 0x80	; 128
    66ba:	f5 2a       	or	r15, r21
    66bc:	02 c0       	rjmp	.+4      	; 0x66c2 <vfprintf+0xe8>
    66be:	98 36       	cpi	r25, 0x68	; 104
    66c0:	49 f4       	brne	.+18     	; 0x66d4 <vfprintf+0xfa>
    66c2:	f2 01       	movw	r30, r4
    66c4:	23 fd       	sbrc	r18, 3
    66c6:	95 91       	lpm	r25, Z+
    66c8:	23 ff       	sbrs	r18, 3
    66ca:	91 91       	ld	r25, Z+
    66cc:	2f 01       	movw	r4, r30
    66ce:	99 23       	and	r25, r25
    66d0:	09 f0       	breq	.+2      	; 0x66d4 <vfprintf+0xfa>
    66d2:	b8 cf       	rjmp	.-144    	; 0x6644 <vfprintf+0x6a>
    66d4:	89 2f       	mov	r24, r25
    66d6:	85 54       	subi	r24, 0x45	; 69
    66d8:	83 30       	cpi	r24, 0x03	; 3
    66da:	18 f0       	brcs	.+6      	; 0x66e2 <vfprintf+0x108>
    66dc:	80 52       	subi	r24, 0x20	; 32
    66de:	83 30       	cpi	r24, 0x03	; 3
    66e0:	38 f4       	brcc	.+14     	; 0x66f0 <vfprintf+0x116>
    66e2:	44 e0       	ldi	r20, 0x04	; 4
    66e4:	50 e0       	ldi	r21, 0x00	; 0
    66e6:	a4 0e       	add	r10, r20
    66e8:	b5 1e       	adc	r11, r21
    66ea:	5f e3       	ldi	r21, 0x3F	; 63
    66ec:	59 83       	std	Y+1, r21	; 0x01
    66ee:	0f c0       	rjmp	.+30     	; 0x670e <vfprintf+0x134>
    66f0:	93 36       	cpi	r25, 0x63	; 99
    66f2:	31 f0       	breq	.+12     	; 0x6700 <vfprintf+0x126>
    66f4:	93 37       	cpi	r25, 0x73	; 115
    66f6:	79 f0       	breq	.+30     	; 0x6716 <vfprintf+0x13c>
    66f8:	93 35       	cpi	r25, 0x53	; 83
    66fa:	09 f0       	breq	.+2      	; 0x66fe <vfprintf+0x124>
    66fc:	56 c0       	rjmp	.+172    	; 0x67aa <vfprintf+0x1d0>
    66fe:	20 c0       	rjmp	.+64     	; 0x6740 <vfprintf+0x166>
    6700:	f5 01       	movw	r30, r10
    6702:	80 81       	ld	r24, Z
    6704:	89 83       	std	Y+1, r24	; 0x01
    6706:	42 e0       	ldi	r20, 0x02	; 2
    6708:	50 e0       	ldi	r21, 0x00	; 0
    670a:	a4 0e       	add	r10, r20
    670c:	b5 1e       	adc	r11, r21
    670e:	61 01       	movw	r12, r2
    6710:	01 e0       	ldi	r16, 0x01	; 1
    6712:	10 e0       	ldi	r17, 0x00	; 0
    6714:	12 c0       	rjmp	.+36     	; 0x673a <vfprintf+0x160>
    6716:	f5 01       	movw	r30, r10
    6718:	c0 80       	ld	r12, Z
    671a:	d1 80       	ldd	r13, Z+1	; 0x01
    671c:	f6 fc       	sbrc	r15, 6
    671e:	03 c0       	rjmp	.+6      	; 0x6726 <vfprintf+0x14c>
    6720:	6f ef       	ldi	r22, 0xFF	; 255
    6722:	7f ef       	ldi	r23, 0xFF	; 255
    6724:	02 c0       	rjmp	.+4      	; 0x672a <vfprintf+0x150>
    6726:	69 2d       	mov	r22, r9
    6728:	70 e0       	ldi	r23, 0x00	; 0
    672a:	42 e0       	ldi	r20, 0x02	; 2
    672c:	50 e0       	ldi	r21, 0x00	; 0
    672e:	a4 0e       	add	r10, r20
    6730:	b5 1e       	adc	r11, r21
    6732:	c6 01       	movw	r24, r12
    6734:	0e 94 d5 34 	call	0x69aa	; 0x69aa <strnlen>
    6738:	8c 01       	movw	r16, r24
    673a:	5f e7       	ldi	r21, 0x7F	; 127
    673c:	f5 22       	and	r15, r21
    673e:	14 c0       	rjmp	.+40     	; 0x6768 <vfprintf+0x18e>
    6740:	f5 01       	movw	r30, r10
    6742:	c0 80       	ld	r12, Z
    6744:	d1 80       	ldd	r13, Z+1	; 0x01
    6746:	f6 fc       	sbrc	r15, 6
    6748:	03 c0       	rjmp	.+6      	; 0x6750 <vfprintf+0x176>
    674a:	6f ef       	ldi	r22, 0xFF	; 255
    674c:	7f ef       	ldi	r23, 0xFF	; 255
    674e:	02 c0       	rjmp	.+4      	; 0x6754 <vfprintf+0x17a>
    6750:	69 2d       	mov	r22, r9
    6752:	70 e0       	ldi	r23, 0x00	; 0
    6754:	42 e0       	ldi	r20, 0x02	; 2
    6756:	50 e0       	ldi	r21, 0x00	; 0
    6758:	a4 0e       	add	r10, r20
    675a:	b5 1e       	adc	r11, r21
    675c:	c6 01       	movw	r24, r12
    675e:	0e 94 ca 34 	call	0x6994	; 0x6994 <strnlen_P>
    6762:	8c 01       	movw	r16, r24
    6764:	50 e8       	ldi	r21, 0x80	; 128
    6766:	f5 2a       	or	r15, r21
    6768:	f3 fe       	sbrs	r15, 3
    676a:	07 c0       	rjmp	.+14     	; 0x677a <vfprintf+0x1a0>
    676c:	1a c0       	rjmp	.+52     	; 0x67a2 <vfprintf+0x1c8>
    676e:	80 e2       	ldi	r24, 0x20	; 32
    6770:	90 e0       	ldi	r25, 0x00	; 0
    6772:	b3 01       	movw	r22, r6
    6774:	0e 94 e0 34 	call	0x69c0	; 0x69c0 <fputc>
    6778:	ea 94       	dec	r14
    677a:	8e 2d       	mov	r24, r14
    677c:	90 e0       	ldi	r25, 0x00	; 0
    677e:	08 17       	cp	r16, r24
    6780:	19 07       	cpc	r17, r25
    6782:	a8 f3       	brcs	.-22     	; 0x676e <vfprintf+0x194>
    6784:	0e c0       	rjmp	.+28     	; 0x67a2 <vfprintf+0x1c8>
    6786:	f6 01       	movw	r30, r12
    6788:	f7 fc       	sbrc	r15, 7
    678a:	85 91       	lpm	r24, Z+
    678c:	f7 fe       	sbrs	r15, 7
    678e:	81 91       	ld	r24, Z+
    6790:	6f 01       	movw	r12, r30
    6792:	90 e0       	ldi	r25, 0x00	; 0
    6794:	b3 01       	movw	r22, r6
    6796:	0e 94 e0 34 	call	0x69c0	; 0x69c0 <fputc>
    679a:	e1 10       	cpse	r14, r1
    679c:	ea 94       	dec	r14
    679e:	01 50       	subi	r16, 0x01	; 1
    67a0:	10 40       	sbci	r17, 0x00	; 0
    67a2:	01 15       	cp	r16, r1
    67a4:	11 05       	cpc	r17, r1
    67a6:	79 f7       	brne	.-34     	; 0x6786 <vfprintf+0x1ac>
    67a8:	ea c0       	rjmp	.+468    	; 0x697e <vfprintf+0x3a4>
    67aa:	94 36       	cpi	r25, 0x64	; 100
    67ac:	11 f0       	breq	.+4      	; 0x67b2 <vfprintf+0x1d8>
    67ae:	99 36       	cpi	r25, 0x69	; 105
    67b0:	69 f5       	brne	.+90     	; 0x680c <vfprintf+0x232>
    67b2:	f7 fe       	sbrs	r15, 7
    67b4:	08 c0       	rjmp	.+16     	; 0x67c6 <vfprintf+0x1ec>
    67b6:	f5 01       	movw	r30, r10
    67b8:	20 81       	ld	r18, Z
    67ba:	31 81       	ldd	r19, Z+1	; 0x01
    67bc:	42 81       	ldd	r20, Z+2	; 0x02
    67be:	53 81       	ldd	r21, Z+3	; 0x03
    67c0:	84 e0       	ldi	r24, 0x04	; 4
    67c2:	90 e0       	ldi	r25, 0x00	; 0
    67c4:	0a c0       	rjmp	.+20     	; 0x67da <vfprintf+0x200>
    67c6:	f5 01       	movw	r30, r10
    67c8:	80 81       	ld	r24, Z
    67ca:	91 81       	ldd	r25, Z+1	; 0x01
    67cc:	9c 01       	movw	r18, r24
    67ce:	44 27       	eor	r20, r20
    67d0:	37 fd       	sbrc	r19, 7
    67d2:	40 95       	com	r20
    67d4:	54 2f       	mov	r21, r20
    67d6:	82 e0       	ldi	r24, 0x02	; 2
    67d8:	90 e0       	ldi	r25, 0x00	; 0
    67da:	a8 0e       	add	r10, r24
    67dc:	b9 1e       	adc	r11, r25
    67de:	9f e6       	ldi	r25, 0x6F	; 111
    67e0:	f9 22       	and	r15, r25
    67e2:	57 ff       	sbrs	r21, 7
    67e4:	09 c0       	rjmp	.+18     	; 0x67f8 <vfprintf+0x21e>
    67e6:	50 95       	com	r21
    67e8:	40 95       	com	r20
    67ea:	30 95       	com	r19
    67ec:	21 95       	neg	r18
    67ee:	3f 4f       	sbci	r19, 0xFF	; 255
    67f0:	4f 4f       	sbci	r20, 0xFF	; 255
    67f2:	5f 4f       	sbci	r21, 0xFF	; 255
    67f4:	e0 e8       	ldi	r30, 0x80	; 128
    67f6:	fe 2a       	or	r15, r30
    67f8:	ca 01       	movw	r24, r20
    67fa:	b9 01       	movw	r22, r18
    67fc:	a1 01       	movw	r20, r2
    67fe:	2a e0       	ldi	r18, 0x0A	; 10
    6800:	30 e0       	ldi	r19, 0x00	; 0
    6802:	0e 94 0c 35 	call	0x6a18	; 0x6a18 <__ultoa_invert>
    6806:	d8 2e       	mov	r13, r24
    6808:	d2 18       	sub	r13, r2
    680a:	40 c0       	rjmp	.+128    	; 0x688c <vfprintf+0x2b2>
    680c:	95 37       	cpi	r25, 0x75	; 117
    680e:	29 f4       	brne	.+10     	; 0x681a <vfprintf+0x240>
    6810:	1f 2d       	mov	r17, r15
    6812:	1f 7e       	andi	r17, 0xEF	; 239
    6814:	2a e0       	ldi	r18, 0x0A	; 10
    6816:	30 e0       	ldi	r19, 0x00	; 0
    6818:	1d c0       	rjmp	.+58     	; 0x6854 <vfprintf+0x27a>
    681a:	1f 2d       	mov	r17, r15
    681c:	19 7f       	andi	r17, 0xF9	; 249
    681e:	9f 36       	cpi	r25, 0x6F	; 111
    6820:	61 f0       	breq	.+24     	; 0x683a <vfprintf+0x260>
    6822:	90 37       	cpi	r25, 0x70	; 112
    6824:	20 f4       	brcc	.+8      	; 0x682e <vfprintf+0x254>
    6826:	98 35       	cpi	r25, 0x58	; 88
    6828:	09 f0       	breq	.+2      	; 0x682c <vfprintf+0x252>
    682a:	ac c0       	rjmp	.+344    	; 0x6984 <vfprintf+0x3aa>
    682c:	0f c0       	rjmp	.+30     	; 0x684c <vfprintf+0x272>
    682e:	90 37       	cpi	r25, 0x70	; 112
    6830:	39 f0       	breq	.+14     	; 0x6840 <vfprintf+0x266>
    6832:	98 37       	cpi	r25, 0x78	; 120
    6834:	09 f0       	breq	.+2      	; 0x6838 <vfprintf+0x25e>
    6836:	a6 c0       	rjmp	.+332    	; 0x6984 <vfprintf+0x3aa>
    6838:	04 c0       	rjmp	.+8      	; 0x6842 <vfprintf+0x268>
    683a:	28 e0       	ldi	r18, 0x08	; 8
    683c:	30 e0       	ldi	r19, 0x00	; 0
    683e:	0a c0       	rjmp	.+20     	; 0x6854 <vfprintf+0x27a>
    6840:	10 61       	ori	r17, 0x10	; 16
    6842:	14 fd       	sbrc	r17, 4
    6844:	14 60       	ori	r17, 0x04	; 4
    6846:	20 e1       	ldi	r18, 0x10	; 16
    6848:	30 e0       	ldi	r19, 0x00	; 0
    684a:	04 c0       	rjmp	.+8      	; 0x6854 <vfprintf+0x27a>
    684c:	14 fd       	sbrc	r17, 4
    684e:	16 60       	ori	r17, 0x06	; 6
    6850:	20 e1       	ldi	r18, 0x10	; 16
    6852:	32 e0       	ldi	r19, 0x02	; 2
    6854:	17 ff       	sbrs	r17, 7
    6856:	08 c0       	rjmp	.+16     	; 0x6868 <vfprintf+0x28e>
    6858:	f5 01       	movw	r30, r10
    685a:	60 81       	ld	r22, Z
    685c:	71 81       	ldd	r23, Z+1	; 0x01
    685e:	82 81       	ldd	r24, Z+2	; 0x02
    6860:	93 81       	ldd	r25, Z+3	; 0x03
    6862:	44 e0       	ldi	r20, 0x04	; 4
    6864:	50 e0       	ldi	r21, 0x00	; 0
    6866:	08 c0       	rjmp	.+16     	; 0x6878 <vfprintf+0x29e>
    6868:	f5 01       	movw	r30, r10
    686a:	80 81       	ld	r24, Z
    686c:	91 81       	ldd	r25, Z+1	; 0x01
    686e:	bc 01       	movw	r22, r24
    6870:	80 e0       	ldi	r24, 0x00	; 0
    6872:	90 e0       	ldi	r25, 0x00	; 0
    6874:	42 e0       	ldi	r20, 0x02	; 2
    6876:	50 e0       	ldi	r21, 0x00	; 0
    6878:	a4 0e       	add	r10, r20
    687a:	b5 1e       	adc	r11, r21
    687c:	a1 01       	movw	r20, r2
    687e:	0e 94 0c 35 	call	0x6a18	; 0x6a18 <__ultoa_invert>
    6882:	d8 2e       	mov	r13, r24
    6884:	d2 18       	sub	r13, r2
    6886:	8f e7       	ldi	r24, 0x7F	; 127
    6888:	f8 2e       	mov	r15, r24
    688a:	f1 22       	and	r15, r17
    688c:	f6 fe       	sbrs	r15, 6
    688e:	0b c0       	rjmp	.+22     	; 0x68a6 <vfprintf+0x2cc>
    6890:	5e ef       	ldi	r21, 0xFE	; 254
    6892:	f5 22       	and	r15, r21
    6894:	d9 14       	cp	r13, r9
    6896:	38 f4       	brcc	.+14     	; 0x68a6 <vfprintf+0x2cc>
    6898:	f4 fe       	sbrs	r15, 4
    689a:	07 c0       	rjmp	.+14     	; 0x68aa <vfprintf+0x2d0>
    689c:	f2 fc       	sbrc	r15, 2
    689e:	05 c0       	rjmp	.+10     	; 0x68aa <vfprintf+0x2d0>
    68a0:	8f ee       	ldi	r24, 0xEF	; 239
    68a2:	f8 22       	and	r15, r24
    68a4:	02 c0       	rjmp	.+4      	; 0x68aa <vfprintf+0x2d0>
    68a6:	1d 2d       	mov	r17, r13
    68a8:	01 c0       	rjmp	.+2      	; 0x68ac <vfprintf+0x2d2>
    68aa:	19 2d       	mov	r17, r9
    68ac:	f4 fe       	sbrs	r15, 4
    68ae:	0d c0       	rjmp	.+26     	; 0x68ca <vfprintf+0x2f0>
    68b0:	fe 01       	movw	r30, r28
    68b2:	ed 0d       	add	r30, r13
    68b4:	f1 1d       	adc	r31, r1
    68b6:	80 81       	ld	r24, Z
    68b8:	80 33       	cpi	r24, 0x30	; 48
    68ba:	19 f4       	brne	.+6      	; 0x68c2 <vfprintf+0x2e8>
    68bc:	99 ee       	ldi	r25, 0xE9	; 233
    68be:	f9 22       	and	r15, r25
    68c0:	08 c0       	rjmp	.+16     	; 0x68d2 <vfprintf+0x2f8>
    68c2:	1f 5f       	subi	r17, 0xFF	; 255
    68c4:	f2 fe       	sbrs	r15, 2
    68c6:	05 c0       	rjmp	.+10     	; 0x68d2 <vfprintf+0x2f8>
    68c8:	03 c0       	rjmp	.+6      	; 0x68d0 <vfprintf+0x2f6>
    68ca:	8f 2d       	mov	r24, r15
    68cc:	86 78       	andi	r24, 0x86	; 134
    68ce:	09 f0       	breq	.+2      	; 0x68d2 <vfprintf+0x2f8>
    68d0:	1f 5f       	subi	r17, 0xFF	; 255
    68d2:	0f 2d       	mov	r16, r15
    68d4:	f3 fc       	sbrc	r15, 3
    68d6:	14 c0       	rjmp	.+40     	; 0x6900 <vfprintf+0x326>
    68d8:	f0 fe       	sbrs	r15, 0
    68da:	0f c0       	rjmp	.+30     	; 0x68fa <vfprintf+0x320>
    68dc:	1e 15       	cp	r17, r14
    68de:	10 f0       	brcs	.+4      	; 0x68e4 <vfprintf+0x30a>
    68e0:	9d 2c       	mov	r9, r13
    68e2:	0b c0       	rjmp	.+22     	; 0x68fa <vfprintf+0x320>
    68e4:	9d 2c       	mov	r9, r13
    68e6:	9e 0c       	add	r9, r14
    68e8:	91 1a       	sub	r9, r17
    68ea:	1e 2d       	mov	r17, r14
    68ec:	06 c0       	rjmp	.+12     	; 0x68fa <vfprintf+0x320>
    68ee:	80 e2       	ldi	r24, 0x20	; 32
    68f0:	90 e0       	ldi	r25, 0x00	; 0
    68f2:	b3 01       	movw	r22, r6
    68f4:	0e 94 e0 34 	call	0x69c0	; 0x69c0 <fputc>
    68f8:	1f 5f       	subi	r17, 0xFF	; 255
    68fa:	1e 15       	cp	r17, r14
    68fc:	c0 f3       	brcs	.-16     	; 0x68ee <vfprintf+0x314>
    68fe:	04 c0       	rjmp	.+8      	; 0x6908 <vfprintf+0x32e>
    6900:	1e 15       	cp	r17, r14
    6902:	10 f4       	brcc	.+4      	; 0x6908 <vfprintf+0x32e>
    6904:	e1 1a       	sub	r14, r17
    6906:	01 c0       	rjmp	.+2      	; 0x690a <vfprintf+0x330>
    6908:	ee 24       	eor	r14, r14
    690a:	04 ff       	sbrs	r16, 4
    690c:	0f c0       	rjmp	.+30     	; 0x692c <vfprintf+0x352>
    690e:	80 e3       	ldi	r24, 0x30	; 48
    6910:	90 e0       	ldi	r25, 0x00	; 0
    6912:	b3 01       	movw	r22, r6
    6914:	0e 94 e0 34 	call	0x69c0	; 0x69c0 <fputc>
    6918:	02 ff       	sbrs	r16, 2
    691a:	1d c0       	rjmp	.+58     	; 0x6956 <vfprintf+0x37c>
    691c:	01 fd       	sbrc	r16, 1
    691e:	03 c0       	rjmp	.+6      	; 0x6926 <vfprintf+0x34c>
    6920:	88 e7       	ldi	r24, 0x78	; 120
    6922:	90 e0       	ldi	r25, 0x00	; 0
    6924:	0e c0       	rjmp	.+28     	; 0x6942 <vfprintf+0x368>
    6926:	88 e5       	ldi	r24, 0x58	; 88
    6928:	90 e0       	ldi	r25, 0x00	; 0
    692a:	0b c0       	rjmp	.+22     	; 0x6942 <vfprintf+0x368>
    692c:	80 2f       	mov	r24, r16
    692e:	86 78       	andi	r24, 0x86	; 134
    6930:	91 f0       	breq	.+36     	; 0x6956 <vfprintf+0x37c>
    6932:	01 ff       	sbrs	r16, 1
    6934:	02 c0       	rjmp	.+4      	; 0x693a <vfprintf+0x360>
    6936:	8b e2       	ldi	r24, 0x2B	; 43
    6938:	01 c0       	rjmp	.+2      	; 0x693c <vfprintf+0x362>
    693a:	80 e2       	ldi	r24, 0x20	; 32
    693c:	f7 fc       	sbrc	r15, 7
    693e:	8d e2       	ldi	r24, 0x2D	; 45
    6940:	90 e0       	ldi	r25, 0x00	; 0
    6942:	b3 01       	movw	r22, r6
    6944:	0e 94 e0 34 	call	0x69c0	; 0x69c0 <fputc>
    6948:	06 c0       	rjmp	.+12     	; 0x6956 <vfprintf+0x37c>
    694a:	80 e3       	ldi	r24, 0x30	; 48
    694c:	90 e0       	ldi	r25, 0x00	; 0
    694e:	b3 01       	movw	r22, r6
    6950:	0e 94 e0 34 	call	0x69c0	; 0x69c0 <fputc>
    6954:	9a 94       	dec	r9
    6956:	d9 14       	cp	r13, r9
    6958:	c0 f3       	brcs	.-16     	; 0x694a <vfprintf+0x370>
    695a:	da 94       	dec	r13
    695c:	f1 01       	movw	r30, r2
    695e:	ed 0d       	add	r30, r13
    6960:	f1 1d       	adc	r31, r1
    6962:	80 81       	ld	r24, Z
    6964:	90 e0       	ldi	r25, 0x00	; 0
    6966:	b3 01       	movw	r22, r6
    6968:	0e 94 e0 34 	call	0x69c0	; 0x69c0 <fputc>
    696c:	dd 20       	and	r13, r13
    696e:	a9 f7       	brne	.-22     	; 0x695a <vfprintf+0x380>
    6970:	06 c0       	rjmp	.+12     	; 0x697e <vfprintf+0x3a4>
    6972:	80 e2       	ldi	r24, 0x20	; 32
    6974:	90 e0       	ldi	r25, 0x00	; 0
    6976:	b3 01       	movw	r22, r6
    6978:	0e 94 e0 34 	call	0x69c0	; 0x69c0 <fputc>
    697c:	ea 94       	dec	r14
    697e:	ee 20       	and	r14, r14
    6980:	c1 f7       	brne	.-16     	; 0x6972 <vfprintf+0x398>
    6982:	43 ce       	rjmp	.-890    	; 0x660a <vfprintf+0x30>
    6984:	f3 01       	movw	r30, r6
    6986:	66 81       	ldd	r22, Z+6	; 0x06
    6988:	77 81       	ldd	r23, Z+7	; 0x07
    698a:	cb 01       	movw	r24, r22
    698c:	2b 96       	adiw	r28, 0x0b	; 11
    698e:	e2 e1       	ldi	r30, 0x12	; 18
    6990:	0c 94 6d 31 	jmp	0x62da	; 0x62da <__epilogue_restores__>

00006994 <strnlen_P>:
    6994:	fc 01       	movw	r30, r24
    6996:	05 90       	lpm	r0, Z+
    6998:	61 50       	subi	r22, 0x01	; 1
    699a:	70 40       	sbci	r23, 0x00	; 0
    699c:	01 10       	cpse	r0, r1
    699e:	d8 f7       	brcc	.-10     	; 0x6996 <strnlen_P+0x2>
    69a0:	80 95       	com	r24
    69a2:	90 95       	com	r25
    69a4:	8e 0f       	add	r24, r30
    69a6:	9f 1f       	adc	r25, r31
    69a8:	08 95       	ret

000069aa <strnlen>:
    69aa:	fc 01       	movw	r30, r24
    69ac:	61 50       	subi	r22, 0x01	; 1
    69ae:	70 40       	sbci	r23, 0x00	; 0
    69b0:	01 90       	ld	r0, Z+
    69b2:	01 10       	cpse	r0, r1
    69b4:	d8 f7       	brcc	.-10     	; 0x69ac <strnlen+0x2>
    69b6:	80 95       	com	r24
    69b8:	90 95       	com	r25
    69ba:	8e 0f       	add	r24, r30
    69bc:	9f 1f       	adc	r25, r31
    69be:	08 95       	ret

000069c0 <fputc>:
    69c0:	0f 93       	push	r16
    69c2:	1f 93       	push	r17
    69c4:	cf 93       	push	r28
    69c6:	df 93       	push	r29
    69c8:	8c 01       	movw	r16, r24
    69ca:	eb 01       	movw	r28, r22
    69cc:	8b 81       	ldd	r24, Y+3	; 0x03
    69ce:	81 ff       	sbrs	r24, 1
    69d0:	1b c0       	rjmp	.+54     	; 0x6a08 <fputc+0x48>
    69d2:	82 ff       	sbrs	r24, 2
    69d4:	0d c0       	rjmp	.+26     	; 0x69f0 <fputc+0x30>
    69d6:	2e 81       	ldd	r18, Y+6	; 0x06
    69d8:	3f 81       	ldd	r19, Y+7	; 0x07
    69da:	8c 81       	ldd	r24, Y+4	; 0x04
    69dc:	9d 81       	ldd	r25, Y+5	; 0x05
    69de:	28 17       	cp	r18, r24
    69e0:	39 07       	cpc	r19, r25
    69e2:	64 f4       	brge	.+24     	; 0x69fc <fputc+0x3c>
    69e4:	e8 81       	ld	r30, Y
    69e6:	f9 81       	ldd	r31, Y+1	; 0x01
    69e8:	01 93       	st	Z+, r16
    69ea:	f9 83       	std	Y+1, r31	; 0x01
    69ec:	e8 83       	st	Y, r30
    69ee:	06 c0       	rjmp	.+12     	; 0x69fc <fputc+0x3c>
    69f0:	e8 85       	ldd	r30, Y+8	; 0x08
    69f2:	f9 85       	ldd	r31, Y+9	; 0x09
    69f4:	80 2f       	mov	r24, r16
    69f6:	09 95       	icall
    69f8:	89 2b       	or	r24, r25
    69fa:	31 f4       	brne	.+12     	; 0x6a08 <fputc+0x48>
    69fc:	8e 81       	ldd	r24, Y+6	; 0x06
    69fe:	9f 81       	ldd	r25, Y+7	; 0x07
    6a00:	01 96       	adiw	r24, 0x01	; 1
    6a02:	9f 83       	std	Y+7, r25	; 0x07
    6a04:	8e 83       	std	Y+6, r24	; 0x06
    6a06:	02 c0       	rjmp	.+4      	; 0x6a0c <fputc+0x4c>
    6a08:	0f ef       	ldi	r16, 0xFF	; 255
    6a0a:	1f ef       	ldi	r17, 0xFF	; 255
    6a0c:	c8 01       	movw	r24, r16
    6a0e:	df 91       	pop	r29
    6a10:	cf 91       	pop	r28
    6a12:	1f 91       	pop	r17
    6a14:	0f 91       	pop	r16
    6a16:	08 95       	ret

00006a18 <__ultoa_invert>:
    6a18:	fa 01       	movw	r30, r20
    6a1a:	aa 27       	eor	r26, r26
    6a1c:	28 30       	cpi	r18, 0x08	; 8
    6a1e:	51 f1       	breq	.+84     	; 0x6a74 <__ultoa_invert+0x5c>
    6a20:	20 31       	cpi	r18, 0x10	; 16
    6a22:	81 f1       	breq	.+96     	; 0x6a84 <__ultoa_invert+0x6c>
    6a24:	e8 94       	clt
    6a26:	6f 93       	push	r22
    6a28:	6e 7f       	andi	r22, 0xFE	; 254
    6a2a:	6e 5f       	subi	r22, 0xFE	; 254
    6a2c:	7f 4f       	sbci	r23, 0xFF	; 255
    6a2e:	8f 4f       	sbci	r24, 0xFF	; 255
    6a30:	9f 4f       	sbci	r25, 0xFF	; 255
    6a32:	af 4f       	sbci	r26, 0xFF	; 255
    6a34:	b1 e0       	ldi	r27, 0x01	; 1
    6a36:	3e d0       	rcall	.+124    	; 0x6ab4 <__ultoa_invert+0x9c>
    6a38:	b4 e0       	ldi	r27, 0x04	; 4
    6a3a:	3c d0       	rcall	.+120    	; 0x6ab4 <__ultoa_invert+0x9c>
    6a3c:	67 0f       	add	r22, r23
    6a3e:	78 1f       	adc	r23, r24
    6a40:	89 1f       	adc	r24, r25
    6a42:	9a 1f       	adc	r25, r26
    6a44:	a1 1d       	adc	r26, r1
    6a46:	68 0f       	add	r22, r24
    6a48:	79 1f       	adc	r23, r25
    6a4a:	8a 1f       	adc	r24, r26
    6a4c:	91 1d       	adc	r25, r1
    6a4e:	a1 1d       	adc	r26, r1
    6a50:	6a 0f       	add	r22, r26
    6a52:	71 1d       	adc	r23, r1
    6a54:	81 1d       	adc	r24, r1
    6a56:	91 1d       	adc	r25, r1
    6a58:	a1 1d       	adc	r26, r1
    6a5a:	20 d0       	rcall	.+64     	; 0x6a9c <__ultoa_invert+0x84>
    6a5c:	09 f4       	brne	.+2      	; 0x6a60 <__ultoa_invert+0x48>
    6a5e:	68 94       	set
    6a60:	3f 91       	pop	r19
    6a62:	2a e0       	ldi	r18, 0x0A	; 10
    6a64:	26 9f       	mul	r18, r22
    6a66:	11 24       	eor	r1, r1
    6a68:	30 19       	sub	r19, r0
    6a6a:	30 5d       	subi	r19, 0xD0	; 208
    6a6c:	31 93       	st	Z+, r19
    6a6e:	de f6       	brtc	.-74     	; 0x6a26 <__ultoa_invert+0xe>
    6a70:	cf 01       	movw	r24, r30
    6a72:	08 95       	ret
    6a74:	46 2f       	mov	r20, r22
    6a76:	47 70       	andi	r20, 0x07	; 7
    6a78:	40 5d       	subi	r20, 0xD0	; 208
    6a7a:	41 93       	st	Z+, r20
    6a7c:	b3 e0       	ldi	r27, 0x03	; 3
    6a7e:	0f d0       	rcall	.+30     	; 0x6a9e <__ultoa_invert+0x86>
    6a80:	c9 f7       	brne	.-14     	; 0x6a74 <__ultoa_invert+0x5c>
    6a82:	f6 cf       	rjmp	.-20     	; 0x6a70 <__ultoa_invert+0x58>
    6a84:	46 2f       	mov	r20, r22
    6a86:	4f 70       	andi	r20, 0x0F	; 15
    6a88:	40 5d       	subi	r20, 0xD0	; 208
    6a8a:	4a 33       	cpi	r20, 0x3A	; 58
    6a8c:	18 f0       	brcs	.+6      	; 0x6a94 <__ultoa_invert+0x7c>
    6a8e:	49 5d       	subi	r20, 0xD9	; 217
    6a90:	31 fd       	sbrc	r19, 1
    6a92:	40 52       	subi	r20, 0x20	; 32
    6a94:	41 93       	st	Z+, r20
    6a96:	02 d0       	rcall	.+4      	; 0x6a9c <__ultoa_invert+0x84>
    6a98:	a9 f7       	brne	.-22     	; 0x6a84 <__ultoa_invert+0x6c>
    6a9a:	ea cf       	rjmp	.-44     	; 0x6a70 <__ultoa_invert+0x58>
    6a9c:	b4 e0       	ldi	r27, 0x04	; 4
    6a9e:	a6 95       	lsr	r26
    6aa0:	97 95       	ror	r25
    6aa2:	87 95       	ror	r24
    6aa4:	77 95       	ror	r23
    6aa6:	67 95       	ror	r22
    6aa8:	ba 95       	dec	r27
    6aaa:	c9 f7       	brne	.-14     	; 0x6a9e <__ultoa_invert+0x86>
    6aac:	00 97       	sbiw	r24, 0x00	; 0
    6aae:	61 05       	cpc	r22, r1
    6ab0:	71 05       	cpc	r23, r1
    6ab2:	08 95       	ret
    6ab4:	9b 01       	movw	r18, r22
    6ab6:	ac 01       	movw	r20, r24
    6ab8:	0a 2e       	mov	r0, r26
    6aba:	06 94       	lsr	r0
    6abc:	57 95       	ror	r21
    6abe:	47 95       	ror	r20
    6ac0:	37 95       	ror	r19
    6ac2:	27 95       	ror	r18
    6ac4:	ba 95       	dec	r27
    6ac6:	c9 f7       	brne	.-14     	; 0x6aba <__ultoa_invert+0xa2>
    6ac8:	62 0f       	add	r22, r18
    6aca:	73 1f       	adc	r23, r19
    6acc:	84 1f       	adc	r24, r20
    6ace:	95 1f       	adc	r25, r21
    6ad0:	a0 1d       	adc	r26, r0
    6ad2:	08 95       	ret

00006ad4 <_exit>:
    6ad4:	f8 94       	cli

00006ad6 <__stop_program>:
    6ad6:	ff cf       	rjmp	.-2      	; 0x6ad6 <__stop_program>
